<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"example.com",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta name="description" content="原文链接 引言上一篇原理篇，我们已经详细地阐述了 Hybrid App 的基础原理，了解了 Native 端 和 H5 端 是如何通信的，还有 bridge 的设计和接入。而本篇文章将开始把这些原因进一步实践，用代码真正地去实现一套完整且稳定的 Hybrid 方案。如果对原理还有疑问的小伙伴，请移步提升海量用户极致体验的 Hybrid 架构设计（原理篇），只有在理解了理论的基础上，进一步与实践相结"><meta property="og:type" content="article"><meta property="og:title" content="提升海量用户极致体验的Hybrid架构设计[转]"><meta property="og:url" content="http://example.com/2022/03/18/[%E8%BD%AC]%E6%8F%90%E5%8D%87%E6%B5%B7%E9%87%8F%E7%94%A8%E6%88%B7%E6%9E%81%E8%87%B4%E4%BD%93%E9%AA%8C%E7%9A%84%20Hybrid%20%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/index.html"><meta property="og:site_name" content="SteveZhang博客"><meta property="og:description" content="原文链接 引言上一篇原理篇，我们已经详细地阐述了 Hybrid App 的基础原理，了解了 Native 端 和 H5 端 是如何通信的，还有 bridge 的设计和接入。而本篇文章将开始把这些原因进一步实践，用代码真正地去实现一套完整且稳定的 Hybrid 方案。如果对原理还有疑问的小伙伴，请移步提升海量用户极致体验的 Hybrid 架构设计（原理篇），只有在理解了理论的基础上，进一步与实践相结"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://static001.infoq.cn/resource/image/62/55/62ed934a1336363916dc24cd6cd3c555.jpg"><meta property="og:image" content="https://static001.infoq.cn/resource/image/f5/59/f54a2b8dfe8d21480d5ac35082ed1059.jpg"><meta property="og:image" content="https://static001.infoq.cn/resource/image/ad/04/adafcb982014f1ad2becf711d66edc04.jpg"><meta property="og:image" content="https://static001.infoq.cn/resource/image/d8/d9/d8aaff5b8f7901c9c3bb0a5d4c2370d9.jpg"><meta property="og:image" content="https://static001.infoq.cn/resource/image/34/fb/3451bc822f66561a8634c459bee34bfb.jpg"><meta property="og:image" content="https://static001.infoq.cn/resource/image/ff/65/ff4c092674a99fcd263c57e9a3099565.jpg"><meta property="og:image" content="https://static001.infoq.cn/resource/image/0b/ca/0be7c175fc4ab0140a8db81bc2898aca.jpg"><meta property="og:image" content="https://static001.infoq.cn/resource/image/0b/ca/0be7c175fc4ab0140a8db81bc2898aca.jpg"><meta property="og:image" content="https://static001.infoq.cn/resource/image/7d/56/7d4aa27dd4ac6036993d7255a3d25756.jpg"><meta property="og:image" content="https://static001.infoq.cn/resource/image/d1/85/d1c4904ff723ce0f0de5d2408d289685.jpg"><meta property="og:image" content="https://static001.infoq.cn/resource/image/e6/b5/e61a71943ab3bbbb8d21a0dc27fa09b5.jpg"><meta property="og:image" content="https://static001.infoq.cn/resource/image/cf/1f/cf5b40ef0c8355b766288e53967d9a1f.jpg"><meta property="og:image" content="https://static001.infoq.cn/resource/image/b2/24/b2c03548947c032a4ee194a8ddf78424.jpg"><meta property="og:image" content="https://static001.infoq.cn/resource/image/74/23/74c741285607493320ac9a37fa8dc423.jpg"><meta property="og:image" content="https://static001.infoq.cn/resource/image/97/0e/97900a687b94670ed17acd2e4bc5070e.jpg"><meta property="og:image" content="https://static001.infoq.cn/resource/image/50/4a/50e6a9e84ffb25172b124337555d404a.jpg"><meta property="og:image" content="https://static001.infoq.cn/resource/image/25/f1/259b6e0441914c490f268d415f0b6ef1.jpg"><meta property="article:published_time" content="2022-03-17T20:23:47.000Z"><meta property="article:modified_time" content="2022-05-12T07:29:40.000Z"><meta property="article:author" content="张龙"><meta property="article:tag" content="webview"><meta property="article:tag" content="hybrid"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://static001.infoq.cn/resource/image/62/55/62ed934a1336363916dc24cd6cd3c555.jpg"><link rel="canonical" href="http://example.com/2022/03/18/[%E8%BD%AC]%E6%8F%90%E5%8D%87%E6%B5%B7%E9%87%8F%E7%94%A8%E6%88%B7%E6%9E%81%E8%87%B4%E4%BD%93%E9%AA%8C%E7%9A%84%20Hybrid%20%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>提升海量用户极致体验的Hybrid架构设计[转] | SteveZhang博客</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="SteveZhang博客" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">SteveZhang博客</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">15</span></a></li></ul></nav></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/03/18/[%E8%BD%AC]%E6%8F%90%E5%8D%87%E6%B5%B7%E9%87%8F%E7%94%A8%E6%88%B7%E6%9E%81%E8%87%B4%E4%BD%93%E9%AA%8C%E7%9A%84%20Hybrid%20%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">提升海量用户极致体验的Hybrid架构设计[转]</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-03-18 04:23:47" itemprop="dateCreated datePublished" datetime="2022-03-18T04:23:47+08:00">2022-03-18</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-05-12 15:29:40" itemprop="dateModified" datetime="2022-05-12T15:29:40+08:00">2022-05-12</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/web/" itemprop="url" rel="index"><span itemprop="name">web</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/5DHTP6xjkMbNmo49Rd2x">原文链接</a></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>上一篇原理篇，我们已经详细地阐述了 Hybrid App 的基础原理，了解了 Native 端 和 H5 端 是如何通信的，还有 bridge 的设计和接入。而本篇文章将开始把这些原因进一步实践，用代码真正地去实现一套完整且稳定的 Hybrid 方案。如果对原理还有疑问的小伙伴，请移步提升海量用户极致体验的 Hybrid 架构设计（原理篇），只有在理解了理论的基础上，进一步与实践相结合，才能真正地去深入一项技术。</p><h3 id="摩天大楼"><a href="#摩天大楼" class="headerlink" title="摩天大楼"></a>摩天大楼</h3><p>说了那么一大堆理论知识，可能有小伙伴会说：“ 你是不是吹流弊啊。”那就先来简单介绍下我们已经使用这套方案落地的项目之一。</p><p><img src="https://static001.infoq.cn/resource/image/62/55/62ed934a1336363916dc24cd6cd3c555.jpg" alt="img"></p><p>这是一个完全内置在 App 里的 Hybrid 模块，由 Native 与 H5 深度协作完成，总共有 4 个页面，其中首页和制作页由 H5 制作，而相机页和保存页是复用 Native 页面。</p><p>项目上线一年累积使用次数已经超过 10 亿次。这套方案经受住了考验，并在过程中仍然在不断的优化和拓展。</p><p>使用这套实现方案是基于以下几点考虑：</p><ul><li>整个模块的风格多变，整体 UI 是与妆容所搭配的，而整个模块一直都在持续不断的迭代之中；</li><li>项目逻辑流程的可变性大，需要 H5 强大的热更新能力，及时应对数据的变化，快速的试错和纠正；</li><li>拍摄页与保存页是客户端已经有的模块，可以略微定制后直接复用；</li><li>需要由客户端协助接入多套 SDK，例如使用算法 SDK 进行复杂的图像处理。</li><li>简单看完项目，我们接下来开始 bridge.js 的构建。由于本系列文章主要面向前端童鞋，因此我们主要展开 H5 的部分，即会注入到每个页面头部的 bridge.js 的实现，客户端中的 SDK 部分就不详细解构了，只会提到一些细节。</li></ul><h3 id="搭建地基-—-bridge-js-架构"><a href="#搭建地基-—-bridge-js-架构" class="headerlink" title="搭建地基 — bridge.js 架构"></a>搭建地基 — bridge.js 架构</h3><p>基于上篇文章阐述的结构，我们进一步去完善细节部分，先整理成下面这样的流程结构图，大家先看下图，有个大致的概念：</p><p><img src="https://static001.infoq.cn/resource/image/f5/59/f54a2b8dfe8d21480d5ac35082ed1059.jpg" alt="img"></p><p>接下来我们会细看里面各个部分的代码实现。</p><h4 id="一-业务方使用姿势"><a href="#一-业务方使用姿势" class="headerlink" title="(一) 业务方使用姿势"></a>(一) 业务方使用姿势</h4><p>首先，我们先看下在这套方案中，业务方是如何使用的，下面以获取网络状态为例：</p><p><img src="https://static001.infoq.cn/resource/image/ad/04/adafcb982014f1ad2becf711d66edc04.jpg" alt="img"></p><h4 id="二-H5-–-gt-Native"><a href="#二-H5-–-gt-Native" class="headerlink" title="(二) H5 –&gt; Native"></a>(二) H5 –&gt; Native</h4><p>接下来直接来看 nativeCall 的内部实现：</p><p><img src="https://static001.infoq.cn/resource/image/d8/d9/d8aaff5b8f7901c9c3bb0a5d4c2370d9.jpg" alt="img"></p><p>里面可以解构成下面 4 个步骤:</p><p>1.生成唯一 handler 标识，从 0 开始累加；</p><p>2.将参数按 handler 值的规则存入参数池(_paramsStore)中；</p><p>3.以 handler 注册自定义事件，绑定 callback，并将 callback 也存入 _callbackStore 中，addEvent()，储存的目的主要是为了事件解绑时使用；</p><p>4.以 iframe 的形式发送协议，并携带唯一标识 handler，send()；</p><p><img src="https://static001.infoq.cn/resource/image/34/fb/3451bc822f66561a8634c459bee34bfb.jpg" alt="img"></p><p>Native:</p><ul><li>客户端接收到请求后，会使用 handler 调用 getParam 从参数池中获取对应的参数。</li><li><img src="https://static001.infoq.cn/resource/image/ff/65/ff4c092674a99fcd263c57e9a3099565.jpg" alt="img"></li><li>执行协议对应的功能；</li><li>这样即走通了 H5 –&gt; Native 的这个流程，在客户端完成了对应的功能后，既开始回传执行结果。</li></ul><h4 id="三-Native-–-gt-H5"><a href="#三-Native-–-gt-H5" class="headerlink" title="(三) Native –&gt; H5"></a>(三) Native –&gt; H5</h4><p>Native：</p><p>Native 完成功能后，直接调用 Bridge.postMessage(handler, data)，将 执行结果 和 之前 nativeCall 传过来的 标识 回传给 H5；</p><p><img src="https://static001.infoq.cn/resource/image/0b/ca/0be7c175fc4ab0140a8db81bc2898aca.jpg" alt="img"></p><p>H5：</p><ul><li>H5 在接收到唯一标识后初始化对应的自定义事件，挂载数据后触发，这里涉及的就是 fireEvent 这个函数:</li><li><img src="https://static001.infoq.cn/resource/image/0b/ca/0be7c175fc4ab0140a8db81bc2898aca.jpg" alt="img"></li><li>这样，我们就已经完成了双端之间的双向交互机制了，梳理出了整个 bridge.js 的核心代码了，包含了：</li><li>最重要的开放 API: nativeCall 与 postMessage ；</li><li>客户端获取参数函数: getParam ；</li><li>事件回调系统中的 addEvent 和 fireEvent ；</li><li>用于发送协议的 send。</li></ul><h3 id="安卓兼容性"><a href="#安卓兼容性" class="headerlink" title="安卓兼容性"></a>安卓兼容性</h3><p>如果看过上一篇提升海量用户极致体验的 Hybrid 架构设计（原理篇）的童鞋，这时可能会有个疑问：在 Android 4.4 以下时，使用的 loadUrl 进行 js 函数的调用，而此时是无法获取函数的返回值的，也就是说 4.4- 时，安卓并无法通过 getParam 这个函数来获取到协议的参数，这里需要做兼容性的处理，而我们这里可以使用一个曲线救国的骚操作，使用到的原理就是上一篇文章中有提到的另一种 H5 -&gt; Native 的方案：WebView 中的 prompt 拦截</p><p>方案如下:</p><ul><li>当安卓接受到协议，并拿到 handler 值；</li><li>使用无兼容性问题的 loadUrl 执行 js：Bridge.getParam(handler) ，直接将返回值直接通过 js 中的 prompt 发出：</li><li><img src="https://static001.infoq.cn/resource/image/7d/56/7d4aa27dd4ac6036993d7255a3d25756.jpg" alt="img"></li><li>通过重写 onJsPrompt 这个方法，拦截上一步发出的 prompt 的内容，并解析出相应的参数；</li><li><img src="https://static001.infoq.cn/resource/image/d1/85/d1c4904ff723ce0f0de5d2408d289685.jpg" alt="img"></li></ul><p>通过这样的方式，安卓全平台都可以完成参数的获取，并且方式统一，不需要分平台兼容，这就非常的 skrskr 啦。</p><p>现在看下来，是不是觉得炒鸡简单？。分分钟能写 100 个。没错！其实核心的原理就是这么的简单，但这只是一个最基础的地基而已，而基于地基之上，我们就可以开始一层一层建造我们的大楼了！</p><h3 id="建造大楼-—-协议的定制"><a href="#建造大楼-—-协议的定制" class="headerlink" title="建造大楼 — 协议的定制"></a>建造大楼 — 协议的定制</h3><p>在完成最基础的架构后，我们就可以开始来进一步完成一些上层建筑了，制定一系列真正开放给业务方使用的协议 API，完善整套方案。</p><p>首先我们可以将这些协议分成 功能协议 和 业务协议。</p><h3 id="功能协议"><a href="#功能协议" class="headerlink" title="功能协议"></a>功能协议</h3><p>这类协议是指用于完善整套方案的基础功能的一些通用协议，以 command:&#x2F;&#x2F;作为通用头，封装在 SDK 之中，可以在全线 App、全线 WebView 中使用：</p><h4 id="1-初始化机制"><a href="#1-初始化机制" class="headerlink" title="1.初始化机制"></a>1.初始化机制</h4><p>上篇文章有提到由于 bridge.js 注入的异步性，我们需要由客户端在注入完成后通知 H5。</p><p>这里我们可以约定一个通用的初始化事件，这里我们约定为 <em>init</em>，因此前端就可以进行入口的监听, 类似于我们常用的 DOMContentLoaded:</p><p><img src="https://static001.infoq.cn/resource/image/e6/b5/e61a71943ab3bbbb8d21a0dc27fa09b5.jpg" alt="img"></p><p>大家可以看到，这里用了个标记位用于避免事件被重复触发，这是由于客户端中是通过监听 WebView 的生命周期钩子来触发的，而 iframe 之类的操作会导致这些钩子的多次触发，因此需要双方各做一层防御性措施。</p><p>接下来，我们可以通过该事件，直接初始化传给 H5 一些环境参数和系统信息等，下面是我们使用到的：</p><p><img src="https://static001.infoq.cn/resource/image/cf/1f/cf5b40ef0c8355b766288e53967d9a1f.jpg" alt="img"></p><p>同样的，我们可以约定更多的页面生命周期事件，例如因为 App 很经常性的隐藏到后台，因此在被激活时，我们可以设置个生命周期: <em>resume</em>，可以用于告知 H5 页面被激活。</p><p>Tips:</p><p>这里就能体现出我们通过事件机制来作为回调系统的优势了，我们可以以最习惯的方式进行事件的监听，而客户端可以直接使用 bridge.fireEvent(‘<em>init</em>’, data)触发事件，这样便可以优雅地实现 Native -&gt; H5 的单方向交互。</p><h4 id="2-打包机制"><a href="#2-打包机制" class="headerlink" title="2.打包机制"></a>2.打包机制</h4><p>Hybrid 模块 的其中一种方式是将前端代码打包后内置于 App 本地，以便拥有最快的启动性能和离线访问能力。而这种方式最大的麻烦点，就是代码的更新，我们不可能每次有修改时就手动重新打包给客户端童鞋替换，而且这样也失去了我们的热更新机制。</p><p>因此这里就需要一套新的热更新机制，这套机制需要由客户端&#x2F;前端&#x2F;服务端 三端的童鞋提供对应的资源，共同协作完成整套流程。</p><p>资源：</p><ul><li>H5: 每个代码包都有一个唯一且递增的版本号；</li><li>Native: 提供包下载且解压到对应目录的服务，前端可以由下面这个协议来调用该功能。</li><li><img src="https://static001.infoq.cn/resource/image/b2/24/b2c03548947c032a4ee194a8ddf78424.jpg" alt="img"></li><li>服务端: 提供一个接口，可以获取线上最新代码包的版本号和下载地址。</li><li>流程：</li><li>前端更新代码打包后按版本号上传至指定的服务器上；</li><li>每次打开页面时，H5 请求接口获取线上最新代码包版本号，并与本地包进行版本号比对，当线上的版本号 大于 本地包版本号时，发起包下载协议：</li><li>客户端接受到协议后，直接去线上地址下载最新的代码包，并解压替换到当前目录文件。</li><li>拥有这样的机制后，H5 在开发后，就可以直接打包将包上传到对应的服务器上，这样在 App 中打开页面后，即可以实时的热更新。</li></ul><h4 id="3-环境系统-和-多语言系统"><a href="#3-环境系统-和-多语言系统" class="headerlink" title="3.环境系统 和 多语言系统"></a>3.环境系统 和 多语言系统</h4><p>通常，我们会将项目分成多个不同的环境，相互隔离。而由于 Hybrid 模块是置于 App 中的，因此环境需要与 App 进行匹配，这里就可以直接使用上面第一点提到的，通过 <em>init</em> 中携带的数据 data.env 来匹配：</p><blockquote><p>env: 0 - 正式环境； 1 - 测试环境； 2 - 开发环境；</p><p>同理， 多语言也可以直接使用 e.data.language 直接进行匹配；</p><p>Tips：</p><p>环境机制我们通常主要用于匹配后端的环境，正式环境和测试环境对应不同的接口。而这里还有一点特别的，就是需要注意代码包的更新，上述的包更新条件要包含三个方面: 版本号、环境和 App 版本，在不同环境不同 App 版本下，也应该更新到相应的最新代码包。</p></blockquote><h4 id="4-事件中转站"><a href="#4-事件中转站" class="headerlink" title="4. 事件中转站"></a>4. 事件中转站</h4><p>由于页面是 H5 开发，而 Native 可能需要控制 H5 页面，例如最常用的场景:</p><p>当页面中有弹窗或者 SPA 切换页面时，安卓的返回实体键应该能完成对应的回退，而不是因为 WebView 没有 history 就直接关闭。</p><p>类似于这类需求，这里就可以定制一个事件中心(<em>eventListeners</em> )，用于监听客户端的实体返回键：</p><p><img src="https://static001.infoq.cn/resource/image/74/23/74c741285607493320ac9a37fa8dc423.jpg" alt="img"></p><h4 id="5-数据传递机制"><a href="#5-数据传递机制" class="headerlink" title="5. 数据传递机制"></a>5. 数据传递机制</h4><p>在业务中，很多场景需要做到 Native 与 H5 保持数据的同步，此时就可以使用类似上面的原理，制定一套数据传递协议:</p><p><img src="https://static001.infoq.cn/resource/image/97/0e/97900a687b94670ed17acd2e4bc5070e.jpg" alt="img"></p><p>Tips：</p><p>Hybrid 模块通常需要从对应的入口进入，因此这里有一种可以优化的方式：</p><p>由 App 在启动时先去获取线上数据，在进入 WebView 后直接通过 <em>init</em> 或者触发 getData 直接发送给 H5，这样能减少请求数量，优化用户体验。</p><h4 id="6-代理请求"><a href="#6-代理请求" class="headerlink" title="6. 代理请求"></a>6. 代理请求</h4><p>H5 中最常用的就是请求，通常我们可以直接使用 ajax，但是这里有几个问题比较棘手:</p><ul><li>最常见的请求跨域；</li><li>数据算法加密；</li><li>用户登录校验；</li><li>而客户端的请求便不会出现这些问题，因此我们可以由客户端代理我们发出的请求，可以定制 4 个协议: getProxy，postProxy， getProxyLogined，postProxyLogined，其中带有 Logined 的协议代表着在请求时会自动携带已登录用户的 token 和 uid 等参数，使用在一些需要登录信息的接口上。这样做的好处是：</li><li>H5 方就无需处理繁多的各项复杂信息，不需要进行跨端传输；</li><li>能够对 H5 与 Native 的请求出口进行统一，方便加工处理。</li><li><img src="https://static001.infoq.cn/resource/image/50/4a/50e6a9e84ffb25172b124337555d404a.jpg" alt="img"></li></ul><h4 id="7-更多"><a href="#7-更多" class="headerlink" title="7.更多"></a>7.更多</h4><p>除了这些重要的功能外，我们还可以非常自由地定制很多协议，让 H5 拥有更多更强大的功能，下面是我们所定制的一些功能：</p><ul><li>getNetwork：获取网络状态；</li><li>openApp：唤起其它 App；</li><li>setShareInfo 与 callShare：分享内容到第三方平台；</li><li>link：使用新的 WebView 打开页面；</li><li>closeWebview：关闭 WebView；</li><li>setStorage 与 getStorage：设置与获取缓存数据；</li><li>loading：调用客户端通用 Loading；</li><li>setWebviewTitle：设置 WebView 标题；</li><li>saveImage：保存图片到本地；</li><li>…</li><li>这里可以定义更多的通用性协议，这里有个原则可以遵守，即这部分协议应该是基础性功能，应该是纯净的，适用于所有的业务方。根据上篇文章提到的理念，这部分是当成通用 SDK 进行维护与升级的，因此不应该耦合业务层的任何逻辑。</li><li>而有时我们会遇到需要定制一些业务上的逻辑，例如上面提到的项目中，我们要将用户图片通过算法处理成卡通画。这样的需求就是非常的业务化，不适用于其它项目，因此我们应该定制成业务协议。</li></ul><h3 id="业务协议"><a href="#业务协议" class="headerlink" title="业务协议"></a>业务协议</h3><p>这类协议区别于功能协议，它们会杂合一定程度的业务逻辑，而这些逻辑只是针对于特定的项目。其实对于 H5 的使用上，差别并不大，只是使用对应特殊的协议头用于区分，例如:</p><p><img src="https://static001.infoq.cn/resource/image/25/f1/259b6e0441914c490f268d415f0b6ef1.jpg" alt="img"></p><p>这类协议通常不包含在 SDK 中，因此需要由客户端的童鞋针对项目的 WebView 进行定制，使用 bridge.js 提供的基础功能实现对应的复杂功能。而在其它的项目入口中，就无法使用这些协议。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>看到总结两个字，有没有长舒了一口气。通过这两篇文章，我们终于将 Hybrid 方案的前端部分完全的解构清楚了，是不是有种神清气爽的感觉，完全可以马上开启你们的 Hybrid 之旅了。鼓掌鼓掌！</p><p>但这也远非终点，或者说这永无终点。~大楼建成后，离真正的摩天大楼还是差着一步 — 内部装修，其实接下来我们还需要做很多的优化措施，来解决一些仍然存在的问题，这部分其实我们也一直还在努力的阶段。</p><p>受篇幅所限，有时间会将这部分再写一篇优化篇，主要来与大家探讨下我们所能想到的一些优化方案，非常期待大佬们也能给我们提供更多的建议和解决办法。感恩~~😇</p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/webview/" rel="tag"># webview</a> <a href="/tags/hybrid/" rel="tag"># hybrid</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2022/03/17/%5B%E8%BD%AC%5D%E6%8F%90%E5%8D%87%E6%B5%B7%E9%87%8F%E7%94%A8%E6%88%B7%E6%9E%81%E8%87%B4%E4%BD%93%E9%AA%8C%E7%9A%84%20Hybrid%20%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E5%8E%9F%E7%90%86%E7%AF%87%EF%BC%89/" rel="prev" title="提升海量用户极致体验的Hybrid架构设计（原理篇）[转]"><i class="fa fa-chevron-left"></i> 提升海量用户极致体验的Hybrid架构设计（原理篇）[转]</a></div><div class="post-nav-item"><a href="/2022/05/13/HTTPS-%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86/" rel="next" title="HTTPS 学习整理">HTTPS 学习整理 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener("tabs:register",()=>{let e=CONFIG.comments["activeClass"];if(CONFIG.comments.storage&&(e=localStorage.getItem("comments_active")||e),e){let t=document.querySelector(`a[href="#comment-${e}"]`);t&&t.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%91%A9%E5%A4%A9%E5%A4%A7%E6%A5%BC"><span class="nav-number">2.</span> <span class="nav-text">摩天大楼</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%90%AD%E5%BB%BA%E5%9C%B0%E5%9F%BA-%E2%80%94-bridge-js-%E6%9E%B6%E6%9E%84"><span class="nav-number">3.</span> <span class="nav-text">搭建地基 — bridge.js 架构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80-%E4%B8%9A%E5%8A%A1%E6%96%B9%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF"><span class="nav-number">3.1.</span> <span class="nav-text">(一) 业务方使用姿势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C-H5-%E2%80%93-gt-Native"><span class="nav-number">3.2.</span> <span class="nav-text">(二) H5 –&gt; Native</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89-Native-%E2%80%93-gt-H5"><span class="nav-number">3.3.</span> <span class="nav-text">(三) Native –&gt; H5</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E5%8D%93%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="nav-number">4.</span> <span class="nav-text">安卓兼容性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%BA%E9%80%A0%E5%A4%A7%E6%A5%BC-%E2%80%94-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%9A%E5%88%B6"><span class="nav-number">5.</span> <span class="nav-text">建造大楼 — 协议的定制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD%E5%8D%8F%E8%AE%AE"><span class="nav-number">6.</span> <span class="nav-text">功能协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="nav-number">6.1.</span> <span class="nav-text">1.初始化机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%89%93%E5%8C%85%E6%9C%BA%E5%88%B6"><span class="nav-number">6.2.</span> <span class="nav-text">2.打包机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E7%8E%AF%E5%A2%83%E7%B3%BB%E7%BB%9F-%E5%92%8C-%E5%A4%9A%E8%AF%AD%E8%A8%80%E7%B3%BB%E7%BB%9F"><span class="nav-number">6.3.</span> <span class="nav-text">3.环境系统 和 多语言系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E4%BA%8B%E4%BB%B6%E4%B8%AD%E8%BD%AC%E7%AB%99"><span class="nav-number">6.4.</span> <span class="nav-text">4. 事件中转站</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6"><span class="nav-number">6.5.</span> <span class="nav-text">5. 数据传递机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E4%BB%A3%E7%90%86%E8%AF%B7%E6%B1%82"><span class="nav-number">6.6.</span> <span class="nav-text">6. 代理请求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-%E6%9B%B4%E5%A4%9A"><span class="nav-number">6.7.</span> <span class="nav-text">7.更多</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%9A%E5%8A%A1%E5%8D%8F%E8%AE%AE"><span class="nav-number">7.</span> <span class="nav-text">业务协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">8.</span> <span class="nav-text">总结</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">张龙</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">15</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">3</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">4</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">张龙</span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script></body></html>