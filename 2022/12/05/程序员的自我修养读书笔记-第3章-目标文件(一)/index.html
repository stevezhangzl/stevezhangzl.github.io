<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"example.com",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta name="description" content="编译器编译源代码后生成的文件叫做目标文件。 目标文件从结构上讲，这是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或有些地址还没有被调整。其实它本身就是按照可执行文件格式存储的，只是跟真正的可执行文件在结构上稍有不同。 可执行文件格式涵盖了程序的编译、链接、装载和执行的各个方面。了解它的结构并深入剖析它对于认识系统、了解背后的机理大有好处。 目标文件的格式现在PC平台流行的"><meta property="og:type" content="article"><meta property="og:title" content="程序员的自我修养读书笔记-第3章 目标文件(一)"><meta property="og:url" content="http://example.com/2022/12/05/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6(%E4%B8%80)/index.html"><meta property="og:site_name" content="SteveZhang博客"><meta property="og:description" content="编译器编译源代码后生成的文件叫做目标文件。 目标文件从结构上讲，这是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或有些地址还没有被调整。其实它本身就是按照可执行文件格式存储的，只是跟真正的可执行文件在结构上稍有不同。 可执行文件格式涵盖了程序的编译、链接、装载和执行的各个方面。了解它的结构并深入剖析它对于认识系统、了解背后的机理大有好处。 目标文件的格式现在PC平台流行的"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/2022/12/05/images/image-20221208132834056.png"><meta property="og:image" content="http://example.com/images/image-20221208135133311.png"><meta property="og:image" content="http://example.com/images/image-20221208140242825.png"><meta property="og:image" content="http://example.com/images/image-20221208145813757.png"><meta property="og:image" content="http://example.com/images/image-20221208150615895.png"><meta property="og:image" content="http://example.com/images/image-20221208152110539.png"><meta property="og:image" content="http://example.com/images/image-20221208153039103.png"><meta property="og:image" content="http://example.com/images/image-20221208153832399.png"><meta property="og:image" content="http://example.com/images/image-20221208153904864.png"><meta property="og:image" content="http://example.com/images/image-20221208160024230.png"><meta property="og:image" content="http://example.com/images/image-20221209093804930.png"><meta property="og:image" content="http://example.com/images/image-20221209094547202.png"><meta property="og:image" content="http://example.com/2022/12/05/images/image-20221209095037002.png"><meta property="og:image" content="http://example.com/images/image-20221209105004038.png"><meta property="og:image" content="http://example.com/images/image-20221209110615180.png"><meta property="og:image" content="http://example.com/images/image-20221209110741748.png"><meta property="og:image" content="http://example.com/images/image-20221209110824065.png"><meta property="og:image" content="http://example.com/images/image-20221209110837646.png"><meta property="og:image" content="http://example.com/images/image-20221209110917620.png"><meta property="og:image" content="http://example.com/images/image-20221209111116053.png"><meta property="og:image" content="http://example.com/images/image-20221209111205539.png"><meta property="og:image" content="http://example.com/images/image-20221209111321412.png"><meta property="og:image" content="http://example.com/images/image-20221209111408212.png"><meta property="og:image" content="http://example.com/images/image-20221209111451191.png"><meta property="og:image" content="http://example.com/images/image-20221209111527639.png"><meta property="og:image" content="http://example.com/images/image-20221209111625057.png"><meta property="og:image" content="http://example.com/images/image-20221209111715664.png"><meta property="og:image" content="http://example.com/images/image-20221209111802059.png"><meta property="og:image" content="http://example.com/images/image-20221209130235027.png"><meta property="og:image" content="http://example.com/images/image-20221209131413041.png"><meta property="og:image" content="http://example.com/2022/12/05/images/image-20221209185728928.png"><meta property="og:image" content="http://example.com/images/image-20221210062408633.png"><meta property="og:image" content="http://example.com/images/image-20221210065104164.png"><meta property="og:image" content="http://example.com/images/image-20221210065115607.png"><meta property="article:published_time" content="2022-12-05T07:49:36.000Z"><meta property="article:modified_time" content="2023-01-12T05:22:36.000Z"><meta property="article:author" content="张龙"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://example.com/2022/12/05/images/image-20221208132834056.png"><link rel="canonical" href="http://example.com/2022/12/05/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6(%E4%B8%80)/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>程序员的自我修养读书笔记-第3章 目标文件(一) | SteveZhang博客</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="SteveZhang博客" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">SteveZhang博客</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">63</span></a></li></ul></nav></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/12/05/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6(%E4%B8%80)/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">程序员的自我修养读书笔记-第3章 目标文件(一)</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-12-05 15:49:36" itemprop="dateCreated datePublished" datetime="2022-12-05T15:49:36+08:00">2022-12-05</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-01-12 13:22:36" itemprop="dateModified" datetime="2023-01-12T13:22:36+08:00">2023-01-12</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/NDK/" itemprop="url" rel="index"><span itemprop="name">NDK</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>编译器编译源代码后生成的文件叫做目标文件。</p><p>目标文件从结构上讲，这是已经编译后的<strong>可执行文件格式</strong>，<strong>只是还没有经过链接的过程</strong>，其中可能有些符号或有些地址还没有被调整。其实它本身就是按照<strong>可执行文件格式</strong>存储的，只是跟真正的可执行文件在结构上稍有不同。</p><p>可执行文件格式涵盖了程序的编译、链接、装载和执行的各个方面。了解它的结构并深入剖析它对于认识系统、了解背后的机理大有好处。</p><h2 id="目标文件的格式"><a href="#目标文件的格式" class="headerlink" title="目标文件的格式"></a>目标文件的格式</h2><p>现在PC平台流行的可执行文件格式主要是windows下的PE和Linux的ELF，它们都是COFF格式的变种。目标文件 就是源代码编译后未进行链接的那些<strong>中间文件</strong>，它跟可执行文件的内容与结构很相似，所以一般可执行文件格式一起采用一种格式存储。从广义上看，目标文件与可执行文件的格式其实几乎是一样的，所以我们可以广义地将目标文件与可执行文件看成是一种类型的文件。</p><p>不光是可执行文件按照可执行文件格式存储。动态链接库及静态链接库文件都是按照可执行文件格式存储。静态链接库稍有不同，它是把很多目标文件捆绑在一起形成一个文件，再加上一些索引，你可以简单地把它理解为一个包含有很多目标文件的文件包。</p><table><thead><tr><th>ELF文件类型</th><th>说明</th><th>实例</th></tr></thead><tbody><tr><td>可重定位文件(Relocatable File)</td><td>这类文件包含了代码和数据，可以被用来链接成可执行文件或共享目标文件，静态库也可以归为这一类</td><td>Linux的.o</td></tr><tr><td>可执行文件(Executable File)</td><td>这类文件包含了可以直接执行的程序，它的代表就是ELF可执行文，它们一般都没有扩展名</td><td>比如&#x2F;bin&#x2F;bash文件</td></tr><tr><td>共享目标文件(shared object file)</td><td>这种文件包含了代码和数据，可以在以下两种情况下使用。第一种是链接器可以全名用这种文件跟其他的可重定位文件和共享目标文件链接，产生新的目标文件。第二种是动态链接器可以将几种这种共享目标文件与可执行文件结合，作为进程映像的一部分来运行。</td><td>Linux的.so</td></tr></tbody></table><p><code>file foobar.o</code></p><p>查看相应的文件格式</p><h2 id="目标文件是什么样的"><a href="#目标文件是什么样的" class="headerlink" title="目标文件是什么样的"></a>目标文件是什么样的</h2><p>程序源代码编译后的<strong>机器指令</strong>经常被放在<strong>代码段</strong>里，代码段常见的名字有**.code<strong>和</strong>.text** ，<strong>全局变量</strong>和<strong>局部静态变量数</strong>据经常放在<strong>数据段</strong>，数据段的一般名字都叫**.data**</p><img src="../images/image-20221208132834056.png" alt="image-20221208132834056" style="zoom:50%"><ul><li>ELF文件的开头是一个“文件头”，它描述了整个文件的文件属性，包括文件是否可执行、是静态链接还是动态链接及入口地址（如果可执行文件）、目标硬件、目标操作系统等信息，文件头还有一个<strong>段表</strong></li><li><strong>段表</strong>是一个<strong>描述</strong>文件中各个段的<strong>数组</strong>。描述了文件中各个段在文件中的<strong>偏移位置</strong>及段的<strong>属性</strong>，从段表里面可以得到每个段的所有信息。文件头后面就是各个段的内容，代码段保存的是程序的指令，数据段保存的是程序的静态变量。</li><li>编译后的语句编译成机器代码，保存在.text段</li><li>已初始化的全局变量和局部静态变量保存在.data段</li><li>未初始化的全局变量和局部静态变量一般放在.bss段，未初始化的默认值都为0，放在.bss段，在文件中不占据空间。</li></ul><blockquote><p>总体来说，程序源代码被编译以后主要分成两种段：程序指令和程序数据。代码段属于程序指令，而数据段和.bss段属于程序数据。</p></blockquote><h2 id="挖掘SimpleSection-o"><a href="#挖掘SimpleSection-o" class="headerlink" title="挖掘SimpleSection.o"></a>挖掘SimpleSection.o</h2><p>SimpleSection.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> global_inti_var = <span class="number">84</span>;</span><br><span class="line"><span class="keyword">int</span>  global_unint_var;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> static_var = <span class="number">85</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> static_var2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	func1(a + b + static_var + static_var2 );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>参数-c 表示只编译不链接</strong></p><p><code>gcc -c SimpleSection.c</code></p><p>得到SimpleSection.o目标文件</p><p><code>objdump -h SimpleSection.o</code></p><p><img src="/../images/image-20221208135133311.png" alt="image-20221208135133311"></p><p>.comment 注释信息段</p><p>.note.gnu-stack 堆栈提示段</p><p>横向看</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Size</td><td>段的长度</td></tr><tr><td>File Offset</td><td>段所在的位置</td></tr><tr><td>CONTENTS</td><td>表示该段在文件中存在</td></tr><tr><td>ALLOC</td><td>该段具有某种属性</td></tr><tr><td>LOAD</td><td>该段具有某种属性</td></tr><tr><td>RELOC</td><td>该段具有某种属性</td></tr><tr><td>READONLY</td><td>该段具有某种属性</td></tr><tr><td>CODE</td><td>该段具有某种属性</td></tr><tr><td>DATA</td><td>该段具有某种属性</td></tr></tbody></table><p>size SimpleSection.o 查看ELF文件的代码段、数据段和BSS段的长度（dec表示3个段长度和的十进制，hex表示长度和的十六进制）</p><p><img src="/../images/image-20221208140242825.png" alt="image-20221208140242825"></p><p><img src="/../images/image-20221208145813757.png" alt="image-20221208145813757"></p><p>用size看的text的长度还包含的.note.gnu.property和.eh_frame的长度，刚好加起来是189</p><h3 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h3><p>objdump</p><ul><li><p>-s 参数可以将所有段的内容以十六进制的方式打印出来</p></li><li><p>-d 参数可以将所有的包含指令的段反汇编</p></li></ul><p><code>objdump -s -d SimpleSection.o</code></p><p><img src="/../images/image-20221208150615895.png" alt="image-20221208150615895"></p><p>Contents of section .text 就是.text的数据以十六进制方式打印出来的内容，总共0x45字节，跟 .text段的长度符合，左边是偏移量，中间4例是十六进制内容，最后面是.text段的ASCII码。</p><p>下面是反汇编结果 -d 可以看到 .text段里，包含的就是SimpeSection.c里两个函数func1和main的指令。左面已经把各条指令分别对应的汇编指令输出来了。</p><h3 id="数据段和只读数据段"><a href="#数据段和只读数据段" class="headerlink" title="数据段和只读数据段"></a>数据段和只读数据段</h3><p>如果我们在代码里加入一句话printf</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global_inti_var = <span class="number">84</span>;</span><br><span class="line"><span class="keyword">int</span>  global_unint_var;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> static_var = <span class="number">85</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> static_var2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	func1(a + b + static_var + static_var2 );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为用到了一个字符串常量 %d\n，是一种只读数据，所以会放在.rodata段，我们再来用</p><p><code>objdump -h SimpleSection.o</code></p><p><img src="/../images/image-20221208152110539.png" alt="image-20221208152110539"></p><ul><li>.data段保存的是那些已经<strong>初始化了的全局变量和局部静态变量</strong>。SimpleSection.c中一个是global_inti_var和static_var这两个变量每个4个字节，刚好是8个字节，所以.data这个段的大小为8个字节。</li></ul><p><code>objdump -s SimpleSection.o</code></p><p><img src="/../images/image-20221208153039103.png" alt="image-20221208153039103"></p><ul><li>printf里用了一个字符串常量“%d\n” 是一个只读数据，这4个字节刚好是这个字符常量 的ASCII字节充，最后以\0x结尾，放在.rodata段，.rodata段存放的是只读数据，一般是程序里面的只读变量（如const修饰的变量）和字符串常量。</li></ul><p><code>objdump -x -s -d SimpleSection.o</code></p><ul><li>-x 输出<strong>文件体系结构</strong> <strong>文件格式</strong> <strong>节信息</strong> <strong>符号表</strong></li><li>-s 参数可以将所有段的内容以十六进制的方式打印出来</li><li>-d 参数可以将所有的包含指令的段反汇编</li></ul><p><img src="/../images/image-20221208153832399.png" alt="image-20221208153832399"></p><p>我们重点是验证前面.data的结论</p><p><img src="/../images/image-20221208153904864.png" alt="image-20221208153904864"></p><p>可以看到.data段里前4个字节，从低到高 0x54 0x00 0x00 0x00 刚好是global_init_var 即十进制的84，而最后4个字节刚好是static_init_var 的值即85。</p><blockquote><p>为什么存放次序为0x54 0x00 0x00 0x00而不是 00 00 00 54？</p><p>涉及CPU的字节序问题，即所谓的大端序（Big-endian）和小端序（Little-endian）问题</p></blockquote><h3 id="BSS段"><a href="#BSS段" class="headerlink" title="BSS段"></a>BSS段</h3><p>.bss段放的是未初始化的全局变量和局部静态变量，上述代码中global_uninit_Var和static_var2就是存放在.bss段，其实更准确的说法是.bss段为它们预留了空间</p><p>但我们发现该段只有4字节，和两个变量大小8个字节不符。</p><p>通过符号表看到</p><p><img src="/../images/image-20221208160024230.png" alt="image-20221208160024230"></p><p>确实只有static_var2放在.bss段，而global_uninit_var却没有存放在任何段，跟编译器的实现有关，有的会把<strong>全局未初始化变量</strong>存放在.bss段，有些则不存放，只是一个未定义的全局变量符号 这里是COMMON符号，等最终链接成可执行文件再在.bss段分配空间。可以把.c文件换成.cpp文件再编译，发现放在.bss段，我们现在全当它们放在.bss段。</p><h3 id="其他段"><a href="#其他段" class="headerlink" title="其他段"></a>其他段</h3><p>除了.text .data .bss 3个最常用段之外，还有一些常见的段。</p><table><thead><tr><th>常用的段名</th><th>说明</th></tr></thead><tbody><tr><td>.rodata1</td><td>Read only Data，这种段里存放的是只读数据，比如字符串常量、全局const变量。跟.rodata一样</td></tr><tr><td>.comment</td><td>存放的是编译器版本信息，比如字符串：GCC:(GNU)4.2.0</td></tr><tr><td>.debug</td><td>调试信息</td></tr><tr><td>.dynamic</td><td>动态链接信息</td></tr><tr><td>.hash</td><td>符号哈希表</td></tr><tr><td>.line</td><td>调试时的行号表，即源代码行号与编译后指令的对应表</td></tr><tr><td>.note</td><td>额外的编译器信息。比如程序的公司名、发布版本号等</td></tr><tr><td>.strtab</td><td>String Table 字符串表，用于存储ELF文件中用到的各种字符串</td></tr><tr><td>.symtab</td><td><strong>Symbol Table符号表</strong></td></tr><tr><td>.shstrtab</td><td>Section String Table 段名表</td></tr><tr><td>.plt</td><td>动态链接跳转表和全局入口表</td></tr><tr><td>.got</td><td>动态链接跳转表和全局入口表</td></tr><tr><td>.init</td><td>程序初始化与终结代码段</td></tr><tr><td>.fini</td><td>程序初始化与终结代码段</td></tr></tbody></table><p><strong>这些表的名字是系统保留的</strong>，应用程序也可以使用一些非系统保留的名字作为段名。比如可以在ELF文件中插入一个music的段，里面放一道mp3音乐，当ELF文件运行起来以后可以读取这个段播放mp3。<strong>但是应用程序自定义的段名不能使用.作为前缀，否则容易跟系统保留段名冲突。</strong></p><blockquote><p>怎么把一个图片、MP3音乐一类的东西作为目标文件中的一个段，要怎么做？</p><p><code>objcopy -I binary -O elf64-x86-64 -B i386 awsl12.jpg awsl12.o</code></p><p>把jpg转成.o</p><p><code>objdump -ht awsl12.o</code> 查看目标文件的格式和符号表</p></blockquote><p><img src="/../images/image-20221209093804930.png" alt="image-20221209093804930"></p><p>它有符号 _binary_awsl12_jpg_start _binary_awsl12_jpg_end 和_binary_awsl12_jpg_size 分别表示该图片在内存中的起始地址、结束地址和大小、可以在程序里面直接声明并使用它们。</p><h3 id="自定义段"><a href="#自定义段" class="headerlink" title="自定义段"></a>自定义段</h3><p>通常代码会放在.text段，全局变量和静态变量会放到.data和.bss段，但你可能希望变量或某些部分代码能够放到你所指定的段中去，实现某些特定的功能。比如为了满足某些硬件的内存和IO地址布局</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format,...)</span></span>;</span><br><span class="line"></span><br><span class="line">__attribute__((section(<span class="string">&quot;FOO&quot;</span>))) <span class="keyword">int</span> global_inti_var = <span class="number">84</span>;</span><br><span class="line"><span class="keyword">int</span>  global_unint_var;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__attribute__((section(<span class="string">&quot;BAR&quot;</span>))) <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> static_var = <span class="number">85</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> static_var2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	func1(a + b + static_var + static_var2 );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>添加_<em>attribute</em>_((section(“name”)))属性就可以把相应的变量或函数以“name”作为段名的段中。注意自定义段不是.开头的</p></blockquote><p><img src="/../images/image-20221209094547202.png" alt="image-20221209094547202"></p><h2 id="ELF文件结构描述"><a href="#ELF文件结构描述" class="headerlink" title="ELF文件结构描述"></a>ELF文件结构描述</h2><img src="../images/image-20221209095037002.png" alt="image-20221209095037002" style="zoom:50%"><p>ELF文件中与段关的重要结构就是<strong>段表</strong>（Section Header Table），该表描述了ELF文件包含的所有段的信息，比如每个段的<strong>段名</strong>、<strong>段的长度</strong>、在文件中的<strong>偏移</strong>、<strong>读写权限</strong>及段的其他属性。</p><h3 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h3><p><code>readelf -h SimpelSection.o</code> 查看ELF文件的文件头</p><p><img src="/../images/image-20221209105004038.png" alt="image-20221209105004038"></p><p>ELF文件头结构及相关常数被定义在 <code>/user/include/elf.h</code>里，ELF文件在各平台下都通用，有32位和64位版本。32和64位版本的ELF文件的文件头内容是一样的，只不过有些成员大小不一样。用<strong>typedef</strong>定义了一套自己的变量体系。</p><table><thead><tr><th>自定义类型</th><th>描述</th><th>原始类型</th><th>长度（字节）</th></tr></thead><tbody><tr><td>Elf64_Addr</td><td>64位版本程序地址</td><td>uint64_t</td><td>8</td></tr><tr><td>Elf64_Half</td><td>..无符号短整形</td><td>uint16_t</td><td>2</td></tr><tr><td>Elf64_Off</td><td>..偏移地址</td><td>uint64_t</td><td>8</td></tr><tr><td>Elf64_Sword</td><td>..有符号整形</td><td>int32_t</td><td>4</td></tr><tr><td>Elf64_Word</td><td>..无符号整形</td><td>uint32_t</td><td>4</td></tr></tbody></table><p>文件头的结构，定义 Elf64_Ehdr 结构体中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_hdr</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>	e_ident[<span class="number">16</span>];	<span class="comment">/* ELF &quot;magic number&quot; */</span></span><br><span class="line">  Elf64_Half e_type;</span><br><span class="line">  Elf64_Half e_machine;</span><br><span class="line">  Elf64_Word e_version;</span><br><span class="line">  Elf64_Addr e_entry;	<span class="comment">/* Entry point virtual address */</span></span><br><span class="line">  Elf64_Off e_phoff;	<span class="comment">/* Program header table file offset */</span></span><br><span class="line">  Elf64_Off e_shoff;	<span class="comment">/* Section header table file offset */</span></span><br><span class="line">  Elf64_Word e_flags;</span><br><span class="line">  Elf64_Half e_ehsize;</span><br><span class="line">  Elf64_Half e_phentsize;</span><br><span class="line">  Elf64_Half e_phnum;</span><br><span class="line">  Elf64_Half e_shentsize;</span><br><span class="line">  Elf64_Half e_shnum;</span><br><span class="line">  Elf64_Half e_shstrndx;</span><br><span class="line">&#125; Elf64_Ehdr;</span><br></pre></td></tr></table></figure><ul><li>e_ident 对应 <strong>类别</strong> &#x2F;<strong>数据</strong>&#x2F; <strong>Version &#x2F;OS&#x2F;ABI</strong>&#x2F; <strong>ABI版本</strong></li></ul><p><img src="/../images/image-20221209110615180.png" alt="image-20221209110615180"></p><p>剩下的参数与Elf64_Ehdr中的成员一一对应</p><ul><li>e_type 类型</li></ul><p><img src="/../images/image-20221209110741748.png" alt="image-20221209110741748"></p><ul><li>e_machine 系统架构</li></ul><p><img src="/../images/image-20221209110824065.png" alt="image-20221209110824065"></p><ul><li>e_version 版本 一般为常数1</li></ul><p><img src="/../images/image-20221209110837646.png" alt="image-20221209110837646"></p><ul><li>e_entry 入口点地址 可重入文件一般没有入口地址，则这个值为0</li></ul><p><img src="/../images/image-20221209110917620.png" alt="image-20221209110917620"></p><ul><li>e_phoff 程序头起点 暂不关系，要看”ELF链接视图和执行视图”</li></ul><p><img src="/../images/image-20221209111116053.png" alt="image-20221209111116053"></p><ul><li>e_shoff 段表在文件中的偏移（ELF文件头会指出段表 Section Header Table在文件中的偏移地址，很重要，通过这个可以找到段表的位置）</li></ul><p><img src="/../images/image-20221209111205539.png" alt="image-20221209111205539"></p><ul><li>e_word 标志位</li></ul><p><img src="/../images/image-20221209111321412.png" alt="image-20221209111321412"></p><ul><li>e_ehsize ELF文件头本身大小这里是64个字节</li></ul><p><img src="/../images/image-20221209111408212.png" alt="image-20221209111408212"></p><ul><li>e_phentsize 看后面ELF链接视图和执行视图一节</li></ul><p><img src="/../images/image-20221209111451191.png" alt="image-20221209111451191"></p><ul><li>e_phnum 看后面ELF链接视图和执行视图一节</li></ul><p><img src="/../images/image-20221209111527639.png" alt="image-20221209111527639"></p><ul><li>e_shentsize 段表描述符的大小 一般等于sizeof(Elf64_Ehdr)</li></ul><p><img src="/../images/image-20221209111625057.png" alt="image-20221209111625057"></p><ul><li>e_shnum 段表描述符数量。这个值等于ELF文件中拥有的段的数量，这里是14</li></ul><p><img src="/../images/image-20221209111715664.png" alt="image-20221209111715664"></p><ul><li>e_shstrndx 段表字符串表所在的段在段表中的下标</li></ul><p><img src="/../images/image-20221209111802059.png" alt="image-20221209111802059"></p><h4 id="ELF魔数"><a href="#ELF魔数" class="headerlink" title="ELF魔数"></a>ELF魔数</h4><p><img src="/../images/image-20221209130235027.png" alt="image-20221209130235027"></p><p>0x7f 0x45 0x4c 0x46 ELF文件的魔数，表示这是一个ELF文件</p><p>0x02 表示是64位的 0x01是32位 0 是无效文件</p><p>0x01 小端序 0x02 大端序 0 无效格式</p><p>0x01 主版本号 一般是1</p><p>后面9个字节 没有定义 一般填0</p><h4 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h4><table><thead><tr><th>常量</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>ET_REL</td><td>1</td><td>可重定位文件，一般为.o文件</td></tr><tr><td>ET_EXEC</td><td>2</td><td>可执行文件</td></tr><tr><td>ET_DYN</td><td>3</td><td>共享目标文件，一般为.so文件</td></tr></tbody></table><h3 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h3><p>Section Header Table 段表是保存这些段的基本属性的结构。ELF文件的段结构就是由段表决定的，每个段的段名、段的长度、在文件中的偏移、读写权限及段的其他属性。</p><blockquote><p>编译器、链接器和装载器都是依靠段表来定位和访问各个段的属性的。</p></blockquote><p>段表在ELF文件中位置由e_shoff成员决定。</p><p>objdump -h 命令只是把ELF文件中的关键段显示出来，省略了其他的辅助性的段，比如符号表、字符串表、段名字符串表、重定位表等。</p><p>用readelf来看ELF的真正段表结构：</p><p><code>readelf -S SimpleSection.o</code></p><p><img src="/../images/image-20221209131413041.png" alt="image-20221209131413041"></p><p>段表的结构体为<strong>Elf64_Shdr</strong>的数组，数组元素为段的个数，每个shdr结构体对应一个段。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_shdr</span> &#123;</span></span><br><span class="line">  Elf64_Word sh_name;	<span class="comment">/* Section name, index in string tbl */</span></span><br><span class="line">  Elf64_Word sh_type;	<span class="comment">/* Type of section */</span></span><br><span class="line">  Elf64_Xword sh_flags;	<span class="comment">/* Miscellaneous section attributes */</span></span><br><span class="line">  Elf64_Addr sh_addr;	<span class="comment">/* Section virtual addr at execution */</span></span><br><span class="line">  Elf64_Off sh_offset;	<span class="comment">/* Section file offset */</span></span><br><span class="line">  Elf64_Xword sh_size;	<span class="comment">/* Size of section in bytes */</span></span><br><span class="line">  Elf64_Word sh_link;	<span class="comment">/* Index of another section */</span></span><br><span class="line">  Elf64_Word sh_info;	<span class="comment">/* Additional section information */</span></span><br><span class="line">  Elf64_Xword sh_addralign;	<span class="comment">/* Section alignment */</span></span><br><span class="line">  Elf64_Xword sh_entsize;	<span class="comment">/* Entry size if section holds table */</span></span><br><span class="line">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure><p>段表是有14个元素的数组，第一个元素是无效的，类型为NULL，共有13个有效的段</p><table><thead><tr><th>成员</th><th>描述</th></tr></thead><tbody><tr><td>sh_name</td><td>Section name 段名<br>段名是字符串，它位于一个叫做.shstrtab的字符串表。sh_name是段名字符串在.shstrtab中的偏移</td></tr><tr><td>sh_type</td><td>Section type 段的类型</td></tr><tr><td>sh_flags</td><td>Section flag 段的标志位</td></tr><tr><td>sh_addr</td><td>Section Address 段虚拟地址<br>如果该段可以被加载，则sh_addr为该段被加载后在进程地址空间中的虚拟地址；否则sh_addr为0</td></tr><tr><td>sh_offset</td><td>Section Offset 段偏移<br>如果该段存在于文件中，则表示该段在文件中的偏移；否则无意义。比如sh_offset对于BSS段来说就没有意义</td></tr><tr><td>sh_size</td><td>Section Size 段的长度</td></tr><tr><td>sh_link和<br>sh_info</td><td>Section Link and Section Information段链接信息</td></tr><tr><td>sh_addralign</td><td>段地址对齐</td></tr><tr><td>sh_entsize</td><td>Section Entry Size项的长度<br>有些段包含固定大小的项，比如符号表它包含的每个符号所占的大小都一样的。表示每个项的大小，如果为0，则表示该段不包含固定大小的项</td></tr></tbody></table><blockquote><p>readelf -S 的输出结果从第二列名称开始的每一列，对应于结构体中的每个成员</p></blockquote><h4 id="段的类型"><a href="#段的类型" class="headerlink" title="段的类型"></a>段的类型</h4><p>段的名字只是链接和编译过程有意义，不能真正地表示段的类型。我们可以将一个数据段命名为.text 决定段的属性的是段的类型sh_type和段的标志位sh_flags</p><img src="../images/image-20221209185728928.png" alt="image-20221209185728928" style="zoom:50%"><p>以SHT_开头</p><table><thead><tr><th>常量</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>SHT_NULL</td><td>0</td><td>无效段</td></tr><tr><td>SHT_PROGBITS</td><td>1</td><td>程序段，代码段，数据段都是这种类型的</td></tr><tr><td>SHT_SYMTAB</td><td>2</td><td>表示该段的内容为符号表</td></tr><tr><td>SHT_STRTAB</td><td>3</td><td>表示该段的内容为字符串表</td></tr><tr><td>SHT_RELA</td><td>4</td><td>重定位表。该段包含了重定位信息</td></tr><tr><td>SHT_HASH</td><td>5</td><td>符号表的哈希表</td></tr><tr><td>SHT_DYNAMIC</td><td>6</td><td>动态链接信息</td></tr><tr><td>SHT_NOTE</td><td>7</td><td>提示性信息</td></tr><tr><td>SHT_NOBITS</td><td>8</td><td>表示该段在文件中没内容</td></tr><tr><td>SHT_REL</td><td>9</td><td>该段包含了重定位信息</td></tr><tr><td>SHT_SHLIB</td><td>10</td><td>保留</td></tr><tr><td>SHT_DNYSYM</td><td>11</td><td>动态链接的符号表</td></tr></tbody></table><h4 id="段的标志位"><a href="#段的标志位" class="headerlink" title="段的标志位"></a>段的标志位</h4><p>是否可写，是否可执行，以SHF_开头</p><table><thead><tr><th>常量</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>SHF_WRITE</td><td>1</td><td>表示该段在进程空间中可写</td></tr><tr><td>SHF_ALLOC</td><td>2</td><td>表示该段在进程空间中须要分配空间。有些包含指示或控制信息的段不需要在进程空间中被分配空间，它们一般不会有这个标志。像代码段、数据段和.bss段都会有这个标志位</td></tr><tr><td>SHF_EXECINSTR</td><td>4</td><td>表示该段在进程空间中可以被执行，一般指代码段</td></tr></tbody></table><h4 id="段的链接信息（sh-link、sh-info）"><a href="#段的链接信息（sh-link、sh-info）" class="headerlink" title="段的链接信息（sh_link、sh_info）"></a>段的链接信息（sh_link、sh_info）</h4><p>如果段的类型是与链接相关的（不论是动态链接或静态链接），比如重定位表、符号表等，那么sh_link和sh_info这两个成员所包含的意义如下，对于其他类型的段，这两个成员没有意义。</p><p>链接信息要配合着sh_type一起看的</p><table><thead><tr><th>sh_type</th><th>sh_link</th><th>sh_info</th></tr></thead><tbody><tr><td>SHT_DYNAMIC</td><td>该段所使用的字符串表在段表中的下标</td><td>0</td></tr><tr><td>SHT_HASH</td><td>该段所使用的符号表在段表中的下标</td><td>0</td></tr><tr><td>SHT_REL<br>SHT_RELA</td><td>该段所使用的相应符号表在段表中的下标</td><td>该重定位表所作用的段在段表中的下标</td></tr><tr><td>SHT_SYMTAB<br>SHT_DYNSYM</td><td>操作系统相关的</td><td>操作系统相关的</td></tr><tr><td>other</td><td>SHN_UNDEF</td><td>0</td></tr></tbody></table><p>比如</p><p><img src="/../images/image-20221210062408633.png" alt="image-20221210062408633"></p><h3 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h3><p>SimpleSection.o有一个叫 .rel.text的段，类型是SHT_RELA 也就是说它是一个重定位表。正如我们前面所说的，链接器在处理目标文件时，需要对目标文件中某些部位进行重定位，即代码段和数据段中那些对绝对地址的引用的位置。这些重定位的信息都记录在ELF文件的重定位表里面，对于每个需要重定位的代码段或数据段，都会有一个相应的重定位表。比如SimpleSection.o中的.rel.text就是针对.text段的重定位表，因为.text段中至少有一个绝对地址的引用，那就是对printf函数的调用；而.data段则没有对绝对地址的引用，它只包含了几个常量，所以没有针对.data段的重定位表.rel.data</p><p>一个重定位表同时也是ELF的一个段，那么这个段的类型sh_type就是SHT_RELA类型的</p><ul><li>sh_link：表示符号表的下标，这里是11 也就是.symtab</li><li>sh_info：表示它作用于哪个段，比如这里是1就是.text段</li></ul><h3 id="字符串表"><a href="#字符串表" class="headerlink" title="字符串表"></a>字符串表</h3><p>ELF文件中用到很多字符串，比如段名、变量名等。因为字符串的长度往往是不定的，所以用固定的结构来表示它比较困难。一种很常见的做法是把字符串集中起来存放到一个表，然后使用字符串在表中的偏移来引用字符串。</p><table><thead><tr><th>偏移</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>0</td><td>\0</td><td>h</td><td>e</td><td>l</td><td>l</td><td>o</td><td>w</td><td>o</td><td>r</td><td>l</td></tr><tr><td>10</td><td>d</td><td>\0</td><td>M</td><td>y</td><td>v</td><td>a</td><td>r</td><td>i</td><td>a</td><td>b</td></tr><tr><td>20</td><td>l</td><td>e</td><td>\0</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>那么偏移与它们对应的字符串如下</p><table><thead><tr><th>偏移</th><th>字符串</th></tr></thead><tbody><tr><td>0</td><td>空字符串</td></tr><tr><td>1</td><td>helloworld</td></tr><tr><td>6</td><td>world</td></tr><tr><td>12</td><td>Myvariable</td></tr></tbody></table><p>通过这种方法，在ELF文件中引用字符串只需要给出一个数字下标即可，不用考虑字符串长度的问题。一般字符串表在ELF文件中也以段的形式保存，常见的段名为.strtab或.shstrtab 这两个字符串表分别为<strong>字符串表</strong>和<strong>段表字符串表</strong>。顾名思义，<strong>字符串表</strong>用来保存普通的字符串，比如<strong>符号的名字</strong>；<strong>段表字符串表</strong>用来保存段表中用到的字符串，最常见的就是<strong>段名</strong>(sh_name)</p><p>回头看ELF文件头e_shstrndx含义，是ELF64_Ehdr的最后一个成员，它是Section header string table index的缩写。段表字符串表本身也是ELF文件中的一个普通的段，它的名字是.shstrtab。那么这个e_shstrndx就是.shstrtab在段表中的下标。</p><p><img src="/../images/image-20221210065104164.png" alt="image-20221210065104164"></p><p>readelf -S SimpleSection.o 看一下，确实是13</p><p><img src="/../images/image-20221210065115607.png" alt="image-20221210065115607"></p><p>只有分析ELF文件头，就可以得到段表和段表字符串表的位置，从而解析整个ELF文件。</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/2022/12/05/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E7%AB%A0-%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5/" rel="prev" title="程序员的自我修养读书笔记-第2章 编译和链接"><i class="fa fa-chevron-left"></i> 程序员的自我修养读书笔记-第2章 编译和链接</a></div><div class="post-nav-item"><a href="/2022/12/06/%E4%B8%80%E7%AF%87%E6%96%87%E4%BB%B6%E7%9C%8B%E6%87%82v1-v2-v3%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6-%E8%BD%AC/" rel="next" title="一篇文件看懂v1/v2/v3签名机制[转]">一篇文件看懂v1/v2/v3签名机制[转] <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener("tabs:register",()=>{let e=CONFIG.comments["activeClass"];if(CONFIG.comments.storage&&(e=localStorage.getItem("comments_active")||e),e){let t=document.querySelector(`a[href="#comment-${e}"]`);t&&t.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="nav-number">1.</span> <span class="nav-text">目标文件的格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84"><span class="nav-number">2.</span> <span class="nav-text">目标文件是什么样的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%96%E6%8E%98SimpleSection-o"><span class="nav-number">3.</span> <span class="nav-text">挖掘SimpleSection.o</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E6%AE%B5"><span class="nav-number">3.1.</span> <span class="nav-text">代码段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%AE%B5%E5%92%8C%E5%8F%AA%E8%AF%BB%E6%95%B0%E6%8D%AE%E6%AE%B5"><span class="nav-number">3.2.</span> <span class="nav-text">数据段和只读数据段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BSS%E6%AE%B5"><span class="nav-number">3.3.</span> <span class="nav-text">BSS段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E6%AE%B5"><span class="nav-number">3.4.</span> <span class="nav-text">其他段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%AE%B5"><span class="nav-number">3.5.</span> <span class="nav-text">自定义段</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E6%8F%8F%E8%BF%B0"><span class="nav-number">4.</span> <span class="nav-text">ELF文件结构描述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%A4%B4"><span class="nav-number">4.1.</span> <span class="nav-text">文件头</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ELF%E9%AD%94%E6%95%B0"><span class="nav-number">4.1.1.</span> <span class="nav-text">ELF魔数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.1.2.</span> <span class="nav-text">文件类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AE%B5%E8%A1%A8"><span class="nav-number">4.2.</span> <span class="nav-text">段表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AE%B5%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.2.1.</span> <span class="nav-text">段的类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AE%B5%E7%9A%84%E6%A0%87%E5%BF%97%E4%BD%8D"><span class="nav-number">4.2.2.</span> <span class="nav-text">段的标志位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AE%B5%E7%9A%84%E9%93%BE%E6%8E%A5%E4%BF%A1%E6%81%AF%EF%BC%88sh-link%E3%80%81sh-info%EF%BC%89"><span class="nav-number">4.2.3.</span> <span class="nav-text">段的链接信息（sh_link、sh_info）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8"><span class="nav-number">4.3.</span> <span class="nav-text">重定位表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A8"><span class="nav-number">4.4.</span> <span class="nav-text">字符串表</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">张龙</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">63</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">14</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">2</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">张龙</span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script></body></html>