<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"example.com",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta property="og:type" content="website"><meta property="og:title" content="SteveZhang博客"><meta property="og:url" content="http://example.com/page/4/index.html"><meta property="og:site_name" content="SteveZhang博客"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="张龙"><meta name="twitter:card" content="summary"><link rel="canonical" href="http://example.com/page/4/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!0,isPost:!1,lang:"zh-CN"}</script><title>SteveZhang博客</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="SteveZhang博客" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">SteveZhang博客</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">47</span></a></li></ul></nav></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content index posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/05/25/%E5%9F%BA%E4%BA%8ERecyclerViewDiffUtilsDatabinding-Starter%E5%BA%94%E7%94%A8-%E5%AD%A6%E4%B9%A0DiffUtils%E5%92%8CDatabinding%E7%9A%84%E4%BD%BF%E7%94%A8/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/05/25/%E5%9F%BA%E4%BA%8ERecyclerViewDiffUtilsDatabinding-Starter%E5%BA%94%E7%94%A8-%E5%AD%A6%E4%B9%A0DiffUtils%E5%92%8CDatabinding%E7%9A%84%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">基于RecyclerViewDiffUtilsDatabinding-Starter应用-学习DiffUtils和Databinding的使用</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-05-25 13:24:47" itemprop="dateCreated datePublished" datetime="2022-05-25T13:24:47+08:00">2022-05-25</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-11-20 12:38:57" itemprop="dateModified" datetime="2022-11-20T12:38:57+08:00">2022-11-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/kotlin/" itemprop="url" rel="index"><span itemprop="name">kotlin</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="开始学习"><a href="#开始学习" class="headerlink" title="开始学习"></a>开始学习</h2><p>看下<code>SleepNightAdapter.kt</code>文件</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SleepNightAdapter</span>: <span class="type">RecyclerView.Adapter</span>&lt;<span class="type">SleepNightAdapter.ViewHolder</span>&gt;</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">data</span> =  listOf&lt;SleepNight&gt;()</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            field = value</span><br><span class="line">            notifyDataSetChanged()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span> = <span class="keyword">data</span>.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">ViewHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> item = <span class="keyword">data</span>[position]</span><br><span class="line">        holder.bind(item)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: ViewHolder &#123;</span><br><span class="line">        <span class="keyword">return</span> ViewHolder.from(parent)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(itemView: View) : RecyclerView.ViewHolder(itemView)&#123;</span><br><span class="line">        <span class="keyword">val</span> sleepLength: TextView = itemView.findViewById(R.id.sleep_length)</span><br><span class="line">        <span class="keyword">val</span> quality: TextView = itemView.findViewById(R.id.quality_string)</span><br><span class="line">        <span class="keyword">val</span> qualityImage: ImageView = itemView.findViewById(R.id.quality_image)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">bind</span><span class="params">(item: <span class="type">SleepNight</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">val</span> res = itemView.context.resources</span><br><span class="line">            sleepLength.text = convertDurationToFormatted(item.startTimeMilli, item.endTimeMilli, res)</span><br><span class="line">            quality.text = convertNumericQualityToString(item.sleepQuality, res)</span><br><span class="line">            qualityImage.setImageResource(<span class="keyword">when</span> (item.sleepQuality) &#123;</span><br><span class="line">                <span class="number">0</span> -&gt; R.drawable.ic_sleep_0</span><br><span class="line">                <span class="number">1</span> -&gt; R.drawable.ic_sleep_1</span><br><span class="line">                <span class="number">2</span> -&gt; R.drawable.ic_sleep_2</span><br><span class="line">                <span class="number">3</span> -&gt; R.drawable.ic_sleep_3</span><br><span class="line">                <span class="number">4</span> -&gt; R.drawable.ic_sleep_4</span><br><span class="line">                <span class="number">5</span> -&gt; R.drawable.ic_sleep_5</span><br><span class="line">                <span class="keyword">else</span> -&gt; R.drawable.ic_sleep_active</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">            <span class="function"><span class="keyword">fun</span> <span class="title">from</span><span class="params">(parent: <span class="type">ViewGroup</span>)</span></span>: ViewHolder &#123;</span><br><span class="line">                <span class="keyword">val</span> layoutInflater = LayoutInflater.from(parent.context)</span><br><span class="line">                <span class="keyword">val</span> view = layoutInflater</span><br><span class="line">                        .inflate(R.layout.list_item_sleep_night, parent, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> ViewHolder(view)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220525132631228.png" alt="image-20220525132631228"></p><ul><li>应用根据用户输入创建 <code>SleepNight</code> 对象列表。每个 <code>SleepNight</code> 对象表示一个夜晚以及用户该晚睡眠的时长和质量。</li><li><code>SleepNightAdapter</code> 会将 <code>SleepNight</code> 对象的列表调整为 <code>RecyclerView</code> 可以使用和显示的内容。</li><li><code>SleepNightAdapter</code> 适配器会生成 <code>ViewHolders</code>，其中包含 RecyclerView 用于显示数据的视图、数据和元数据信息。</li><li><code>RecyclerView</code> 使用 <code>SleepNightAdapter</code> 来确定要显示的项数 (<code>getItemCount()</code>)。<code>RecyclerView</code> 使用 <code>onCreateViewHolder()</code> 和 <code>onBindViewHolder()</code> 获取与要显示的数据绑定的 ViewHolder。</li></ul><h3 id="notifyDataSetChanged-方法效率低下"><a href="#notifyDataSetChanged-方法效率低下" class="headerlink" title="notifyDataSetChanged() 方法效率低下"></a>notifyDataSetChanged() 方法效率低下</h3><p>为了告知 <code>RecyclerView</code> 列表中的某个项已更改且需要更新，当前代码会在 <code>SleepNightAdapter</code> 中调用 <a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/widget/BaseAdapter"><code>notifyDataSetChanged()</code></a>，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">data</span> =  listOf&lt;SleepNight&gt;()</span><br><span class="line">   <span class="keyword">set</span>(value) &#123;</span><br><span class="line">       field = value</span><br><span class="line">       notifyDataSetChanged()</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>但是，<code>notifyDataSetChanged()</code> 会告知 <code>RecyclerView</code> 整个列表可能无效。因此，<code>RecyclerView</code> 会重新绑定并重新绘制列表中的每个项，<strong>包括屏幕上看不到的项</strong>。这是一项既繁重又不必要的工作。对于较大或复杂的列表，这个过程可能需要较长时间，<strong>以至于在用户滚动浏览列表时，屏幕会闪烁或卡顿。</strong></p><p>要解决此问题，您可以确切地告诉 <code>RecyclerView</code> 发生了什么更改。然后，<code>RecyclerView</code> 便可仅更新屏幕上已经发生更改的视图。</p><p><code>RecyclerView</code> 拥有一个用于更新单个元素的功能丰富的 API。您可以使用 <a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/support/v7/widget/RecyclerView.Adapter#notifyitemchanged"><code>notifyItemChanged()</code></a> 告知 <code>RecyclerView</code> 某个项发生了更改，并且您可以对添加、移除或移动的项使用类似的函数。您可以全部手动完成，但这样任务就会很繁重，并且可能需要使用大量代码。</p><p>幸运的是，我们有一个更好的办法。</p><h3 id="DiffUtil-很高效并可为您完成繁重工作"><a href="#DiffUtil-很高效并可为您完成繁重工作" class="headerlink" title="DiffUtil 很高效并可为您完成繁重工作"></a>DiffUtil 很高效并可为您完成繁重工作</h3><p><code>RecyclerView</code> 有一个名为 <code>DiffUtil</code> 的类，用于计算两个列表之间的差异。<code>DiffUtil</code> 会接受一个旧列表和一个新列表，并确定二者有何不同。它会查找已添加、移除或更改的项。然后，它会使用一种算法（名为 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Diff">Eugene W. Myers 差分算法</a>），来确定要生成新列表，需要对旧列表做出的最小更改量。</p><p>在 <code>DiffUtil</code> 确定了更改内容后，<code>RecyclerView</code> 可以根据这些信息仅更新已更改、添加、移除或移动的项，这比重做整个列表要高效得多。</p><h2 id="使用DiffUtil刷新列表内容"><a href="#使用DiffUtil刷新列表内容" class="headerlink" title="使用DiffUtil刷新列表内容"></a>使用DiffUtil刷新列表内容</h2><h3 id="第-1-步：实现-SleepNightDiffCallback"><a href="#第-1-步：实现-SleepNightDiffCallback" class="headerlink" title="第 1 步：实现 SleepNightDiffCallback"></a>第 1 步：实现 SleepNightDiffCallback</h3><p>为了使用 <code>DiffUtil</code> 类的功能，请扩展 <code>DiffUtil.ItemCallback</code>。</p><p>1.打开 <code>SleepNightAdapter.kt</code>。</p><p>2.在 <code>SleepNightAdapter</code> 的完整类定义下方，创建一个名为 <code>SleepNightDiffCallback</code> 的新顶级类，用于扩展 <code>DiffUtil.ItemCallback</code>。以通用参数的形式传递 <code>SleepNight</code>。</p><p>3.将光标放在 <code>SleepNightDiffCallback</code> 类名称上。</p><p>4.<code>Alt+Enter</code>（在 Mac 上，按 <code>Option+Enter</code>）并选择 <strong>Implement Members</strong>。</p><p>5.在打开的对话框中，按住 Shift 键并点击鼠标左键以选择 <code>areItemsTheSame()</code> 和 <code>areContentsTheSame()</code> 方法，然后点击 <strong>OK</strong>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SleepNightDiffCallback</span> : <span class="type">DiffUtil.ItemCallback</span>&lt;<span class="type">SleepNight</span>&gt;</span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此操作会针对这两个方法在 <code>SleepNightDiffCallback</code> 中生成桩，如下所示。<code>DiffUtil</code> 使用这两种方法来确定列表和项的具体更改。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    TODO(<span class="string">&quot;not implemented&quot;</span>) <span class="comment">//To change body of created functions use File | Settings | File Templates.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">areContentsTheSame</span><span class="params">(oldItem: <span class="type">SleepNight</span>, newItem: <span class="type">SleepNight</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    TODO(<span class="string">&quot;not implemented&quot;</span>) <span class="comment">//To change body of created functions use File | Settings | File Templates.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.在 <code>areItemsTheSame()</code> 中，将 <code>TODO</code> 替换为用于测试两个传入 <code>SleepNight</code> 项 <code>oldItem</code> 和 <code>newItem</code> 是否相同的代码。如果这两个项具有相同的 <code>nightId</code>，则表明它们是相同的，因此返回 <code>true</code>。否则返回 <code>false</code>。<code>DiffUtil</code> 使用此测试来帮助发现是否已添加、移除或移动某个项。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">areItemsTheSame</span><span class="params">(oldItem: <span class="type">SleepNight</span>, newItem: <span class="type">SleepNight</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> oldItem.nightId == newItem.nightId</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.在 <code>areContentsTheSame()</code> 中，检查 <code>oldItem</code> 和 <code>newItem</code> 是否包含相同的数据；即判断它们是否相等。由于 <code>SleepNight</code> 是一个数据类，<strong>此相等性检查将检查所有字段</strong>。<code>Data</code> 类会自动为您定义 <code>equals</code> 和一些其他方法。如果 <code>oldItem</code> 和 <code>newItem</code> 之间存在差异，此代码会告知 <code>DiffUtil</code> 相应项已更新。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">areContentsTheSame</span><span class="params">(oldItem: <span class="type">SleepNight</span>, newItem: <span class="type">SleepNight</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> oldItem == newItem</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用ListAdapter管理列表"><a href="#使用ListAdapter管理列表" class="headerlink" title="使用ListAdapter管理列表"></a>使用ListAdapter管理列表</h2><p>通常使用 <code>RecyclerView</code> 来显示会发生变化的列表。<code>RecyclerView</code> 提供适配器类 <code>ListAdapter</code>，可帮助您构建由列表支持的 <code>RecyclerView</code> 适配器。</p><p><code>ListAdapter</code> 会为您跟踪列表，并在列表更新时通知适配器。</p><p>1.在 <code>SleepNightAdapter.kt</code> 文件中，更改 <code>SleepNightAdapter</code> 的类签名以扩展 <code>ListAdapter</code>。</p><p>2.如果出现提示，请导入 <code>androidx.recyclerview.widget.ListAdapter</code>。</p><p>3.将 <code>SleepNight</code> 作为第一个参数添加到 <code>ListAdapter</code> 中 <code>SleepNightAdapter.ViewHolder</code> 之前。</p><p>4.将 <code>SleepNightDiffCallback()</code> 作为参数添加到构造函数中。<code>ListAdapter</code> 将利用此参数确定列表中的更改内容。完成后的 <code>SleepNightAdapter</code> 类签名应如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SleepNightAdapter</span> : <span class="type">ListAdapter</span>&lt;<span class="type">SleepNight, SleepNightAdapter.ViewHolder</span>&gt;</span>(SleepNightDiffCallback()) &#123;</span><br></pre></td></tr></table></figure><p>5.在 <code>SleepNightAdapter</code> 类中，删除 <code>data</code> 字段，包括 setter。您已不再需要它，因为 <code>ListAdapter</code> 会为您跟踪列表。</p><p>6.删除 <code>getItemCount()</code> 的替换方法，因为 <code>ListAdapter</code> 为您实现了此方法。</p><p>7.如需消除 <code>onBindViewHolder()</code> 中的错误，请更改 <code>item</code> 变量。调用 <code>ListAdapter</code> 提供的 <code>getItem(position)</code> 方法，而不要使用 <code>data</code> 来获取 <code>item</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> item = getItem(position)</span><br></pre></td></tr></table></figure><h3 id="第-2-步：使用-submitList-及时更新列表"><a href="#第-2-步：使用-submitList-及时更新列表" class="headerlink" title="第 2 步：使用 submitList() 及时更新列表"></a>第 2 步：使用 submitList() 及时更新列表</h3><p>在有已更改的列表时，您的代码需要告知 <code>ListAdapter</code>。<code>ListAdapter</code> 提供了一个名为 <code>submitList()</code> 的方法，用于告知 <code>ListAdapter</code> 列表有新版本。调用此方法时，<code>ListAdapter</code> 会将新列表与旧列表进行差异比较，并检测已添加、移除、移动或更改的项。然后，<code>ListAdapter</code> 会更新 <code>RecyclerView</code> 所显示的项。</p><p>1.打开 <code>SleepTrackerFragment.kt</code>。</p><p>2.在 <code>sleepTrackerViewModel</code> 内的观察器上，在 <code>onCreateView()</code> 中找到引用您已删除的 <code>data</code> 变量的错误。</p><p>3.将 <code>adapter.data = it</code> 替换为对 <code>adapter.submitList(it)</code> 的调用。更新后的代码如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sleepTrackerViewModel.nights.observe(viewLifecycleOwner, Observer &#123;</span><br><span class="line">   it?.let &#123;</span><br><span class="line">       adapter.submitList(it)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>4.运行您的应用。您可能需要导入 findNavController。您可能会注意到，您的应用运行速度变快了，然而如果列表太小，这个变化可能不明显。</p><h2 id="将DataBinding与RecyclerView搭配使用"><a href="#将DataBinding与RecyclerView搭配使用" class="headerlink" title="将DataBinding与RecyclerView搭配使用"></a>将DataBinding与RecyclerView搭配使用</h2><p>在此任务中，您需要使用与之前 Codelab 相同的方法来设置数据绑定，并消除对 <code>findViewById()</code> 的调用。</p><h3 id="第-1-步：向布局文件添加数据绑定"><a href="#第-1-步：向布局文件添加数据绑定" class="headerlink" title="第 1 步：向布局文件添加数据绑定"></a>第 1 步：向布局文件添加数据绑定</h3><p>1.在 <strong>Code</strong> 标签页中打开 <code>list_item_sleep_night.xml</code> 布局文件。</p><p>2.将光标放在 <code>ConstraintLayout</code> 标签上，然后按 <code>Alt+Enter</code>（在 Mac 上，按 <code>Option+Enter</code>）。系统随即会打开 intent 菜单（“quick fix”菜单）。</p><p>3.选择 <strong>Convert to data binding layout</strong>。这会将布局封装到 <code>&lt;layout&gt;</code> 中，并在其中添加 <code>&lt;data&gt;</code> 标签。</p><p>4.根据需要滚动回顶部，并在 <code>&lt;data&gt;</code> 标签内声明一个名为 <code>sleep</code> 的变量。</p><p>5.将其 <code>type</code> 设为 <code>SleepNight</code> 的完全限定名称 <code>com.example.android.trackmysleepquality.database.SleepNight</code>。完成后的 <code>&lt;data&gt;</code> 标签应如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">data</span>&gt;</span><br><span class="line">     &lt;variable</span><br><span class="line">         name=<span class="string">&quot;sleep&quot;</span></span><br><span class="line">         type=<span class="string">&quot;com.example.android.trackmysleepquality.database.SleepNight&quot;</span>/&gt;</span><br><span class="line"> &lt;/<span class="keyword">data</span>&gt;</span><br></pre></td></tr></table></figure><p>6.如需强制创建 <code>Binding</code> 对象，请依次选择 <strong>Build &gt; Clean Project</strong>，然后依次选择 <strong>Build &gt; Rebuild Project</strong>。（如果仍然存在问题，请依次选择 <strong>File &gt; Invalidate Caches &#x2F; Restart</strong>。）<code>ListItemSleepNightBinding</code> 绑定对象以及相关代码会添加到项目生成的文件中。</p><h3 id="第-2-步：使用数据绑定膨胀项布局"><a href="#第-2-步：使用数据绑定膨胀项布局" class="headerlink" title="第 2 步：使用数据绑定膨胀项布局"></a>第 2 步：使用数据绑定膨胀项布局</h3><p>1.打开 <code>SleepNightAdapter.kt</code>。</p><p>2.在 <code>companion object</code> 中，找到 <code>from(parent: ViewGroup)</code> 函数。</p><p>3.删除 <code>view</code> 变量的声明。</p><p>要<strong>删除</strong>的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> view = layoutInflater</span><br><span class="line">       .inflate(R.layout.list_item_sleep_night, parent, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>4.在 <code>view</code> 变量所在的位置，定义一个名为 <code>binding</code> 的新变量，以膨胀 <code>ListItemSleepNightBinding</code> 绑定对象，如下所示。根据需要导入绑定对象。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> binding =</span><br><span class="line">ListItemSleepNightBinding.inflate(layoutInflater, parent, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>5.在函数结尾，不要返回 <code>view</code>，而应返回 <code>binding</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> ViewHolder(binding)</span><br></pre></td></tr></table></figure><p>6.要消除 <code>binding</code> 上的错误，请将光标放在 <code>binding</code> 一词上。按 <code>Alt+Enter</code>（在 Mac 上，按 <code>Option+Enter</code>）打开 intent 菜单。</p><p>7.选择 **Change parameter ‘itemView’ type of primary constructor of class ‘ViewHolder’ to ‘ListItemSleepNightBinding’**。这将更新 <code>ViewHolder</code> 类的参数类型。</p><p><img src="/../images/image-20220525135714938.png" alt="image-20220525135714938"></p><p>8.向上滚动到 <code>ViewHolder</code> 的类定义，以查看签名中的更改。您会看到 <code>itemView</code> 的错误，因为您在 <code>from()</code> 方法中将 <code>itemView</code> 更改为了 <code>binding</code>。</p><p>在 <code>ViewHolder</code> 类定义中，右键点击 <code>itemView</code> 的一个发生实例，然后依次选择 <strong>Refactor</strong> &gt; <strong>Rename</strong>。将名称更改为 <code>binding</code>。</p><p>9.为构造函数参数 <code>binding</code> 添加 <code>val</code> 前缀，使其成为属性。</p><p>10.在对父类 <code>RecyclerView.ViewHolder</code> 的调用中，将参数从 <code>binding</code> 更改为 <code>binding.root</code>。您需要传递 <code>View</code>，并且将 <code>binding.root</code> 作为项布局中的根 <code>ConstraintLayout</code>。</p><p>11.完成后的类声明应如以下代码所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(<span class="keyword">val</span> binding: ListItemSleepNightBinding) : RecyclerView.ViewHolder(binding.root)&#123;</span><br></pre></td></tr></table></figure><p>您还会看到对 <code>findViewById().</code> 的调用的错误。您将在下一部分中修复这些错误。</p><h3 id="第-3-步：替换-findViewById"><a href="#第-3-步：替换-findViewById" class="headerlink" title="第 3 步：替换 findViewById()"></a>第 3 步：替换 findViewById()</h3><p>您现在可以更新 <code>sleepLength</code>、<code>quality</code> 和 <code>qualityImage</code> 属性，以使用 <code>binding</code> 对象代替 <code>findViewById()</code>。</p><p>1.将 <code>sleepLength</code>、<code>qualityString</code> 和 <code>qualityImage</code> 的初始化更改为使用 <code>binding</code> 对象的视图，如下所示。此后，您的代码应该不会再显示任何错误。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sleepLength: TextView = binding.sleepLength</span><br><span class="line"><span class="keyword">val</span> quality: TextView = binding.qualityString</span><br><span class="line"><span class="keyword">val</span> qualityImage: ImageView = binding.qualityImage</span><br></pre></td></tr></table></figure><p>绑定对象就位后，您根本不需要定义 <code>sleepLength</code>、<code>quality</code> 和 <code>qualityImage</code> 属性。<code>DataBinding</code> 将缓存查询，因此无需声明这些属性。</p><p>2.右键点击 <code>sleepLength</code>、<code>quality</code> 和 <code>qualityImage</code> 属性名称。对于每个属性，依次选择 <strong>Refactor &gt; Inline</strong>，或按 <code>Ctrl+Alt+N</code>（在 Mac 上按 <code>Option+Command+N</code>）。</p><p><img src="/../images/image-20220525135903462.png" alt="image-20220525135903462"></p><p>3.运行您的应用。（如果项目出现错误，您可能需要<strong>清理</strong>并<strong>重建</strong>项目。）</p><h2 id="创建绑定适配器"><a href="#创建绑定适配器" class="headerlink" title="创建绑定适配器"></a>创建绑定适配器</h2><p>在此任务中，您需要升级应用，将数据绑定与绑定适配器结合使用，在视图中设置数据。</p><p>在上一个 Codelab 中，您使用了 <a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/arch/lifecycle/Transformations"><code>Transformations</code></a> 类来获取 <code>LiveData</code> 并生成要在文本视图中显示的格式化字符串。但是，如果您需要绑定不同类型或复杂类型的数据，您可以提供绑定适配器来帮助数据绑定功能使用这些类型。绑定适配器会获取您的数据，并将其调整为可供数据绑定功能用于绑定视图（例如文本或图片）的内容。</p><p>您需要实现三个绑定适配器，一个用于高质量图片，另外两个分别用于一个文本字段。总而言之，如需声明绑定适配器，您需要定义一种获取项和视图的方法，并用 <code>@BindingAdapter</code> 进行注解。在该方法的正文中，您可以实现转换。在 Kotlin 中，您可以在接收数据的视图类上将绑定适配器编写为扩展函数。</p><h3 id="第-1-步：创建绑定适配器"><a href="#第-1-步：创建绑定适配器" class="headerlink" title="第 1 步：创建绑定适配器"></a>第 1 步：创建绑定适配器</h3><p>请注意，您必须在此步骤中导入很多类。</p><p>1.打开 <code>SleepNightAdapter.kt</code>。</p><p>2.在 <code>ViewHolder</code> 类中，找到 <code>bind()</code> 方法并注意该方法的用途。您需要获取用于计算 <code>binding.sleepLength</code>、<code>binding.quality</code> 和 <code>binding.qualityImage</code> 的值的代码，并在适配器中改用该代码。（目前不要更改代码，您需要在后续步骤中移动代码。）</p><p>3.在 <code>sleeptracker</code> 软件包中，创建一个名为 <code>BindingUtils.kt</code> 的新文件并打开此文件。</p><p>4.删除 <code>BindingUtils</code> 类中的所有内容，因为您接下来要创建静态函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BindingUtils</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>5.在 <code>TextView</code> 上声明一个名为 <code>setSleepDurationFormatted</code> 的扩展函数，并传入 <code>SleepNight</code>。此函数将作为适配器，用于计算和格式化睡眠时长。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> TextView.<span class="title">setSleepDurationFormatted</span><span class="params">(item: <span class="type">SleepNight</span>)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>6.在 <code>setSleepDurationFormatted</code> 的正文中，将数据绑定到视图，如在 <code>ViewHolder.bind()</code> 中一样。调用 <code>convertDurationToFormatted()</code>，然后将 <code>TextView</code> 的 <code>text</code> 设置为格式化文本。（由于这是 <code>TextView</code> 上的扩展函数，您可以直接访问 <code>text</code> 属性。）</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text = convertDurationToFormatted(item.startTimeMilli, item.endTimeMilli, context.resources)</span><br></pre></td></tr></table></figure><p>7.如需向数据绑定功能告知此绑定适配器，请使用 <code>@BindingAdapter</code> 为该函数添加注解。</p><p>8.此函数是用于 <code>sleepDurationFormatted</code> 属性的适配器，因此请将 <code>sleepDurationFormatted</code> 作为参数传递给 <code>@BindingAdapter</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(<span class="meta-string">&quot;sleepDurationFormatted&quot;</span>)</span></span><br></pre></td></tr></table></figure><p>9.第二个适配器根据 <code>SleepNight</code> 对象中的值设置睡眠质量。在 <code>TextView</code> 上再创建一个名为 <code>setSleepQualityString()</code> 的扩展函数，并传入 <code>SleepNight</code>。</p><p>10.在正文中，将数据绑定到视图，如在 <code>ViewHolder.bind()</code> 中一样。调用 <code>convertNumericQualityToString</code> 并设置 <code>text</code>。</p><p>11.使用 <code>@BindingAdapter(&quot;sleepQualityString&quot;)</code> 为该函数添加注解。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(<span class="meta-string">&quot;sleepQualityString&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> TextView.<span class="title">setSleepQualityString</span><span class="params">(item: <span class="type">SleepNight</span>)</span></span> &#123;</span><br><span class="line">   text = convertNumericQualityToString(item.sleepQuality, context.resources)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>12.我们需要第三个绑定适配器，用于在图片视图上设置图片。在 <code>ImageView</code> 上创建第三个扩展函数，调用 <code>setSleepImage</code>，并使用 <code>ViewHolder.bind()</code> 中的代码，如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(<span class="meta-string">&quot;sleepImage&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> ImageView.<span class="title">setSleepImage</span><span class="params">(item: <span class="type">SleepNight</span>)</span></span> &#123;</span><br><span class="line">   setImageResource(<span class="keyword">when</span> (item.sleepQuality) &#123;</span><br><span class="line">       <span class="number">0</span> -&gt; R.drawable.ic_sleep_0</span><br><span class="line">       <span class="number">1</span> -&gt; R.drawable.ic_sleep_1</span><br><span class="line">       <span class="number">2</span> -&gt; R.drawable.ic_sleep_2</span><br><span class="line">       <span class="number">3</span> -&gt; R.drawable.ic_sleep_3</span><br><span class="line">       <span class="number">4</span> -&gt; R.drawable.ic_sleep_4</span><br><span class="line">       <span class="number">5</span> -&gt; R.drawable.ic_sleep_5</span><br><span class="line">       <span class="keyword">else</span> -&gt; R.drawable.ic_sleep_active</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可能需要导入 convertDurationToFormatted 和 convertNumericQualityToString。</p><h3 id="第-2-步：更新-SleepNightAdapter"><a href="#第-2-步：更新-SleepNightAdapter" class="headerlink" title="第 2 步：更新 SleepNightAdapter"></a>第 2 步：更新 SleepNightAdapter</h3><p>1.打开 <code>SleepNightAdapter.kt</code>。</p><p>2.删除 <code>bind()</code> 方法中的所有内容，因为您现在可以使用数据绑定和新的适配器来为您执行这项操作。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">bind</span><span class="params">(item: <span class="type">SleepNight</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.在 <code>bind()</code> 中，为 <code>item</code> 分配 sleep，因为您需要告知绑定对象您的新 <code>SleepNight</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binding.sleep = item</span><br></pre></td></tr></table></figure><p>4.在该行的下方，添加 <code>binding.executePendingBindings()</code>。此调用是一种优化，用于要求数据绑定功能立即执行任何待处理的绑定。当您在 <code>RecyclerView</code> 中使用绑定适配器时，最好调用 <code>executePendingBindings()</code>，因为它可以略微加快调整视图大小的过程。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binding.executePendingBindings()</span><br></pre></td></tr></table></figure><h2 id="第-3-步：向-XML-布局添加绑定"><a href="#第-3-步：向-XML-布局添加绑定" class="headerlink" title="第 3 步：向 XML 布局添加绑定"></a>第 3 步：向 XML 布局添加绑定</h2><p>1.打开 <code>list_item_sleep_night.xml</code>。</p><p>2.在 <code>ImageView</code> 中，添加与设置图片的绑定适配器同名的 <code>app</code> 属性。传入 <code>sleep</code> 变量，如下所示。</p><p>此属性通过适配器建立视图与绑定对象之间的连接。每当引用 <code>sleepImage</code> 时，适配器都会调整 <code>SleepNight</code> 中的数据。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:sleepImage=<span class="string">&quot;@&#123;sleep&#125;&quot;</span></span><br></pre></td></tr></table></figure><p>3.现在，为 <code>sleep_length</code> 和 <code>quality_string</code> 文本视图添加类似的应用属性。每当引用 <code>sleepDurationFormatted</code> 或 <code>sleepQualityString</code> 时，适配器都会调整来自 <code>SleepNight</code> 中的数据。请务必将每个属性分别放入其各自的 <code>TextView.</code> 中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app:sleepDurationFormatted=<span class="string">&quot;@&#123;sleep&#125;&quot;</span></span><br><span class="line">app:sleepQualityString=<span class="string">&quot;@&#123;sleep&#125;&quot;</span></span><br></pre></td></tr></table></figure><p>4.运行您的应用，其运行情况与之前完全一样。绑定适配器负责处理随着数据变化而格式化和更新视图的所有工作，从而简化 <code>ViewHolder</code> 并为代码提供比之前更好的结构。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/05/20/Lifecycle-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E8%BD%AC-%E6%9B%B4%E6%96%B0%E4%B8%AD/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/05/20/Lifecycle-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E8%BD%AC-%E6%9B%B4%E6%96%B0%E4%B8%AD/" class="post-title-link" itemprop="url">Lifecycle 官方文档[转](更新中)</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-05-20 05:56:29" itemprop="dateCreated datePublished" datetime="2022-05-20T05:56:29+08:00">2022-05-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-11-20 12:38:57" itemprop="dateModified" datetime="2022-11-20T12:38:57+08:00">2022-11-20</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="使用生命周期感知型组件处理生命周期"><a href="#使用生命周期感知型组件处理生命周期" class="headerlink" title="使用生命周期感知型组件处理生命周期"></a>使用生命周期感知型组件处理生命周期</h2><p>生命周期感知型组件可执行操作来响应另一个组件（如 <code>Activity</code> 和 <code>Fragment</code>）的生命周期状态的变化。这些组件有助于您编写出更有条理且往往更精简的代码，此类代码更易于维护。</p><p>一种常见的模式是在 Activity 和 Fragment 的生命周期方法中实现依赖组件的操作。但是，这种模式会导致代码条理性很差而且会扩散错误。通过使用生命周期感知型组件，您可以将依赖组件的代码从生命周期方法移入组件本身中。</p><p><a target="_blank" rel="noopener" href="https://developer.android.com/reference/androidx/lifecycle/package-summary?hl=zh-cn"><code>androidx.lifecycle</code></a> 软件包提供了可用于构建生命周期感知型组件的类和接口 - 这些组件可以根据 Activity 或 Fragment 的当前生命周期状态自动调整其行为。</p><blockquote><p><strong>注意</strong>：如需将 <a target="_blank" rel="noopener" href="https://developer.android.com/reference/androidx/lifecycle/package-summary?hl=zh-cn"><code>androidx.lifecycle</code></a>导入 Android 项目，请参阅 <a target="_blank" rel="noopener" href="https://developer.android.com/jetpack/androidx/releases/lifecycle?hl=zh-cn#declaring_dependencies">Lifecycle 版本说明</a>中关于声明依赖项的说明。</p></blockquote><p>在 Android 框架中定义的大多数应用组件都存在生命周期。生命周期由操作系统或进程中运行的框架代码管理。它们是 Android 工作原理的核心，应用必须遵循它们。如果不这样做，可能会引发内存泄漏甚至应用崩溃。</p><p>假设我们有一个在屏幕上显示设备位置的 Activity。常见的实现可能如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLocationListener</span></span>(</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> context: Context,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> callback: (Location) -&gt; <span class="built_in">Unit</span></span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// connect to system location service</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// disconnect from system location service</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> myLocationListener: MyLocationListener</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(...)</span></span> &#123;</span><br><span class="line">        myLocationListener = MyLocationListener(<span class="keyword">this</span>) &#123; location -&gt;</span><br><span class="line">            <span class="comment">// update UI</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart()</span><br><span class="line">        myLocationListener.start()</span><br><span class="line">        <span class="comment">// manage other components that need to respond</span></span><br><span class="line">        <span class="comment">// to the activity lifecycle</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop()</span><br><span class="line">        myLocationListener.stop()</span><br><span class="line">        <span class="comment">// manage other components that need to respond</span></span><br><span class="line">        <span class="comment">// to the activity lifecycle</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h2><p><a target="_blank" rel="noopener" href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle?hl=zh-cn"><code>Lifecycle</code></a> 是一个类，用于存储有关组件（如 Activity 或 Fragment）的生命周期状态的信息，并允许其他对象观察此状态。</p><p><a target="_blank" rel="noopener" href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle?hl=zh-cn"><code>Lifecycle</code></a> 使用两种主要枚举跟踪其关联组件的生命周期状态：</p><ul><li><p>事件</p><p>从框架和 <a target="_blank" rel="noopener" href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle?hl=zh-cn"><code>Lifecycle</code></a> 类分派的生命周期事件。这些事件映射到 Activity 和 Fragment 中的回调事件。</p></li><li><p>状态</p><p>由 <a target="_blank" rel="noopener" href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle?hl=zh-cn"><code>Lifecycle</code></a> 对象跟踪的组件的当前状态。</p></li></ul><p><img src="/../images/image-20220520060137800.png" alt="image-20220520060137800"></p><p>您可以将状态看作图中的节点，将事件看作这些节点之间的边。</p><p>类可以通过实现 <a target="_blank" rel="noopener" href="https://developer.android.com/reference/androidx/lifecycle/DefaultLifecycleObserver?hl=zh-cn"><code>DefaultLifecycleObserver</code></a> 并替换相应的方法（如 <code>onCreate</code> 和 <code>onStart</code> 等）来监控组件的生命周期状态。然后，您可以通过调用 <a target="_blank" rel="noopener" href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle?hl=zh-cn"><code>Lifecycle</code></a> 类的 <a target="_blank" rel="noopener" href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle?hl=zh-cn#addObserver(androidx.lifecycle.LifecycleObserver)"><code>addObserver()</code></a> 方法并传递观察器的实例来添加观察器，如下例所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObserver</span> : <span class="type">DefaultLifecycleObserver &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">(owner: <span class="type">LifecycleOwner</span>)</span></span> &#123;</span><br><span class="line">        connect()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPause</span><span class="params">(owner: <span class="type">LifecycleOwner</span>)</span></span> &#123;</span><br><span class="line">        disconnect()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myLifecycleOwner.getLifecycle().addObserver(MyObserver())</span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>myLifecycleOwner</code> 对象实现了 <a target="_blank" rel="noopener" href="https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner?hl=zh-cn"><code>LifecycleOwner</code></a> 接口，我们将在接下来的部分中对该接口进行说明。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/05/17/Android8-0%E4%BB%A5%E4%B8%8A%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%A6%82%E4%BD%95%E4%BF%9D%E6%B4%BB-%E8%BD%AC/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/05/17/Android8-0%E4%BB%A5%E4%B8%8A%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%A6%82%E4%BD%95%E4%BF%9D%E6%B4%BB-%E8%BD%AC/" class="post-title-link" itemprop="url">Android8.0以上系统应用如何保活[转]</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-05-17 12:59:09" itemprop="dateCreated datePublished" datetime="2022-05-17T12:59:09+08:00">2022-05-17</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-11-20 12:38:56" itemprop="dateModified" datetime="2022-11-20T12:38:56+08:00">2022-11-20</time></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="Android-8-0以上系统应用如何保活"><a href="#Android-8-0以上系统应用如何保活" class="headerlink" title="Android 8.0以上系统应用如何保活"></a><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000020159573">Android 8.0以上系统应用如何保活</a></h1><p>最近在做一个埋点的sdk，由于埋点是分批上传的，不是每次都上传，所以会有个进程保活的机制，这也是自研推送的实现技术之一：如何保证Android进程的存活。</p><p>对于Android来说，保活主要有以下一些方法：</p><ul><li>开启前台Service（效果好，推荐）</li><li>Service中循环播放一段无声音频（效果较好，但耗电量高，谨慎使用）</li><li>双进程守护（Android 5.0前有效）</li><li>JobScheduler（Android 5.0后引入，8.0后失效）</li><li>1 像素activity保活方案（不推荐）</li><li>广播锁屏、自定义锁屏（不推荐）</li><li>第三方推送SDK唤醒（效果好，缺点是第三方接入）</li></ul><p>下面是具体的实现方案：</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/05/17/WorkManager%E7%9B%B8%E5%85%B3-%E6%9B%B4%E6%96%B0%E4%B8%AD/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/05/17/WorkManager%E7%9B%B8%E5%85%B3-%E6%9B%B4%E6%96%B0%E4%B8%AD/" class="post-title-link" itemprop="url">WorkManager相关(更新中)</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-05-17 12:08:53" itemprop="dateCreated datePublished" datetime="2022-05-17T12:08:53+08:00">2022-05-17</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-11-20 12:38:57" itemprop="dateModified" datetime="2022-11-20T12:38:57+08:00">2022-11-20</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><ul><li><p>WorkManager</p><ul><li>WorkManager可以自动维护后台任务的执行时机，执行顺序，执行状态。</li><li>执行时机：我们创建一个任务可以指定它在什么时机执行，比如立刻执行，还是必须要等到设备空闲的时候执行，还是要等到设备的充电量必须要满足的时候执行，还是必须在wifi下才能执行，还是设备必须在存储空间足够的情况下执行。</li><li>执行顺序：指任务在执行过程中，是允许有依赖的关系，比如a执行完成才能执行任务b，任务b完成才能执行任务c,允许他们之间有相互的依赖关系。</li><li>执行状态：指任务执行的每个状态都会回调给我们，比如队列任务执行中，取消，成功，失败，结束等等。</li></ul><p>相比于后台任务service,intentservice workmanager更加的轻量，更加的省电，理论上service能做的东西，workmaanager都能做。但是workmanager可以用于支持异步场景。</p></li><li><p>依赖添加</p><ul><li>implementation ‘androidx.work:work-runtime:2.2.0’</li></ul></li></ul><h2 id="使用WorkManager来构建任务"><a href="#使用WorkManager来构建任务" class="headerlink" title="使用WorkManager来构建任务"></a>使用WorkManager来构建任务</h2><p><img src="/../images/image-20220517121757299.png" alt="image-20220517121757299"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WorkContinuation left,right;</span><br><span class="line">left = workManager.beginWith(A).then(B);</span><br><span class="line">right = workManager.beginWith(C).then(D);</span><br><span class="line">WorkContinuatioin.combine(Arrays.asList(left,right)).then(E).Enqueue();</span><br></pre></td></tr></table></figure><ul><li>任务A执行完才能执行B</li><li>任务C执行完才能执行任务D</li><li>BD都执行完才能执行E</li></ul><p>之前使用service还要做线程间的同步，我们看workmanager怎么实现相同的效果？</p><ul><li>beginWith(A).then(B) 指任务A执行完，才执行任务B，beginWith就可以使得两个任务串行依赖</li><li>WorkContinuation left right 分别创建出左侧的任务队列，右侧的任务队列</li><li>WorkContinuation 就是可以支持任务之间相互的串联，相互的依赖的对象</li><li>combine后，调用Enqueu()加入任务队列</li></ul><h2 id="WorkManager（状态通知）"><a href="#WorkManager（状态通知）" class="headerlink" title="WorkManager（状态通知）"></a>WorkManager（状态通知）</h2><p><img src="/../images/image-20220517122315734.png" alt="image-20220517122315734"></p><h2 id="WorkManager（任务控制）"><a href="#WorkManager（任务控制）" class="headerlink" title="WorkManager（任务控制）"></a>WorkManager（任务控制）</h2><p><img src="/../images/image-20220517122359574.png" alt="image-20220517122359574"></p><p>UUID是我们创建work的时候返回的</p><p>我们创建任务的时候，可以给任务打上一组标签tag</p><h2 id="WorkManager-类关系"><a href="#WorkManager-类关系" class="headerlink" title="WorkManager(类关系)"></a>WorkManager(类关系)</h2><p><img src="/../images/image-20220517122546929.png" alt="image-20220517122546929"></p><p>OneTimeWorkRequest 一次性</p><p>PeriodicWorkRequest 定时执行任务 ，定时任务最小的周期是15分钟，所以保活就不行了</p><h2 id="WorkManager的使用"><a href="#WorkManager的使用" class="headerlink" title="WorkManager的使用"></a>WorkManager的使用</h2><p>1.创建任务 2.输入参数 3.创建workRequest 4.加入队列 5.监听结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.编写一个UploadFileWorker.class 继承自Worker</span></span><br><span class="line"><span class="comment">//2.创建输入参数</span></span><br><span class="line">Data inputData = <span class="keyword">new</span> Data.Builder()</span><br><span class="line">  .putString(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>)</span><br><span class="line">  .putBoolean(<span class="string">&quot;key1&quot;</span>,<span class="keyword">false</span>)</span><br><span class="line">  .putStringArray(<span class="string">&quot;key2&quot;</span>,<span class="keyword">new</span> String[]&#123;&#125;)</span><br><span class="line">  .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.创建workrequest  																				构建任务</span></span><br><span class="line">OneTimeWorkRequest request = <span class="keyword">new</span> OneTimeWorkRequest.Builder(UploadFileWorker.class)</span><br><span class="line">  <span class="comment">//传入参</span></span><br><span class="line">  .setInputData(inputData)</span><br><span class="line">  <span class="comment">//...其他许许多多约束</span></span><br><span class="line">  .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.加入队列</span></span><br><span class="line">WorkContinuation continuation = WorkManager.getInstance().beginWith(list).enqueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.观察执行状态及结果</span></span><br><span class="line">continuation.getWorkInfosLiveData().observe(<span class="keyword">this</span>,<span class="keyword">new</span> Observer&lt;List&lt;WorkInfo&gt;&gt;()&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChanged</span><span class="params">(List&lt;WorkInfo&gt; workInfos)</span></span>&#123;</span><br><span class="line">    <span class="comment">//监听任务执行的结果</span></span><br><span class="line">    <span class="comment">//所以我们在创建work的时候需要work的UUID,用于观察这里是哪个work执行完成了</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/05/16/MVVM%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/05/16/MVVM%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">MVVM及Databinding使用及原理解析</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-05-16 06:35:47" itemprop="dateCreated datePublished" datetime="2022-05-16T06:35:47+08:00">2022-05-16</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-11-20 12:38:57" itemprop="dateModified" datetime="2022-11-20T12:38:57+08:00">2022-11-20</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="什么是MVVM"><a href="#什么是MVVM" class="headerlink" title="什么是MVVM"></a>什么是MVVM</h2><ul><li>双向绑定。数据变更<code>UI</code>会自动刷新，<code>UI</code>变化了数据也会自动同步到最新的值</li><li>数据驱动UI：比如<code>User</code>中的字段，数据变化了，可以做到自动刷新UI。</li><li>UI同步数据：比如<code>EditText</code>、<code>CheckBox</code>、<code>ToggleButton</code>具有状态的<code>View</code>，当状态变化后，数据模型中与之关联的字段的值也会自动同步最新状态</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开启databinding</span></span><br><span class="line">android&#123;</span><br><span class="line">	dataBinding&#123;</span><br><span class="line">		enable = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="传统的MVVM"><a href="#传统的MVVM" class="headerlink" title="传统的MVVM"></a>传统的MVVM</h3><p><img src="/../images/image-20220516064045932.png" alt="image-20220516064045932"></p><ul><li><p>此时<code>view</code>层的定义比较广泛，可以指<code>Activity/Fragment/xml</code>实例化出来的<code>view</code>对象或者自定义<code>view</code>对象</p></li><li><p><code>VM</code>就是这里的<code>viewmodel</code>,但是这并不是<code>Jetpack</code>组件里的<code>viewmodel</code>,18年，<code>livedata</code>和<code>viewmodel</code>没有出来前，这里的<code>viewmodel</code>只是一个普通的类，用于从<code>model</code>中获取数据，从<code>Model</code>中获取数据成功后会通过<code>callback</code>回传给<code>viewmodel</code>，而<code>viewmodel</code>中的数据更新后，并不是通过<code>view</code>接口(区别于<code>MVP</code>)回传给<code>view</code>更新的，而是通过<code>Databinding</code>，利用它观察者的特性，实现<code>UI</code>的更新</p></li></ul><p>定义<code>ViewModel</code>用于处理数据相关的业务逻辑。并通过<code>ObserverableField</code> 观察者把结果回传出去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeViewModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ObservableField&lt;User&gt; userField = <span class="keyword">new</span> ObservableField&lt;&gt;();</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryUserInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.nickName = <span class="string">&quot;nickName&quot;</span>;</span><br><span class="line">        user.address = <span class="string">&quot;address&quot;</span>;</span><br><span class="line">        <span class="comment">//自动通知与之关联的观察者</span></span><br><span class="line">        userField.set(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><blockquote><p>注意一定要给<code>userField.set(user)</code> 把对象set给<code>userField</code> 这步不调用，是无法从<code>userField</code>中取数据的，会报NPE</p></blockquote><p>基于<code>DataBinding</code>在xml中进行数据绑定，可以实现数据&amp;UI双向绑定&#x3D;&gt;数据变更ui自动刷新，UI变动自动同步数据</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">&quot;viewModel&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;com.steve.mvvmdemo.test.HomeViewModel&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--单向绑定@--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/nick_name&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;@&#123;viewModel.userField.nickName&#125;&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--双向绑定@=--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/edit_address&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;@=&#123;viewModel.userField.address&#125;&quot;</span></span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>只要<code>userField</code>中的<code>nickName</code>发生变化，UI会刷新，这是单向的</p><p>编写完<code>xml</code>后<code>rebuild</code>一个项目</p><p><code>Activity</code>控制数据的获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> <span class="meta">@org</span>.jetbrains.annotations.Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">      </span><br><span class="line">        ActivityHomeBinding binding = DataBindingUtil.setContentView(<span class="keyword">this</span>, R.layout.activity_home);</span><br><span class="line"></span><br><span class="line">        HomeViewModel vm = <span class="keyword">new</span> HomeViewModel();</span><br><span class="line">        binding.setViewModel(vm);</span><br><span class="line">      </span><br><span class="line">      	model.queryUserInfo();</span><br><span class="line"></span><br><span class="line">        binding.editAddress.addTextChangedListener(<span class="keyword">new</span> TextWatcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeTextChanged</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> count, <span class="keyword">int</span> after)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTextChanged</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> before, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterTextChanged</span><span class="params">(Editable s)</span> </span>&#123;</span><br><span class="line">              <span class="comment">//当输入框文本变更后，userField的address数据会自动更新，变成输入框输入的内容</span></span><br><span class="line">                Log.e(<span class="string">&quot;zzl&quot;</span>,<span class="string">&quot;after:&quot;</span> + vm.userField.get().address);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过<code>DataBindingUtil.setContentView</code>完成<code>Activity</code>和xml布局文件的绑定工作，返回一个<code>Databinding</code>对象，这个<code>databinding</code>对象是根据xml的名称在编译阶段生成的，我们可以直接拿来使用。</li><li>把vm通过<code>setViewModel</code>设置给<code>databinding</code></li><li>然后在<code>Activity</code>中调用 <code>model.queryUserInfo()</code>去获取数据，可能是网络上的数据，然后<code>activity</code>就不管数据获取后UI的更新了</li></ul><p>这就是传统的MVVM，它着重利用了<code>Databinding</code>的能力，大部分的数据都是在xml中进行绑定，当然也会根据场景，具体问题具体分析。如果需要用户交互复杂的逻辑控制，可能还是需要在<code>activity</code>中进行控制更为方便。</p><p>但是这种写法已经过时了，后面出现了<code>Jetpack</code>，在<code>Jetpack</code>模式下，我们通常会利用<code>VieModel + LiveData</code>的组件结合。</p><p>这样做的目的是既能保证数据不会无缘无故丢失，还能<strong>自动关联宿主的生命周期</strong>，避免空指针的问题。<code>Activity</code>，<code>Fragment UI</code>逻辑和用户交互控制就可以了。数据的绑定可以交给<code>Databindging</code></p><h3 id="Jetpack-Viewmodel-livedata使用"><a href="#Jetpack-Viewmodel-livedata使用" class="headerlink" title="Jetpack Viewmodel + livedata使用"></a>Jetpack Viewmodel + livedata使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LiveData <span class="title">getUserInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        MutableLiveData&lt;User&gt; liveData = <span class="keyword">new</span> MutableLiveData&lt;&gt;();</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.nickName = <span class="string">&quot;zzl&quot;</span>;</span><br><span class="line">        user.address = <span class="string">&quot;changchun&quot;</span>;</span><br><span class="line"></span><br><span class="line">        liveData.postValue(user);</span><br><span class="line">        <span class="keyword">return</span> liveData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li>注意这里既不是使用观察者<code>ObservableField</code>包裹对象，也不是使用<code>view</code>的接口回调<code>callback</code>去回传数据，而是使用了<code>livedata</code>，通过<code>liveData.postValue(user)</code>并返回<code>liveData</code>，去通知观察者</li></ul><p>下面看下xml文件的变化</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">&quot;user&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;com.steve.mvvmdemo.test.User&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--单向绑定@--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/nick_name&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;@&#123;user.nickName&#125;&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--双向绑定@=--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/edit_address&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;@=&#123;user.address&#125;&quot;</span></span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>这里注意绑定的对象不再是<code>viewmodel</code>而直接是<code>user</code>对象</li><li>直接使用<code>user.nickName</code> <code>user.address</code>访问对象的值</li></ul><p>看下<code>Activity</code>里的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeActivity3</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> <span class="meta">@org</span>.jetbrains.annotations.Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        ActivityHome2Binding binding = DataBindingUtil.setContentView(<span class="keyword">this</span>, R.layout.activity_home2);</span><br><span class="line">        ViewModelProvider provider = <span class="keyword">new</span> ViewModelProvider(<span class="keyword">this</span>,<span class="keyword">new</span> ViewModelProvider.NewInstanceFactory());</span><br><span class="line">        HomeViewModel vm = provider.get(HomeViewModel.class);</span><br><span class="line"></span><br><span class="line">        vm.getUserInfo().observe(<span class="keyword">this</span>, (Observer&lt;User&gt;) user -&gt; &#123;</span><br><span class="line">            binding.setUser(user);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Jetpack里的api使用会有一点点不同</p><ul><li><code>DataBindingUtil.setContentView</code>把xml和<code>activity</code>进行绑定，生成<code>databinding</code></li><li>通过<code>ViewModelProvider</code>获取具体的<code>HomeViewModel</code>对象</li><li>通过vm获取发送数据的<code>liveData</code>，注册观察者，在回调里进行<code>binding.setUser(user);</code>绑定</li></ul><h2 id="DataBinding的高频用法及注意事项"><a href="#DataBinding的高频用法及注意事项" class="headerlink" title="DataBinding的高频用法及注意事项"></a>DataBinding的高频用法及注意事项</h2><h3 id="什么是dataBinding"><a href="#什么是dataBinding" class="headerlink" title="什么是dataBinding?"></a>什么是dataBinding?</h3><ul><li>可以理解为<code>dataBinding</code>只是一种工具，它解决了view和数据之间的双向绑定</li></ul><h3 id="dataBinding的优势？"><a href="#dataBinding的优势？" class="headerlink" title="dataBinding的优势？"></a>dataBinding的优势？</h3><ul><li>双向数据绑定 数据发生改变后，自动通知刷新UI页面，不再需要人工绑定最新数据到view上。UI改变后也能同步给数据。</li><li>减少模板代码 有了dataBinding，从此不用再写<code>findViewById</code>,<code>setOnClickListener</code>等枯燥生硬的代码，大大提高工作效率。从此<code>Butterknife</code>靠边站。</li><li>释放<code>Activitty/Fragment</code>压力 我们可以直接在xml布局文件中完成数据，事件绑定工作。<code>Activity</code>,<code>Fragment</code>让它更加只关注核心业务。</li><li>数据绑定空安全 在xml中绑定数据它是空安全的，因为<code>dataBinding</code>在数据绑定上会自动装箱和空判断，所以大大减少了数据绑定带来的<code>NPE</code>问题</li></ul><h3 id="dataBinding如何使用？"><a href="#dataBinding如何使用？" class="headerlink" title="dataBinding如何使用？"></a>dataBinding如何使用？</h3><ul><li>在布局文件中，选中根布局的标签，按住 <code>alt + 回车</code> ，点击<code>convert to data binding layout</code> 即可转换成<code>dataBinding</code>布局。</li><li>转换后的布局，最外层变成了<code>layout</code>标签，里面包裹了<code>data</code>标签和常规的布局元素。data元素用来声明在此布局使用到的变量和变量类型，以及类引用。最不是所有的属性都能用<code>dataBinding</code>来绑定呢？当然不是！如果一个属性<code>xxx</code>，在该类中有<code>setXXX</code>方法，我们才能使用<code>dataBinding</code>来绑定。比如<code>android:layout_width</code>，<code>android_height</code>就不能使用<code>dataBinding</code>来绑定值，而<code>android:paddingLeft</code>，<code>android:textSize</code>都是可以的。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">&quot;user&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;com.steve.mvvmdemo.test.User&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">&quot;com.steve.mvvmdemo.test.UserManager&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">import</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/tvName&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>  //不能使用<span class="attr">dataBinding</span>动态绑定</span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;@&#123;user.name&#125;&quot;</span> //单向绑定数据变更自动通知<span class="attr">UI</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">&quot;@&#123;@dimen/16sp&#125;&quot;</span> //资源引用</span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;@&#123;user.nickName + @string/suffix&#125;&quot;</span> //字符串拼接需要引用资源</span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;@&#123;UserManager.getUserName()&#125;&quot;</span> //调用静态方法，类必须先导入</span></span><br><span class="line"><span class="tag">            <span class="attr">android:onClick</span>=<span class="string">&quot;@&#123;()-&gt;UserManager.login()&#125;&quot;</span></span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>android:text=&quot;@&#123;user.name&#125;&quot;</code>等价于<code>tvName.text = user.name</code>这样就将数据和<code>view</code>相关联了。那么如何实现<code>view</code>和数据的双向绑定呢？我们除了上面提到的让<code>ObservableField</code>持有外，还可以让实体类<code>User</code>继承<code>BaseObservable</code>。当user中字段发生变更，只需要调用<code>user.notifyPropertyChanged</code>就可以让<code>UI刷新</code>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">BaseObservable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当使用name字段发生变更后，若想UI自动刷新，我们需要给它写个get方法并且标记为Bindable注解</span></span><br><span class="line">    <span class="comment">//最后调用 notifyPropertyChanged方法即可</span></span><br><span class="line">    <span class="meta">@Bindable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        notifyPropertyChanged(BR.user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>dataBinding</code> 也支持在布局文件中使用<code>数组、List、Set和Map</code>，且在布局文件中都可以通过<code>list[index]</code>的形式来获取元素，因为xml的特性，在声明<code>List&lt;String&gt;</code>之类的类型时，需要使用尖括号的<code>转义字符</code>，如下</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">&quot;java.util.List&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">&quot;java.util.Set&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">&quot;java.util.Map&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">&quot;android.util.SparseArray&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">&quot;array&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;String[]&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--List&lt;String&gt; 需要转义--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">&quot;list&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;List<span class="symbol">&amp;lt;</span>String<span class="symbol">&amp;gt;</span>&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--Map&lt;String&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">&quot;map&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;Map<span class="symbol">&amp;lt;</span>String,String<span class="symbol">&amp;gt;</span>&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--Set&lt;Strin&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">&quot;set&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;Set<span class="symbol">&amp;lt;</span>String<span class="symbol">&amp;gt;</span>&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--SparseArray&lt;String&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">&quot;sparse&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;SparseArray<span class="symbol">&amp;lt;</span>String<span class="symbol">&amp;gt;</span>&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">&quot;index&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">&quot;key&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;String&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;@&#123;array[1]&#125;&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;@&#123;sparse[index]&#125;&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;@&#123;list[index]&#125;&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;@&#123;map[key]&#125;&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&#x27;@&#123;map[&quot;移动端架构师&quot;]&#125;&#x27;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&#x27;@&#123;set.contains(&quot;xxx&quot;)?&quot;移动端架构师&quot;:key&#125;&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>dataBinding</code>在xml中数据绑定支持的语法表达式也是非常丰富的，支持在布局文件中使用以下运算符、表达式和关键字</li></ul><p><img src="/../images/image-20220516091030481.png" alt="image-20220516091030481"></p><p><img src="/../images/image-20220516091050642.png" alt="image-20220516091050642"></p><ul><li>dataBinding 拓展view属性</li></ul><p>我们知道，以前想要给ImageView增加几个属性，必须要写个自定义的ImageView在构造函数中一顿解析。那看看使用dataBinding如何拓展view属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HiImageView</span> <span class="keyword">extends</span> <span class="title">ImageView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BindingAdapter(value = &#123;&quot;image_url&quot;,&quot;isCircle&quot;,&quot;radius&quot;&#125;,requireAll = false)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setImageUrl</span><span class="params">(ImageView view,String imageUrl,<span class="keyword">boolean</span> isCircle,<span class="keyword">int</span> radius)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>需要定义成<code>public static</code> 使用<code>BindingAdapter</code>注解并标记</li><li><code>value</code>中的字段随意添加和方法参数一一对应即可。</li><li>requirAll &#x3D; false代表是否以下三个属性在xml中同时使用才会调用该方法，为<code>flase</code>的话，只要有一个属性被使用就能调用到该方法</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.steve.mvvmdemo.jetpackmvvm.HiImageView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:image_url</span>=<span class="string">&quot;@&#123;user.avatar&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:radius</span>=<span class="string">&quot;@&#123;50&#125;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在布局文件中如下使用，便能实现图片圆角和资源url绑定的功能</li></ul><h3 id="dataBinding使用建议"><a href="#dataBinding使用建议" class="headerlink" title="dataBinding使用建议"></a>dataBinding使用建议</h3><ul><li>不建议在列表中乱用，因为dataBinding数据绑定是延迟一帧的，如果列表中的ItemView的宽高需要计算后才能正确展示，或者显隐控制，不建议使用databinding操作，否则会看到列表itemview有可能撑开的动画，体验不好。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">requestRebind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mContainingBinding != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mContainingBinding.requestRebind();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> LifecycleOwner owner = <span class="keyword">this</span>.mLifecycleOwner;</span><br><span class="line">        <span class="keyword">if</span> (owner != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Lifecycle.State state = owner.getLifecycle().getCurrentState();</span><br><span class="line">            <span class="keyword">if</span> (!state.isAtLeast(Lifecycle.State.STARTED)) &#123;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// wait until lifecycle owner is started</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mPendingRebind) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingRebind = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//这里下一次屏幕绘制才会进行绑定</span></span><br><span class="line">        <span class="keyword">if</span> (USE_CHOREOGRAPHER) &#123;</span><br><span class="line">            mChoreographer.postFrameCallback(mFrameCallback);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mUIThreadHandler.post(mRebindRunnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SDK_INT&gt;&#x3D;16 都会执行这里，在下一次绘制时，才会重新绑定数据</p></blockquote><ul><li>如fragment_layout_my.xml布局，在编译时会生成FragmentLayoutMyImpl.class我们可以搜索这种类debug跟进解决问题。</li></ul><p>build&#x2F;intermediates&#x2F;javac&#x2F;debug&#x2F;clasees&#x2F;org&#x2F;…&#x2F;databinding&#x2F;FragmentLayoutMyImpl.class</p><h2 id="dataBinding与ViewBinding的区别"><a href="#dataBinding与ViewBinding的区别" class="headerlink" title="dataBinding与ViewBinding的区别"></a>dataBinding与ViewBinding的区别</h2><ul><li>viewbinding可以看做是一个databinding的一部分功能 最主要的表现就是可以通过绑定后不用findviewbyid了，但不能进行双向绑定</li><li>相对来说databinding的功能更强大一些，不只是可以直接获取控件对象，并且可以通过数据绑定的形式实时更新页面UI</li><li>从编译效率来讲viewBinding的效率更快一些，databinding的效率要慢一些</li><li>viewbinding优点也是明显的不需要对原有的xml文件进行侵入</li></ul><h2 id="DataBinding原理与编译时绑定布局对象"><a href="#DataBinding原理与编译时绑定布局对象" class="headerlink" title="DataBinding原理与编译时绑定布局对象"></a>DataBinding原理与编译时绑定布局对象</h2><p><img src="/../images/image-20220516120558811.png" alt="image-20220516120558811"></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><ul><li>1.通过源码我们要知道<code>databinding</code>如何实现<code>M-V V-M</code>的<code>双向刷新机制</code></li><li>2.<code>databinding</code>内存开销过大的原因是什么？</li></ul><p>1.<code>rebuild</code>后，生成两个<code>xml</code>文件</p><p><img src="/../images/image-20220516122044224.png" alt="image-20220516122044224"></p><p>这两个xml文件分别有各自的用处 <code>xxx-layout</code> 用于Databinding处理，正常的xml文件中也会有tag</p><p><code>activity_home-layout.xml</code>文件的路径是</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app<span class="regexp">/build/i</span>ntermediates<span class="regexp">/data_binding_layout_info_type_merge/</span>debug<span class="regexp">/out/</span>activity_home-layout.xml</span><br></pre></td></tr></table></figure><p><code>activity_home.xml</code>文件的路径是</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app<span class="regexp">/build/i</span>ntermediates<span class="regexp">/incremental/m</span>ergeDebugResources<span class="regexp">/stripped.dir/</span>layout/activity_home.xml</span><br></pre></td></tr></table></figure><p>我们看下<code>acitivty_home-layout.xml</code>文件的内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;yes&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Layout</span> <span class="attr">directory</span>=<span class="string">&quot;layout&quot;</span> <span class="attr">filePath</span>=<span class="string">&quot;app/src/main/res/layout/activity_home.xml&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">isBindingData</span>=<span class="string">&quot;true&quot;</span> <span class="attr">isMerge</span>=<span class="string">&quot;false&quot;</span> <span class="attr">layout</span>=<span class="string">&quot;activity_home&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">modulePackage</span>=<span class="string">&quot;com.steve.mvvmdemo&quot;</span> <span class="attr">rootNodeType</span>=<span class="string">&quot;android.widget.LinearLayout&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Targets</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Target</span> <span class="attr">tag</span>=<span class="string">&quot;layout/activity_home_0&quot;</span> <span class="attr">view</span>=<span class="string">&quot;LinearLayout&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Expressions</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">location</span> <span class="attr">endLine</span>=<span class="string">&quot;30&quot;</span> <span class="attr">endOffset</span>=<span class="string">&quot;18&quot;</span> <span class="attr">startLine</span>=<span class="string">&quot;10&quot;</span> <span class="attr">startOffset</span>=<span class="string">&quot;4&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Target</span> <span class="attr">id</span>=<span class="string">&quot;@+id/nick_name&quot;</span> <span class="attr">tag</span>=<span class="string">&quot;binding_1&quot;</span> <span class="attr">view</span>=<span class="string">&quot;TextView&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Expressions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Expression</span> <span class="attr">attribute</span>=<span class="string">&quot;android:text&quot;</span> <span class="attr">text</span>=<span class="string">&quot;viewModel.userField.nickName&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">Location</span> <span class="attr">endLine</span>=<span class="string">&quot;20&quot;</span> <span class="attr">endOffset</span>=<span class="string">&quot;57&quot;</span> <span class="attr">startLine</span>=<span class="string">&quot;20&quot;</span> <span class="attr">startOffset</span>=<span class="string">&quot;12&quot;</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">TwoWay</span>&gt;</span>false<span class="tag">&lt;/<span class="name">TwoWay</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">ValueLocation</span> <span class="attr">endLine</span>=<span class="string">&quot;20&quot;</span> <span class="attr">endOffset</span>=<span class="string">&quot;55&quot;</span> <span class="attr">startLine</span>=<span class="string">&quot;20&quot;</span> <span class="attr">startOffset</span>=<span class="string">&quot;28&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">Expression</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Expressions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">location</span> <span class="attr">endLine</span>=<span class="string">&quot;20&quot;</span> <span class="attr">endOffset</span>=<span class="string">&quot;59&quot;</span> <span class="attr">startLine</span>=<span class="string">&quot;16&quot;</span> <span class="attr">startOffset</span>=<span class="string">&quot;8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Target</span> <span class="attr">id</span>=<span class="string">&quot;@+id/edit_address&quot;</span> <span class="attr">tag</span>=<span class="string">&quot;binding_2&quot;</span> <span class="attr">view</span>=<span class="string">&quot;EditText&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Expressions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Expression</span> <span class="attr">attribute</span>=<span class="string">&quot;android:text&quot;</span> <span class="attr">text</span>=<span class="string">&quot;viewModel.userField.address&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">Location</span> <span class="attr">endLine</span>=<span class="string">&quot;27&quot;</span> <span class="attr">endOffset</span>=<span class="string">&quot;57&quot;</span> <span class="attr">startLine</span>=<span class="string">&quot;27&quot;</span> <span class="attr">startOffset</span>=<span class="string">&quot;12&quot;</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">TwoWay</span>&gt;</span>true<span class="tag">&lt;/<span class="name">TwoWay</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">ValueLocation</span> <span class="attr">endLine</span>=<span class="string">&quot;27&quot;</span> <span class="attr">endOffset</span>=<span class="string">&quot;55&quot;</span> <span class="attr">startLine</span>=<span class="string">&quot;27&quot;</span> <span class="attr">startOffset</span>=<span class="string">&quot;29&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">Expression</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Expressions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">location</span> <span class="attr">endLine</span>=<span class="string">&quot;28&quot;</span> <span class="attr">endOffset</span>=<span class="string">&quot;13&quot;</span> <span class="attr">startLine</span>=<span class="string">&quot;23&quot;</span> <span class="attr">startOffset</span>=<span class="string">&quot;8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Targets</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Variables</span> <span class="attr">name</span>=<span class="string">&quot;viewModel&quot;</span> <span class="attr">declared</span>=<span class="string">&quot;true&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.steve.mvvmdemo.test.HomeViewModel&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">location</span> <span class="attr">endLine</span>=<span class="string">&quot;6&quot;</span> <span class="attr">endOffset</span>=<span class="string">&quot;58&quot;</span> <span class="attr">startLine</span>=<span class="string">&quot;4&quot;</span> <span class="attr">startOffset</span>=<span class="string">&quot;8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Variables</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Layout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再看下<code>activity_home.xml</code>文件的内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line">                                                                   </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">                 </span><br><span class="line">                            </span><br><span class="line">                                                           </span><br><span class="line"></span><br><span class="line">           </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span> <span class="attr">android:tag</span>=<span class="string">&quot;layout/activity_home_0&quot;</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--单向绑定@--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/nick_name&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:tag</span>=<span class="string">&quot;binding_1&quot;</span>                       /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--双向绑定@=--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/edit_address&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:tag</span>=<span class="string">&quot;binding_2&quot;</span>                       </span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">         </span><br></pre></td></tr></table></figure><ul><li>它会把<code>layout</code>标签去掉，然后在每个标签下打上<code>tag</code></li></ul><p><code>rebuild</code>后发生了啥</p><p><img src="/../images/image-20220516122508848.png" alt="image-20220516122508848"></p><p>2.从<code>setContentView</code>开始看源码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.必须先ReBuilder 2.书写代码绑定</span></span><br><span class="line"><span class="keyword">val</span> contentView = DataBindingUtil.setContentView&lt;ActivityLoginBinding&gt;(<span class="keyword">this</span>, R.layout.activity_login)</span><br></pre></td></tr></table></figure><p><code>Databinding</code>为什么还要去<code>setContentView</code></p><p><img src="file://../images/image-20220516122354494.png?lastModify=1652754461" alt="image-20220516122354494"></p><p>因为需要<code>activity</code>去获取根布局<code>root</code> 这样<code>binding</code>才能去更改布局刷新</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends ViewDataBinding&gt; <span class="function">T <span class="title">setContentView</span><span class="params">(<span class="meta">@NonNull</span> Activity activity,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> layoutId, <span class="meta">@Nullable</span> DataBindingComponent bindingComponent)</span> </span>&#123;</span><br><span class="line">    activity.setContentView(layoutId);</span><br><span class="line">    View decorView = activity.getWindow().getDecorView();</span><br><span class="line">    ViewGroup contentView = (ViewGroup) decorView.findViewById(android.R.id.content);</span><br><span class="line">    <span class="keyword">return</span> bindToAddedViews(bindingComponent, contentView, <span class="number">0</span>, layoutId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>activity.getWindow().getDecorView()</code> 获取根布局<code>view</code> 由<code>decorView</code> 获取<code>contentView</code> 然后发生<code>bind</code>绑定，执行<code>bindToAddedViews</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T extends ViewDataBinding&gt; <span class="function">T <span class="title">bindToAddedViews</span><span class="params">(DataBindingComponent component,</span></span></span><br><span class="line"><span class="params"><span class="function">        ViewGroup parent, <span class="keyword">int</span> startChildren, <span class="keyword">int</span> layoutId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> endChildren = parent.getChildCount();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childrenAdded = endChildren - startChildren;</span><br><span class="line">    <span class="keyword">if</span> (childrenAdded == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> View childView = parent.getChildAt(endChildren - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> bind(component, childView, layoutId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> View[] children = <span class="keyword">new</span> View[childrenAdded];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childrenAdded; i++) &#123;</span><br><span class="line">            children[i] = parent.getChildAt(i + startChildren);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bind(component, children, layoutId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>所有的<code>view</code>子<code>view</code>都会执行<code>bind</code>函数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T extends ViewDataBinding&gt; <span class="function">T <span class="title">bind</span><span class="params">(DataBindingComponent bindingComponent, View[] roots,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> layoutId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (T) sMapper.getDataBinder(bindingComponent, roots, layoutId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getDataBinder</code> 是一个抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DataBinderMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ViewDataBinding <span class="title">getDataBinder</span><span class="params">(DataBindingComponent bindingComponent, View view,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">int</span> layoutId)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ViewDataBinding <span class="title">getDataBinder</span><span class="params">(DataBindingComponent bindingComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">            View[] view, <span class="keyword">int</span> layoutId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看它具体的实现类<code>DataBinderMapperImpl</code> 注意要找自己包名下的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataBinderMapperImpl</span> <span class="keyword">extends</span> <span class="title">DataBinderMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ViewDataBinding <span class="title">getDataBinder</span><span class="params">(DataBindingComponent component, View view, <span class="keyword">int</span> layoutId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> localizedLayoutId = INTERNAL_LAYOUT_ID_LOOKUP.get(layoutId);</span><br><span class="line">    <span class="keyword">if</span>(localizedLayoutId &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> Object tag = view.getTag();</span><br><span class="line">      <span class="keyword">if</span>(tag == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;view must have a tag&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">switch</span>(localizedLayoutId) &#123;</span><br><span class="line">        <span class="keyword">case</span>  LAYOUT_ACTIVITYHOME: &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="string">&quot;layout/activity_home_0&quot;</span>.equals(tag)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ActivityHomeBindingImpl(component, view);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;The tag for activity_home is invalid. Received: &quot;</span> + tag);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span>  LAYOUT_ACTIVITYLOGIN: &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="string">&quot;layout/activity_login_0&quot;</span>.equals(tag)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ActivityLoginBindingImpl(component, view);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;The tag for activity_login is invalid. Received: &quot;</span> + tag);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>之前说把所有的<code>view</code>都打上了<code>tag</code> 这里通过获取<code>tag</code> 开始匹配不同的<code>bindingimpl</code>，<code>layout/activity_home_0</code> 和之前的<code>xml</code>中的<code>LineanerLayout</code>标签的<code>tag</code>对应上了，走<code>ActivityHomeBindingImpl</code>的构造方法的逻辑</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ActivityHomeBindingImpl</span><span class="params">(<span class="meta">@Nullable</span> androidx.databinding.DataBindingComponent bindingComponent, <span class="meta">@NonNull</span> View root)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(bindingComponent, root, mapBindings(bindingComponent, root, <span class="number">3</span>, sIncludes, sViewsWithIds));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ActivityHomeBindingImpl</span><span class="params">(androidx.databinding.DataBindingComponent bindingComponent, View root, Object[] bindings)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(bindingComponent, root, <span class="number">1</span></span><br><span class="line">        , (android.widget.EditText) bindings[<span class="number">2</span>]</span><br><span class="line">        , (android.widget.TextView) bindings[<span class="number">1</span>]</span><br><span class="line">        );</span><br><span class="line">    <span class="keyword">this</span>.editAddress.setTag(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">this</span>.mboundView0 = (android.widget.LinearLayout) bindings[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">this</span>.mboundView0.setTag(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">this</span>.nickName.setTag(<span class="keyword">null</span>);</span><br><span class="line">    setRootTag(root);</span><br><span class="line">    <span class="comment">// listeners</span></span><br><span class="line">    invalidateAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>第一个内存占用过高的原因来了</code>，注意看</p></li><li><p><code>Object[]</code> 这个对象数组缓存了控件，这块内存是额外的，通过执行<code>mapBindings</code>方法传入，我们看<code>mapBindings</code>怎么填充的这个对象数组</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mapBindings</span><span class="params">(DataBindingComponent bindingComponent, View view,</span></span></span><br><span class="line"><span class="params"><span class="function">        Object[] bindings, IncludedLayouts includes, SparseIntArray viewsWithIds,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">boolean</span> isRoot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> indexInIncludes;</span><br><span class="line">    <span class="keyword">final</span> ViewDataBinding existingBinding = getBinding(view);</span><br><span class="line">    <span class="keyword">if</span> (existingBinding != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Object objTag = view.getTag();</span><br><span class="line">    <span class="keyword">final</span> String tag = (objTag <span class="keyword">instanceof</span> String) ? (String) objTag : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> isBound = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (isRoot &amp;&amp; tag != <span class="keyword">null</span> &amp;&amp; tag.startsWith(<span class="string">&quot;layout&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> underscoreIndex = tag.lastIndexOf(<span class="string">&#x27;_&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (underscoreIndex &gt; <span class="number">0</span> &amp;&amp; isNumeric(tag, underscoreIndex + <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = parseTagInt(tag, underscoreIndex + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (bindings[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                bindings[index] = view;</span><br><span class="line">            &#125;</span><br><span class="line">            indexInIncludes = includes == <span class="keyword">null</span> ? -<span class="number">1</span> : index;</span><br><span class="line">            isBound = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            indexInIncludes = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag != <span class="keyword">null</span> &amp;&amp; tag.startsWith(BINDING_TAG_PREFIX)) &#123;</span><br><span class="line">        <span class="keyword">int</span> tagIndex = parseTagInt(tag, BINDING_NUMBER_START);</span><br><span class="line">        <span class="keyword">if</span> (bindings[tagIndex] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            bindings[tagIndex] = view;</span><br><span class="line">        &#125;</span><br><span class="line">        isBound = <span class="keyword">true</span>;</span><br><span class="line">        indexInIncludes = includes == <span class="keyword">null</span> ? -<span class="number">1</span> : tagIndex;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Not a bound view</span></span><br><span class="line">        indexInIncludes = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isBound) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> id = view.getId();</span><br><span class="line">        <span class="keyword">if</span> (id &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> index;</span><br><span class="line">            <span class="keyword">if</span> (viewsWithIds != <span class="keyword">null</span> &amp;&amp; (index = viewsWithIds.get(id, -<span class="number">1</span>)) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    bindings[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                bindings[index] = view;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (view <span class="keyword">instanceof</span>  ViewGroup) &#123;</span><br><span class="line">        <span class="keyword">final</span> ViewGroup viewGroup = (ViewGroup) view;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> count = viewGroup.getChildCount();</span><br><span class="line">        <span class="keyword">int</span> minInclude = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = viewGroup.getChildAt(i);</span><br><span class="line">            <span class="keyword">boolean</span> isInclude = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (indexInIncludes &gt;= <span class="number">0</span> &amp;&amp; child.getTag() <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                String childTag = (String) child.getTag();</span><br><span class="line">                <span class="keyword">if</span> (childTag.endsWith(<span class="string">&quot;_0&quot;</span>) &amp;&amp;</span><br><span class="line">                        childTag.startsWith(<span class="string">&quot;layout&quot;</span>) &amp;&amp; childTag.indexOf(<span class="string">&#x27;/&#x27;</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// This *could* be an include. Test against the expected includes.</span></span><br><span class="line">                    <span class="keyword">int</span> includeIndex = findIncludeIndex(childTag, minInclude,</span><br><span class="line">                            includes, indexInIncludes);</span><br><span class="line">                    <span class="keyword">if</span> (includeIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        isInclude = <span class="keyword">true</span>;</span><br><span class="line">                        minInclude = includeIndex + <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> index = includes.indexes[indexInIncludes][includeIndex];</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> layoutId = includes.layoutIds[indexInIncludes][includeIndex];</span><br><span class="line">                        <span class="keyword">int</span> lastMatchingIndex = findLastMatching(viewGroup, i);</span><br><span class="line">                        <span class="keyword">if</span> (lastMatchingIndex == i) &#123;</span><br><span class="line">                            bindings[index] = DataBindingUtil.bind(bindingComponent, child,</span><br><span class="line">                                    layoutId);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">final</span> <span class="keyword">int</span> includeCount =  lastMatchingIndex - i + <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">final</span> View[] included = <span class="keyword">new</span> View[includeCount];</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; includeCount; j++) &#123;</span><br><span class="line">                                included[j] = viewGroup.getChildAt(i + j);</span><br><span class="line">                            &#125;</span><br><span class="line">                            bindings[index] = DataBindingUtil.bind(bindingComponent, included,</span><br><span class="line">                                    layoutId);</span><br><span class="line">                            i += includeCount - <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isInclude) &#123;</span><br><span class="line">                mapBindings(bindingComponent, child, bindings, includes, viewsWithIds, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>对标签进行了解析，以<code>layout</code>开头的，以<code>binding</code>开头的 把<code>view</code>填充到<code>object[]</code>数组里</p></li><li><p>这样内存中就了<code>textview</code> <code>edittext</code>的副本，这是内存的额外开销</p></li></ul><p><code>这是第一个为什么内存大的原因</code></p><p><strong>我们来看看M-V V-M更新的机制</strong></p><p><code>ActivityHomeBinding</code>继承自<code>ViewDataBinding</code> ，看下<code>ViewDataBinding</code>的<code>static</code>静态代码块初始都做了啥</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (VERSION.SDK_INT &lt; VERSION_CODES.KITKAT) &#123;</span><br><span class="line">        ROOT_REATTACHED_LISTENER = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ROOT_REATTACHED_LISTENER = <span class="keyword">new</span> OnAttachStateChangeListener() &#123;</span><br><span class="line">            <span class="meta">@TargetApi(VERSION_CODES.KITKAT)</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewAttachedToWindow</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// execute the pending bindings.</span></span><br><span class="line">                <span class="keyword">final</span> ViewDataBinding binding = getBinding(v);</span><br><span class="line">                binding.mRebindRunnable.run();</span><br><span class="line">                v.removeOnAttachStateChangeListener(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewDetachedFromWindow</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始就注册了一个对view attachtowindow的监听</p><p><code>binding.mRebindRunnable</code>是个的Runnable</p><p>这是第二个为什么占内存的原因，因为每一个使用了<code>databinding</code>的界面都会生成一个这个<code>Runnable</code>，同时数据的双向绑定也是在这里完成的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable mRebindRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            mPendingRebind = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        processReferenceQueue();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (VERSION.SDK_INT &gt;= VERSION_CODES.KITKAT) &#123;</span><br><span class="line">            <span class="comment">// Nested so that we don&#x27;t get a lint warning in IntelliJ</span></span><br><span class="line">            <span class="keyword">if</span> (!mRoot.isAttachedToWindow()) &#123;</span><br><span class="line">                <span class="comment">// Don&#x27;t execute the pending bindings until the View</span></span><br><span class="line">                <span class="comment">// is attached again.</span></span><br><span class="line">                mRoot.removeOnAttachStateChangeListener(ROOT_REATTACHED_LISTENER);</span><br><span class="line">                mRoot.addOnAttachStateChangeListener(ROOT_REATTACHED_LISTENER);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        executePendingBindings();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>看下<code>executePendingBindings</code>最后会执行到<code>protected abstract void executeBindings()</code> 这是一个抽象类，我们看它在<code>ActivityHomeBindingImpl</code>的实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeBindings</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line">    <span class="comment">// batch finished</span></span><br><span class="line">    <span class="keyword">if</span> ((dirtyFlags &amp; <span class="number">0x7L</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// api target 1</span></span><br><span class="line"></span><br><span class="line">        androidx.databinding.adapters.TextViewBindingAdapter.setText(<span class="keyword">this</span>.editAddress, viewModelUserFieldAddress);</span><br><span class="line">        androidx.databinding.adapters.TextViewBindingAdapter.setText(<span class="keyword">this</span>.nickName, viewModelUserFieldNickName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((dirtyFlags &amp; <span class="number">0x4L</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// api target 1</span></span><br><span class="line"></span><br><span class="line">        androidx.databinding.adapters.TextViewBindingAdapter.setTextWatcher(<span class="keyword">this</span>.editAddress, (androidx.databinding.adapters.TextViewBindingAdapter.BeforeTextChanged)<span class="keyword">null</span>, (androidx.databinding.adapters.TextViewBindingAdapter.OnTextChanged)<span class="keyword">null</span>, (androidx.databinding.adapters.TextViewBindingAdapter.AfterTextChanged)<span class="keyword">null</span>, editAddressandroidTextAttrChanged);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>看到这里应该就明白了，<code>UI和data是怎么双向绑定的</code></li></ul><p>那么还有一个内存过大的原因，我们看<code>ActivityHomeBindingImpl</code>的构造中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ActivityHomeBindingImpl</span><span class="params">(androidx.databinding.DataBindingComponent bindingComponent, View root, Object[] bindings)</span> </span>&#123;</span><br><span class="line">		...</span><br><span class="line">    <span class="comment">// listeners</span></span><br><span class="line">    invalidateAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这个<code>invalidateAll</code>会执行<code>requestRebind</code>函数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">requestRebind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mContainingBinding != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mContainingBinding.requestRebind();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> LifecycleOwner owner = <span class="keyword">this</span>.mLifecycleOwner;</span><br><span class="line">        <span class="keyword">if</span> (owner != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Lifecycle.State state = owner.getLifecycle().getCurrentState();</span><br><span class="line">            <span class="keyword">if</span> (!state.isAtLeast(Lifecycle.State.STARTED)) &#123;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// wait until lifecycle owner is started</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mPendingRebind) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingRebind = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (USE_CHOREOGRAPHER) &#123;</span><br><span class="line">            mChoreographer.postFrameCallback(mFrameCallback);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mUIThreadHandler.post(mRebindRunnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后这里给主线程发送消息,这也是内存开销之一</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/05/16/%E7%AB%9F%E7%84%B6%E5%A6%82%E6%AD%A4%E7%AE%80%E5%8D%95%EF%BC%8CDataBinding-%E5%92%8C-ViewBinding-%E8%BD%AC/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/05/16/%E7%AB%9F%E7%84%B6%E5%A6%82%E6%AD%A4%E7%AE%80%E5%8D%95%EF%BC%8CDataBinding-%E5%92%8C-ViewBinding-%E8%BD%AC/" class="post-title-link" itemprop="url">竟然如此简单，DataBinding 和 ViewBinding[转]</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-05-16 04:27:52" itemprop="dateCreated datePublished" datetime="2022-05-16T04:27:52+08:00">2022-05-16</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-11-20 12:38:57" itemprop="dateModified" datetime="2022-11-20T12:38:57+08:00">2022-11-20</time></span></div></header><div class="post-body" itemprop="articleBody"><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6913723416671420430">原文链接：竟然如此简单，DataBinding 和 ViewBinding</a></p><p>在之前的文章 <a target="_blank" rel="noopener" href="https://juejin.cn/post/6905942568467759111">Kotlin 插件的落幕，ViewBinding 的崛起</a> 中介绍了 Google 为什么不建议在项目中使用 Kotlin 合成方法（Synthetic 视图）， Google 建议使用 ViewBinding 替换 Kotlin 合成方法，那么 ViewBinding 和 DataBinding 都有什么区别。</p><p><strong>ViewBinding：</strong></p><ul><li>仅仅支持绑定 View</li><li>不需要在布局文件中添加 layout 标签</li><li>需要在模块级 <code>build.gradle</code> 文件中添加 <code>viewBinding = true</code> 即可使用</li><li>效率高于 DataBinding，因为避免了与数据绑定相关的开销和性能问题</li><li>相比于 <code>kotlin-android-extensions</code> 插件避免了空异常</li></ul><p><strong>DataBinding：</strong></p><ul><li>包含了 ViewBinding 所有的功能</li><li>需要在模块级 <code>build.gradle</code> 文件内添加 <code>dataBinding = true</code> 并且需要在布局文件中添加 layout 标签才可以使用</li><li>支持 data 和 view 双向绑定</li><li>效率低于 ViewBinding，因为注释处理器会影响数据绑定的构建时间。</li></ul><p>ViewBinding 可以实现的， DataBinding 都可以实现，但是 DataBinding 的性能低于 ViewBinding，DataBinding 和 ViewBinding 会为每个 XML 文件生成绑定类。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">R</span>.</span></span>layout.activity_main -&gt; ActivityMainBinding</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">R</span>.</span></span>layout.fragment_main -&gt; FragmentMainBinding</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">R</span>.</span></span>layout.dialog_app -&gt; DialogAppBinding</span><br></pre></td></tr></table></figure><p>在 <a target="_blank" rel="noopener" href="https://juejin.cn/post/6905942568467759111">Kotlin 插件的落幕，ViewBinding 的崛起</a> 文章中同时也分析了 Kotlin 合成方法所带来的问题。即使 Kotlin 合成方法有很多问题，但是还有小伙伴愿意使用。</p><p>ViewBinding 和 DataBinding 为我们解决了这么多问题，但是为什么很多小伙伴们不愿意使用 ViewBinding 和 DataBinding，今天我们从使用的角度来分析。</p><h2 id="ViewBinding-和-DataBinding"><a href="#ViewBinding-和-DataBinding" class="headerlink" title="ViewBinding 和 DataBinding"></a>ViewBinding 和 DataBinding</h2><p>我大概汇总了 ViewBinding 和 DataBinding 在不同场景的所有用法，我们来看一下在项目中如何使用。</p><p><strong>基本配置</strong></p><p>从 <code>Android Studio 3.6</code> 版本开始，就内置在 Gradle 插件中了，不需要添加任何额外的库来使用它们，但是在 <code>Android Studio 3.6</code> 和 <code>Android Studio 4.0</code> 中使用方式不一样。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Android Studio 3.6</span></span><br><span class="line">android &#123;</span><br><span class="line">    viewBinding &#123;</span><br><span class="line">        enabled = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    dataBinding&#123;</span><br><span class="line">        enabled = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Android Studio 4.0</span></span><br><span class="line">android &#123;</span><br><span class="line">    buildFeatures &#123;</span><br><span class="line">        dataBinding = <span class="literal">true</span></span><br><span class="line">        viewBinding = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ViewBinding-的使用"><a href="#ViewBinding-的使用" class="headerlink" title="ViewBinding 的使用"></a>ViewBinding 的使用</h3><p>因为涉及到的场景比较多，为了减少篇幅，我只列出来核心部分，如果之前从来没有用过，这里只需要知道 ViewBinding 的门槛比 Kotlin 合成方法要高即可。</p><p><strong>不想为某个布局生成 binding 类，将下面属性添加到布局文件的根视图中</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">tools:viewBindingIgnore</span>=<span class="string">&quot;true&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>在 Activity 中使用</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    <span class="keyword">val</span> binding: ActivityMainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">    setContentView(binding.root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>在 Fragment 中使用</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?, savedInstanceState: <span class="type">Bundle</span>?)</span></span>: View &#123;</span><br><span class="line">    <span class="keyword">val</span> binding = FragmentViewBindBinding.inflate(inflater,container,<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">return</span> binding.root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在 Adapter 中的使用</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: RecyclerView.ViewHolder &#123;</span><br><span class="line">    RecycleItemProductBinding.inflate(LayoutInflater.from(parent.context), parent, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在 Dialog 中使用</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    binding = DialogAppBinding.inflate(layoutInflater)</span><br><span class="line">    setContentView(binding.root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>include 标签的使用</strong></p><p><code>include</code> 标签不带 <code>merge</code> 标签，需要给 <code>include</code> 标签添加 id, 直接使用 id 即可，用法如下所示。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">include</span></span><br><span class="line">    android:id=<span class="string">&quot;@+id/include&quot;</span></span><br><span class="line">    layout=<span class="string">&quot;@layout/layout_include_item&quot;</span> /&gt;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">val</span> binding: ActivityMainBinding = <span class="module-access"><span class="module"><span class="identifier">ActivityMainBinding</span>.</span></span>inflate(layoutInflater)</span><br><span class="line">binding.<span class="keyword">include</span>.includeTvTitle.set<span class="constructor">Text(<span class="string">&quot;使用 include 布局中的控件, 不包含 merge&quot;</span>)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>作者：DHL<br>链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6913723416671420430">https://juejin.cn/post/6913723416671420430</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>作者：DHL<br>链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6913723416671420430">https://juejin.cn/post/6913723416671420430</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>作者：DHL<br>链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6913723416671420430">https://juejin.cn/post/6913723416671420430</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/05/14/Jetpack%E7%B3%BB%E5%88%97%E2%80%94Lifecycle%E6%9E%84%E6%9E%B6%E7%BB%84%E4%BB%B6%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/05/14/Jetpack%E7%B3%BB%E5%88%97%E2%80%94Lifecycle%E6%9E%84%E6%9E%B6%E7%BB%84%E4%BB%B6%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">Jetpack系列—Lifecycle构架组件原理解析(更新中)</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-05-14 11:14:51" itemprop="dateCreated datePublished" datetime="2022-05-14T11:14:51+08:00">2022-05-14</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-11-20 12:38:56" itemprop="dateModified" datetime="2022-11-20T12:38:56+08:00">2022-11-20</time></span></div></header><div class="post-body" itemprop="articleBody"><ul><li>什么是Lifecycle</li><li>如何使用Lifecycle观察宿主状态</li><li>Fragment是如何实现Lifecycle的</li><li>Activity是如何实现Lifecycle的</li><li>Lifecycle是如何分发宿主状态的</li></ul><h2 id="什么是Lifecycle"><a href="#什么是Lifecycle" class="headerlink" title="什么是Lifecycle"></a>什么是Lifecycle</h2><ul><li>具备宿主生命周期感知能力的组件。它能持有组件(如Activty或Fragment)生命周期状态的信息，并且允许其他观察者监听宿主的状态</li></ul><h2 id="Lifecycle怎么使用"><a href="#Lifecycle怎么使用" class="headerlink" title="Lifecycle怎么使用"></a>Lifecycle怎么使用</h2><h3 id="自定义LifecycleObserver观察者"><a href="#自定义LifecycleObserver观察者" class="headerlink" title="自定义LifecycleObserver观察者"></a>自定义LifecycleObserver观察者</h3><ul><li>这种写法是为了避免在Activity或者Fragment中去覆写大量的生命周期函数回调，如onCreate onStart等，可以在自己的生命周期回调里去写逻辑，避免宿主太乱</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.自定义的LifecycleObserver观察者，用注解声明每个方法观察的宿主的状态，想感知哪个，就在哪个上加注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocationObserver</span> <span class="keyword">implements</span> <span class="title">LifecycleObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_START)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//开启定位</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_STOP)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//停止定位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.注册观察者，观察宿主生命周期状态变化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> <span class="meta">@org</span>.jetbrains.annotations.Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.注册观察者，观察宿主生命周期状态变化</span></span><br><span class="line">        getLifecycle().addObserver(<span class="keyword">new</span> LocationObserver());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Fragment和Activity是如何进行消息派发的？"><a href="#Fragment和Activity是如何进行消息派发的？" class="headerlink" title="Fragment和Activity是如何进行消息派发的？"></a>Fragment和Activity是如何进行消息派发的？</h2><h3 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h3><ol><li>实现LifecycleOwner接口，返回LifecycleRegistry</li><li>通过LifecycleRegistry在各生命周期进行派发</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fragment</span> <span class="keyword">implements</span> <span class="title">ComponentCallbacks</span>, <span class="title">OnCreateContextMenuListener</span>, <span class="title">LifecycleOwner</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ViewModelStoreOwner</span>, <span class="title">HasDefaultViewModelProviderFactory</span>, <span class="title">SavedStateRegistryOwner</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ActivityResultCaller</span> </span>&#123;</span><br><span class="line">          </span><br><span class="line">    LifecycleRegistry mLifecycleRegistry;</span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Lifecycle <span class="title">getLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mLifecycleRegistry;</span><br><span class="line">    &#125;</span><br><span class="line">          </span><br><span class="line">   	</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">performStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">        mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START);</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><ol><li>实现LifecycleOwner接口，实现getLifecycle方法，返回mLifecycleRegistry</li><li>并没有直接使用mLifecycleRegistry在各生命周期函数中进行派发，而是借助了一个透明的ReportFragment进行的</li><li>执行ReportFragment.injectIfNeededIn(this)，把自己挂载到Activity上</li><li>然后在对应的生命周期进行派出事件</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentActivity</span> <span class="keyword">extends</span> <span class="title">androidx</span>.<span class="title">core</span>.<span class="title">app</span>.<span class="title">ComponentActivity</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">        <span class="title">ContextAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">LifecycleOwner</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ViewModelStoreOwner</span>,</span></span><br><span class="line"><span class="class">        <span class="title">HasDefaultViewModelProviderFactory</span>,</span></span><br><span class="line"><span class="class">        <span class="title">SavedStateRegistryOwner</span>,</span></span><br><span class="line"><span class="class">        <span class="title">OnBackPressedDispatcherOwner</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ActivityResultRegistryOwner</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ActivityResultCaller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Lifecycle <span class="title">getLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mLifecycleRegistry;</span><br><span class="line">    &#125;</span><br><span class="line">          </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        ReportFragment.injectIfNeededIn(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (mContentLayoutId != <span class="number">0</span>) &#123;</span><br><span class="line">            setContentView(mContentLayoutId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReportFragment</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">app</span>.<span class="title">Fragment</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//把自己添加到Activity上</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectIfNeededIn</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">29</span>) &#123;</span><br><span class="line">            <span class="comment">// On API 29+, we can register for the correct Lifecycle callbacks directly</span></span><br><span class="line">            LifecycleCallbacks.registerIn(activity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Prior to API 29 and to maintain compatibility with older versions of</span></span><br><span class="line">        <span class="comment">// ProcessLifecycleOwner (which may not be updated when lifecycle-runtime is updated and</span></span><br><span class="line">        <span class="comment">// need to support activities that don&#x27;t extend from FragmentActivity from support lib),</span></span><br><span class="line">        <span class="comment">// use a framework fragment to get the correct timing of Lifecycle events</span></span><br><span class="line">        android.app.FragmentManager manager = activity.getFragmentManager();</span><br><span class="line">        <span class="keyword">if</span> (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            manager.beginTransaction().add(<span class="keyword">new</span> ReportFragment(), REPORT_FRAGMENT_TAG).commit();</span><br><span class="line">            <span class="comment">// Hopefully, we are the first to make a transaction.</span></span><br><span class="line">            manager.executePendingTransactions();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        dispatchStart(mProcessListener);</span><br><span class="line">        dispatch(Lifecycle.Event.ON_START);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(<span class="meta">@NonNull</span> Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="number">29</span>) &#123;</span><br><span class="line">            <span class="comment">// Only dispatch events from ReportFragment on API levels prior</span></span><br><span class="line">            <span class="comment">// to API 29. On API 29+, this is handled by the ActivityLifecycleCallbacks</span></span><br><span class="line">            <span class="comment">// added in ReportFragment.injectIfNeededIn</span></span><br><span class="line">            dispatch(getActivity(), event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//真正派发的地方法 获取所在activity的LifecycleRegistry 这就是为什么ComponentActivity要实现LifecycleOnwer接口</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(<span class="meta">@NonNull</span> Activity activity, <span class="meta">@NonNull</span> Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleRegistryOwner) &#123;</span><br><span class="line">            ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleOwner) &#123;</span><br><span class="line">            Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();</span><br><span class="line">            <span class="keyword">if</span> (lifecycle <span class="keyword">instanceof</span> LifecycleRegistry) &#123;</span><br><span class="line">                ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么要这么做？</p><p>这是一种切面的方式，为了兼容不是继承AppcompactActivity的Activity,而是直接继承Activity这个类的，在LifecycleDispatcher这个类里，通过注册Ativity的生命周期回调，实现DispatchActivityCallback，然后在回调的onActivityCreated方法内执行ReportFragment.injectIfNeededIn(this); 这样每个继承自Activity的也同样可以进行生命周期事件的派发了</p></blockquote><h3 id="LifecycleOwner、Lifecycle、LifecycleRegistry的关系"><a href="#LifecycleOwner、Lifecycle、LifecycleRegistry的关系" class="headerlink" title="LifecycleOwner、Lifecycle、LifecycleRegistry的关系"></a>LifecycleOwner、Lifecycle、LifecycleRegistry的关系</h3><p><img src="/../images/image-20220514122303160.png" alt="image-20220514122303160"></p><h2 id="LifecycleRestry事件分发的源码"><a href="#LifecycleRestry事件分发的源码" class="headerlink" title="LifecycleRestry事件分发的源码"></a>LifecycleRestry事件分发的源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleRegistry</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(<span class="meta">@NonNull</span> LifecycleObserver observer)</span> </span>&#123;</span><br><span class="line">        enforceMainThreadIfNeeded(<span class="string">&quot;addObserver&quot;</span>);</span><br><span class="line">      	<span class="comment">//宿主的状态，和宿主的生命周期不是一个概念</span></span><br><span class="line">      	<span class="comment">//切换到后台后，会执行onPause()但是状态是started状态，因为State这个枚举中并没有Paused的状态，只到started状态后面是Resumed状态</span></span><br><span class="line">        State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;</span><br><span class="line">        ObserverWithState statefulObserver = <span class="keyword">new</span> ObserverWithState(observer, initialState);</span><br><span class="line">        ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);</span><br><span class="line"></span><br><span class="line">      	...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行addObserver方法的可能在onCreate在onStart在onResume都可以，只要不是在onDestroy，都把宿主状态初始为INTIALIZED状态</p><p>把initialState包装成ObserverWithState即为带有状态的观察者</p><p><strong>宿主的生命周期和宿主状态模型图</strong></p><ul><li><p>前进状态：执行onCreate方法变为CREATED状态，执行onStart方法后，变为STARTED状态，执行onResume方法后，变为RESUMED状态，这是前进状态</p></li><li><p>倒退状态：执行onPause方法后，由RESUMED状态倒退到STARTED状态，执行onSop方法后，由STARTED状态倒退到CREATED状态，这是倒退的状态</p></li></ul><p><img src="/../images/image-20220515112325695.png" alt="image-20220515112325695"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(<span class="meta">@NonNull</span> LifecycleObserver observer)</span> </span>&#123;</span><br><span class="line">    enforceMainThreadIfNeeded(<span class="string">&quot;addObserver&quot;</span>);</span><br><span class="line">...</span><br><span class="line">    State targetState = calculateTargetState(observer);</span><br><span class="line">    mAddingObserverCounter++;</span><br><span class="line">    <span class="keyword">while</span> ((statefulObserver.mState.compareTo(targetState) &lt; <span class="number">0</span></span><br><span class="line">            &amp;&amp; mObserverMap.contains(observer))) &#123;</span><br><span class="line">        pushParentState(statefulObserver.mState);</span><br><span class="line">        <span class="keyword">final</span> Event event = Event.upFrom(statefulObserver.mState);</span><br><span class="line">        <span class="keyword">if</span> (event == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;no event up from &quot;</span> + statefulObserver.mState);</span><br><span class="line">        &#125;</span><br><span class="line">        statefulObserver.dispatchEvent(lifecycleOwner, event);</span><br><span class="line">        popParentState();</span><br><span class="line">        <span class="comment">// mState / subling may have been changed recalculate</span></span><br><span class="line">        targetState = calculateTargetState(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isReentrance) &#123;</span><br><span class="line">        <span class="comment">// we do sync only on the top level.</span></span><br><span class="line">        sync();</span><br><span class="line">    &#125;</span><br><span class="line">    mAddingObserverCounter--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Event <span class="title">upFrom</span><span class="params">(<span class="meta">@NonNull</span> State state)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">    <span class="keyword">case</span> INITIALIZED:</span><br><span class="line">      <span class="keyword">return</span> ON_CREATE;</span><br><span class="line">    <span class="keyword">case</span> CREATED:</span><br><span class="line">      <span class="keyword">return</span> ON_START;</span><br><span class="line">    <span class="keyword">case</span> STARTED:</span><br><span class="line">      <span class="keyword">return</span> ON_RESUME;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchEvent</span><span class="params">(LifecycleOwner owner, Event event)</span> </span>&#123;</span><br><span class="line">  State newState = event.getTargetState();</span><br><span class="line">  mState = min(mState, newState);</span><br><span class="line">  mLifecycleObserver.onStateChanged(owner, event);</span><br><span class="line">  mState = newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> State <span class="title">getTargetState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> ON_CREATE:</span><br><span class="line">    <span class="keyword">case</span> ON_STOP:</span><br><span class="line">      <span class="keyword">return</span> State.CREATED;</span><br><span class="line">    <span class="keyword">case</span> ON_START:</span><br><span class="line">    <span class="keyword">case</span> ON_PAUSE:</span><br><span class="line">      <span class="keyword">return</span> State.STARTED;</span><br><span class="line">    <span class="keyword">case</span> ON_RESUME:</span><br><span class="line">      <span class="keyword">return</span> State.RESUMED;</span><br><span class="line">    <span class="keyword">case</span> ON_DESTROY:</span><br><span class="line">      <span class="keyword">return</span> State.DESTROYED;</span><br><span class="line">    <span class="keyword">case</span> ON_ANY:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="keyword">this</span> + <span class="string">&quot; has no target state&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个while循环很重要，这个循环会把宿主由初始状态INITIALIZED 前进到当前宿主应有的生命周期状态可能是STARTED也可能是RESUMED的</p><ol><li>先通过calculateTargetState(observer)拿到宿主的当前状态，比如宿主在onResume中注册的addObserver方法，那它当前<strong>应该</strong>的状态是RESUMED</li><li>通过比较当前状态和当前应该处于的状态statefulObserver.mState.compareTo(targetState)小于0代表状态还没有前进到，比如第一次状态肯定是INITIALIZED而宿主应该处于是RESUMED，所以执行while循环</li><li>final Event event &#x3D; Event.upFrom(statefulObserver.mState)由当前状态获取应该执行的生周期事件，得知要执行的事件是ON_CREATE</li><li>执行 statefulObserver.dispatchEvent(lifecycleOwner, event)</li><li>先由event.getTargetState() 事件获取newState，比如当前是ON_CREATE 得到CREATED</li><li>mState &#x3D; newState赋值当前状态为新的状态，这样再去while中比较</li></ol><p>这样就会把当前RESUMED之前的事件都派发给宿主，而不是在于它在哪里进行了注册，宿主会收到一个完整的生命周期事件，进行注册等操作</p><p><img src="/../images/image-20220515114041728.png" alt="image-20220515114041728"></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/05/13/%E8%81%8A%E8%81%8AWebSocket%E5%8F%8AOkHttp%E5%AE%9E%E7%8E%B0WebSocket/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/05/13/%E8%81%8A%E8%81%8AWebSocket%E5%8F%8AOkHttp%E5%AE%9E%E7%8E%B0WebSocket/" class="post-title-link" itemprop="url">聊聊WebSocket及OkHttp实现WebSocket</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-05-13 18:43:51" itemprop="dateCreated datePublished" datetime="2022-05-13T18:43:51+08:00">2022-05-13</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-11-20 12:38:57" itemprop="dateModified" datetime="2022-11-20T12:38:57+08:00">2022-11-20</time></span></div></header><div class="post-body" itemprop="articleBody"><p>OkHttp应该算是Android中使用最广泛的网络库了，我们通常会利用它来实现HTTP请求，但是实际上它还可以支持WebSocket，并且使用起来还非常的便捷。那本文就来聊聊，利用OkHttp实现WebSocket的一些细节，包括对WebSocket的介绍，以及在传输如何做鉴权、长连接保活及其原理。</p><h2 id="1-WebSocket"><a href="#1-WebSocket" class="headerlink" title="1.WebSocket"></a>1.WebSocket</h2><h3 id="1-1-为什么使用WebSocket"><a href="#1-1-为什么使用WebSocket" class="headerlink" title="1.1 为什么使用WebSocket?"></a>1.1 为什么使用WebSocket?</h3><p>我们做客户端开发时，接触最多的应用层网络协议，就是HTTP协议，而今天介绍的<code>WebSocket</code>，下层和<code>HTTP</code>一样也是基于<code>TCP</code>协议，这是一种轻量级网络通信协议，也属于应用层协议。</p><p><code>WebSocket</code>与<code>HTTP2</code> 一样，其实都是为了解决<code>HTTP1.1</code>的一些缺陷而诞生的，而<code>WebSocket</code>针对的就是<code>「请求-应答」</code>这种<code>「半双工」</code>的模式的通信缺陷。</p><p><code>「请求-应答」</code>是半双工的通信模式，数据的传输必须经过一次请求应答，这个完整的通信过程，通信的同一时刻数据只能在一个方向上传递。它最大的问题在于，HTTP是一种被动的模式，服务端必须等待客户端请求才可以返回数据，无法主动向客户端发送数据。</p><p>这也导致在<code>WebSocket</code>出现之前，一些对实时性有要求的服务，通常是基于轮询这种简单的模式来实现。轮询就是由客户端定时发起请求，如果服输端有需要传递的数据，可以借助这个请求去响应数据。</p><p>轮询的缺点也非常明显，大量空闲的时间，其实是在反复发送无效的请求，这显然是一种资源的损耗。</p><p>虽然在之后的<code>HTTP2</code> <code>HTTP3</code>中针对这种半双工的缺陷新增了<code>Stream</code> <code>Server</code> <code>Push</code>等特性，但是’请求-应答’依然是<code>HTTP</code>协议请要的通信方式。</p><p><code>WebSocket</code>协议是由<code>HTML5</code>规范定义的，原本是为了浏览器而设计的，可以避免同源的限制，浏览器可以与任意服务端通信，现代浏览器基本上都已经支持<code>WebSocket</code>。</p><p>虽然WebSocket原本是被定义在<code>HTML5</code>中，但它也适用于移动端，尽管移动端也可以直接通过<code>Socket</code>与服务端通信，但借助<code>WebSocket</code>，可以利用<code>80（HTTP）</code>或<code>443（HTTPS）</code>端口通信，有效的避免一些防火墙的拦截。</p><p><code>WebSocket</code>是真正意义上的<code>全双工模式</code>，也就我们俗称的<code>‘长连接’</code>。当完成握手连接后，客户端和服务端均可以主动的发起请求，回复响应，并且两边的传输都是相互独立的。</p><h3 id="1-2-WebSocket的特点"><a href="#1-2-WebSocket的特点" class="headerlink" title="1.2 WebSocket的特点"></a>1.2 WebSocket的特点</h3><p><code>WebSocket</code>的数据传输，是基于<code>TCP</code>协议，但是在传输之前，还有一个握手的过程，双方确认过眼神，才能够正式的传输数据。</p><p><code>WebSocket</code>的握手过程，符合其<code>‘Web’</code>的特性，是利用<code>HTTP</code>本身的<code>‘协议升级’</code>来实现。</p><p>在建立连接前，客户端还需要知道服务端的地址，WebSocket并没有另辟路径，而是沿用了HTTP的URL格式，但协议标识变成了<code>‘ws’</code>或者<code>‘wss’</code>，分别表示明文加密的<code>WebSocket</code>协议，这一点和<code>HTTP</code>和<code>HTTPS</code>的关系类似。</p><p>以下是一些WebSocket的URL例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws://cxmydev.com/some/path</span><br><span class="line">ws://cxmydev.com:8080/some/path</span><br><span class="line">wss://cxmydev.com:443?uid=xxx</span><br></pre></td></tr></table></figure><p>而在连接建立后，<code>WebSocket</code>采用二进制帧的形式传输数据，其中常用的包括用于数据传输的数据帧<code>MESSAGE</code>以及3个<code>控制帧</code>：</p><ul><li><code>PING</code>:主动保活的PING帧</li><li><code>PONG</code>：收到PING帧后回复</li><li><code>CLOSE</code>：主动关闭WebSocket连接</li></ul><p>小结下<code>WebSocket</code>特性：</p><ol><li><code>WebSocket</code>建立在TCP协议之上，对服务端友好。</li><li>默认端口采用80或443，握手阶段采用HTTP协议，不容易被防火墙屏蔽，能够通过各种HTTP代理服务器。</li><li>传输数据相比HTTP更轻量，少了HTTP HEADER，性能开销更小，通信更高效。</li><li>通过MESSAGE帧发送数据，可以发送文本或者二进制数据，如果数据过大，会被分为多个MESSAGE帧发送。</li><li>WebSocket沿用HTTP的URL，协议标识符’ws’或‘wss’</li></ol><h3 id="1-3-WebSocket原理"><a href="#1-3-WebSocket原理" class="headerlink" title="1.3 WebSocket原理"></a>1.3 WebSocket原理</h3><p><code>WebSocket</code>在<code>TCP</code>连接建立后，还要通过<code>Http</code>进行一次握手，也就是通过<code>Http</code>发送一条<code>GET请求</code>消息给服务器，告诉服务器我要建立<code>WebSocket连接</code>了，你准备好哦，具体做法就是在头部信息中添加相关参数。然后服务器响应我知道了，并且将连接协议改成<code>WebSocket</code>，开始建立长连接。</p><p>这里贴上请求头和响应头信息，从网上找了一张图：</p><p><img src="/../images/image-20220514062147256.png" alt="image-20220514062147256"></p><p>简单说明下参数：</p><ul><li>URL一般是以<code>ws</code>或者<code>wss</code>开头，<code>ws</code>对应<code>Websocket</code>协议，<code>wss</code>对应在<code>TLS</code>之上的<code>WebSocket</code>。类似于<code>Http</code>和<code>Https</code>的关系。</li><li>请求方法为GET方法。</li><li><code>Connection:Upgrade</code>，表示客户端要连接升级，不用Http协议。</li><li><code>Upgrade:websocket</code>， 表示客户端要升级建立<code>Websocket</code>连接。</li><li><code>Sec-Websocket-Key:key</code>， 这个key是随机生成的，服务器会通过这个参数验证该请求是否有效。</li><li><code>Sec-WebSocket-Version:13</code>， websocket使用的版本，一般就是13。</li><li><code>Sec-webSocket-Extension:permessage-deflate</code>，客户端指定的一些扩展协议，比如这里<code>permessage-deflate</code>就是<code>WebSocket</code>的一种压缩协议。</li><li><code>响应码101,</code>表示响应协议升级，后续的数据交互都按照Upgradet指定的<code>WebSocket</code>协议来。</li></ul><h2 id="2-结合OkHttp使用WebSocket进行通信"><a href="#2-结合OkHttp使用WebSocket进行通信" class="headerlink" title="2.结合OkHttp使用WebSocket进行通信"></a>2.结合OkHttp使用WebSocket进行通信</h2><h3 id="2-1-添加OkHttp依赖"><a href="#2-1-添加OkHttp依赖" class="headerlink" title="2.1 添加OkHttp依赖"></a>2.1 添加OkHttp依赖</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation(<span class="string">&quot;com.squareup.okhttp3:okhttp:4.7.2&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-2-实现代码"><a href="#2-2-实现代码" class="headerlink" title="2.2 实现代码"></a>2.2 实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化WebSocket</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mWbSocketUrl = <span class="string">&quot;ws://echo.websocket.org&quot;</span>;</span><br><span class="line">    mClient = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">            .pingInterval(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">            .build();</span><br><span class="line">    Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">            .url(mWbSocketUrl)</span><br><span class="line">            .build();</span><br><span class="line">    mWebSocket = mClient.newWebSocket(request, <span class="keyword">new</span> WsListener());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要是配置了<code>OkHttp</code>的一些参数，以及<code>WebSocket</code>的连接地址。其中<code>newWebSocket</code>方法就是进行<code>WebSocket</code>的初始化和连接。</p><p>这里要注意的点是<code>pingInterval</code>方法的配置，这个方法主要是用来设置<code>WebSocket</code>连接的保活。 相信做过长连接的同学都知道，一个长连接一般要隔几秒发送一条消息告诉服务器我在线，而服务器也会回复一个消息表示收到了，这样就确认了连接正常，客户端和服务器端都在线。</p><p>如果服务器没有<code>按时收到</code>这个消息那么服务器可能就会<code>主动关闭</code>这个连接，节约资源。 客户端没有<code>正常收到</code>这个返回的消息，也会做一些类似<code>重连的操作</code>，所以这个保活消息非常重要。</p><p>我们称这个消息叫作<code>心跳包</code>，一般用<code>PING，PONG</code>表示，像乒乓球一样，一来一回。 所以这里的<code>pingInterval</code>就是设置心跳包发送的间隔时间，设置了这个方法之后，<code>OkHttp</code>就会自动帮我们发送心跳包事件，也就是<code>ping</code>包。当间隔时间到了，没有收到<code>pong</code>包的话，监听事件中的<code>onFailure</code>方法就会被调用，此时我们就可以进行断线重连。</p><p>但是由于实际业务需求不一样，以及<code>okhttp</code>中心跳包事件给予我们权限较少，所以我们也可以自己完成心跳包事件，即在<code>WebSocket</code>连接成功之后，开始定时发送<code>ping</code>包，在下一次发送<code>ping</code>包之前检查上一个<code>pong</code>包是否收到，如果没收到，就视为异常，开始断线重连。感兴趣的同学可以看看文末的相关源码。</p><p>建立连接后，我们就可以正常发送和读取消息了，也就是在上文<code>WsListener</code>监听事件中表现：</p><blockquote><p>在<code>Android</code>程序中，如果应用被系统<code>kill</code>了进程，这种我们是没办法告诉<code>Sever</code>端，结束连接的，所以心跳包是有必要的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//监听事件，用于收消息，监听连接的状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WsListener</span> <span class="keyword">extends</span> <span class="title">WebSocketListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClosed</span><span class="params">(<span class="meta">@NotNull</span> WebSocket webSocket, <span class="keyword">int</span> code, <span class="meta">@NotNull</span> String reason)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onClosed(webSocket, code, reason);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClosing</span><span class="params">(<span class="meta">@NotNull</span> WebSocket webSocket, <span class="keyword">int</span> code, <span class="meta">@NotNull</span> String reason)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onClosing(webSocket, code, reason);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(<span class="meta">@NotNull</span> WebSocket webSocket, <span class="meta">@NotNull</span> Throwable t, <span class="meta">@Nullable</span> Response response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onFailure(webSocket, t, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="meta">@NotNull</span> WebSocket webSocket, <span class="meta">@NotNull</span> String text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onMessage(webSocket, text);</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;客户端收到消息:&quot;</span> + text);</span><br><span class="line">        onWSDataChanged(DATE_NORMAL, text);</span><br><span class="line">       <span class="comment">//测试发消息</span></span><br><span class="line">        webSocket.send(<span class="string">&quot;我是客户端，你好啊&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="meta">@NotNull</span> WebSocket webSocket, <span class="meta">@NotNull</span> ByteString bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onMessage(webSocket, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(<span class="meta">@NotNull</span> WebSocket webSocket, <span class="meta">@NotNull</span> Response response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onOpen(webSocket, response);</span><br><span class="line">        Log.e(TAG,<span class="string">&quot;连接成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//发送String消息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">final</span> String message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mWebSocket != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mWebSocket.send(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送byte消息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">final</span> ByteString message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mWebSocket != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mWebSocket.send(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">//主动断开连接</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnect</span><span class="params">(<span class="keyword">int</span> code, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mWebSocket != <span class="keyword">null</span>)</span><br><span class="line">        mWebSocket.close(code, reason);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>这里要注意，回调的方法都是在子线程回调的，如果需要<code>更新UI</code>，需要切换到主线程。</p></blockquote><p>基本操作就这么多，还是很简单的吧，初始化<code>Websocket</code>——连接——连接成功——收发消息。</p><p>其中<code>WebSocket</code>类是一个操作接口，主要提供了以下<strong>几个方法</strong></p><ul><li><code>send(text: String)</code>发送一个String类型的消息</li><li><code>send(bytes: ByteString)</code> 发送一个二进制类型的消息</li><li><code>close(code: Int, reason: String?)</code>关闭WebSocket连接</li></ul><p>如果有同学想测试下<code>WebSocket</code>的功能但是又没有<strong>实际的服务器</strong>，怎么办呢？ 其实<code>OkHttp</code>官方有一个<code>MockWebSocket</code>服务，可以用来模拟服务端，下面我们一起试一下：</p><h3 id="2-3-模拟服务器"><a href="#2-3-模拟服务器" class="headerlink" title="2.3 模拟服务器"></a>2.3 模拟服务器</h3><p>首先集成<code>MockWebSocket</code>服务库：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;com.squareup.okhttp3:mockwebserver:4.7.2&#x27;</span></span><br></pre></td></tr></table></figure><p>然后就可以新建<code>MockWebServer</code>，并加入<code>MockResponse</code>作为接收消息的响应。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">MockWebServer mMockWebServer = <span class="keyword">new</span> MockWebServer();</span><br><span class="line">MockResponse response = <span class="keyword">new</span> MockResponse()</span><br><span class="line">        .withWebSocketUpgrade(<span class="keyword">new</span> WebSocketListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(<span class="meta">@NotNull</span> WebSocket webSocket, <span class="meta">@NotNull</span> Response response)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.onOpen(webSocket, response);</span><br><span class="line">                <span class="comment">//有客户端连接时回调</span></span><br><span class="line">                Log.e(TAG, <span class="string">&quot;服务器收到客户端连接成功回调：&quot;</span>);</span><br><span class="line">                mWebSocket = webSocket;</span><br><span class="line">                mWebSocket.send(<span class="string">&quot;我是服务器，你好呀&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="meta">@NotNull</span> WebSocket webSocket, <span class="meta">@NotNull</span> String text)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.onMessage(webSocket, text);</span><br><span class="line"></span><br><span class="line">                Log.e(TAG, <span class="string">&quot;服务器收到消息：&quot;</span> + text);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClosed</span><span class="params">(<span class="meta">@NotNull</span> WebSocket webSocket, <span class="keyword">int</span> code, <span class="meta">@NotNull</span> String reason)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.onClosed(webSocket, code, reason);</span><br><span class="line">                Log.e(TAG, <span class="string">&quot;onClosed：&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">mMockWebServer.enqueue(response);</span><br></pre></td></tr></table></figure><p>这里服务器端在收到客户端连接成功消息后，给客户端发送了一条消息。 要注意的是这段代码要在子线程执行，因为主线程不能进行网络操作。</p><p>然后就可以去初始化<code>Websocket</code>客户端了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取连接url，初始化websocket客户端</span></span><br><span class="line">String websocketUrl = <span class="string">&quot;ws://&quot;</span> + mMockWebServer.getHostName() + <span class="string">&quot;:&quot;</span> + mMockWebServer.getPort() + <span class="string">&quot;/&quot;</span>;</span><br><span class="line">WSManager.getInstance().init(websocketUrl);</span><br></pre></td></tr></table></figure><p>ok，运行项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//运行结果</span><br><span class="line">E/jimu: mWbSocketUrl=ws://localhost:38355/</span><br><span class="line">E/jimu: 服务器收到客户端连接成功回调：</span><br><span class="line">E/jimu: 连接成功！</span><br><span class="line">E/jimu: 客户端收到消息:我是服务器，你好呀</span><br><span class="line">E/jimu: 服务器收到消息：我是客户端，你好啊</span><br></pre></td></tr></table></figure><h3 id="2-4-WebSocket如何进行鉴权"><a href="#2-4-WebSocket如何进行鉴权" class="headerlink" title="2.4 WebSocket如何进行鉴权"></a>2.4 WebSocket如何进行鉴权</h3><p>接下来我们聊聊 <code>WebSocket</code> 连接的鉴权问题。</p><p>所谓鉴权，其实就是为了安全考虑，避免服务端启动 <code>WebSocket</code> 的连接服务后，任谁都可以连接，这肯定会引发一些安全问题。其次，服务端还需要将 <code>WebSocket</code> 的连接实体与一个真是的用户对应起来，否者业务无法保证了。</p><p>那么问题就回到了，<code>WebSocket</code> 通信的完整过程中，如何以及何时将一些业务数据传递给服务端？当然在 <code>WebSocket</code> 连接建立之后，立即给服务端发送一些鉴权的数据，必然是可以做到业务实现的，但是这样明显是不够优雅的。</p><p>前文提到，<code>WebSocket</code> 在握手阶段，使用的是 <code>HTTP</code> 的 “协议升级”，它本质上还是 <code>HTTP</code> 的报文头发送一些特殊的头数据，来完成协议升级。</p><p>例如在 <code>RealWebSocket</code> 中，就有构造 <code>Header</code> 的过程，如 <code>Upgrade</code>、<code>Connection</code> 等等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(OkHttpClient client)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">final</span> Request request = originalRequest.newBuilder()</span><br><span class="line">    .header(<span class="string">&quot;Upgrade&quot;</span>, <span class="string">&quot;websocket&quot;</span>)</span><br><span class="line">    .header(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;Upgrade&quot;</span>)</span><br><span class="line">    .header(<span class="string">&quot;Sec-WebSocket-Key&quot;</span>, key)</span><br><span class="line">    .header(<span class="string">&quot;Sec-WebSocket-Version&quot;</span>, <span class="string">&quot;13&quot;</span>)</span><br><span class="line">    .build();</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么实际我们在 <code>WebSocket</code> 阶段，也可以通过 <code>Header</code> 传输一些鉴权的数据，例如 <code>uid</code>、<code>token</code> 之类，具体方法就是在构造 <code>Request</code> 的时候，为其增加 <code>Header</code>，这里就不举例说明了。</p><p>另外 <code>WebSocket</code> 的 <code>URL</code> 也是可以携带参数的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wss://cxmydev.com:443?uid=xxx&amp;token=xxx</span><br></pre></td></tr></table></figure><h2 id="3-OkHttp-源码解读WebSocket连接过程及协议"><a href="#3-OkHttp-源码解读WebSocket连接过程及协议" class="headerlink" title="3.OkHttp 源码解读WebSocket连接过程及协议"></a>3.OkHttp 源码解读WebSocket连接过程及协议</h2><p><code>WebSocket</code>整个流程无非三个功能：连接，接收消息，发送消息。下面我们就从这<code>三个方面</code>分析下具体是怎么实现的。</p><h3 id="3-1-连接"><a href="#3-1-连接" class="headerlink" title="3.1 连接"></a>3.1 连接</h3><p>通过上面的代码我们得知，<code>WebSocket</code>连接是通过<code>newWebSocket</code>方法。直接点进去看这个方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newWebSocket</span><span class="params">(request: <span class="type">Request</span>, listener: <span class="type">WebSocketListener</span>)</span></span>: WebSocket &#123;</span><br><span class="line">  <span class="keyword">val</span> webSocket = RealWebSocket(</span><br><span class="line">      taskRunner = TaskRunner.INSTANCE,</span><br><span class="line">      originalRequest = request,</span><br><span class="line">      listener = listener,</span><br><span class="line">      random = Random(),</span><br><span class="line">      pingIntervalMillis = pingIntervalMillis.toLong(),</span><br><span class="line">      extensions = <span class="literal">null</span>, <span class="comment">// Always null for clients.</span></span><br><span class="line">      minimumDeflateSize = minWebSocketMessageToCompress</span><br><span class="line">  )</span><br><span class="line">  webSocket.connect(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">return</span> webSocket</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里做了两件事：</p><ul><li>初始化<code>RealWebSocket</code>，主要是设置了一些参数（比如<code>pingIntervalMillis</code>心跳包时间间隔，还有监听事件之类的）</li><li><code>connect</code>方法进行<code>WebSocket</code>连接</li></ul><p>继续查看connect方法：</p><h4 id="3-1-1-connect-WebSocket连接握手"><a href="#3-1-1-connect-WebSocket连接握手" class="headerlink" title="3.1.1 connect(WebSocket连接握手)"></a>3.1.1 connect(WebSocket连接握手)</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">connect</span><span class="params">(client: <span class="type">OkHttpClient</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">//***</span></span><br><span class="line">  <span class="keyword">val</span> webSocketClient = client.newBuilder()</span><br><span class="line">      .eventListener(EventListener.NONE)</span><br><span class="line">      .protocols(ONLY_HTTP1)</span><br><span class="line">      .build()</span><br><span class="line">  <span class="keyword">val</span> request = originalRequest.newBuilder()</span><br><span class="line">      .header(<span class="string">&quot;Upgrade&quot;</span>, <span class="string">&quot;websocket&quot;</span>)</span><br><span class="line">      .header(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;Upgrade&quot;</span>)</span><br><span class="line">      .header(<span class="string">&quot;Sec-WebSocket-Key&quot;</span>, key)</span><br><span class="line">      .header(<span class="string">&quot;Sec-WebSocket-Version&quot;</span>, <span class="string">&quot;13&quot;</span>)</span><br><span class="line">      .header(<span class="string">&quot;Sec-WebSocket-Extensions&quot;</span>, <span class="string">&quot;permessage-deflate&quot;</span>)</span><br><span class="line">      .build()</span><br><span class="line">  call = RealCall(webSocketClient, request, forWebSocket = <span class="literal">true</span>)</span><br><span class="line">  call!!.enqueue(<span class="keyword">object</span> : Callback &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>, response: <span class="type">Response</span>)</span></span> &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//得到数据流</span></span><br><span class="line">      <span class="keyword">val</span> streams: Streams</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        checkUpgradeSuccess(response, exchange)</span><br><span class="line">        streams = exchange!!.newWebSocketStreams()</span><br><span class="line">      &#125; </span><br><span class="line">      </span><br><span class="line">      <span class="comment">//***</span></span><br><span class="line">      <span class="comment">// Process all web socket messages.</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> name = <span class="string">&quot;<span class="variable">$okHttpName</span> WebSocket <span class="subst">$&#123;request.url.redact()&#125;</span>&quot;</span></span><br><span class="line">        initReaderAndWriter(name, streams)</span><br><span class="line">        listener.onOpen(<span class="keyword">this</span><span class="symbol">@RealWebSocket</span>, response)</span><br><span class="line">        loopReader()</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        failWebSocket(e, <span class="literal">null</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Websocket</code>连接需要一次<code>Http</code>协议的握手，然后才能把协议升级成<code>WebSocket</code>。所以这段代码就体现出这个功能了。</p><p>首先就<code>new</code>了一个用来进行<code>Http</code>连接的<code>request</code>，其中<code>Header</code>的参数就表示我要进行<code>WebSocket</code>连接了，参数解析如下：</p><ul><li><code>Connection:Upgrade</code>，表示客户端要连接升级</li><li><code>Upgrade:websocket</code>， 表示客户端要升级建立Websocket连接</li><li><code>Sec-Websocket-Key:key</code>， 这个key是随机生成的，服务器会通过这个参数验证该请求是否有效</li><li><code>Sec-WebSocket-Version:13</code>， websocket使用的版本，一般就是13</li><li><code>Sec-webSocket-Extension:permessage-deflate</code>，客户端指定的一些扩展协议，比如这里<code>permessage-deflate</code>就是<code>WebSocket</code>的一种压缩协议。</li></ul><p><code>Header</code>设置好之后，就调用了<code>call</code>的<code>enqueue</code>方法，这个方法大家应该都很熟悉吧，<code>OkHttp</code>里面对于<code>Http</code>请求的异步请求就是这个方法。 至此，握手结束，服务器返回<code>响应码101</code>，表示协议升级。</p><p>然后我们继续看看获取服务器响应之后又做了什么？ 在发送<code>Http</code>请求成功之后，<code>onResponse</code>响应方法里面主要表现为四个处理逻辑：</p><ul><li>将<code>Http</code>流转换成<code>WebSocket</code>流，得到<code>Streams</code>对象，这个流后面会转化成输入流和输出流，也就是进行发送和读取的操作流</li><li><code>listener.onOpen(this@RealWebSocket, response)</code>，回调了接口<code>WebSocketListener</code>的<code>onOpen</code>方法，告诉用户<code>WebSocket</code>已经连接</li><li><code>initReaderAndWriter(name, streams)</code></li><li><code>loopReader()</code></li></ul><p>前两个逻辑还是比较好理解，主要是后两个方法，我们分别解析下。 首先看<code>initReaderAndWriter</code>方法。</p><h4 id="3-1-2-initReaderAndWriter（初始化输入流输出流）"><a href="#3-1-2-initReaderAndWriter（初始化输入流输出流）" class="headerlink" title="3.1.2 initReaderAndWriter（初始化输入流输出流）"></a>3.1.2 initReaderAndWriter（初始化输入流输出流）</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RealWebSocket.kt</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">initReaderAndWriter</span><span class="params">(name: <span class="type">String</span>, streams: <span class="type">Streams</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> extensions = <span class="keyword">this</span>.extensions!!</span><br><span class="line">  synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">//***</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写数据，发送数据的工具类</span></span><br><span class="line">    <span class="keyword">this</span>.writer = WebSocketWriter()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置心跳包事件</span></span><br><span class="line">    <span class="keyword">if</span> (pingIntervalMillis != <span class="number">0L</span>) &#123;</span><br><span class="line">      <span class="keyword">val</span> pingIntervalNanos = MILLISECONDS.toNanos(pingIntervalMillis)</span><br><span class="line">      taskQueue.schedule(<span class="string">&quot;<span class="variable">$name</span> ping&quot;</span>, pingIntervalNanos) &#123;</span><br><span class="line">        writePingFrame()</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@schedule</span> pingIntervalNanos</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//***</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//***</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取数据的工具类</span></span><br><span class="line">  reader = WebSocketReader(     </span><br><span class="line">    ***</span><br><span class="line">    frameCallback = <span class="keyword">this</span>,</span><br><span class="line">    ***</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">writePingFrame</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="comment">//***</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    writer.writePing(ByteString.EMPTY)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">    failWebSocket(e, <span class="literal">null</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个方法主要干了两件事：</p><ul><li>实例化输出流输入流工具类，也就是<code>WebSocketWriter</code>和<code>WebSocketReader</code>，用来处理数据的收发。</li><li>设置心跳包事件。如果<code>pingIntervalMillis</code>参数不为0，就通过计时器，每隔<code>pingIntervalNanos</code>发送一个<code>ping</code>消息。其中<code>writePingFrame</code>方法就是发送了<code>ping</code>帧数据。</li></ul><h3 id="3-2-接收消息处理消息"><a href="#3-2-接收消息处理消息" class="headerlink" title="3.2 接收消息处理消息"></a>3.2 接收消息处理消息</h3><h4 id="3-2-1-loopReader"><a href="#3-2-1-loopReader" class="headerlink" title="3.2.1 loopReader"></a>3.2.1 loopReader</h4><p>接着看看这个<code>loopReader</code>方法是干什么的，看这个名字我们大胆猜测下，难道这个方法就是用来循环读取数据的？去代码里找找答案：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">loopReader</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (receivedCloseCode == -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// This method call results in one or more onRead* methods being called on this thread.</span></span><br><span class="line">    reader!!.processNextFrame()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码很简单，一个<code>while</code>循环，循环条件是<code>receivedCloseCode == -1</code>的时候，做的事情是<code>reader!!.processNextFrame()</code>方法。继续：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//WebSocketWriter.kt</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">processNextFrame</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">//读取头部信息</span></span><br><span class="line">  readHeader()</span><br><span class="line">  <span class="keyword">if</span> (isControlFrame) &#123;</span><br><span class="line">    <span class="comment">//如果是控制帧，读取控制帧内容</span></span><br><span class="line">    readControlFrame()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//读取普通消息内容</span></span><br><span class="line">    readMessageFrame()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取头部信息</span></span><br><span class="line"><span class="meta">@Throws(IOException::class, ProtocolException::class)</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">readHeader</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (closed) <span class="keyword">throw</span> IOException(<span class="string">&quot;closed&quot;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">//读取数据，获取数据帧的前8位</span></span><br><span class="line">    b0 = source.readByte() and <span class="number">0xff</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    source.timeout().timeout(timeoutBefore, TimeUnit.NANOSECONDS)</span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="comment">//***</span></span><br><span class="line">  <span class="comment">//获取数据帧的opcode（数据格式）</span></span><br><span class="line">  opcode = b0 and B0_MASK_OPCODE</span><br><span class="line">  <span class="comment">//是否为最终帧</span></span><br><span class="line">  isFinalFrame = b0 and B0_FLAG_FIN != <span class="number">0</span></span><br><span class="line">  <span class="comment">//是否为控制帧（指令）</span></span><br><span class="line">  isControlFrame = b0 and OPCODE_FLAG_CONTROL != <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//判断最终帧，获取帧长度等等</span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取控制帧（指令）</span></span><br><span class="line">  <span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">readControlFrame</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (frameLength &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">    source.readFully(controlFrameBuffer, frameLength)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">when</span> (opcode) &#123;</span><br><span class="line">    OPCODE_CONTROL_PING -&gt; &#123;</span><br><span class="line">    <span class="comment">//ping 帧</span></span><br><span class="line">      frameCallback.onReadPing(controlFrameBuffer.readByteString())</span><br><span class="line">    &#125;</span><br><span class="line">    OPCODE_CONTROL_PONG -&gt; &#123;</span><br><span class="line">      <span class="comment">//pong 帧</span></span><br><span class="line">      frameCallback.onReadPong(controlFrameBuffer.readByteString())</span><br><span class="line">    &#125;</span><br><span class="line">    OPCODE_CONTROL_CLOSE -&gt; &#123;</span><br><span class="line">      <span class="comment">//关闭 帧</span></span><br><span class="line">      <span class="keyword">var</span> code = CLOSE_NO_STATUS_CODE</span><br><span class="line">      <span class="keyword">var</span> reason = <span class="string">&quot;&quot;</span></span><br><span class="line">      <span class="keyword">val</span> bufferSize = controlFrameBuffer.size</span><br><span class="line">      <span class="keyword">if</span> (bufferSize == <span class="number">1L</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ProtocolException(<span class="string">&quot;Malformed close payload length of 1.&quot;</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bufferSize != <span class="number">0L</span>) &#123;</span><br><span class="line">        code = controlFrameBuffer.readShort().toInt()</span><br><span class="line">        reason = controlFrameBuffer.readUtf8()</span><br><span class="line">        <span class="keyword">val</span> codeExceptionMessage = WebSocketProtocol.closeCodeExceptionMessage(code)</span><br><span class="line">        <span class="keyword">if</span> (codeExceptionMessage != <span class="literal">null</span>) <span class="keyword">throw</span> ProtocolException(codeExceptionMessage)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//回调onReadClose方法</span></span><br><span class="line">      frameCallback.onReadClose(code, reason)</span><br><span class="line">      closed = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取普通消息</span></span><br><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">readMessageFrame</span><span class="params">()</span></span> &#123;</span><br><span class="line">  </span><br><span class="line">  readMessage()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (readingCompressedMessage) &#123;</span><br><span class="line">    <span class="keyword">val</span> messageInflater = <span class="keyword">this</span>.messageInflater</span><br><span class="line">        ?: MessageInflater(noContextTakeover).also &#123; <span class="keyword">this</span>.messageInflater = it &#125;</span><br><span class="line">    messageInflater.inflate(messageFrameBuffer)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (opcode == OPCODE_TEXT) &#123;</span><br><span class="line">    frameCallback.onReadMessage(messageFrameBuffer.readUtf8())</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    frameCallback.onReadMessage(messageFrameBuffer.readByteString())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码还是比较直观，这个<code>processNextFrame</code>其实就是读取数据用的，首先读取头部信息，获取数据帧的类型，判断是否为控制帧，再分别去读取控制帧数据或者普通消息帧数据。</p><h4 id="3-2-2-数据帧格式"><a href="#3-2-2-数据帧格式" class="headerlink" title="3.2.2 数据帧格式"></a>3.2.2 数据帧格式</h4><p>问题来了，什么是<strong>数据头部信息</strong>，什么是<strong>控制帧</strong>？ 这里就要说下<code>WebSocket</code>的数据帧了，先附上一个数据帧格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> 0 1 2 3 4 5 6 7    0 1 2 3 4 5 6 7  0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7</span><br><span class="line">+-+-+-+-+-------+  +-+-------------+ +-----------------------------+</span><br><span class="line">|F|R|R|R| OP    |  |M| LENGTH      |   Extended payload length</span><br><span class="line">|I|S|S|S| CODE  |  |A|             |  （if LENGTH=126）</span><br><span class="line">|N|V|V|V|       |  |S|             |</span><br><span class="line">| |1|2|3|       |  |K|             |</span><br><span class="line">+-+-+-+-+-------+  +-+-------------+</span><br><span class="line">|                      Extended payload length（if LENGTH=127）</span><br><span class="line">+                                  +-------------------------------</span><br><span class="line">|      Extended payload length     | Masking-key，if Mask set to 1</span><br><span class="line">+----------------------------------+-------------------------------</span><br><span class="line">|   Masking-key                    |       Data</span><br><span class="line">+----------------------------------+-------------------------------</span><br><span class="line">|                                Data</span><br><span class="line">+----------------------------------+-------------------------------</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我承认，我懵逼了。 冷静冷静，一步一步分析下吧。</p><p>首先每一行代表4个字节，一共也就是32位数，哦，那也就是几个字节而已嘛，每个字节有他自己的代表意义呗，这样想是不是就很简单了，下面来具体看看每个字节。</p><p><strong>第1个字节：</strong></p><ul><li>第一位是<code>FIN码</code>，其实就是一个标示位，因为数据可能多帧操作嘛，所以多帧情况下，只有最后一帧的<code>FIN</code>设置成1，标示结束帧，前面所有帧设置为0。</li><li>第二位到第四位是<code>RSV码</code>，一般通信两端没有设置自定义协议，就默认为0。</li><li>后四位是<code>opcode</code>，我们叫它操作码。这个就是判断这个数据帧的类型了，一般有以下几个被定义好的类型：</li></ul><p>1） <code>0x0</code> 表示附加数据帧<br>2） <code>0x1</code> 表示文本数据帧<br>3） <code>0x2</code> 表示二进制数据帧<br>4） <code>0x3-7</code> 保留用于未来的非控制帧<br>5） <code>0x8</code> 表示连接关闭<br>6） <code>0x9</code> 表示ping<br>7） <code>0xA</code> 表示pong<br>8） <code>0xB-F</code> 保留用于未来的非控制帧</p><p>是不是发现了些什么，这不就对应了我们应用中的几种格式吗？<code>2和3</code>对应的是普通消息帧，包括了文本和二进制数据。<code>567</code>对应的就是控制帧格式，包括了<code>close，ping，pong</code>。</p><p><strong>第2个字节：</strong></p><ul><li>第一位是<code>Mask</code>掩码，其实就是标识数据是否加密混淆，1代表数据经过掩码的，0是没有经过掩码的，如果是1的话，后续就会有4个字节代表<code>掩码key</code>，也就是数据帧中<code>Masking-key</code>所处的位置。</li><li>后7位是<code>LENGTH</code>，用来标示数据长度。因为只有7位，所以最大只能储存1111111对应的十进制数<code>127长度</code>的数据，如果需要更大的数据，这个储存长度肯定就不够了。 <strong>所以规定来了</strong>，1) <code>小于126长度</code>则数据用这七位表示实际长度。2) 如果长度<code>设置为126</code>，也就是二进制1111110，就代表取<code>额外2个字节</code>表示数据长度，共是16位表示数据长度。3) 如果长度<code>设置为127</code>，也就是二进制1111111，就代表取<code>额外8个字节</code>，共是64位表示数据长度。</li></ul><blockquote><p>需要注意的是LENGHT的三种情况在一个数据帧里面只会出现一种情况，不共存，所以在图中是用<strong>if</strong>表示。同样的，Masking-key也是当Mask为1的时候才存在。</p></blockquote><p>所以也就有了数据帧里面的<code>Extended payload length（LENGTH=126）</code>所处的2个字节，以及<code>Extended payload length（LENGTH=127）</code>所处的8个字节。</p><p>最后的字节部分自然就是<code>掩码key</code>（Mask为1的时候才存在）和具体的<code>传输数据</code>了。<br>还是有点晕吧😷，来张图总结下： <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/13/173476f65b9b0001~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.image" alt="数据帧格式.jpeg"></p><p>好了，了解了<strong>数据帧格式</strong>后，我们再来读源码就清晰多了。 先看看怎么读的<code>头部信息</code>并解析的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取数据帧前8位数据</span></span><br><span class="line">b0 = source.readByte() and <span class="number">0xff</span></span><br><span class="line"><span class="comment">//获取数据帧的opcode（数据格式）</span></span><br><span class="line">opcode = b0 and B0_MASK_OPCODE（<span class="number">15</span>）</span><br><span class="line"><span class="comment">//是否为最终帧</span></span><br><span class="line">isFinalFrame = b0 and B0_FLAG_FIN（<span class="number">128</span>） != <span class="number">0</span></span><br><span class="line"><span class="comment">//是否为控制帧（指令）</span></span><br><span class="line">isControlFrame = b0 and OPCODE_FLAG_CONTROL（<span class="number">8</span>） != <span class="number">0</span>  </span><br></pre></td></tr></table></figure><ul><li>第一句获取头信息，<code>and</code>是按位与计算，<code>and 0xff</code>意思就是按位与11111111，所以头部信息其实就是取了数据帧的<code>前8位数据</code>，一个字节。</li><li>第二句获取<code>opcode</code>，<code>and 15</code>也就是按位与00001111，其实也就是取了后四位数据，刚好对应上<code>opcode</code>的位置，第一个字节的后四位。</li><li>第三句获取是否为<code>最终帧</code>，刚才数据帧格式中说过，第一位<code>FIN</code>标识了是否为最后一帧数据，1代表结束帧，所以这里<code>and 128</code>也就是按位与10000000，也就是取的第一位数。</li><li>第四句获取是否为控制帧，<code>and 8</code>也就是按位与00001000，取得是第五位，也就是<code>opcode</code>的第一位，这是什么意思呢？我们看看刚才的数据帧格式，发现从<code>0x8</code>开始就是所谓的控制帧了。<code>0x8</code>对应的二进制是1000，<code>0x7</code>对应的二进制是0111。发现了吧，如果为控制帧的时候，<code>opcode</code>第一位肯定是为1的，所以这里就判断的第五位。</li></ul><p>后面还有读取第二个字节的代码，大家可以自己沿着这个思路自己看看，包括了读取<code>MASK</code>，读取数据长度的三种长度等。</p><p>所以这个<code>processNextFrame</code>方法主要做了三件事：</p><ul><li><code>readHeader</code>方法中，判断了是否为控制帧，是否为<code>结束帧</code>，然后获取了<code>Mask</code>标识，帧长度等参数</li><li><code>readControlFrame</code>方法中，主要处理了该帧数据为<code>ping，pong，close</code>三种情况，并且在收到<code>close关闭帧</code>的情况下，回调了<code>onReadClose</code>方法，这个待会要细看下。</li><li><code>readMessageFrame</code>方法中，主要是读取了消息后，回调了onReadMessage方法。</li></ul><p>至此可以发现，其实<code>WebSocket</code>传输数据并不是一个简单的事，只是<code>OkHttp</code>都帮我们封装好了，我们只需要直接传输数据即可，感谢这些三方库为我们开发作出的贡献，不知道什么时候我也能做出点贡献呢🤔。</p><p>对了，刚才说回调也很重要，接着看看。<code>onReadClose</code>和<code>onReadMessage</code>回调到哪了呢？还记得上文初始化<code>WebSocketWriter</code>的时候设置了回调接口吗。所以就是回调给<code>RealWebSocket</code>了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RealWebSocket.kt</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onReadClose</span><span class="params">(code: <span class="type">Int</span>, reason: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">  require(code != -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> toClose: Streams? = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">var</span> readerToClose: WebSocketReader? = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">var</span> writerToClose: WebSocketWriter? = <span class="literal">null</span></span><br><span class="line">  synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">    check(receivedCloseCode == -<span class="number">1</span>) &#123; <span class="string">&quot;already closed&quot;</span> &#125;</span><br><span class="line">    receivedCloseCode = code</span><br><span class="line">    receivedCloseReason = reason </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    listener.onClosing(<span class="keyword">this</span>, code, reason)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (toClose != <span class="literal">null</span>) &#123;</span><br><span class="line">      listener.onClosed(<span class="keyword">this</span>, code, reason)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    toClose?.closeQuietly()</span><br><span class="line">    readerToClose?.closeQuietly()</span><br><span class="line">    writerToClose?.closeQuietly()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onReadMessage</span><span class="params">(text: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">  listener.onMessage(<span class="keyword">this</span>, text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onReadMessage</span><span class="params">(bytes: <span class="type">ByteString</span>)</span></span> &#123;</span><br><span class="line">  listener.onMessage(<span class="keyword">this</span>, bytes)</span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>onReadClose</code>回调方法里面有个关键的参数，<code>receivedCloseCode</code>。还记得这个参数吗？上文中解析消息的循环条件就是<code>receivedCloseCode == -1</code>，所以当收到关闭帧的时候，<code>receivedCloseCode</code>就不再等于-1（规定大于1000），也就不再去读取解析消息了。这样整个流程就结束了。</p><p>其中还有一些<code>WebSocketListener</code>的回调，比如<code>onClosing，onClosed，onMessage</code>等，就直接回调给用户使用了。至此，接收消息处理消息说完了。</p><h3 id="3-3-发消息"><a href="#3-3-发消息" class="headerlink" title="3.3 发消息"></a>3.3 发消息</h3><p>好了。接着说发送，看看<code>send</code>方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Synchronized</span> <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">send</span><span class="params">(<span class="keyword">data</span>: <span class="type">ByteString</span>, formatOpcode: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">  <span class="comment">// ***</span></span><br><span class="line">  <span class="comment">// Enqueue the message frame.</span></span><br><span class="line">  queueSize += <span class="keyword">data</span>.size.toLong()</span><br><span class="line">  messageAndCloseQueue.add(Message(formatOpcode, <span class="keyword">data</span>))</span><br><span class="line">  runWriter()</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先，把要发送的<code>data</code>封装成<code>Message</code>对象，然后入队列<code>messageAndCloseQueue</code>。最后执行<code>runWriter</code>方法。这都不用猜了，<code>runWriter</code>肯定就要开始发送消息了，继续看：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RealWebSocket.kt</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">runWriter</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.assertThreadHoldsLock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> writerTask = writerTask</span><br><span class="line">  <span class="keyword">if</span> (writerTask != <span class="literal">null</span>) &#123;</span><br><span class="line">    taskQueue.schedule(writerTask)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">WriterTask</span> : <span class="type">Task</span></span>(<span class="string">&quot;<span class="variable">$name</span> writer&quot;</span>) &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">runOnce</span><span class="params">()</span></span>: <span class="built_in">Long</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (writeOneFrame()) <span class="keyword">return</span> <span class="number">0L</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">      failWebSocket(e, <span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1L</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是schedule方法转到WriterTask的runOnce方法过程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//TaskQueue.kt</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">schedule</span><span class="params">(task: <span class="type">Task</span>, delayNanos: <span class="type">Long</span> = <span class="number">0</span>L)</span></span> &#123;</span><br><span class="line">  synchronized(taskRunner) &#123;</span><br><span class="line">    <span class="keyword">if</span> (scheduleAndDecide(task, delayNanos, recurrence = <span class="literal">false</span>)) &#123;</span><br><span class="line">      taskRunner.kickCoordinator(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">scheduleAndDecide</span><span class="params">(task: <span class="type">Task</span>, delayNanos: <span class="type">Long</span>, recurrence: <span class="type">Boolean</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">  <span class="comment">//***</span></span><br><span class="line">  <span class="keyword">if</span> (insertAt == -<span class="number">1</span>) insertAt = futureTasks.size</span><br><span class="line">  futureTasks.add(insertAt, task)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Impact the coordinator if we inserted at the front.</span></span><br><span class="line">  <span class="keyword">return</span> insertAt == <span class="number">0</span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//TaskRunner.kt</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">kickCoordinator</span><span class="params">(taskQueue: <span class="type">TaskQueue</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.assertThreadHoldsLock()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (taskQueue.activeTask == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (taskQueue.futureTasks.isNotEmpty()) &#123;</span><br><span class="line">      readyQueues.addIfAbsent(taskQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      readyQueues.remove(taskQueue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;    </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (coordinatorWaiting) &#123;</span><br><span class="line">    backend.coordinatorNotify(<span class="keyword">this</span><span class="symbol">@TaskRunner</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    backend.execute(runnable)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> runnable: Runnable = <span class="keyword">object</span> : Runnable &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">val</span> task = synchronized(<span class="keyword">this</span><span class="symbol">@TaskRunner</span>) &#123;</span><br><span class="line">        awaitTaskToRun()</span><br><span class="line">      &#125; ?: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">      logElapsed(task, task.queue!!) &#123;</span><br><span class="line">        <span class="keyword">var</span> completedNormally = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          runTask(task)</span><br><span class="line">          completedNormally = <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">// If the task is crashing start another thread to service the queues.</span></span><br><span class="line">          <span class="keyword">if</span> (!completedNormally) &#123;</span><br><span class="line">            backend.execute(<span class="keyword">this</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">runTask</span><span class="params">(task: <span class="type">Task</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    delayNanos = task.runOnce()</span><br><span class="line">  &#125; </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码有点长，这里是从<code>runWriter</code>开始跟的几个方法，拿到<code>writerTask</code>实例后，存到<code>TaskQueue</code>的<code>futureTasks列表</code>里，然后到<code>runnable</code>这里可以看到是一个<code>while</code>死循环，不断的从<code>futureTasks</code>中取出<code>Task</code>并执行<code>runTask</code>方法，直到<code>Task</code>为空，循环停止。</p><p>其中涉及到两个新的类：</p><ul><li><code>TaskQueue类</code>主要就是管理消息任务列表，保证按顺序执行</li><li><code>TaskRunner类</code>主要就是做一些任务的具体操作，比如线程池里执行任务，记录消息任务的状态（准备发送的任务队列<code>readyQueues</code>，正在执行的任务队列<code>busyQueues</code>等等）</li></ul><p>而每一个Task最后都是执行到了<code>WriterTask</code>的<code>runOnce</code>方法，也就是<code>writeOneFrame</code>方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">writeOneFrame</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">  synchronized(<span class="keyword">this</span><span class="symbol">@RealWebSocket</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (failed) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// Failed web socket.</span></span><br><span class="line">    &#125;</span><br><span class="line">    writer = <span class="keyword">this</span>.writer</span><br><span class="line">    pong = pongQueue.poll()</span><br><span class="line">    <span class="keyword">if</span> (pong == <span class="literal">null</span>) &#123;</span><br><span class="line">      messageOrClose = messageAndCloseQueue.poll()</span><br><span class="line">      <span class="keyword">if</span> (messageOrClose <span class="keyword">is</span> Close) &#123;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (messageOrClose == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// The queue is exhausted.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//发送消息逻辑，包括`pong`消息，普通消息，关闭消息</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pong != <span class="literal">null</span>) &#123;</span><br><span class="line">      writer!!.writePong(pong)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (messageOrClose <span class="keyword">is</span> Message) &#123;</span><br><span class="line">      <span class="keyword">val</span> message = messageOrClose <span class="keyword">as</span> Message</span><br><span class="line">      writer!!.writeMessageFrame(message.formatOpcode, message.<span class="keyword">data</span>)</span><br><span class="line">      synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">        queueSize -= message.<span class="keyword">data</span>.size.toLong()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (messageOrClose <span class="keyword">is</span> Close) &#123;</span><br><span class="line">      <span class="keyword">val</span> close = messageOrClose <span class="keyword">as</span> Close</span><br><span class="line">      writer!!.writeClose(close.code, close.reason)</span><br><span class="line">      <span class="comment">// We closed the writer: now both reader and writer are closed.</span></span><br><span class="line">      <span class="keyword">if</span> (streamsToClose != <span class="literal">null</span>) &#123;</span><br><span class="line">        listener.onClosed(<span class="keyword">this</span>, receivedCloseCode, receivedCloseReason!!)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    streamsToClose?.closeQuietly()</span><br><span class="line">    readerToClose?.closeQuietly()</span><br><span class="line">    writerToClose?.closeQuietly()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里就会执行发送消息的逻辑了，主要有三种消息情况处理：</p><ul><li><code>pong消息</code>，这个主要是为服务器端准备的，发送给客户端回应心跳包。</li><li><code>普通消息</code>，就会把数据类型<code>Opcode</code>和具体数据发送过去</li><li><code>关闭消息</code>，其实当用户执行<code>close</code>方法关闭<code>WebSocket</code>的时候，也是发送了一条<code>Close控制帧</code>消息给服务器告知这个关闭需求，并带上<code>code状态码</code>和<code>reason关闭原因</code>，然后服务器端就会关闭当前连接。</li></ul><p>好了。最后一步了，就是把这些数据组装成<code>WebSocket</code>数据帧并写入流，分成<code>控制帧</code>数据和<code>普通消息数据帧</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写入（发送）控制帧</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">writeControlFrame</span><span class="params">(opcode: <span class="type">Int</span>, payload: <span class="type">ByteString</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (writerClosed) <span class="keyword">throw</span> IOException(<span class="string">&quot;closed&quot;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">val</span> length = payload.size</span><br><span class="line">  require(length &lt;= PAYLOAD_BYTE_MAX) &#123;</span><br><span class="line">    <span class="string">&quot;Payload size must be less than or equal to <span class="variable">$PAYLOAD_BYTE_MAX</span>&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">val</span> b0 = B0_FLAG_FIN or opcode</span><br><span class="line">  sinkBuffer.writeByte(b0)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> b1 = length</span><br><span class="line">  <span class="keyword">if</span> (isClient) &#123;</span><br><span class="line">    b1 = b1 or B1_FLAG_MASK</span><br><span class="line">    sinkBuffer.writeByte(b1)</span><br><span class="line">    random.nextBytes(maskKey!!)</span><br><span class="line">    sinkBuffer.write(maskKey)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">val</span> payloadStart = sinkBuffer.size</span><br><span class="line">      sinkBuffer.write(payload)</span><br><span class="line">      sinkBuffer.readAndWriteUnsafe(maskCursor!!)</span><br><span class="line">      maskCursor.seek(payloadStart)</span><br><span class="line">      toggleMask(maskCursor, maskKey)</span><br><span class="line">      maskCursor.close()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sinkBuffer.writeByte(b1)</span><br><span class="line">    sinkBuffer.write(payload)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sink.flush()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//写入（发送）普通消息数据帧</span></span><br><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">writeMessageFrame</span><span class="params">(formatOpcode: <span class="type">Int</span>, <span class="keyword">data</span>: <span class="type">ByteString</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (writerClosed) <span class="keyword">throw</span> IOException(<span class="string">&quot;closed&quot;</span>)</span><br><span class="line"></span><br><span class="line">  messageBuffer.write(<span class="keyword">data</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> b0 = formatOpcode or B0_FLAG_FIN</span><br><span class="line">  <span class="keyword">val</span> dataSize = messageBuffer.size</span><br><span class="line">  sinkBuffer.writeByte(b0)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> b1 = <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> (isClient) &#123;</span><br><span class="line">    b1 = b1 or B1_FLAG_MASK</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">when</span> &#123;</span><br><span class="line">    dataSize &lt;= PAYLOAD_BYTE_MAX -&gt; &#123;</span><br><span class="line">      b1 = b1 or dataSize.toInt()</span><br><span class="line">      sinkBuffer.writeByte(b1)</span><br><span class="line">    &#125;</span><br><span class="line">    dataSize &lt;= PAYLOAD_SHORT_MAX -&gt; &#123;</span><br><span class="line">      b1 = b1 or PAYLOAD_SHORT</span><br><span class="line">      sinkBuffer.writeByte(b1)</span><br><span class="line">      sinkBuffer.writeShort(dataSize.toInt())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">      b1 = b1 or PAYLOAD_LONG</span><br><span class="line">      sinkBuffer.writeByte(b1)</span><br><span class="line">      sinkBuffer.writeLong(dataSize)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isClient) &#123;</span><br><span class="line">    random.nextBytes(maskKey!!)</span><br><span class="line">    sinkBuffer.write(maskKey)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dataSize &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">      messageBuffer.readAndWriteUnsafe(maskCursor!!)</span><br><span class="line">      maskCursor.seek(<span class="number">0L</span>)</span><br><span class="line">      toggleMask(maskCursor, maskKey)</span><br><span class="line">      maskCursor.close()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sinkBuffer.write(messageBuffer, dataSize)</span><br><span class="line">  sink.emit()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>大家应该都能看懂了吧，其实就是组装数据帧，包括<code>Opcode，mask，数据长度</code>等等。两个方法的不同就在于普通数据需要判断数据长度的三种情况，再组装数据帧。最后都会通过<code>sinkBuffer</code>写入到输出数据流。</p><p>终于，基本的流程说的差不多了。其中还有很多细节，同学们可以自己花时间看看琢磨琢磨，比如<code>Okio</code>部分。还是那句话，希望大家有空自己也读一读相关源码，这样理解才能深刻，而且你肯定会发现很多我没说到的细节，欢迎大家讨论。我也会继续努力，最后大家给我加个油点个赞吧，感谢感谢。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/13/173476f65e6e3ed4~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.image" alt="OkHttp-WebSocket源码.jpg"></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/05/13/HTTPS-%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/05/13/HTTPS-%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">HTTPS 学习整理</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-05-13 08:23:15" itemprop="dateCreated datePublished" datetime="2022-05-13T08:23:15+08:00">2022-05-13</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-11-20 12:38:56" itemprop="dateModified" datetime="2022-11-20T12:38:56+08:00">2022-11-20</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="HTTPS-学习整理"><a href="#HTTPS-学习整理" class="headerlink" title="HTTPS 学习整理"></a>HTTPS 学习整理</h2><h3 id="1-HTTPS-连接及握手过程"><a href="#1-HTTPS-连接及握手过程" class="headerlink" title="1.HTTPS 连接及握手过程"></a>1.HTTPS 连接及握手过程</h3><p><strong>第一步</strong>，客户端发送给服务器Client Hello，叫做Client Hello 其实是一个一字节的数据</p><p><img src="/../images/image-20220513082622256.png" alt="image-20220513082622256"></p><p>发送Client Hello 还会附加一些信息</p><ol><li>可选的TLS版本</li><li>可选的加密套件<ul><li>可选的对称加密算法</li><li>可选的非对称加密算法</li><li>可选的hash算法</li></ul></li><li>客户端随机数（这个随机数随后会用到，等于是第一个随机数客户端和服务器都会使用到）</li></ol><p><img src="/../images/image-20220513082816474.png" alt="image-20220513082816474"></p><p><strong>第二步</strong>，服务端返回Server Hello 也是一个单字节数据，并把Client Hello 附加信息的确认值返回给客户端，同时生成服务端的随机数，返回给客户端</p><p><img src="/../images/image-20220513083321789.png" alt="image-20220513083321789"></p><p><strong>第三步</strong>，服务端下发证书，然后客户端这里会做证书的较验，这里的过程比较麻烦和复杂</p><p><img src="/../images/image-20220513083443606.png" alt="image-20220513083443606"></p><p>如图所示，证书中包含</p><ul><li>服务器公钥</li><li>服务器主机名</li><li>服务器公钥的签名</li><li>证书签发机构的公钥</li><li>证书签发机构的公角的签名</li><li>….</li></ul><p>较验的顺序也是如此，链式去使用签名去较验公钥是否准确，防止公钥被修改，一层层直到找到根证书，根证书一般都安装在pc或者手机里，然后逐层去较验公钥的正确性，最后证明服务器的公钥确实是真的，而不是假的</p><p><img src="/../images/image-20220513134035609.png" alt="image-20220513134035609"></p><p>如图所示，访问hencoder.com 然后证书链中的三级证书，客户端验证服务器证书的真实性，还通过主机名确认对方的身份，确实是我要访问的服务器，而不是其他在ca公签的服务器</p><p><img src="/../images/image-20220513134238446.png" alt="image-20220513134238446"></p><p><strong>第四步</strong>，客户端拿到服务器公钥后，和服务器一起通过公钥生成加密的Pre-master secret ，双方就公同持有了三个东西</p><ul><li>客户端随机数</li><li>服务器随机数</li><li>Pre-master secret</li></ul><p>通过这三个东西会各自独立的生成master secret 所以注意啦，<strong>最终的对称密钥并不是客户端生成后发给服务器的，而是由前面交互的随机数，及加密后的公钥独立生成的</strong></p><p><img src="/../images/image-20220513134634905.png" alt="image-20220513134634905"></p><p><strong>而且，生成的对称加密的密钥并不是简单的一个密码</strong></p><p><img src="/../images/image-20220513134726832.png" alt="image-20220513134726832"></p><p>那么有人可能会有疑问，为什么要很麻烦的生成客户端的加密密钥，服务端的加密密钥？用一个不行么？</p><p><img src="/../images/image-20220513134838968.png" alt="image-20220513134838968"></p><p><strong>第五步，客户端告诉服务器，我将使用加密通信，还有把前面几步合一起加密发给服务器，生送Finished 同样服务器也返回客户端：将使用加密通信，同时Finished握手</strong></p><p><img src="/../images/image-20220513135059793.png" alt="image-20220513135059793"></p><p>服务端返回</p><p><img src="/../images/image-20220513135117684.png" alt="image-20220513135117684"></p><p><img src="/../images/image-20220513135132604.png" alt="image-20220513135132604"></p><h3 id="2-在Android中合理使用HTTPS"><a href="#2-在Android中合理使用HTTPS" class="headerlink" title="2.在Android中合理使用HTTPS"></a>2.在Android中合理使用HTTPS</h3><p>CA公签的就不讨论了，使用很方便，根据所使用的网络框架，可以自行百度，非常简单方便。这里说下如何较验主机名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create an HostnameVerifier that hardwires the expected hostname.</span></span><br><span class="line"><span class="comment">// Note that is different than the URL&#x27;s hostname:</span></span><br><span class="line"><span class="comment">// example.com versus example.org</span></span><br><span class="line">HostnameVerifier hostnameVerifier = <span class="keyword">new</span> HostnameVerifier() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String hostname, SSLSession session)</span> </span>&#123;</span><br><span class="line">        HostnameVerifier hv =</span><br><span class="line">            HttpsURLConnection.getDefaultHostnameVerifier();</span><br><span class="line">        <span class="keyword">return</span> hv.verify(<span class="string">&quot;example.com&quot;</span>, session);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell the URLConnection to use our HostnameVerifier</span></span><br><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">&quot;https://example.org/&quot;</span>);</span><br><span class="line">HttpsURLConnection urlConnection =</span><br><span class="line">    (HttpsURLConnection)url.openConnection();</span><br><span class="line">urlConnection.setHostnameVerifier(hostnameVerifier);</span><br><span class="line">InputStream in = urlConnection.getInputStream();</span><br><span class="line">copyInputStreamToOutputStream(in, System.out);</span><br></pre></td></tr></table></figure><p>还有一种情况，有一些公司使用自签名证书，或者非知名机构颁发的证书，如果不做处理，会报https的网络异常，那么这时候上网上查的话，很多都是告诉不做较验，放开所有的证书，当然这样可以走的通，但是同时也失去了使用HTTPS的作用，是不认真负责的。</p><p>我们看官网上对这一过程的描述，之所以之前我们记不住，也是因为我们对HTTPS的握手和证书较验过程不够理解，现在看这段话</p><blockquote><p>在这种情况下，由于您的 CA 不受系统信任，将发生 SSLHandshakeException。原因可能是您有一个由 Android 尚不信任的新 CA 颁发的证书，或您的应用在没有 CA 的较旧版本上运行。CA 未知的原因通常是因为它不是公共 CA，而是由政府、公司或教育机构等组织颁发的仅供其自己使用的私有 CA。</p><p>幸运的是，您可以指示 HttpsURLConnection 信任特定的 CA 集。这个过程可能有点复杂，下面的示例展示了这个过程：从 InputStream 获取一个特定的 CA，用该 CA 创建 KeyStore，然后用后者创建和初始化 TrustManager。TrustManager 是系统用于验证来自服务器的证书的工具，可以通过包含一个或多个 CA 的 KeyStore 创建，而创建的 TrustManager 将仅信任这些 CA。</p><p>由于 TrustManager 是新建的，此示例将启动一个新的 SSLContext，它会提供一个 SSLSocketFactory，可用于替换来自 HttpsURLConnection 的默认 SSLSocketFactory。这样一来，连接将使用您的 CA 来验证证书。</p></blockquote><p>这下你知道，为啥Android客户会有一个证书文件了吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">// Load CAs from an InputStream</span></span><br><span class="line"><span class="comment">// (could be from a resource or ByteArrayInputStream or ...)</span></span><br><span class="line">CertificateFactory cf = CertificateFactory.getInstance(<span class="string">&quot;X.509&quot;</span>);</span><br><span class="line"><span class="comment">// From https://www.washington.edu/itconnect/security/ca/load-der.crt</span></span><br><span class="line">InputStream caInput = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;load-der.crt&quot;</span>));</span><br><span class="line">Certificate ca;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ca = cf.generateCertificate(caInput);</span><br><span class="line">    System.out.println(<span class="string">&quot;ca=&quot;</span> + ((X509Certificate) ca).getSubjectDN());</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    caInput.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a KeyStore containing our trusted CAs</span></span><br><span class="line">String keyStoreType = KeyStore.getDefaultType();</span><br><span class="line">KeyStore keyStore = KeyStore.getInstance(keyStoreType);</span><br><span class="line">keyStore.load(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">keyStore.setCertificateEntry(<span class="string">&quot;ca&quot;</span>, ca);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a TrustManager that trusts the CAs in our KeyStore</span></span><br><span class="line">String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();</span><br><span class="line">TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);</span><br><span class="line">tmf.init(keyStore);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create an SSLContext that uses our TrustManager</span></span><br><span class="line">SSLContext context = SSLContext.getInstance(<span class="string">&quot;TLS&quot;</span>);</span><br><span class="line">context.init(<span class="keyword">null</span>, tmf.getTrustManagers(), <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell the URLConnection to use a SocketFactory from our SSLContext</span></span><br><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">&quot;https://certs.cac.washington.edu/CAtest/&quot;</span>);</span><br><span class="line">HttpsURLConnection urlConnection =</span><br><span class="line">    (HttpsURLConnection)url.openConnection();</span><br><span class="line">urlConnection.setSSLSocketFactory(context.getSocketFactory());</span><br><span class="line">InputStream in = urlConnection.getInputStream();</span><br><span class="line">copyInputStreamToOutputStream(in, System.out);</span><br></pre></td></tr></table></figure><p>这个SSLContext很关键，由得到的SSLContextFactory是我们很多网络框架可以进行替换和设置，这样就可以通过自签名的ca集来检验较验证书的合法性了。</p><p>之所以说SSLContext很关键，因为不光HTTP可以使用SSL较验，很多上层加密都使用了SSL层的加密特性，比如我们可能会遇到的WSS Websocket的加密协议，怎么处理，一样的道理。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/05/08/Jetpack%E7%B3%BB%E5%88%97%E2%80%94%E5%BA%95%E9%83%A8%E5%AF%BC%E8%88%AA%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/05/08/Jetpack%E7%B3%BB%E5%88%97%E2%80%94%E5%BA%95%E9%83%A8%E5%AF%BC%E8%88%AA%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Jetpack系列—底部导航路由BottomNavigationView原理</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-05-08 06:35:47" itemprop="dateCreated datePublished" datetime="2022-05-08T06:35:47+08:00">2022-05-08</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-11-20 12:38:57" itemprop="dateModified" datetime="2022-11-20T12:38:57+08:00">2022-11-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Jetpack%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Jetpack系列</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>主要介绍BottomNavigationView及其实现原理</p><div class="post-button"><a class="btn" href="/2022/05/08/Jetpack%E7%B3%BB%E5%88%97%E2%80%94%E5%BA%95%E9%83%A8%E5%AF%BC%E8%88%AA%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><nav class="pagination"><a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a></nav></div><script>window.addEventListener("tabs:register",()=>{let e=CONFIG.comments["activeClass"];if(CONFIG.comments.storage&&(e=localStorage.getItem("comments_active")||e),e){let t=document.querySelector(`a[href="#comment-${e}"]`);t&&t.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">张龙</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">47</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">11</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">2</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">张龙</span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script></body></html>