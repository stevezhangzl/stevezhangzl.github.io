<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"example.com",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta property="og:type" content="website"><meta property="og:title" content="SteveZhang博客"><meta property="og:url" content="http://example.com/page/2/index.html"><meta property="og:site_name" content="SteveZhang博客"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="张龙"><meta name="twitter:card" content="summary"><link rel="canonical" href="http://example.com/page/2/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!0,isPost:!1,lang:"zh-CN"}</script><title>SteveZhang博客</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="SteveZhang博客" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">SteveZhang博客</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">52</span></a></li></ul></nav></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content index posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/10/24/%E6%B0%94%E8%B1%A1%E6%95%B0%E6%8D%AE-%E7%AC%AC2%E7%AB%A0%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E6%B0%B8%E4%B8%8D%E5%81%9C%E6%9C%BA-6-Linux%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/10/24/%E6%B0%94%E8%B1%A1%E6%95%B0%E6%8D%AE-%E7%AC%AC2%E7%AB%A0%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E6%B0%B8%E4%B8%8D%E5%81%9C%E6%9C%BA-6-Linux%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/" class="post-title-link" itemprop="url">气象数据-第2章如何保证服务程序永不停机-6-Linux共享内存</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-10-24 08:27:43" itemprop="dateCreated datePublished" datetime="2022-10-24T08:27:43+08:00">2022-10-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-11-29 15:26:42" itemprop="dateModified" datetime="2022-11-29T15:26:42+08:00">2022-11-29</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C%E6%B0%94%E8%B1%A1%E6%95%B0%E6%8D%AE%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">C气象数据项目</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Linux中每个进程是互相独立的，互相不能访问，共享内存允许多个进程访问同一块内存，是进程之间共享和传递数据最高效的方式，没有之一。</p><h2 id="共享内存的操作"><a href="#共享内存的操作" class="headerlink" title="共享内存的操作"></a>共享内存的操作</h2><ul><li>1.调用shm<strong>get</strong>函数获取或创建共享内存。（也就是说共享内存如果不存在，就创建它，如果已经存在就获取它）</li><li>2.调用shm<strong>at</strong>函数把共享内存连接到当前进程的地址空间。</li><li>3.调用shm<strong>dt</strong>函数把共享内存从当前进程中分离。（比如进程要退出了）</li><li>4.调用shm<strong>ctl</strong>函数删除共享内存。（一般共享内存创建了，一般不删除，除非整个项目服务程序都要停止运行）</li></ul><h3 id="shmget"><a href="#shmget" class="headerlink" title="shmget"></a>shmget</h3><p><code>int shmget(key_t key, size_t size, int shmflg) 获取或者创建共享内存的函数</code></p><ul><li>key：在进程通信中不管是消息队列，共享内存还是信号量，每个对象都有一个key，不同的进程通过key来识别不同的对象，key是一个整数</li><li>size：第2个参数是共享内存的大小</li><li>shmflg：第3个参数是共享内存的标志，操作权限，如0640|IPC_CREAT 前面是操作权限，和文件的操作权限一样，后面的标志位表示，如果共享内存不存在就创建它，后面基本没选择，前面的看项目需要。</li><li>get函数成功返回共享内存的id，失败返回-1</li></ul><p>book.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//shmget函数需要头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st_pid</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> pid;<span class="comment">//进程编号</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">51</span>]; <span class="comment">//进程名称</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">	<span class="comment">//共享内存的标志。</span></span><br><span class="line">	<span class="keyword">int</span> shmid;	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((shmid = <span class="built_in">shmget</span>(<span class="number">0x5005</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(struct st_pid),<span class="number">0640</span>|IPC_CREAT)) == <span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;错误提示&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过<code>ipcs -m</code> 命令查询我们创建的共享内存</p><p><img src="/../images/image-20221031082632099.png" alt="image-20221031082632099"></p><p>shmid就是创建的共享内存的id 权限也是我们指定的640</p><p>通过<code>ipcrm -m &lt;shmid&gt;</code> 可以删除我们创建的共享内存</p><p><img src="/../images/image-20221031082740863.png" alt="image-20221031082740863"></p><p>已经没有了</p><h3 id="shmat"><a href="#shmat" class="headerlink" title="shmat"></a>shmat</h3><p><code>void *shmat(int shmid, const void *shmaddr, int shmflg)</code></p><p>at就是把共享内存连接到当前进程的地址空间，dt就是分离出去</p><ul><li>第2，3个参数都填0就行</li><li>返回的是共享内存的地址，我们可以通过地址操作共享内存，很方便</li></ul><p>在程序中我们用一个指针指向共享内存的地址，就像操作本地的变量，非常方便</p><h3 id="shmdt"><a href="#shmdt" class="headerlink" title="shmdt"></a>shmdt</h3><p><code>int shmdt(const void *shmaddr)</code></p><ul><li>参数就是共享内存的地址</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st_pid</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> pid;<span class="comment">//进程编号</span></span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">51</span>]; <span class="comment">//进程名称</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">        <span class="comment">//共享内存的标志。</span></span><br><span class="line">        <span class="keyword">int</span> shmid;</span><br><span class="line"></span><br><span class="line">  			<span class="comment">//获取或者创建共享内存，键值为0x5005</span></span><br><span class="line">        <span class="keyword">if</span>((shmid = <span class="built_in">shmget</span>(<span class="number">0x5005</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(struct st_pid),<span class="number">0640</span>|IPC_CREAT)) == <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;错误提示&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  			<span class="comment">//用于指向共享内存的结构体变量</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">st_pid</span> *<span class="title">stpid</span> =</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  			<span class="comment">//把共享内存连接到当前进程的地址空间</span></span><br><span class="line">        <span class="keyword">if</span>((stpid =(struct st_pid *)<span class="built_in">shmat</span>(shmid,<span class="number">0</span>,<span class="number">0</span>)) == (<span class="keyword">void</span> *)<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;shmat 0x5005 failed\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pid=%d,name=%s\n&quot;</span>,stpid-&gt;pid,stpid-&gt;name);</span><br><span class="line">        stpid-&gt;pid = <span class="built_in">getpid</span>();</span><br><span class="line">        <span class="built_in">strcpy</span>(stpid-&gt;name,argv[<span class="number">1</span>]);</span><br><span class="line">  </span><br><span class="line"> 				<span class="comment">//把共享内存从当前进程中分离</span></span><br><span class="line">        <span class="built_in">shmdt</span>(stpid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221104095908907.png" alt="image-20221104095908907"></p><p>不同的进程分别执行.&#x2F;book aaa .&#x2F;book bbb .&#x2F;book ccccc</p><p>不同的进程把自己进程的内容写进了共享内存中，共享内存中的值会不断的变化</p><h3 id="shmctl"><a href="#shmctl" class="headerlink" title="shmctl"></a>shmctl</h3><p>删除或者操作共享内存</p><p><code>int shmctl(int shmid, int cmd, struct shmid_ds *buf)</code></p><ul><li>第一个参数是共享内存的id</li><li>第二个参数是命令，我们一般只用它来删除，所以传IPC_RMID</li><li>第三个参数是结构体，我们删除时传0</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st_pid</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> pid;<span class="comment">//进程编号</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">51</span>]; <span class="comment">//进程名称</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">	<span class="comment">//共享内存的标志。</span></span><br><span class="line">	<span class="keyword">int</span> shmid;	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((shmid = <span class="built_in">shmget</span>(<span class="number">0x5005</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(struct st_pid),<span class="number">0640</span>|IPC_CREAT)) == <span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;错误提示&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">st_pid</span> *<span class="title">stpid</span> =</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((stpid =(struct st_pid *)<span class="built_in">shmat</span>(shmid,<span class="number">0</span>,<span class="number">0</span>)) == (<span class="keyword">void</span> *)<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;shmat 0x5005 failed\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;pid=%d,name=%s\n&quot;</span>,stpid-&gt;pid,stpid-&gt;name);</span><br><span class="line">	stpid-&gt;pid = <span class="built_in">getpid</span>();</span><br><span class="line">	<span class="built_in">strcpy</span>(stpid-&gt;name,argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;pid=%d,name=%s\n&quot;</span>,stpid-&gt;pid,stpid-&gt;name);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">shmdt</span>(stpid);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">shmctl</span>(shmid,IPC_RMID,<span class="number">0</span>) == <span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;shmctl failed\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行.&#x2F;book aaaa</p><p>再用ipcs -m 查看共享内存情况，发现已经删除成功了</p><p><img src="/../images/image-20221104100607131.png" alt="image-20221104100607131"></p><p>如图，已经没有我们创建的共享内存了。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/10/22/%E7%94%B1undefined-reference-to-gxx-personality-v0%E9%94%99%E8%AF%AF%E7%9C%8B%E4%B8%8Bg-%E5%92%8Cgcc%E7%9A%84%E5%8C%BA%E5%88%AB/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/10/22/%E7%94%B1undefined-reference-to-gxx-personality-v0%E9%94%99%E8%AF%AF%E7%9C%8B%E4%B8%8Bg-%E5%92%8Cgcc%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">由undefined reference to __gxx_personality_v0错误，看下g++和gcc的区别</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-10-22 04:56:13" itemprop="dateCreated datePublished" datetime="2022-10-22T04:56:13+08:00">2022-10-22</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-11-29 15:26:42" itemprop="dateModified" datetime="2022-11-29T15:26:42+08:00">2022-11-29</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="一个编译例子"><a href="#一个编译例子" class="headerlink" title="一个编译例子"></a>一个编译例子</h2><p>之前编译一个cpp文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> *pargv[argc];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> ii =<span class="number">2</span>;ii&lt;argc;ii++)&#123;</span><br><span class="line">		pargv[ii <span class="number">-2</span>] = argv[ii];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pargv[argc<span class="number">-2</span>] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">execv</span>(argv[<span class="number">2</span>],pargv);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">int</span> status;</span><br><span class="line">			<span class="built_in">wait</span>(&amp;status);</span><br><span class="line">			<span class="built_in">sleep</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));</span><br><span class="line">		&#125;	</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用指令进行编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o procctl procctl.cpp</span><br></pre></td></tr></table></figure><p>然后报错了</p><p><img src="/../images/image-20221022050317567.png" alt="image-20221022050317567"></p><p>没有去链接c++的标准库，我们使用gcc编译就要加上<code>-lstdc++</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o procctl procctl.cpp -lstdc++</span><br></pre></td></tr></table></figure><p>这样才会去链接c++的标准库，可以编译成功</p><p>实际上使用g++编译就不会有问题了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o procctl procctl.cpp</span><br></pre></td></tr></table></figure><p>也是可以编译的</p><h2 id="g-和gcc的区别"><a href="#g-和gcc的区别" class="headerlink" title="g++和gcc的区别"></a>g++和gcc的区别</h2><p>gcc 最开始的时候是 GNU C Compiler, 如你所知，就是一个c编译器。但是后来因为这个项目里边集成了更多其他不同语言的编译器，GCC就代表 the GNU Compiler Collection，所以表示一堆编译器的合集。 g++则是GCC的c++编译器。</p><p>gcc 和 g++ 的区别无非就是调用的编译器不同, 并且传递给链接器的参数不同.</p><p>具体而言</p><p><strong>g++</strong> 会把 <code>.c</code> 文件当做是 C++ 语言 (在 <code>.c</code> 文件前后分别加上 <code>-xc++</code> 和 <code>-xnone</code>, 强行变成 C++), 从而调用 <code>cc1plus</code> 进行编译.</p><p><strong>g++</strong> 遇到 <code>.cpp</code> 文件也会当做是 C++, 调用 <code>cc1plus</code> 进行编译.</p><p><strong>g++</strong> 还会默认告诉链接器, 让它链接上 C++ 标准库.</p><p><strong>gcc</strong> 会把 <code>.c</code> 文件当做是 C 语言. 从而调用 <code>cc1</code> 进行编译.</p><p><strong>gcc</strong> 遇到 <code>.cpp</code> 文件, 会处理成 C++ 语言. 调用 <code>cc1plus</code> 进行编译.</p><p><strong>gcc</strong> 默认不会链接上 C++ 标准库.</p><p>我们编译c的时候最好使用gcc 编译c++的时候最好使用g++能避免麻烦</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/10/19/%E6%B0%94%E8%B1%A1%E6%95%B0%E6%8D%AE-%E7%AC%AC2%E7%AB%A0%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E6%B0%B8%E4%B8%8D%E5%81%9C%E6%9C%BA-5-%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E8%B0%83%E5%BA%A6/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/10/19/%E6%B0%94%E8%B1%A1%E6%95%B0%E6%8D%AE-%E7%AC%AC2%E7%AB%A0%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E6%B0%B8%E4%B8%8D%E5%81%9C%E6%9C%BA-5-%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E8%B0%83%E5%BA%A6/" class="post-title-link" itemprop="url">气象数据-第2章如何保证服务程序永不停机-5-服务程序调度</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-10-19 07:37:40" itemprop="dateCreated datePublished" datetime="2022-10-19T07:37:40+08:00">2022-10-19</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-11-29 15:26:42" itemprop="dateModified" datetime="2022-11-29T15:26:42+08:00">2022-11-29</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C%E6%B0%94%E8%B1%A1%E6%95%B0%E6%8D%AE%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">C气象数据项目</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="服务程序的调度"><a href="#服务程序的调度" class="headerlink" title="服务程序的调度"></a>服务程序的调度</h2><ul><li>周期性的启动后台服务程序。</li><li>常驻内存中的服务程序异常中止，在短时间内重启。</li></ul><p>execl函数，执行ls命令</p><p>procctl.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">execl</span>(<span class="string">&quot;/usr/bin/ls&quot;</span>,<span class="string">&quot;/usr/bin/ls&quot;</span>,<span class="string">&quot;-lt&quot;</span>,<span class="string">&quot;./&quot;</span>,(<span class="keyword">char</span>*)<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第一个参数，传入执行程序全路径</li><li>第二个参数，伟入执行程序（可不传全路径）</li><li>第三个参数后开始传入执行程序的可变参数</li><li>。。。</li><li>最后一个参数传入(char*)0</li></ul><p>我们再来看</p><p>procctl1.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;aaa\n&quot;</span>);</span><br><span class="line">	<span class="built_in">execl</span>(<span class="string">&quot;/usr/bin/ls&quot;</span>,<span class="string">&quot;/usr/bin/ls&quot;</span>,<span class="string">&quot;-lt&quot;</span>,<span class="string">&quot;./&quot;</span>,(<span class="keyword">char</span>*)<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;bbb\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221020080146799.png" alt="image-20221020080146799"></p><p>发现只打印了aaa ，没有打印bbb</p><blockquote><p>exec是用参数中指定程序替换了当前进程的正文段、数据段、堆和栈。</p></blockquote><p>调用execl 使用ls的影像替换了当前进程，当前进程已经不存在了，所以后面bbb的代码都不会执行，写再多也没用。如果调用失败，后面的代码还是会执行的。</p><blockquote><p>解决方案</p><p>先执行fork函数，创建一个子进程，让子进程调用execl执行新的程序。</p><p>新程序将替换子进程，不会影响父进程。</p><p>在父进程中，可以调用wait函数等待新程序运行的结果，这样就可以实现调度的功能。</p></blockquote><p>实现程序每隔5秒执行一次ls</p><p>procctl2.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">execl</span>(<span class="string">&quot;/usr/bin/ls&quot;</span>,<span class="string">&quot;/usr/bin/ls&quot;</span>,<span class="string">&quot;-lt&quot;</span>,<span class="string">&quot;./&quot;</span>,(<span class="keyword">char</span>*)<span class="number">0</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">int</span> status;</span><br><span class="line">			<span class="built_in">wait</span>(&amp;status);</span><br><span class="line">			<span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">		&#125;	</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把程序按传参的形式补全</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//execl(&quot;/usr/bin/ls&quot;,&quot;/usr/bin/ls&quot;,&quot;-lt&quot;,&quot;./&quot;,(char*)0);</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(argc == <span class="number">3</span>) <span class="built_in">execl</span>(argv[<span class="number">2</span>],argv[<span class="number">2</span>],(<span class="keyword">char</span>*)<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span>(argc == <span class="number">4</span>) <span class="built_in">execl</span>(argv[<span class="number">2</span>],argv[<span class="number">2</span>],argv[<span class="number">3</span>],(<span class="keyword">char</span>*)<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span>(argc == <span class="number">5</span>) <span class="built_in">execl</span>(argv[<span class="number">2</span>],argv[<span class="number">2</span>],argv[<span class="number">3</span>],argv[<span class="number">4</span>],(<span class="keyword">char</span>*)<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span>(argc == <span class="number">6</span>) <span class="built_in">execl</span>(argv[<span class="number">2</span>],argv[<span class="number">2</span>],argv[<span class="number">3</span>],argv[<span class="number">4</span>],argv[<span class="number">5</span>],(<span class="keyword">char</span>*)<span class="number">0</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">int</span> status;</span><br><span class="line">			<span class="built_in">wait</span>(&amp;status);</span><br><span class="line">			<span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">		&#125;	</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会发现，我们要不停的判断参数的个数，来补全execl函数，好麻烦，一般要提前判断20个参数左右才行。为了支持参数不确定的情况，我们使用exec家族另一个函数比较合适。</p><ul><li>execv</li></ul><p>procctl3.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭信号和IO，本程序不希望被打扰。</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> ii = <span class="number">0</span>;ii&lt;<span class="number">64</span>;ii++)&#123;</span><br><span class="line">		<span class="built_in">signal</span>(ii,SIG_IGN);<span class="built_in">close</span>(ii);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//生成子进程，父进程退出，让程序运行在后台，由系统1号进程托管</span></span><br><span class="line">	<span class="keyword">if</span>(fork()!=<span class="number">0</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//启用SIGCHILD信号，让父进程可以wait子进程的退出的状态。</span></span><br><span class="line">	<span class="built_in">signal</span>(SIGCHLD,SIG_DFL);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//1.声明一个长度为argc的字符数组</span></span><br><span class="line">	<span class="keyword">char</span> *pargv[argc];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> ii =<span class="number">2</span>;ii&lt;argc;ii++)&#123;</span><br><span class="line">    <span class="comment">//2.把从命令开始的参数，赋值给pargv</span></span><br><span class="line">    <span class="comment">//argv[0]是procctl argv[1]是执行次数 argv[2] 才是/usr/bin/ls</span></span><br><span class="line">		pargv[ii <span class="number">-2</span>] = argv[ii];</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">//3.设置指令结尾为NULL</span></span><br><span class="line">	pargv[argc<span class="number">-2</span>] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">//4.第一人参数为指令，第二个参数为可变参数</span></span><br><span class="line">			<span class="built_in">execv</span>(argv[<span class="number">2</span>],pargv);</span><br><span class="line">			<span class="comment">//这行代码在execv成功的时候不会执行，在execv失败的时候会退。</span></span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">int</span> status;</span><br><span class="line">			<span class="built_in">wait</span>(&amp;status);</span><br><span class="line">			<span class="built_in">sleep</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));</span><br><span class="line">		&#125;	</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/10/13/%E6%B0%94%E8%B1%A1%E6%95%B0%E6%8D%AE%E9%A1%B9%E7%9B%AE-%E7%AC%AC2%E7%AB%A0%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E6%B0%B8%E4%B8%8D%E5%81%9C%E6%9C%BA-4-Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/10/13/%E6%B0%94%E8%B1%A1%E6%95%B0%E6%8D%AE%E9%A1%B9%E7%9B%AE-%E7%AC%AC2%E7%AB%A0%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E6%B0%B8%E4%B8%8D%E5%81%9C%E6%9C%BA-4-Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/" class="post-title-link" itemprop="url">气象数据-第2章如何保证服务程序永不停机-4-Linux多进程</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-10-13 07:27:53" itemprop="dateCreated datePublished" datetime="2022-10-13T07:27:53+08:00">2022-10-13</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-11-29 15:26:42" itemprop="dateModified" datetime="2022-11-29T15:26:42+08:00">2022-11-29</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C%E6%B0%94%E8%B1%A1%E6%95%B0%E6%8D%AE%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">C气象数据项目</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="Linux的0、1、2号进程"><a href="#Linux的0、1、2号进程" class="headerlink" title="Linux的0、1、2号进程"></a>Linux的0、1、2号进程</h2><ul><li><strong>idel进程：</strong>系统创建的第一个进程，加载系统。系统启动的时候，它开始加载系统，加载完成后，演变成1号和2号进程。</li><li><strong>systemd进程：</strong>系统初始化，是所有其它用户进程的祖先。负责启动系统服务，例如网络服务、防火墙，SSH服务，ftp服务。有些系统叫init</li><li><strong>kthreadd进程：</strong>负责所有内核线程的调度和管理。</li></ul><h2 id="进程标识"><a href="#进程标识" class="headerlink" title="进程标识"></a>进程标识</h2><ul><li>每个进程都有一个非负整数表示的唯一进程ID。</li><li>查看进程：<code>ps -ef|grep 进程名</code> 可以查看进程的详细信息</li></ul><p><img src="/../images/image-20221013074013314.png" alt="image-20221013074013314"></p><p>可以分别去查看进程的详情，能看到层层的父进程ID</p><ul><li>getpid(void)，获取进程ID。</li><li>getppid(void)，获取父进程ID。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;getpid()=%d\n&quot;</span>,getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;getppid()=%d\n&quot;</span>,getppid());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221013074804676.png" alt="image-20221013074804676"></p><h2 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h2><ul><li>一个现有的进程调用函数fork创建一个新的进程。新的进程叫做子进程，原有的进程叫做父进程。</li><li>子进程和父进程继续执行fork函数后的代码。</li><li>fork函数调用一次返回两次。</li><li>子进程返回0，父进程返回子进程的进程ID。</li><li>子进程是父进程的副本。</li><li>子进程获得了父进程的数据空间、堆和栈的副本，不是共享。</li><li>父进程中打开文件描述符也被复制到子进程中。</li><li>如果父进程先退出，子进程会成为孤儿进程。</li><li>如果子进程先退出，内核向父进程发送SIGCHLD信号，如果父进程不处理这个信号，子进程会成为僵尸进程。</li></ul><p>book03.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//- 一个现有的进程调用函数fork创建一个新的进程。新的进程叫做子进程，原有的进程叫做父进程。</span></span><br><span class="line"><span class="comment">//- 子进程和父进程继续执行fork函数后的代码。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;aaa=%d\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bbb=%d\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        fork();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ccc=%d\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">30</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ddd=%d\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果，子进程和父进程都打印了ccc 和ddd 而且两个进程的id是不同的</p><p><img src="/../images/image-20221013083301770.png" alt="image-20221013083301770"></p><p>book04.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//- fork函数调用一次返回两次。</span></span><br><span class="line"><span class="comment">//- 子进程返回0，父进程返回子进程的进程ID。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;aaa=%d\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">	<span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;bbb=%d\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> pid = fork();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;pid=%d\n&quot;</span>,pid);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ccc=%d\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">	<span class="built_in">sleep</span>(<span class="number">30</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ddd=%d\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221013083840483.png" alt="image-20221013083840483"></p><p>看运行结果，fork后面，pid打印了两次，一个是0 一个非0 子进程的返回0 父进程的返回子进程的id。fork函数中一个进程分叉成了两个进程，fork返回了两次。</p><p>book05.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pid = fork();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;这是子进程%d，将执行子进程的任务。\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">                <span class="built_in">sleep</span>(<span class="number">20</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;这是父进程%d,将执行父进程的任务。\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">                <span class="built_in">sleep</span>(<span class="number">30</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221014073721111.png" alt="image-20221014073721111"></p><blockquote><p>getpid()调用失败，返回-1 一般是子进程太多，或者内存不足，比较极端的情况</p></blockquote><p>我们来做这样一个事情，在父进程中定义一个变量，然后在子进程中修改变量的值，然后看变量是否会改变</p><p>book06.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//- 子进程是父进程的副本。</span></span><br><span class="line"><span class="comment">//- 子进程获得了父进程的数据空间、堆和栈的副本，不是共享。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ii = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> pid = fork();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;这是子进程%d，将执行子进程的任务。\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;aaaaaa ii = %d\n&quot;</span>,ii++); <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;aaaaaa ii = %d\n&quot;</span>,ii++); <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;aaaaaa ii = %d\n&quot;</span>,ii++); <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;aaaaaa ii = %d\n&quot;</span>,ii++); <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;aaaaaa ii = %d\n&quot;</span>,ii++); <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;这是父进程%d,将执行父进程的任务。\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;bbbb ii = %d\n&quot;</span>,ii); <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;bbbb ii = %d\n&quot;</span>,ii); <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;bbbb ii = %d\n&quot;</span>,ii); <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;bbbb ii = %d\n&quot;</span>,ii); <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;bbbb ii = %d\n&quot;</span>,ii); <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;bbbb ii = %d\n&quot;</span>,ii); <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;bbbb ii = %d\n&quot;</span>,ii); <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221014074339553.png" alt="image-20221014074339553"></p><p>子进程做了改变，父进程不会改变，原因就是子进程是父进程的一个副本，子进程获得了父进程的数据空间、堆和栈的副本，不是共享。就像把一张纸复印了一份，你在复印件上修改，并不会影响原件上的内容，同样在原件上修改，也不会影响复印件。</p><blockquote><p>补充一点：</p><p>父进程打开的文件描述符也被复制到子进程中</p></blockquote><p>book07.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	FILE *fp = <span class="built_in">fopen</span>(<span class="string">&quot;./tmp/tmp.txt&quot;</span>,<span class="string">&quot;a+&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(fp,<span class="string">&quot;我要成为优秀的程序员。\n&quot;</span>);</span><br><span class="line">	<span class="keyword">int</span> ii = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> pid = fork();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;这是子进程%d，将执行子进程的任务。\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">		<span class="built_in">fprintf</span>(fp,<span class="string">&quot;aaaa 我我我我我我我&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;这是父进程%d,将执行父进程的任务。\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">		<span class="built_in">fprintf</span>(fp,<span class="string">&quot;bbbb 我我我多我我我&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fclose</span>(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221014093055959.png" alt="image-20221014093055959"></p><p>看现象，我要成为优秀的程序员，这句话写入两次，原因是刚开始写在了内存中，然后内存被复制，所以父子进程各最终写入了一次。这是因为有内存缓冲区，写入文件会先写到缓冲区上，缓冲区满了才会一次性写入文件，如果想到达到我们理想的状态，那在fork调用之前，要刷新一次缓冲区，把缓冲区内容强制刷到文件上，就没问题了。</p><blockquote><p>fork之前数据空间被复制了一份，数据空间包括缓冲区，父进程的缓冲区有这个内容，子进程的缓冲区也有这个内容。改一下加入fflush(fp); 强刷。</p></blockquote><p>book08.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	FILE *fp = <span class="built_in">fopen</span>(<span class="string">&quot;./tmp/tmp.txt&quot;</span>,<span class="string">&quot;a+&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(fp,<span class="string">&quot;我要成为优秀的程序员。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fflush</span>(fp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ii = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> pid = fork();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;这是子进程%d，将执行子进程的任务。\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">		<span class="built_in">fprintf</span>(fp,<span class="string">&quot;aaaa 我我我我我我我&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;这是父进程%d,将执行父进程的任务。\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">		<span class="built_in">fprintf</span>(fp,<span class="string">&quot;bbbb 我我我多我我我&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fclose</span>(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这回的输出就对了</p><p><img src="/../images/image-20221014094521812.png" alt="image-20221014094521812"></p><blockquote><p>说明：bbb我我我我我我 和aaaa我我我我我 这两个的写入顺序是不确定的，因为执行fork以后，父子进程执行的顺序是不确定的，跟操作系统的算法有关，一般来说，我们也不关注哪个进程先执行。</p></blockquote><p>父进程和子进程虽然是父子进程，但是是两个独立的进程，如果在子进程中关闭的文件，不会影响父进程，如果在父进程中关闭的文件，也不会影响子进程。</p><p>我们在子进程关闭文件操作符，在父进程中每隔1秒接着往文件里继续写。</p><p>book09.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	FILE *fp = <span class="built_in">fopen</span>(<span class="string">&quot;./tmp/tmp.txt&quot;</span>,<span class="string">&quot;a+&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(fp,<span class="string">&quot;我要成为优秀的程序员。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fflush</span>(fp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ii = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> pid = fork();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;这是子进程%d，将执行子进程的任务。\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">		<span class="built_in">fclose</span>(fp);</span><br><span class="line">		<span class="built_in">fprintf</span>(fp,<span class="string">&quot;aaaa 我我我我我我我。\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;这是父进程%d,将执行父进程的任务。\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">		<span class="built_in">fprintf</span>(fp,<span class="string">&quot;bbbb 我我我多我我我。\n&quot;</span>);  <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">fprintf</span>(fp,<span class="string">&quot;bbbb 我我我多我我我。\n&quot;</span>);  <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">fprintf</span>(fp,<span class="string">&quot;bbbb 我我我多我我我。\n&quot;</span>);  <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">fprintf</span>(fp,<span class="string">&quot;bbbb 我我我多我我我。\n&quot;</span>);  <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">fprintf</span>(fp,<span class="string">&quot;bbbb 我我我多我我我。\n&quot;</span>);  <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">fprintf</span>(fp,<span class="string">&quot;bbbb 我我我多我我我。\n&quot;</span>);  <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fclose</span>(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221014164017466.png" alt="image-20221014164017466"></p><p>发现子进程关闭操作符后，子进程不能再写入，但父进程不受影响，还能继续写入文件。</p><h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><h3 id="什么是僵尸进程？"><a href="#什么是僵尸进程？" class="headerlink" title="什么是僵尸进程？"></a>什么是僵尸进程？</h3><p>我们接下来看看僵尸进程</p><p><strong>如果子进程先退出，内核向父进程发送SIGCHLD信号，如果父进程不处理这个信号，子进程会成为僵尸进程。</strong></p><p>book10.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> pid = fork();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;这是子进程%d，将执行子进程的任务。\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;这是父进程%d,将执行父进程的任务。\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">20</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让子进程sleep 5秒后退出，父进程sleep 10秒后退出，然后通过ps -ef|grep book10来查看父子进程</p><p>5秒后，子进程退出，出现了僵尸进程</p><p><img src="/../images/image-20221017074358725.png" alt="image-20221017074358725"></p><p>20秒后，父进程也退出，僵尸进程也消失了，这就是僵尸进程</p><p><img src="/../images/image-20221017074427136.png" alt="image-20221017074427136"></p><blockquote><p>僵尸进程的危害：</p><p>如果子进程在父进程之前终止，内核为每个子进程保留了一个数据结构，包括进程编号、终止状态和使用CPU时间等，父进程如果处理了子进程退出的信息，内核就会释放这个数据结构，如果父进程没有处理子进程退出的信息，内核就不会释放这个数据结构，子进程编号就会一直被占用，但是系统可用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，这就是僵尸进程的危害。</p></blockquote><h3 id="僵尸进程解决方法"><a href="#僵尸进程解决方法" class="headerlink" title="僵尸进程解决方法"></a>僵尸进程解决方法</h3><p><strong>方法一：直接忽略这个信号</strong></p><p>book11.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">signal</span>(SIGCHLD,SIG_IGN);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> pid = fork();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;这是子进程%d，将执行子进程的任务。\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;这是父进程%d,将执行父进程的任务。\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">20</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们再观察结果，发现5秒后子进程退了，并没有产生僵尸进程</p><p><img src="/../images/image-20221017080731676.png" alt="image-20221017080731676"></p><p><strong>方法二：父进程wait子进程退出</strong></p><p>book12.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	signal(SIGCHLD,SIG_IGN);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> pid = fork();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;这是子进程%d，将执行子进程的任务。\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;这是父进程%d,将执行父进程的任务。\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">		<span class="keyword">int</span> sts;</span><br><span class="line">		<span class="built_in">wait</span>(&amp;sts);</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">20</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>wait函数 父进程等待子进程的退出，子进程退出后，父进程才执行wait后面的代码。</p></blockquote><p>这种方法有一个问题，就是阻塞在这里。</p><p><strong>方法三：设置CHLD这个信号的处理函数，在这个处理函数中wait</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> sig)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sts;</span><br><span class="line">	<span class="built_in">wait</span>(&amp;sts);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">signal</span>(SIGCHLD,func);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> pid = fork();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;这是子进程%d，将执行子进程的任务。\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;这是父进程%d,将执行父进程的任务。\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样不影响父进程执行后面的函数，信号到达了，就执行func，注意这里面并不代表父进程一定会等待子进程的退出，因为父进程可能会先退出，如果sleep(1) 那么父进程退出后就不再关心信号处理函数了。</p><blockquote><p>如果父进程先退出，子进程会成为孤儿进程，将被1号进程收养，由1号进程对它们完成状态收集工作。</p><p>如果子进程先退出，内核向父进程发送SIGCHLD信号，如果父进程不处理这个信号，子进程会成为僵尸进程。</p></blockquote></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/10/12/%E6%B0%94%E8%B1%A1%E6%95%B0%E6%8D%AE%E9%A1%B9%E7%9B%AE-%E7%AC%AC2%E7%AB%A0%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E6%B0%B8%E4%B8%8D%E5%81%9C%E6%9C%BA-3-Linux%E4%BF%A1%E5%8F%B7/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/10/12/%E6%B0%94%E8%B1%A1%E6%95%B0%E6%8D%AE%E9%A1%B9%E7%9B%AE-%E7%AC%AC2%E7%AB%A0%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E6%B0%B8%E4%B8%8D%E5%81%9C%E6%9C%BA-3-Linux%E4%BF%A1%E5%8F%B7/" class="post-title-link" itemprop="url">气象数据-第2章如何保证服务程序永不停机-3-Linux信号</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-10-12 07:31:10" itemprop="dateCreated datePublished" datetime="2022-10-12T07:31:10+08:00">2022-10-12</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-11-29 15:26:42" itemprop="dateModified" datetime="2022-11-29T15:26:42+08:00">2022-11-29</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C%E6%B0%94%E8%B1%A1%E6%95%B0%E6%8D%AE%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">C气象数据项目</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="程序实践"><a href="#程序实践" class="headerlink" title="程序实践"></a>程序实践</h2><p>先来看一段程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;执行了一次任务。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221012073818201.png" alt="image-20221012073818201"></p><p>程序运行结果如图所示。每一秒执行一次任务，然后我们通过control + c 或者 killall book都可以终止程序。其实是<strong>发送了信号</strong>linux进程一共有<strong>64个信号</strong>，我们往程序里添加一段代码，把它们都打印出来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;接收到了信号%d\n&quot;</span>,sig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> ii = <span class="number">1</span>;ii &lt;= <span class="number">64</span>; ii++)</span><br><span class="line">                signal(ii,handler);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;执行了一次任务。\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>sighandler_t signal(int signum, sighandler_t handler);</code></p><p>信号处理函数，第一个参数是信号值，0-64。第二个参数是信号处理函数。如果我们给信号设置了处理函数，那么当我们发送信号，比如control + c 或者 killall book 的时候，会执行信号处理函数；如果没有设置处理函数，则会执行系统缺省的行为，也就是系统默认的信号处理行为就是杀死进程。</p><p>程序如图所示</p><p><img src="/../images/image-20221012074824441.png" alt="image-20221012074824441"></p><p>在接到信号2和15的时候，并没有像之前一样被杀死。而是执行了我们的信号处理函数。直到我们发送了信号9，强制杀死进程，进程才终止。</p><p><code>signal(int signum,SIG_IGN);</code></p><p>对信号进行忽略处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;接收到了信号%d\n&quot;</span>,sig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> ii = <span class="number">1</span>;ii &lt;= <span class="number">64</span>; ii++)</span><br><span class="line">                signal(ii,handler);</span><br><span class="line"></span><br><span class="line">  			<span class="comment">//信号忽略</span></span><br><span class="line">        signal(<span class="number">15</span>,SIG_IGN);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;执行了一次任务。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们对15信号进行了忽略，那么我们就不会接到15信号，尽管我们发送了killall book 发送了15号信号，但是处理函数并没有处理。</p><p><img src="/../images/image-20221012075432590.png" alt="image-20221012075432590"></p><p>能处理信号2，但信号9并没有处理。</p><blockquote><p>信号9 既不能捕获处理，也不能忽略。</p></blockquote><p><code>signal(15,SIG_DFL)</code></p><p>信号缺省处理</p><p>对该信号进行捕获，并进行系统默认缺省处理，也就是杀死进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;接收到了信号%d\n&quot;</span>,sig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> ii = <span class="number">1</span>;ii &lt;= <span class="number">64</span>; ii++)</span><br><span class="line">                signal(ii,handler);</span><br><span class="line"></span><br><span class="line">        signal(<span class="number">15</span>,SIG_IGN);</span><br><span class="line"></span><br><span class="line">				<span class="comment">//信号缺省处理</span></span><br><span class="line">        signal(<span class="number">15</span>,SIG_DFL);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;执行了一次任务。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221012075747261.png" alt="image-20221012075747261"></p><h2 id="信号的概念"><a href="#信号的概念" class="headerlink" title="信号的概念"></a>信号的概念</h2><p>信号signal是软件中断，是进程之间相互传递消息的一种方法，用于通知进程发生了事件，但是，不能给进程传递任何数据。</p><p>信号产生的原因很多，在Linux下，可以用kill和killall命令发送信号。kill后面要跟进程id</p><p>通过ps -ef|grep book 可以查book的pid 然后通过kill进行信号发送</p><h2 id="常用信号"><a href="#常用信号" class="headerlink" title="常用信号"></a>常用信号</h2><p><img src="/../images/image-20221012080202254.png" alt="image-20221012080202254"></p><p><img src="/../images/image-20221012080216373.png" alt="image-20221012080216373"></p><p><img src="/../images/image-20221012080225139.png" alt="image-20221012080225139"></p><p><img src="/../images/image-20221012080237675.png" alt="image-20221012080237675"></p><h2 id="发送时钟信号ALRM"><a href="#发送时钟信号ALRM" class="headerlink" title="发送时钟信号ALRM"></a>发送时钟信号ALRM</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;接收到了信号%d\n&quot;</span>,sig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//时钟处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">alarmfunc</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;接收到了时钟信号%d。\n&quot;</span>,num);</span><br><span class="line">  			alarm(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> ii = <span class="number">1</span>;ii &lt;= <span class="number">64</span>; ii++)</span><br><span class="line">                signal(ii,handler);</span><br><span class="line">				<span class="comment">//时钟信号捕获</span></span><br><span class="line">        signal(SIGALRM,alarmfunc);</span><br><span class="line"></span><br><span class="line">  			<span class="comment">//发送时钟信号，第3秒开始，只会发送一次，如果想要每隔3秒发送一次，要在处理函数中发送alarm(3)</span></span><br><span class="line">        alarm(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        signal(<span class="number">15</span>,SIG_DFL);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;执行了一次任务。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>只发送一次</p><p><img src="/../images/image-20221012083103915.png" alt="image-20221012083103915"></p><p>每隔3秒发送一次</p><p><img src="/../images/image-20221012083407102.png" alt="image-20221012083407102"></p><h2 id="信号有什么用"><a href="#信号有什么用" class="headerlink" title="信号有什么用"></a>信号有什么用</h2><p>服务程序运行在后台，如果想让中止它，杀掉不是个好办法，因为程序被杀的时候，程序突然死亡，没有安排善后工作。</p><p>如果向服务程序发送一个信号，服务程序收到这个信号后，调用一个函数，在函数中编写善后的代码，程序就可以有计划的退出。</p><p><strong>向服务程序发送0的信号，可以检测程序是否存活。</strong></p><h2 id="信号应用示例"><a href="#信号应用示例" class="headerlink" title="信号应用示例"></a>信号应用示例</h2><p>在实际开发中，在main开始的地方，程序会先屏蔽全部的信号。</p><p><code>for(int ii = 1; i&lt;= 64 ; ii++) signal(ii,SIG_IGN);</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//善后处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXIT</span><span class="params">(<span class="keyword">int</span> sig)</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;接收到了信号%d\n&quot;</span>,sig);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  			<span class="comment">//全部忽略，避免被干扰</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> ii = <span class="number">1</span>;ii &lt;= <span class="number">64</span>; ii++)</span><br><span class="line">                signal(ii,SIG_IGN);</span><br><span class="line">				<span class="comment">//对感兴趣的信号进行善后处理</span></span><br><span class="line">        signal(SIGINT,EXIT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;执行了一次任务。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/10/01/%E6%B0%94%E8%B1%A1%E6%95%B0%E6%8D%AE-%E7%AC%AC2%E7%AB%A0%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E6%B0%B8%E4%B8%8D%E5%81%9C%E6%9C%BA-1-%E7%94%9F%E6%88%90%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/10/01/%E6%B0%94%E8%B1%A1%E6%95%B0%E6%8D%AE-%E7%AC%AC2%E7%AB%A0%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E6%B0%B8%E4%B8%8D%E5%81%9C%E6%9C%BA-1-%E7%94%9F%E6%88%90%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE/" class="post-title-link" itemprop="url">气象数据-第2章如何保证服务程序永不停机-1-生成测试数据</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-10-01 08:05:03" itemprop="dateCreated datePublished" datetime="2022-10-01T08:05:03+08:00">2022-10-01</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-11-29 15:26:42" itemprop="dateModified" datetime="2022-11-29T15:26:42+08:00">2022-11-29</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C%E6%B0%94%E8%B1%A1%E6%95%B0%E6%8D%AE%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">C气象数据项目</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/09/27/NDK-Makefile%E8%AF%A6%E8%A7%A3/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/09/27/NDK-Makefile%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">NDK系列(一)-Makefile详解</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-09-27 09:19:25" itemprop="dateCreated datePublished" datetime="2022-09-27T09:19:25+08:00">2022-09-27</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-11-29 15:26:41" itemprop="dateModified" datetime="2022-11-29T15:26:41+08:00">2022-11-29</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/NDK/" itemprop="url" rel="index"><span itemprop="name">NDK</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="makefile、cmake与shell之间的联系"><a href="#makefile、cmake与shell之间的联系" class="headerlink" title="makefile、cmake与shell之间的联系"></a>makefile、cmake与shell之间的联系</h2><ul><li><p>makefile:帮助我们管理编译项目</p></li><li><p>cmake:CMake 是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装（编译过程）他能够输出各种各样Makefile或者project文件。CMake并不直接构建出最终的软件，而是产生标准的构建文档（如Makefile或projects）</p></li><li><p>shell脚本：一系列命令和语法</p></li></ul><h2 id="makefile自动编译和链接"><a href="#makefile自动编译和链接" class="headerlink" title="makefile自动编译和链接"></a>makefile自动编译和链接</h2><p>gcc的四个步骤中生成.o比较耗时(汇编阶段)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -c sub.cpp -o sub.o</span><br><span class="line">gcc -c add.cpp -o add.o</span><br><span class="line">gcc -c div.cpp -o div.o</span><br><span class="line">gcc -c hello.cpp -o hello.o</span><br></pre></td></tr></table></figure><h3 id="怎么把这些写在Makefile文件中？"><a href="#怎么把这些写在Makefile文件中？" class="headerlink" title="怎么把这些写在Makefile文件中？"></a>怎么把这些写在Makefile文件中？</h3><h4 id="一个规则"><a href="#一个规则" class="headerlink" title="一个规则"></a>一个规则</h4><p>目标:依赖条件</p><p>(一个tab缩进)命令</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">a.out:a.c</span></span><br><span class="line">	gcc a.c -o a.out</span><br></pre></td></tr></table></figure><p>把上面的生成的hello.o改成写Makefile形式</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hello.out:hello.o sub.o add.o div.o</span></span><br><span class="line">	gcc -c hello.o sub.o add.o div.o -o hello.out</span><br><span class="line"><span class="section">sub.o:sub.cpp</span></span><br><span class="line">	gcc -c sub.cpp -o sub.o</span><br><span class="line"><span class="section">div.o:div.cpp</span></span><br><span class="line">	gcc -c div.cpp -o div.o</span><br><span class="line"><span class="section">add.o:add.cpp</span></span><br><span class="line">	gcc -c add.cpp -o add.o</span><br><span class="line"><span class="section">hello.o:hello.cpp</span></span><br><span class="line">	gcc -c hello.cpp -o hello.o</span><br></pre></td></tr></table></figure><blockquote><p>注意：默认只会执行第一个，所以要把hello.out的命令放在第一个，然后会把所有的依赖都执行</p></blockquote><h4 id="两个函数"><a href="#两个函数" class="headerlink" title="两个函数"></a>两个函数</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span> <span class="comment">#找到当前目录下所有后缀为.c的文件，然后赋值给src</span></span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> %cpp,%o,<span class="variable">$(src)</span>)</span> <span class="comment">#就是把，src变量里所有的xxxcpp的字符串替换成xxxo</span></span><br></pre></td></tr></table></figure><p>通过这两个函数，可以把多个.o进行替换，省略了</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> *.cpp)</span></span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> %cpp,%o,<span class="variable">$(src)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">hello.out:<span class="variable">$(obj)</span></span></span><br><span class="line">	gcc -c <span class="variable">$(obj)</span> -o hello.out</span><br><span class="line"><span class="section">sub.o:sub.cpp</span></span><br><span class="line">	gcc -c sub.cpp -o sub.o</span><br><span class="line"><span class="section">div.o:div.cpp</span></span><br><span class="line">	gcc -c div.cpp -o div.o</span><br><span class="line"><span class="section">add.o:add.cpp</span></span><br><span class="line">	gcc -c add.cpp -o add.o</span><br><span class="line"><span class="section">hello.o:hello.cpp</span></span><br><span class="line">	gcc -c hello.cpp -o hello.o</span><br><span class="line">	</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf <span class="variable">$(obj)</span> hello.out</span><br></pre></td></tr></table></figure><blockquote><p>通过自定义clean指令，可以执行make clean执行rm -rf 指令，在执行前可以先加-n 看执行的是不是需要的指令make clean -n</p></blockquote><p>但还是很麻烦，如果我们动态的增加一个.cpp或者改动一个.cpp每次都要去改Makefile文件，所以看三个规则。</p><h4 id="三个自动变量"><a href="#三个自动变量" class="headerlink" title="三个自动变量"></a>三个自动变量</h4><ul><li>$@:表示规则中的目标。</li><li>$^:表示规则中所有的依赖条件，组成一个列表，以空格隔开，如果这个列表有重复项则消除重复</li><li>$&lt;:表示模式套用规则中的第一个依赖条件，如果运行在模式套用中，相当于依次取出依赖条件套用该模式规则</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> *.cpp)</span></span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> %cpp,%o,<span class="variable">$(src)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">hello.out:<span class="variable">$(obj)</span></span></span><br><span class="line">	gcc <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="comment">#模式套用规则</span></span><br><span class="line"><span class="section">%o:%cpp</span></span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o %@</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/08/17/chromium-%E7%BD%91%E7%BB%9C%E6%A0%88%E7%A0%94%E7%A9%B6/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/08/17/chromium-%E7%BD%91%E7%BB%9C%E6%A0%88%E7%A0%94%E7%A9%B6/" class="post-title-link" itemprop="url">chromium 网络栈研究</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-08-17 14:57:03" itemprop="dateCreated datePublished" datetime="2022-08-17T14:57:03+08:00">2022-08-17</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-11-29 15:26:42" itemprop="dateModified" datetime="2022-11-29T15:26:42+08:00">2022-11-29</time></span></div></header><div class="post-body" itemprop="articleBody"><p>网络栈位于net目录下</p><p>顶层网络栈对象是UrlRequestContext</p><p>位于net&#x2F;url_request&#x2F;url_request_context.cc</p><p>context含有创建和发出URL请求需要的对象的非所有权指针。Context的生命期必须比所有使用它的request的生命期要长。创建Context是一个相当复杂的过程，通常由URLRequestContextBuilder管理。</p><p>net&#x2F;url_request&#x2F;url_request_context_builder.cc</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;URLRequest&gt; <span class="title">URLRequestContext::CreateRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> GURL&amp; url,</span></span></span><br><span class="line"><span class="params"><span class="function">    RequestPriority priority,</span></span></span><br><span class="line"><span class="params"><span class="function">    URLRequest::Delegate* delegate,</span></span></span><br><span class="line"><span class="params"><span class="function">    NetworkTrafficAnnotationTag traffic_annotation,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">bool</span> is_for_websockets,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> absl::optional&lt;net::NetLogSource&gt; net_log_source)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> base::<span class="built_in">WrapUnique</span>(<span class="keyword">new</span> <span class="built_in">URLRequest</span>(url, priority, delegate, <span class="keyword">this</span>,</span><br><span class="line">                                         traffic_annotation, is_for_websockets,</span><br><span class="line">                                         net_log_source));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>URLRequestContext 的主要用途是使用URLRequestContext::CreateRequest()来创建URLRequest对象</p><p>URLRequest是网络栈consumer使用的主要接口。它负责加载使用http、https、ws、wss的URLs。使用其他协议的URLs，例如file、filesystem、blob、chrome和data，都被&#x2F;&#x2F;net外的对象管理。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/08/16/ViewModel%E7%9A%84%E5%8E%9F%E7%90%86/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/08/16/ViewModel%E7%9A%84%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">ViewModel的原理</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-08-16 10:18:59" itemprop="dateCreated datePublished" datetime="2022-08-16T10:18:59+08:00">2022-08-16</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-11-29 15:26:42" itemprop="dateModified" datetime="2022-11-29T15:26:42+08:00">2022-11-29</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="ViewModel原理"><a href="#ViewModel原理" class="headerlink" title="ViewModel原理"></a>ViewModel原理</h2><p>在页面中通过ViewModelProvider类来实现化ViewModel。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> timerViewModel = ViewModelProvider(<span class="keyword">this</span>).<span class="keyword">get</span>(TimerViewModel::<span class="keyword">class</span>.java)</span><br></pre></td></tr></table></figure><p>ViewModelProvider接收一个ViewModelStoreOwner对象作为参数。在以上示例代码中该参数是this,指代当前的Activity。这是因为我们的Activity继承自FragmentActivity，而在androidx依赖包中，FragmentActivity默认实现了ViewModelStoreOwner接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentActivity</span> <span class="keyword">extends</span> <span class="title">androidx</span>.<span class="title">core</span>.<span class="title">app</span>.<span class="title">ComponentActivity</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">        <span class="title">ContextAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">LifecycleOwner</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ViewModelStoreOwner</span>,</span></span><br><span class="line"><span class="class">        <span class="title">HasDefaultViewModelProviderFactory</span>,</span></span><br><span class="line"><span class="class">        <span class="title">SavedStateRegistryOwner</span>,</span></span><br><span class="line"><span class="class">        <span class="title">OnBackPressedDispatcherOwner</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ActivityResultRegistryOwner</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ActivityResultCaller</span></span></span><br></pre></td></tr></table></figure><p>ViewModelStoreOwner.java 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ViewModelStoreOwner</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns owned &#123;<span class="doctag">@link</span> ViewModelStore&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a &#123;<span class="doctag">@code</span> ViewModelStore&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function">ViewModelStore <span class="title">getViewModelStore</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口返回类型是ViewModelStore</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewModelStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, ViewModel&gt; mMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, ViewModel viewModel)</span> </span>&#123;</span><br><span class="line">        ViewModel oldViewModel = mMap.put(key, viewModel);</span><br><span class="line">        <span class="keyword">if</span> (oldViewModel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            oldViewModel.onCleared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> ViewModel <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Set&lt;String&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HashSet&lt;&gt;(mMap.keySet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Clears internal storage and notifies ViewModels that they are no longer used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ViewModel vm : mMap.values()) &#123;</span><br><span class="line">            vm.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        mMap.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码可以看出，ViewModel实际上是以HashMap&lt;String,ViewModel&gt;的形式被缓存起来了。ViewModel与页面之间没有直接关联，它们通过ViewModelProvider索要，ViewModelProvider检查该ViewModel是否已经存在于缓存中，若存在，则直接返回，若不存在，则实例化一个。因此Activity由于配置变化导致的销毁重建并不会影响ViewModel，ViewModel是独立于页面而存在的。<strong>也正因为此，我们使用ViewModel时，需要特别注意，不要向ViewModel中传入任何类型Context或带有Context引用的对象，这可能会导致页面无法被销毁，从而引发内存泄漏。</strong></p><p>需要注意的是，除了Activity，androidx依赖包中的Fragment也默认实现了ViewModelStoreOwner接口。因此我们也可以在Fragment中正常使用ViewModel。</p><h2 id="ViewModel与AndroidViewModel"><a href="#ViewModel与AndroidViewModel" class="headerlink" title="ViewModel与AndroidViewModel"></a>ViewModel与AndroidViewModel</h2><p>前面提到过，使用ViewModel时，不能将任何类型的Context或含有Context引用的对象传入ViewModel，因为可能会导致内存泄漏。但如果你希望在ViewModel中使用Context，该怎么办？可以使用AndroidViewModel，它继承自ViewModel，并接收Application作为Context。这意味着，它的生命周期和Applicatioin是一样的，那么这就不算是一个内存泄漏了。</p><h2 id="ViewModel与onSaveInstanceState-方法"><a href="#ViewModel与onSaveInstanceState-方法" class="headerlink" title="ViewModel与onSaveInstanceState()方法"></a>ViewModel与onSaveInstanceState()方法</h2><p>对于页面数据的保存与恢复，也许你会有这样的疑问，onSaveInstanceState()方法同样可以解决屏幕旋转带来的数据丢失问题，那么是不是没有必要使用ViewModel呢？好问题！请注意，onSaveInstanceState方法只能保存少量的、能支持序列化的数据，而ViewModel没有这个限制。ViewModel能支持页面中所有的数据。同样需要注意的是，ViewModel不支持数据的持久化，当界面被彻底销毁时，ViewModel及其持有的数据就不存在了，但是onSaveInstanceState方法没有这个限制，它可以持久化页面的数据。可见，onSaveInstance方法有其特殊用途，二者不可混淆。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/08/01/Android-%E5%B9%B3%E5%8F%B0Native%E4%BB%A3%E7%A0%81%E5%B4%A9%E6%BA%83%E6%8D%95%E8%8E%B7%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%AE%9E%E7%8E%B0/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/08/01/Android-%E5%B9%B3%E5%8F%B0Native%E4%BB%A3%E7%A0%81%E5%B4%A9%E6%BA%83%E6%8D%95%E8%8E%B7%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">Android 平台Native代码崩溃捕获机制及实现</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-08-01 14:25:05" itemprop="dateCreated datePublished" datetime="2022-08-01T14:25:05+08:00">2022-08-01</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-11-29 15:26:41" itemprop="dateModified" datetime="2022-11-29T15:26:41+08:00">2022-11-29</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="信号机制"><a href="#信号机制" class="headerlink" title="信号机制"></a>信号机制</h2><h3 id="程序崩溃"><a href="#程序崩溃" class="headerlink" title="程序崩溃"></a>程序崩溃</h3><ul><li>在Unix-like系统中，所有的崩溃都是编程错误或者硬件错误相关的，系统遇到不可恢复的错误时会触发崩溃机制让程序退出，如除零、段地址错误等。</li><li>异常发生时，CPU通过异常中断的方式，触发异常处理流程。不同的处理器，有不同的异常中断类型和中断处理方式。</li><li>linux把这些中断处理，统一为信号量，可以注册信号量向量进行处理。</li><li>信号机制是进程之间相互传递消息的一种方法，信号全称为软中断信号。</li></ul><h3 id="信号机制-1"><a href="#信号机制-1" class="headerlink" title="信号机制"></a>信号机制</h3><p>函数运行在用户态，当遇到系统调用、中断或是异常的情况时，程序会进入内核态。信号涉及到了这两种状态之间的转换。</p><p><img src="/../images/image-20220801142645905.png" alt="image-20220801142645905"></p><h4 id="1-信号的接收"><a href="#1-信号的接收" class="headerlink" title="(1) 信号的接收"></a>(1) 信号的接收</h4><p>接收信号的任务是由内核代理的，当内核接收到信号后，会将其放到对应进程的信号队列中，同时向进程发送一个中断，使其陷入内核态。注意，此时信号还只是在队列中，对进程来说暂时是不知道有信号到来的。</p><h4 id="2-信号的检测"><a href="#2-信号的检测" class="headerlink" title="(2) 信号的检测"></a>(2) 信号的检测</h4><p>进程陷入内核态后，有两种场景会对信号进行检测：</p><ul><li><strong>进程从内核态返回到用户态前进行信号检测</strong></li><li><strong>进程在内核态中，从睡眠状态被唤醒的时候进行信号检测</strong></li></ul><p>当发现有新信号时，便会进入下一步，信号的处理。</p><h4 id="3-信号的处理"><a href="#3-信号的处理" class="headerlink" title="(3) 信号的处理"></a>(3) 信号的处理</h4><p>信号处理函数是运行在用户态的，调用处理函数前，内核会将当前内核栈的内容备份拷贝到用户栈上，并且修改指令寄存器（eip）将其指向信号处理函数。</p><p>接下来进程返回到用户态中，执行相应的信号处理函数。</p><p>信号处理函数执行完成后，还需要返回内核态，检查是否还有其它信号未处理。如果所有信号都处理完成，就会将内核栈恢复（从用户栈的备份拷贝回来），同时恢复指令寄存器（eip）将其指向中断前的运行位置，最后回到用户态继续执行进程。</p><p>至此，一个完整的信号处理流程便结束了，如果同时有多个信号到达，上面的处理流程会在第2步和第3步骤间重复进行。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><nav class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a></nav></div><script>window.addEventListener("tabs:register",()=>{let e=CONFIG.comments["activeClass"];if(CONFIG.comments.storage&&(e=localStorage.getItem("comments_active")||e),e){let t=document.querySelector(`a[href="#comment-${e}"]`);t&&t.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">张龙</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">52</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">12</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">2</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">张龙</span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script></body></html>