<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SteveZhang博客</title>
  
  
  <link href="https://stevezhangzl.github.io/atom.xml" rel="self"/>
  
  <link href="https://stevezhangzl.github.io/"/>
  <updated>2023-01-16T22:23:55.000Z</updated>
  <id>https://stevezhangzl.github.io/</id>
  
  <author>
    <name>张龙</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>c/cpp开发技巧性总结</title>
    <link href="https://stevezhangzl.github.io/2023/01/15/c-cpp%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    <id>https://stevezhangzl.github.io/2023/01/15/c-cpp%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7%E6%80%A7%E6%80%BB%E7%BB%93/</id>
    <published>2023-01-15T06:37:42.000Z</published>
    <updated>2023-01-16T22:23:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>​    </p><h2 id="C-x2F-C-开发"><a href="#C-x2F-C-开发" class="headerlink" title="C&#x2F;C++开发"></a>C&#x2F;C++开发</h2><h3 id="需要数组的大小，记得使用巧用sizeof"><a href="#需要数组的大小，记得使用巧用sizeof" class="headerlink" title="需要数组的大小，记得使用巧用sizeof"></a>需要数组的大小，记得使用巧用sizeof</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> JNINativeMethod gMethods[] = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;craoc&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>,                               (<span class="keyword">void</span> *) callRealApplicationOnCreate&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;craa&quot;</span>,  <span class="string">&quot;(Landroid/content/Context;Ljava/lang/String;)V&quot;</span>,      (<span class="keyword">void</span> *) callRealApplicationAttach&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;ia&quot;</span>,    <span class="string">&quot;(Landroid/content/Context;Ljava/lang/ClassLoader;)V&quot;</span>, (<span class="keyword">void</span> *) init_app&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;gap&quot;</span>,   <span class="string">&quot;(Ljava/lang/ClassLoader;)Ljava/lang/String;&quot;</span>,         (<span class="keyword">void</span> *) getApkPath&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;rcf&quot;</span>,   <span class="string">&quot;(Ljava/lang/ClassLoader;)Ljava/lang/String;&quot;</span>,         (<span class="keyword">void</span> *) readAppComponentFactory&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;mde&quot;</span>,   <span class="string">&quot;(Ljava/lang/ClassLoader;Ljava/lang/ClassLoader;)V&quot;</span>,        (<span class="keyword">void</span> *) mergeDexElements&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;rde&quot;</span>,   <span class="string">&quot;(Ljava/lang/ClassLoader;Ljava/lang/ClassLoader;)V&quot;</span>,        (<span class="keyword">void</span> *) replaceDexElements&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">registerNativeMethods</span><span class="params">(JNIEnv *env)</span> </span>&#123;</span><br><span class="line">    jclass JniBridgeClass = env-&gt;<span class="built_in">FindClass</span>(<span class="string">&quot;com/luoyesiqiu/shell/JniBridge&quot;</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//最后一个参数是数组的size，通过sizeof(数组)/sizeof(某项) 来获取数组的大小，这个技巧要记住</span></span><br><span class="line">    <span class="keyword">if</span> (env-&gt;<span class="built_in">RegisterNatives</span>(JniBridgeClass, gMethods, <span class="built_in"><span class="keyword">sizeof</span></span>(gMethods) / <span class="built_in"><span class="keyword">sizeof</span></span>(gMethods[<span class="number">0</span>])) ==</span><br><span class="line">        <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NDK开发"><a href="#NDK开发" class="headerlink" title="NDK开发"></a>NDK开发</h2><h3 id="NDK-开发Android-Log日志"><a href="#NDK-开发Android-Log日志" class="headerlink" title="NDK 开发Android Log日志"></a>NDK 开发Android Log日志</h3><p><code>android_log.h</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DPT_DPT_LOG_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DPT_DPT_LOG_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAG  <span class="meta-string">&quot;dpt_native&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;android/log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLOGI(...) __android_log_print(ANDROID_LOG_INFO,TAG,__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLOGD(...) __android_log_print(ANDROID_LOG_DEBUG, TAG, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLOGE(...) __android_log_print(ANDROID_LOG_ERROR,TAG,__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLOGW(...) __android_log_print(ANDROID_LOG_WARN,TAG,__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLOGI(...)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLOGD(...)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLOGE(...)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLOGW(...)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NOICE_LOG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NLOG(...) &#123; \</span></span><br><span class="line"><span class="meta">    __android_log_print(ANDROID_LOG_INFO,TAG,__VA_ARGS__); \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NLOG(...)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//DPT_DPT_LOG_H</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​    &lt;/p&gt;
&lt;h2 id=&quot;C-x2F-C-开发&quot;&gt;&lt;a href=&quot;#C-x2F-C-开发&quot; class=&quot;headerlink&quot; title=&quot;C&amp;#x2F;C++开发&quot;&gt;&lt;/a&gt;C&amp;#x2F;C++开发&lt;/h2&gt;&lt;h3 id=&quot;需要数组的大小，记得使用巧用si</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【Gradle7.0】依赖统一管理的全新方式，了解一下[转]</title>
    <link href="https://stevezhangzl.github.io/2023/01/13/%E3%80%90Gradle7-0%E3%80%91%E4%BE%9D%E8%B5%96%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86%E7%9A%84%E5%85%A8%E6%96%B0%E6%96%B9%E5%BC%8F%EF%BC%8C%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B-%E8%BD%AC/"/>
    <id>https://stevezhangzl.github.io/2023/01/13/%E3%80%90Gradle7-0%E3%80%91%E4%BE%9D%E8%B5%96%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86%E7%9A%84%E5%85%A8%E6%96%B0%E6%96%B9%E5%BC%8F%EF%BC%8C%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B-%E8%BD%AC/</id>
    <published>2023-01-13T05:54:52.000Z</published>
    <updated>2023-01-16T22:23:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着项目的不断发展，项目中的依赖也越来越多，有时可能会有几百个，这个时候对项目依赖做一个统一的管理很有必要，我们一般会有以下需求：</p><ol><li>项目依赖统一管理，在单独文件中配置</li><li>不同<code>Module</code>中的依赖版本号统一</li><li>不同项目中的依赖版本号统一</li></ol><p>针对这些需求，目前其实已经有了一些方案：</p><ol><li><a href="https://juejin.cn/post/6947675376835362846#heading-2">使用循环优化Gradle依赖管理</a></li><li><a href="https://juejin.cn/post/6844903615346245646">使用buildSrc管理Gradle依赖</a></li><li><a href="https://juejin.cn/post/6844904169833234439">使用includeBuild统一配置依赖版本</a></li></ol><p>上面的方案支持在不同<code>Module</code>间统一版本号，同时如果需要在项目间共享，也可以做成<code>Gradle</code>插件发布到远端，已经基本可以满足我们的需求<br>不过<code>Gradle7.0</code>推出了一个新的特性，使用<code>Catalog</code>统一依赖版本，它支持以下特性：</p><ol><li>对所有<code>module</code>可见，可统一管理所有<code>module</code>的依赖</li><li>支持声明依赖<code>bundles</code>,即总是一起使用的依赖可以组合在一起</li><li>支持版本号与依赖名分离，可以在多个依赖间共享版本号</li><li>支持在单独的<code>libs.versions.toml</code>文件中配置依赖</li><li>支持在项目间共享依赖</li></ol><h2 id="使用Version-Catalog"><a href="#使用Version-Catalog" class="headerlink" title="使用Version Catalog"></a>使用<code>Version Catalog</code></h2><p>注意，<code>Catalog</code>仍然是一个孵化中的特性，如需使用,需要在<code>settings.gradle</code>中添加以下内容：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enableFeaturePreview(<span class="string">&#x27;VERSION_CATALOGS&#x27;</span>)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>从命名上也可以看出，<code>Version Catalog</code>其实就是一个版本的目录,我们可以从目录中选出我们需要的依赖使用<br>我们可以通过如下方式使用<code>Catalog</code>中声明的依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation(libs.retrofit)</span><br><span class="line">    implementation(libs.groovy.core)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，<code>libs</code>是一个目录，<code>retrofit</code>表示该目录中可用的依赖项。 与直接在构建脚本中声明依赖项相比，<code>Version Catalog</code>具有许多优点：</p><ul><li>对于每个<code>catalog</code>,<code>Gradle</code>都会生成类型安全的访问器,以便你在<code>IDE</code>中可以自动补全.(注:目前在<code>build.gradle</code>中还不能自动补全，可能是指<code>kts</code>或者开发中？)</li><li>声明在<code>catalog</code>中的依赖对所有<code>module</code>可见，当修改版本号时，可以统一管理统一修改</li><li><code>catalog</code>支持声明一个依赖<code>bundles</code>,即一些总是一起使用的依赖的组合</li><li><code>catalog</code>支持版本号与依赖名分离，可以在多个依赖间共享版本号</li></ul><h2 id="声明Version-Catalog"><a href="#声明Version-Catalog" class="headerlink" title="声明Version Catalog"></a>声明<code>Version Catalog</code></h2><p><code>Version Catalog</code>可以在<code>settings.gradle(.kts)</code>文件中声明。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dependencyResolutionManagement &#123;</span><br><span class="line">    versionCatalogs &#123;</span><br><span class="line">        libs &#123;</span><br><span class="line">            alias(<span class="string">&#x27;retrofit&#x27;</span>).to(<span class="string">&#x27;com.squareup.retrofit2:retrofit:2.9.0&#x27;</span>)</span><br><span class="line">            alias(<span class="string">&#x27;groovy-core&#x27;</span>).to(<span class="string">&#x27;org.codehaus.groovy:groovy:3.0.5&#x27;</span>)</span><br><span class="line">            alias(<span class="string">&#x27;groovy-json&#x27;</span>).to(<span class="string">&#x27;org.codehaus.groovy:groovy-json:3.0.5&#x27;</span>)</span><br><span class="line">            alias(<span class="string">&#x27;groovy-nio&#x27;</span>).to(<span class="string">&#x27;org.codehaus.groovy:groovy-nio:3.0.5&#x27;</span>)</span><br><span class="line">            alias(<span class="string">&#x27;commons-lang3&#x27;</span>).to(<span class="string">&#x27;org.apache.commons&#x27;</span>, <span class="string">&#x27;commons-lang3&#x27;</span>).version &#123;</span><br><span class="line">                strictly <span class="string">&#x27;[3.8, 4.0[&#x27;</span></span><br><span class="line">                prefer <span class="string">&#x27;3.9&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别名必须由一系列以破折号（<code>-</code>，推荐）、下划线 (<code>_</code>) 或点 (<code>.</code>) 分隔的标识符组成。<br>标识符本身必须由<code>ascii</code>字符组成，最好是小写，最后是数字。</p><p>值得注意的是，<code>groovy-core</code>会被映射成<code>libs.groovy.core</code><br>如果你想避免映射可以使用大小写来区分，比如<code>groovyCore</code>会被处理成<code>libs.groovyCore</code></p><h2 id="具有相同版本号的依赖"><a href="#具有相同版本号的依赖" class="headerlink" title="具有相同版本号的依赖"></a>具有相同版本号的依赖</h2><p>在上面的示例中，我们可以看到三个<code>groovy</code>依赖具有相同的版本号，我们可以把它们统一起来</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dependencyResolutionManagement &#123;</span><br><span class="line">    versionCatalogs &#123;</span><br><span class="line">        libs &#123;</span><br><span class="line">            version(<span class="string">&#x27;groovy&#x27;</span>, <span class="string">&#x27;3.0.5&#x27;</span>)</span><br><span class="line">            version(<span class="string">&#x27;compilesdk&#x27;</span>, <span class="string">&#x27;30&#x27;</span>)</span><br><span class="line">            version(<span class="string">&#x27;targetsdk&#x27;</span>, <span class="string">&#x27;30&#x27;</span>)</span><br><span class="line">            alias(<span class="string">&#x27;groovy-core&#x27;</span>).to(<span class="string">&#x27;org.codehaus.groovy&#x27;</span>, <span class="string">&#x27;groovy&#x27;</span>).versionRef(<span class="string">&#x27;groovy&#x27;</span>)</span><br><span class="line">            alias(<span class="string">&#x27;groovy-json&#x27;</span>).to(<span class="string">&#x27;org.codehaus.groovy&#x27;</span>, <span class="string">&#x27;groovy-json&#x27;</span>).versionRef(<span class="string">&#x27;groovy&#x27;</span>)</span><br><span class="line">            alias(<span class="string">&#x27;groovy-nio&#x27;</span>).to(<span class="string">&#x27;org.codehaus.groovy&#x27;</span>, <span class="string">&#x27;groovy-nio&#x27;</span>).versionRef(<span class="string">&#x27;groovy&#x27;</span>)</span><br><span class="line">            alias(<span class="string">&#x27;commons-lang3&#x27;</span>).to(<span class="string">&#x27;org.apache.commons&#x27;</span>, <span class="string">&#x27;commons-lang3&#x27;</span>).version &#123;</span><br><span class="line">                strictly <span class="string">&#x27;[3.8, 4.0[&#x27;</span></span><br><span class="line">                prefer <span class="string">&#x27;3.9&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了在依赖中，我们同样可以在<code>build.gradle</code>中获取版本,比如可以用来指定<code>compileSdk</code>等</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdk libs.versions.compilesdk.get().toInteger()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">&quot;com.zj.gradlecatalog&quot;</span></span><br><span class="line">        minSdk <span class="number">21</span></span><br><span class="line">        targetSdk libs.versions.targetsdk.get().toInteger()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，可以使用<code>catalog</code>统一<code>compileSdk</code>,<code>targetSdk</code>,<code>minSdk</code>的版本号</p><h2 id="依赖bundles"><a href="#依赖bundles" class="headerlink" title="依赖bundles"></a>依赖<code>bundles</code></h2><p>因为在不同的项目中经常系统地一起使用某些依赖项，所以<code>Catalog</code>提供了<code>bundle</code>(依赖包)的概念。依赖包基本上是几个依赖项打包的别名。<br>例如，你可以这样使用一个依赖包，而不是像上面那样声明 3 个单独的依赖项：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation libs.bundles.groovy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>groovy</code>依赖包声明如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dependencyResolutionManagement &#123;</span><br><span class="line">    versionCatalogs &#123;</span><br><span class="line">        libs &#123;</span><br><span class="line">            version(<span class="string">&#x27;groovy&#x27;</span>, <span class="string">&#x27;3.0.5&#x27;</span>)</span><br><span class="line">            version(<span class="string">&#x27;checkstyle&#x27;</span>, <span class="string">&#x27;8.37&#x27;</span>)</span><br><span class="line">            alias(<span class="string">&#x27;groovy-core&#x27;</span>).to(<span class="string">&#x27;org.codehaus.groovy&#x27;</span>, <span class="string">&#x27;groovy&#x27;</span>).versionRef(<span class="string">&#x27;groovy&#x27;</span>)</span><br><span class="line">            alias(<span class="string">&#x27;groovy-json&#x27;</span>).to(<span class="string">&#x27;org.codehaus.groovy&#x27;</span>, <span class="string">&#x27;groovy-json&#x27;</span>).versionRef(<span class="string">&#x27;groovy&#x27;</span>)</span><br><span class="line">            alias(<span class="string">&#x27;groovy-nio&#x27;</span>).to(<span class="string">&#x27;org.codehaus.groovy&#x27;</span>, <span class="string">&#x27;groovy-nio&#x27;</span>).versionRef(<span class="string">&#x27;groovy&#x27;</span>)</span><br><span class="line">            alias(<span class="string">&#x27;commons-lang3&#x27;</span>).to(<span class="string">&#x27;org.apache.commons&#x27;</span>, <span class="string">&#x27;commons-lang3&#x27;</span>).version &#123;</span><br><span class="line">                strictly <span class="string">&#x27;[3.8, 4.0[&#x27;</span></span><br><span class="line">                prefer <span class="string">&#x27;3.9&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">            bundle(<span class="string">&#x27;groovy&#x27;</span>, [<span class="string">&#x27;groovy-core&#x27;</span>, <span class="string">&#x27;groovy-json&#x27;</span>, <span class="string">&#x27;groovy-nio&#x27;</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示：添加<code>groovy</code>依赖包等同于添加依赖包下的所有依赖项</p><h2 id="插件版本"><a href="#插件版本" class="headerlink" title="插件版本"></a>插件版本</h2><p>除了<code>Library</code>之外，<code>Catalog</code>还支持声明插件版本。<br>因为<code>library</code>由它们的<code>group</code>、<code>artifact</code>和<code>version</code>表示，但<code>Gradle</code>插件仅由它们的<code>id</code>和<code>version</code>标识。<br>因此，插件需要单独声明：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dependencyResolutionManagement &#123;</span><br><span class="line">    versionCatalogs &#123;</span><br><span class="line">        libs &#123;</span><br><span class="line">            alias(<span class="string">&#x27;jmh&#x27;</span>).toPluginId(<span class="string">&#x27;me.champeau.jmh&#x27;</span>).version(<span class="string">&#x27;0.6.5&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后可以在<code>plugins</code>块下面使用</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;java-library&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;checkstyle&#x27;</span></span><br><span class="line">    <span class="comment">// 使用声明的插件</span></span><br><span class="line">    alias(libs.plugins.jmh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在单独文件中配置Catalog"><a href="#在单独文件中配置Catalog" class="headerlink" title="在单独文件中配置Catalog"></a>在单独文件中配置<code>Catalog</code></h2><p>除了在<code>settings.gradle</code>中声明<code>Catalog</code>外，也可以通过一个单独的文件来配置<code>Catalog</code><br>如果在根构建的<code>gradle</code>目录中找到了<code>libs.versions.toml</code>文件,则将使用该文件的内容自动声明一个<code>Catalog</code></p><p><code>TOML</code>文件主要由4个部分组成：</p><ul><li><code>[versions]</code> 部分用于声明可以被依赖项引用的版本</li><li><code>[libraries]</code> 部分用于声明<code>Library</code>的别名</li><li><code>[bundles]</code> 部分用于声明依赖包</li><li><code>[plugins]</code> 部分用于声明插件</li></ul><p>如下所示：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[versions]</span><br><span class="line">groovy = <span class="string">&quot;3.0.5&quot;</span></span><br><span class="line">checkstyle = <span class="string">&quot;8.37&quot;</span></span><br><span class="line">compilesdk = <span class="string">&quot;30&quot;</span></span><br><span class="line">targetsdk = <span class="string">&quot;30&quot;</span></span><br><span class="line"></span><br><span class="line">[libraries]</span><br><span class="line">retrofit = <span class="string">&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;</span></span><br><span class="line">groovy-core = &#123; module = <span class="string">&quot;org.codehaus.groovy:groovy&quot;</span>, version.ref = <span class="string">&quot;groovy&quot;</span> &#125;</span><br><span class="line">groovy-json = &#123; module = <span class="string">&quot;org.codehaus.groovy:groovy-json&quot;</span>, version.ref = <span class="string">&quot;groovy&quot;</span> &#125;</span><br><span class="line">groovy-nio = &#123; module = <span class="string">&quot;org.codehaus.groovy:groovy-nio&quot;</span>, version.ref = <span class="string">&quot;groovy&quot;</span> &#125;</span><br><span class="line">commons-lang3 = &#123; group = <span class="string">&quot;org.apache.commons&quot;</span>, name = <span class="string">&quot;commons-lang3&quot;</span>, version = &#123; strictly = <span class="string">&quot;[3.8, 4.0[&quot;</span>, prefer=<span class="string">&quot;3.9&quot;</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">[bundles]</span><br><span class="line">groovy = [<span class="string">&quot;groovy-core&quot;</span>, <span class="string">&quot;groovy-json&quot;</span>, <span class="string">&quot;groovy-nio&quot;</span>]</span><br><span class="line"></span><br><span class="line">[plugins]</span><br><span class="line">jmh = &#123; id = <span class="string">&quot;me.champeau.jmh&quot;</span>, version = <span class="string">&quot;0.6.5&quot;</span> &#125;</span><br></pre></td></tr></table></figure><p>如上所示，依赖可以定义成一个字符串，也可以将<code>module</code>与<code>version</code>分离开来<br>其中<code>versions</code>可以定义成一个字符串，也可以定义成一个范围，详情可参见<a href="https://link.juejin.cn/?target=https://docs.gradle.org/current/userguide/rich_versions.html%23rich-version-constraints">rich-version</a></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[versions]</span><br><span class="line">my-lib = &#123; strictly = <span class="string">&quot;[1.0, 2.0[&quot;</span>, prefer = <span class="string">&quot;1.2&quot;</span> &#125;</span><br></pre></td></tr></table></figure><h2 id="在项目间共享Catalog"><a href="#在项目间共享Catalog" class="headerlink" title="在项目间共享Catalog"></a>在项目间共享<code>Catalog</code></h2><p><code>Catalog</code>不仅可以在项目内统一管理依赖，同样可以实现在项目间共享<br>例如我们需要在团队内制定一个依赖规范，不同组的不同项目需要共享这些依赖，这是个很常见的需求</p><h3 id="通过文件共享"><a href="#通过文件共享" class="headerlink" title="通过文件共享"></a>通过文件共享</h3><p><code>Catalog</code>支持通过从<code>Toml</code>文件引入依赖，这就让我们可以通过指定文件路径来实现共享依赖<br>如下所示，我们在<code>settins.gradle</code>中配置如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dependencyResolutionManagement &#123;</span><br><span class="line">    versionCatalogs &#123;</span><br><span class="line">        libs &#123;</span><br><span class="line">            from(files(<span class="string">&quot;../gradle/libs.versions.toml&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此技术可用于声明来自不同文件的多个目录：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dependencyResolutionManagement &#123;</span><br><span class="line">    versionCatalogs &#123;</span><br><span class="line">        <span class="comment">// 声明一个&#x27;testLibs&#x27;目录, 从&#x27;test-libs.versions.toml&#x27;文件中</span></span><br><span class="line">        testLibs &#123;</span><br><span class="line">            from(files(<span class="string">&#x27;gradle/test-libs.versions.toml&#x27;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发布插件实现共享"><a href="#发布插件实现共享" class="headerlink" title="发布插件实现共享"></a>发布插件实现共享</h3><p>虽然从本地文件导入<code>Catalog</code>很方便，但它并没有解决在组织或外部消费者中共享<code>Catalog</code>的问题。<br>我们还可能通过<code>Catalog</code>插件来发布目录，这样用户直接引入这个插件即可</p><p><code>Gradle</code>提供了一个<code>Catalog</code>插件，它提供了声明然后发布<code>Catalog</code>的能力。</p><h4 id="1-首先引入两个插件"><a href="#1-首先引入两个插件" class="headerlink" title="1. 首先引入两个插件"></a>1. 首先引入两个插件</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;version-catalog&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;maven-publish&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，此插件将公开可用于声明目录的<code>catalog</code>扩展</p><h4 id="2-定义目录"><a href="#2-定义目录" class="headerlink" title="2. 定义目录"></a>2. 定义目录</h4><p>上面引入插件后，即可使用<code>catalog</code>扩展定义目录</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">catalog &#123;</span><br><span class="line">    <span class="comment">// 定义目录</span></span><br><span class="line">    versionCatalog &#123;</span><br><span class="line">        from files(<span class="string">&#x27;../libs.versions.toml&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后可以通过<code>maven-publish</code>插件来发布目录</p><h4 id="3-发布目录"><a href="#3-发布目录" class="headerlink" title="3. 发布目录"></a>3. 发布目录</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">publishing &#123;</span><br><span class="line">    publications &#123;</span><br><span class="line">        maven(MavenPublication) &#123;</span><br><span class="line">            groupId = <span class="string">&#x27;com.zj.catalog&#x27;</span></span><br><span class="line">            artifactId = <span class="string">&#x27;catalog&#x27;</span></span><br><span class="line">            version = <span class="string">&#x27;1.0.0&#x27;</span></span><br><span class="line">            from components.versionCatalog</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义好<code>groupId</code>,<code>artifactId</code>,<code>version</code>,<code>from</code>就可以发布了<br>我们这里发布到<code>mavenLocal</code>，你也可以根据需要配置发布到自己的<code>maven</code><br>以上发布的所有代码可见：<a href="https://link.juejin.cn/?target=https://github.com/shenzhen2017/GradleCatalog">Catalog发布相关代码</a></p><h4 id="4-使用目录"><a href="#4-使用目录" class="headerlink" title="4. 使用目录"></a>4. 使用目录</h4><p>因为我们已经发布到了<code>mavenLocal</code>,在仓库中引入<code>mavenLocal</code>就可以使用插件了</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># settings.gradle</span><br><span class="line">dependencyResolutionManagement &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenLocal()</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enableFeaturePreview(<span class="string">&#x27;VERSION_CATALOGS&#x27;</span>)</span><br><span class="line">dependencyResolutionManagement &#123;</span><br><span class="line">    versionCatalogs &#123;</span><br><span class="line">        libs &#123;</span><br><span class="line">            from(<span class="string">&quot;com.zj.catalog:catalog:1.0.0&quot;</span>)</span><br><span class="line">            <span class="comment">// 我们也可以重写覆盖catalog中的groovy版本</span></span><br><span class="line">            version(<span class="string">&quot;groovy&quot;</span>, <span class="string">&quot;3.0.6&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上就成功引入了插件，就可以使用<code>catalog</code>中的依赖了<br>这样就完成了依赖的项目间共享，以上使用的所有代码可见：<a href="https://link.juejin.cn/?target=https://github.com/shenzhen2017/GradleCatalog/tree/feature/useCatalog">Catalog使用相关代码</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>项目间共享依赖是比较常见的需求，虽然我们也可以通过自定义插件实现，但还是不够方便<br><code>Gradle</code>官方终于推出了<code>Catalog</code>,让我们可以方便地实现依赖的共享,<code>Catalog</code>主要具有以下特性：</p><ol><li>对所有<code>module</code>可见，可统一管理所有<code>module</code>的依赖</li><li>支持声明依赖<code>bundles</code>,即总是一起使用的依赖可以组合在一起</li><li>支持版本号与依赖名分离，可以在多个依赖间共享版本号</li><li>支持在单独的<code>libs.versions.toml</code>文件中配置依赖</li><li>支持在项目间共享依赖</li></ol><p>作者：程序员江同学<br>链接：<a href="https://juejin.cn/post/6997396071055900680">https://juejin.cn/post/6997396071055900680</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;随着项目的不断发展，项目中的依赖也越来越多，有时可能会有几百个，这个时候对项目依赖做一个统一的管理很有必要，我们一般会有以下需求：&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Gradle" scheme="https://stevezhangzl.github.io/categories/Gradle/"/>
    
    
  </entry>
  
  <entry>
    <title>Gradle 7.0都有哪些新特性[转]</title>
    <link href="https://stevezhangzl.github.io/2023/01/13/Gradle-7-0%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7-%E8%BD%AC/"/>
    <id>https://stevezhangzl.github.io/2023/01/13/Gradle-7-0%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7-%E8%BD%AC/</id>
    <published>2023-01-13T01:32:30.000Z</published>
    <updated>2023-01-16T22:23:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Gradle-7-0都有哪些新特性"><a href="#Gradle-7-0都有哪些新特性" class="headerlink" title="Gradle 7.0都有哪些新特性?"></a>Gradle 7.0都有哪些新特性?</h1><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1efda28fbe2844118cf3188a1df755af~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp" alt="Gradle 7.0都有哪些新特性?"></p><blockquote><p>原文链接：<a href="https://link.juejin.cn/?target=https://gradle.org/whats-new/gradle-7/">gradle.org&#x2F;whats-new&#x2F;g…</a></p></blockquote><p><code>Gradle 7.0</code>的发布已经一段时间了，我们来看下从Gradle 6.0到7.0，都有哪些有趣的特性。</p><ul><li>加快增量编译速度</li><li>通过验证构建依赖项的完整性，使您的构建更安全。</li><li>支持使用<code>Java 16</code>开发</li><li>使用<code>included builds</code>简化构建</li><li>通过新的依赖管理特性降低了<code>Multi-Project</code>构建的维护成本</li><li>使用最新版本的<code>Groovy</code>和<code>Kotlin</code>开发</li></ul><h2 id="性能方面的优化"><a href="#性能方面的优化" class="headerlink" title="性能方面的优化"></a>性能方面的优化</h2><h3 id="更快的up-to-date检查"><a href="#更快的up-to-date检查" class="headerlink" title="更快的up-to-date检查"></a>更快的<code>up-to-date</code>检查</h3><p>本地增量编译的快速反馈对于提高开发效率至关重要。文件系统监视通过减少判断哪些文件发生了变化的<code>IO</code>操作，来提高增量编译速度<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/147a658ea6664b8d9e6df9662267d8c6~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="img"><br>截至<code>Gradle 7.0</code>，在包括最近版本的<code>Windows</code>，<code>Linux</code>和<code>MacOS</code>的所有支持的操作系统上，默认情况下启用此优化。</p><p>关于文件系统监视的更多细节与原理，可参见：<a href="https://link.juejin.cn/?target=https://blog.gradle.org/introducing-file-system-watching">Introducing file system watching</a></p><h3 id="加快kotlin-DSL脚本编译速度"><a href="#加快kotlin-DSL脚本编译速度" class="headerlink" title="加快kotlin DSL脚本编译速度"></a>加快<code>kotlin DSL</code>脚本编译速度</h3><p><code>Gradle 7.0</code>可以以更快的速度，更小的内存编译<code>Kotlin DSL</code>构建脚本，即<code>KTS</code><br>此前当我们修改<code>buildsrc</code>中的代码时，会使大多数缓存失效，从而触发完全的重新编译<br>而在<code>Gradle 7.0</code>之后，修改<code>buildsrc</code>中的<code>kts</code>插件可以完全跳过未受影响的构建脚本文件的编译。<br>因此当修改<code>buildsrc</code>时，在<code>Gradle7.0</code>中，<code>kts</code>插件编译会远比<code>gradle</code>插件要快</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28ce5dff2e124384ac4e763174795973~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p><h3 id="提高build-cache命中率"><a href="#提高build-cache命中率" class="headerlink" title="提高build cache命中率"></a>提高<code>build cache</code>命中率</h3><p><code>Gradle7.0</code>通过有选择的忽略不会影响系统行为的一些更改，从而提高<code>build cache</code>的命中率<br>例如空的文件目录，属性文件中的空格和注释等，这些更改都会被忽略</p><h3 id="支持configuration-cache-实验性质"><a href="#支持configuration-cache-实验性质" class="headerlink" title="支持configuration cache(实验性质)"></a>支持<code>configuration cache</code>(实验性质)</h3><p><code>Gradle</code>已经支持了<code>build cache</code>，但是在执行任何<code>Task</code>之前，<code>Gradle</code>需要经过<code>configuration</code>阶段。目前<code>configuration</code>在每次构建时都会执行，并且可能导致明显的延迟，特别是在大型项目中。</p><p><code>configuration cache</code>通过缓存<code>configuration</code>阶段的结果来提高构建性能。使用<code>configuration cache</code>，当没有影响<code>configuration</code>的更改时，<code>Gradle</code>可以完全跳过<code>configuration</code>阶段，以加快构建速度。</p><p>此外，使用<code>configuration cache</code>时，更多的工作是并行执行的，也可以加速构建的<code>execution</code>阶段。<br>请注意，此功能目前是实验性的，默认情况下未启用，并且自 <code>Gradle 7.0</code> 起也并非所有核心插件都支持。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb567df501064f83ad573e224a27666c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p><p>关于<code>configuration cache</code>的更多细节与原理,可参见：<a href="https://link.juejin.cn/?target=https://docs.gradle.org/7.0/userguide/configuration_cache.html">Configuration cache</a></p><h3 id="更快的临时构建速度"><a href="#更快的临时构建速度" class="headerlink" title="更快的临时构建速度"></a>更快的临时构建速度</h3><p>有时我们会进行一些临时的构建，临时构建机器需要重新下载所有依赖，这会付出比较大的代价。 <code>Gradle 7.0</code>可以通过跨机器重用<code>dependency cache</code>来加快临时构建的速度。</p><h4 id="重定向dependency-cache"><a href="#重定向dependency-cache" class="headerlink" title="重定向dependency cache"></a>重定向<code>dependency cache</code></h4><p><code>dependency cache</code>的默认位置为：<code>$GRADLE_HOME/caches/modules-2</code>，缓存目录可以重新定位到另一个目录或主机以缓存依赖项。<br>当重定向到新位置或新主机时，如果已下载依赖项，则使用<code>dependency cache</code>的构建将不需要访问网络来下载依赖</p><p>值得注意的是，应该使用兼容的 <code>Gradle</code> 版本来创建和使用缓存。可以浏览<a href="https://link.juejin.cn/?target=https://docs.gradle.org/7.0/userguide/dependency_resolution.html%23sub:cache_copy">文档</a>以了解更多细节</p><h4 id="共享只读的dependency-cache"><a href="#共享只读的dependency-cache" class="headerlink" title="共享只读的dependency cache"></a>共享只读的<code>dependency cache</code></h4><p><code>Gradle</code>提供了在多个<code>Gradle</code>实例之间共享<code>dependency cache</code>的能力。<br>这使得我们可以创建一个共享目录，其中包含所有构建所需的依赖项。</p><ul><li>每个<code>Gradle</code>实例都可以访问共享只读依赖性缓存，这避免了构建之间的冗余下载。</li><li>可以在<code>Gradle</code>实例之间安全地共享此高速缓存，而无需创建其单独的副本。</li></ul><h2 id="易用性与新特性优化"><a href="#易用性与新特性优化" class="headerlink" title="易用性与新特性优化"></a>易用性与新特性优化</h2><h3 id="JVM项目的工具链支持"><a href="#JVM项目的工具链支持" class="headerlink" title="JVM项目的工具链支持"></a><code>JVM</code>项目的工具链支持</h3><p>默认情况下，<code>Gradle</code>使用相同的<code>Java</code>版本来运行<code>Gradle</code>本身并构建<code>JVM</code>项目，但这并不总是适用的。<br>在不同的开发机和 <code>CI</code> 服务器上构建，可能会使用不同的<code>Java</code>版本，这可能会导致预料之外的问题。此外，您可能希望使用与运行 <code>Gradle</code> 不兼容的 <code>Java</code> 版本来构建项目。</p><p><code>Gradle</code> 提供了可以设置项目构建的<code>Java</code>版本的工具链：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java &#123;</span><br><span class="line">    toolchain &#123;</span><br><span class="line">        languageVersion = JavaLanguageVersion.of(<span class="number">14</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Gradle</code>将检查本地<code>Java</code>的安装情况，如果本地没有与构建要求匹配的 <code>Java</code> 版本，<code>Gradle</code> 将从 <code>AdoptOpenJDK</code> 的网站下载匹配的 <code>JDK</code>。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b277113bf4464ca69b1e9000165aba9f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p><p>关于<code>JVM</code>项目工具链支持的具体使用，可参见：<a href="https://link.juejin.cn/?target=https://docs.gradle.org/7.0/userguide/toolchains.html">Toolchains for JVM projects</a></p><h3 id="处理用户凭据"><a href="#处理用户凭据" class="headerlink" title="处理用户凭据"></a>处理用户凭据</h3><p>构建有时需要用户提供凭据。 例如，为了发布<code>aar</code>，<code>Maven</code>库可能需要身份验证，而将凭据保存在构建脚本之外是一种很好的做法。</p><p><code>Gradle</code> 提供了一个 <code>API</code>，提供了一个 <code>Gradle</code> 属性来提供凭据，方便我们更轻松地使用凭据，这些属性可以作为命令行参数、环境变量或 <code>gradle.properties</code> 文件中的键值对，然后在构建脚本中可以读取这些值。 当 <code>Gradle</code> 知道构建在某些时候需要凭据并且缺少凭据时，它还会引入快速失败行为。</p><p>关于<code>Gradle</code>用户凭据的使用示例，可参考：<a href="https://link.juejin.cn/?target=https://docs.gradle.org/7.0/samples/sample_publishing_credentials.html">Publishing Credentials Sample</a></p><h3 id="支持执行included-builds中的task"><a href="#支持执行included-builds中的task" class="headerlink" title="支持执行included builds中的task"></a>支持执行<code>included builds</code>中的task</h3><p><code>Gradle</code> 允许用户直接从命令行从<code> included builds</code>中执行<code>Task</code>。 例如，如果您的构建<code>included build</code>了 <code>my-other-project</code>，并且它有一个带有<code>Task foo</code>的子项目 <code>sub</code>，那么您可以使用以下命令执行 <code>foo</code>：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">gradle :</span>my-other-<span class="attr">project:</span><span class="attr">sub:</span>foo</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="依赖锁定文件只保留一个"><a href="#依赖锁定文件只保留一个" class="headerlink" title="依赖锁定文件只保留一个"></a>依赖锁定文件只保留一个</h3><p>依赖锁定是一种在使用动态依赖版本时确保可重现构建的机制。<code>Gradle 7.0</code> 使用单个锁定文件将动态依赖项锁定到其解析的版本。而以前版本的 <code>Gradle</code> 每个<code>Configuration</code>使用一个文件, 在<code>Gradle7.0</code>中 会自动迁移到单锁文件。</p><h2 id="安全性优化"><a href="#安全性优化" class="headerlink" title="安全性优化"></a>安全性优化</h2><h3 id="依赖验证"><a href="#依赖验证" class="headerlink" title="依赖验证"></a>依赖验证</h3><p>我们的项目中常常会使用大量外部依赖项，这使他们面临使用不受信任代码的风险。 例如，有人可能会通过传递依赖意外引入恶意代码。同样，您的构建脚本本身也可能通过执行被感染插件的恶意代码，从而受到攻击。<br>为了减轻这些风险，<code>Gradle</code> 提供了依赖关系验证。 依赖项验证可以验证校验和以及构建期间使用的依赖项和插件的签名。</p><p>如果启用依赖项验证，<code>Gradle</code> 将：</p><ul><li>确保依赖项没有被篡改（通过验证它们的校验和）</li><li>确保您使用的依赖项和插件的出处（通过验证它们的签名）</li><li>从而降低将恶意代码发送到生产环境的风险。</li></ul><p>关于依赖验证的更多细节和使用，可以参见：<a href="https://link.juejin.cn/?target=https://docs.gradle.org/7.0/userguide/dependency_verification.html">Verifying dependencies</a></p><h3 id="声明专有存储库依赖"><a href="#声明专有存储库依赖" class="headerlink" title="声明专有存储库依赖"></a>声明专有存储库依赖</h3><p><code>Gradle</code> 允许您声明应在哪些存储库中搜索特定依赖项。<br><code>Gradle</code> 还允许您声明只能在一个存储库中找到且不应在任何其他存储库中搜索的专有依赖。</p><p>关于存储库专有依赖的具体细节，可以参见：<a href="https://link.juejin.cn/?target=https://docs.gradle.org/7.0/userguide/declaring_repositories.html%23declaring_content_exclusively_found_in_one_repository">user manual</a></p><h3 id="验证-Gradle-Wrappers-的完整性"><a href="#验证-Gradle-Wrappers-的完整性" class="headerlink" title="验证 Gradle Wrappers 的完整性"></a>验证 <code>Gradle Wrappers</code> 的完整性</h3><p><code>Gradle Wrapper</code> 是一个可执行代码的二进制文件，在数百万个 <code>GitHub</code> 存储库中使用。如果这个文件发生改变，可能存在一定的安全隐患<br>我们创建了一个官方 <code>GitHub Action</code>，它允许 <code>GitHub</code> 上的项目自动验证其存储库中的 <code>gradle-wrapper.jar</code> 是否由 <code>Gradle</code> 发布。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e39eb76e4c2f442b99f9fe5359ee4e25~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p><p>当然，你也可以通过<a href="https://link.juejin.cn/?target=https://docs.gradle.org/7.0/userguide/gradle_wrapper.html%23sec:wrapper_checksum_verification">user manual</a>中的步骤，手动检验<code>Gradle Wrapper</code>文件的合法性</p><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><h3 id="依赖解析一致性"><a href="#依赖解析一致性" class="headerlink" title="依赖解析一致性"></a>依赖解析一致性</h3><p><code>configurations</code>之间的依赖关系是独立解析的。这可能会导致一个问题，即测试的运行时<code>classpath</code>可能使用与生产代码的运行时<code>classpath</code>不同的版本。</p><p>为了缓解这个问题，<code>Gradle</code> 允许您<a href="https://link.juejin.cn/?target=https://docs.gradle.org/7.0/userguide/resolution_strategy_tuning.html%23resolution_consistency">声明依赖项<code>configurations</code>之间的一致性</a>，以便保证两个<code>classpath</code>的公共依赖项的版本是一致的。</p><h3 id="存储库统一声明"><a href="#存储库统一声明" class="headerlink" title="存储库统一声明"></a>存储库统一声明</h3><p>此前我们一般是在根目录的<code>build.gradle</code>中声明存储库，现在也可以在 <code>settings.gradle (.kts)</code> 中方便地为整个构建定义存储库：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencyResolutionManagement &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral ()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这允许 <code>Gradle</code> 确保您使用相同的存储库来解决构建的所有项目中的依赖关系。 了解更多，可以参考<a href="https://link.juejin.cn/?target=https://docs.gradle.org/7.0/userguide/declaring_repositories.html%23sub:centralized-repository-declaration">如何为整个构建声明存储库</a></p><h3 id="组件元数据规则的统一声明"><a href="#组件元数据规则的统一声明" class="headerlink" title="组件元数据规则的统一声明"></a>组件元数据规则的统一声明</h3><p>从存储库中提取的每个模块都有与之关联的元数据，例如其组、名称、版本以及它提供的不同变体及其工件和依赖项。有时元数据不完整或不正确。为了在构建脚本中操作这些不完整的元数据，<code>Gradle</code> 提供了一个 <code>API</code> 来编写组件元数据规则。 这些规则在模块的元数据下载后，并且在用于依赖解析之前生效。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencyResolutionManagement &#123;</span><br><span class="line">    components &#123;</span><br><span class="line">        withModule (<span class="string">&#x27;com.google.guava: guava&#x27;</span>, GuavaRule)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于组件元数据规则统一声明的具体细节，可参见：<a href="https://link.juejin.cn/?target=https://docs.gradle.org/7.0/userguide/component_metadata_rules.html">Fixing metadata with component metadata rules</a></p><h3 id="依赖统一管理的新特性"><a href="#依赖统一管理的新特性" class="headerlink" title="依赖统一管理的新特性"></a>依赖统一管理的新特性</h3><p>我们有多种方法可以在多项目构建中的项目之间共享依赖版本。 例如，用户可以直接在构建脚本的<code>ext</code> 块、外部文件（例如 <code>dependencies.gradle</code>）、<code>buildSrc</code> 甚至专用插件中声明版本或依赖坐标。 然而，没有任何标准机制可以结合每种方法的优点来做到这一点。</p><p><code>Gradle</code> 引入了<code>Version Catalog</code>，使构建者能够将其第三方依赖项的依赖坐标（组、工件、版本）集中在常规配置文件中，并以类型安全的方式声明实际依赖项。</p><p>关于<code>Version Catalog</code>的具体使用，之前也写过一篇介绍，感兴趣的同学可以参见：<a href="https://juejin.cn/post/6997396071055900680">【Gradle7.0】依赖统一管理的全新方式，了解一下~</a></p><h3 id="类型安全的Project访问器"><a href="#类型安全的Project访问器" class="headerlink" title="类型安全的Project访问器"></a>类型安全的<code>Project</code>访问器</h3><p><code>Gradle</code> 为类型安全的<code>Project</code>访问器提供了一个实验性功能，它可以在 <code>IDE</code> 中完成代码自动补全地声明对其它<code>Project</code>的依赖<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d66f8cc20579410ca42c5b8824a26b4a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="1_Tf11L05IMeC1Y0u42zsPqw.gif"><br>这比较大地解决了我们此前添加依赖的痛点，但目前似乎只对<code>kts</code>有效，了解更多细节可参见：<a href="https://link.juejin.cn/?target=https://docs.gradle.org/7.0/userguide/declaring_dependencies.html%23sec:type-safe-project-accessors">Type-safe project dependencies</a></p><h2 id="如何升级"><a href="#如何升级" class="headerlink" title="如何升级"></a>如何升级</h2><p>可以直接查看<code>Gradle</code>文档：<a href="https://link.juejin.cn/?target=https://docs.gradle.org/7.0/userguide/upgrading_version_6.html">Upgrading your build from Gradle 6.x to the latest</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Gradle-7-0都有哪些新特性&quot;&gt;&lt;a href=&quot;#Gradle-7-0都有哪些新特性&quot; class=&quot;headerlink&quot; title=&quot;Gradle 7.0都有哪些新特性?&quot;&gt;&lt;/a&gt;Gradle 7.0都有哪些新特性?&lt;/h1&gt;&lt;p&gt;&lt;img src</summary>
      
    
    
    
    <category term="Gradle" scheme="https://stevezhangzl.github.io/categories/Gradle/"/>
    
    
  </entry>
  
  <entry>
    <title>关于 Gradle 你应该知道的知识点[转]</title>
    <link href="https://stevezhangzl.github.io/2023/01/12/%E5%85%B3%E4%BA%8E-Gradle-%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9-%E8%BD%AC/"/>
    <id>https://stevezhangzl.github.io/2023/01/12/%E5%85%B3%E4%BA%8E-Gradle-%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9-%E8%BD%AC/</id>
    <published>2023-01-12T05:20:19.000Z</published>
    <updated>2023-01-16T22:23:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于<code>Android</code>开发者来说，<code>Gradle</code>也可以说是熟悉的陌生人了，可以说天天会用到<code>Gradle</code>，但对于<code>Gradle</code>的一些原理与细节又往往不太了解<br> 本文主要介绍<code>Gradle</code>的一些基础知识与原理，如果对你有所帮助，欢迎点赞</p><p>本文主要包括以下内容：</p><ol><li><code>Gradle</code>到底是什么?</li><li><code>Gradle Wrapper</code>是什么？</li><li><code>AGP</code>到底是什么?</li><li><code>gradle.properties</code>是什么?</li><li><code>settings.gradle</code>是什么?</li><li><code>build.gradle</code>是什么？</li><li><code>Gradle</code>生命周期是怎样的?</li></ol><h2 id="1-Gradle到底是什么"><a href="#1-Gradle到底是什么" class="headerlink" title="1. Gradle到底是什么?"></a>1. <code>Gradle</code>到底是什么?</h2><p><code>Gradle</code>也用了这么久了，如果要用一句话来描述<code>Gradle</code>，该如何回答呢？一个依赖管理框架？一个构建框架？</p><p><strong><code>Gradle</code> 是一个 运行在 <code>JVM</code> 的通用构建工具</strong>,其核心模型是一个由 <code>Task</code> 组成的有向无环图(<code>Directed Acyclic Graphs</code>).<br> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e5125271fcf4b5893ada25e4a2e0547~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p><h2 id="2-Gradle-Wrapper是什么？"><a href="#2-Gradle-Wrapper是什么？" class="headerlink" title="2. Gradle Wrapper是什么？"></a>2. <code>Gradle Wrapper</code>是什么？</h2><p>说起来我们一直在使用<code>Gradle</code>，但仔细想想我们在项目中其实没有用<code>gradle</code>命令，而一般是使用<code>gradlew</code>命令，同时如下图所示，找遍整个项目，与<code>gradle</code>有关的就这两个文件夹，却只发现<code>gradle-wrapper.jar</code>。<br> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/403baeaf752a4e8aa25d323667b73e26~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p><p>那么问题来了，<code>gradlew</code>是什么，<code>gradle-wrapper.jar</code>又是什么?</p><p><strong><code>wrapper</code>的意思：包装。</strong><br> 那么可想而已，这是<code>gradle</code>的包装。其实是这样的，因为<code>gradle</code>处于快速迭代阶段，经常发布新版本，如果我们的项目直接去引用，那么更改版本等会变得无比麻烦。而且每个项目又有可能用不一样的<code>gradle</code>版本，这样去手动配置每一个项目对应的<code>gradle</code>版本就会变得麻烦，<code>gradle</code>的引入本来就是想让大家构建项目变得轻松，如果这样的话，岂不是又增加了新的麻烦？<br> 所以<code>android</code>想到了包装，引入<code>gradle-wrapper</code>，通过读取配置文件中<code>gradle</code>的版本，为每个项目自动的下载和配置<code>gradle</code>，就是这么简单。我们便不用关心如何去下载<code>gradle</code>,如何配置到项目中。</p><p>至于<code>gradlew</code>也是一样的道理，它共有两个文件，<code>gradlew</code>是在<code>linux</code>,<code>mac</code>下使用的，<code>gradlew.bat</code>是在<code>window</code>下使用的，提供在命令行下执行<code>gradle</code>命令的功能<br> 至于为什么不直接执行<code>Gradle</code>，而是执行<code>Gradlew</code>命令呢?<br> 因为就像<code>wrapper</code>本身的意义，<code>gradle</code>命令行也是善变的，所以<code>wrapper</code>对命令行也进行了一层封装，使用同一的<code>gradlew</code>命令，<code>wrapper</code>会自动去执行具体版本对应的<code>gradle</code>命令。<br> 同时如果我们配置了全局的<code>gradle</code>命令，在项目中如果也用<code>gradle</code>容易造成混淆，而<code>gradlew</code>明确就是项目中指定的<code>gradle</code>版本，更加清晰与明确</p><h2 id="3-AGP到底是什么"><a href="#3-AGP到底是什么" class="headerlink" title="3. AGP到底是什么?"></a>3. <code>AGP</code>到底是什么?</h2><p><code>AGP</code>即<code>Android Gradle Plugin</code>，即<code>android</code>官方开发的<code>Gradle</code>插件，在了解<code>AGP</code>之前，我们先介绍一下什么是插件?</p><p><code>Gradle</code> 本身是一个通用的构建系统, 它并不知道你要编译的是 <code>Java</code> 还是 <code>C</code>. 如果是在<code>Java</code> 中需要调用 <code>javac</code> 将 <code>.java</code> 文件编译为 <code>.class</code> 文件, 而 <code>C</code> 则需要调用 <code>gcc</code> 将 <code>.c</code> 文件编译为 <code>.o</code> 文件. 那么这些构建流程如果让每个开发者自己去管理就太麻烦了. 所谓插件, 就是将某种类型的编译的模板.</p><p>而<code>AGP</code>也就是是一系列适合<code>Android</code>开发的<code>Gradle</code>插件的集合，比如<code>com.android.application</code>等<br> <code>AGP</code> 插件提供了<code>compileKotlin</code>,<code>compileJava</code>,<code>processResource</code>等一系列<code>Task</code>, 并设置了<code>Task</code>之间的依赖关系. 同时还提供了很多可配置属性. 而使用者只需要在 <code>build script</code> 中通过 <code>plugins &#123;...&#125;</code> 引入插件, 根据项目情况配置几个属性, 即可实现自定义的 <code>Android</code> 构建. 通过<code>AGP</code>插件可以快速实现<code>Android</code>项目的构建，这就是<code>AGP</code>插件的意义，其执行过程中的<code>task</code>列表如下所示</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d64b4bc166aa46b4a1fc530cc8eaa039~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p><h2 id="4-gradle-properties是什么"><a href="#4-gradle-properties是什么" class="headerlink" title="4. gradle.properties是什么?"></a>4. <code>gradle.properties</code>是什么?</h2><p>除了<code>Gradlew</code>与<code>AGP</code>，我们也经常会用到<code>gradle.properties</code>，我们经常在<code>gradle.peoperties</code>中定义一些统一的版本号，如<code>minSdkVersion</code>,<code>targetSdkVersion</code>等，然后再在各个<code>module</code>中通过<code>rootProject.minSdkVersion</code>获取以实现复用</p><p>那么问题来了,<code>rootProject</code>是如何获取<code>gradle.properties</code>中定义的值的呢?<br> 答案其实很简单，<code>Gradle</code> 启动时会默认读取<code>gradle.properties</code>, 并加载其中的参数。这跟我们在运行<code>Gradle</code>的时候通过命令行向其传递参数，效果是一样的<br> 当然不同的方式有不同的优先级，指定参数的优先级: 命令行参数 &gt; <code>GRADLE_USER_HOME gradle.properties</code> 文件 &gt; 项目根目录 <code>gradle.properties</code> 文件.</p><blockquote><p><code>Gradle</code> 使用的两个目录:<br> <code>Gradle</code> 在执行过程中会涉及到两个目录, 一个是 <code>Gradle User Home</code> 另一个是 <code>Project Root Directory</code>.<br> <code>Gradle User Home</code><br> <code>User Home</code> 中主要保存全局配置, 全局初始化脚本以及依赖的缓存和日志等文件. 如果开启 <code>build cache</code> 的话, 构建缓存也会存在这里共所有项目共享.<br> 默认为: <code>$USER_HOME/.gradle</code>.<br> <code>Project Root Directory</code><br> <code>Project</code> 目录则存储与当前项目构建相关的内容. 例如用于增量编译缓存.</p></blockquote><p>总得来说，<code>gradle.properties</code>其实就是一个参数的配置文件，与在命令行传递参数是一样的效果，因此在<code>Project</code>中可以读取到</p><h2 id="5-settings-gradle是什么"><a href="#5-settings-gradle是什么" class="headerlink" title="5. settings.gradle是什么?"></a>5. <code>settings.gradle</code>是什么?</h2><p>当我们在某个目录执行<code>gradle</code>命令时, 约定的会从当前目录查找以下两个文件:</p><ol><li><code>settings.gradle(.kts)</code></li><li><code>build.gradle(.kts)</code></li></ol><p>我们常常会在<code>settings.gradle</code>中配置<code>module</code>,那么<code>settings.gradle</code>究竟是什么？起什么作用?<br> 所有需要被构建的模块都需要在<code>settings.gradle</code> 中注册, 因此它的作用是描述 “当前构建所参与的模块”.</p><p><code>settings.gradle</code>查找顺序为: 从前目录开始, 如果找到<code>settings.gradle(.kts)</code>则停止, 否则向父目录递归查找.<br> <code>setting script</code>承担了统筹所有模块的重任, 因此<code>api</code>主要是在操作所参与构建的模块以及管理构建过程需要的插件.</p><p> 可以通过如下方式注册需要参与构建的模块，项目名称中 <code>:</code> 代表项目的分隔符, 类似路径中的 <code>/</code>. 如果以 <code>:</code> 开头则表示相对于 <code>root project</code></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include(<span class="string">&quot;:app&quot;</span>, <span class="string">&quot;:libs:someLibrary&quot;</span>)</span><br><span class="line"></span><br><span class="line">include(<span class="string">&quot;:anotherLibrary&quot;</span>)</span><br><span class="line">project(<span class="string">&quot;:anotherLibrary&quot;</span>).projectDir = File(rootDir, <span class="string">&quot;../another-library&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="6-build-gradle是什么？"><a href="#6-build-gradle是什么？" class="headerlink" title="6.build.gradle是什么？"></a>6.<code>build.gradle</code>是什么？</h3><p>到了我们最熟悉也是最常用的<code>build.gradle</code>了，每个模块都会有一个<code>build.gradle</code>来配置当前模块的构建信息, 根目录模块的<code>build.gradle</code>叫做 <code>root build script</code>, 其他子模块的 <code>build script</code> 叫做 <code>module build script</code>.</p><p>项目构建的流程大致如下所示，其中的<code>init script</code>指<code>$GRADLE_USER_HOME</code>目录下的<code>init.gradle</code>文件，主要做一些初始化配置<br> 单模块构建的执行流程大致为: <code>init script</code> -&gt; <code>setting script</code> -&gt; <code>build script</code><br> 而多模块的构建流程, 比单模块多了一步: <code>init script</code> -&gt; <code>setting script</code> -&gt; <code>root build script</code> -&gt; <code>build script</code></p><p>一般而言, <code>root build script</code> 并不是一个实际的模块, 而是用于对子模块进行统一的配置, 所以 <code>root build script</code> 一般不会有太多的内容.</p><p><code>Gradle</code> 在 <code>Initialization</code> 阶段还没有执行 <code>build.gradle(.kts)</code> 文件, 真正解析 <code>build script</code> 是在 <code>Configuration</code> 阶段. 但是 <code>build script</code> 的执行比较特殊, 它并不是简单执行所有代码, 其本质是 <strong>用代码描述和配置构建规则, 然后按规则执行任务</strong>. <code>Build script</code> 作为整个 <code>Gradle</code> 中配置最复杂的脚本, 实际上仅仅做了两件事: 一个是引入插件, 另一个是配置属性</p><p>所谓引入插件如下所示，<code>plugins</code> 闭包中还可以通过 <code>version</code> 指定插件的版本, 以及 <code>apply</code> 来决定是否立刻应用插件:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id(<span class="string">&quot;com.android.application&quot;</span>)</span><br><span class="line">    id(<span class="string">&quot;com.dorongold.task-tree&quot;</span>)   version <span class="string">&quot;1.4&quot;</span></span><br><span class="line">    id(<span class="string">&quot;com.dorongold.task-tree&quot;</span>)   version <span class="string">&quot;1.4&quot;</span>   apply <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而所谓配置属性, 实际上是对引入的插件进行配置. 原本 <code>build script</code> 中并没有 <code>android &#123;...&#125;</code> 这个 <code>dsl</code> 属性, 这是 <code>plugin</code> 提供的. 一旦应用了某个插件, 就可以使用插件提供的 <code>dsl</code> 对其进行配置, 从而影响该模块的构建过程. 换个角度看, 这些插件提供的属性配置 <code>dsl</code> 就相当于插件 <code>init</code> 函数的参数, 最终传入到插件中. 当构建执行的时候就会根据配置对当前模块进行编译.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id(<span class="string">&quot;com.android.application&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion(<span class="number">28</span>)</span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure><h2 id="7-Gradle生命周期是怎样的"><a href="#7-Gradle生命周期是怎样的" class="headerlink" title="7. Gradle生命周期是怎样的?"></a>7. <code>Gradle</code>生命周期是怎样的?</h2><p>在了解了上面这些知识后，我们可以开始了解一下<code>Gradle</code>的生命周期。在了解了<code>Gradle</code>的生命周期后，我们可以对<code>Gradle</code>执行的总体流程有一个了解，也可以利用这些生命周期做一些<code>Hook</code>的操作</p><p>不同于传统脚本的自上而下执行, 一次 <code>Gradle</code> 构建涉及到多个文件, 主体流程如下:<br> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3eee5d921c6c40bc9a4cd41ac3fbf24a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p><p>图片来源：<a href="https://juejin.cn/book/6844733819363262472/section/6844733819421999118">juejin.cn&#x2F;book&#x2F;684473…</a></p><p>总体来说, <code>Gradle</code> 的执行分为三大阶段: <code>Initialization</code> -&gt; <code>Configuration</code> -&gt; <code>Execution</code>. 每个阶段都有自己的职责.</p><h2 id="7-1-Initialization阶段"><a href="#7-1-Initialization阶段" class="headerlink" title="7.1 Initialization阶段"></a>7.1 <code>Initialization</code>阶段</h2><p><code>Initialization</code> 阶段主要目的是初始化构建, 它又分为两个子过程, 一个是执行 <code>Init Script</code>, 另一个是执行 <code>Setting Script</code>.<br> <code>Init script</code> 会读取全局脚本, 主要作用是初始化一些全局通用的属性, 例如获取 <code>Gradle User Home</code> 目录, <code>Gradle version</code> 等<br> 而<code>Setting Script</code>就是我们上面提到的<code>settings.gradle</code></p><h2 id="7-2-Configuration阶段"><a href="#7-2-Configuration阶段" class="headerlink" title="7.2 Configuration阶段"></a>7.2 <code>Configuration</code>阶段</h2><p>当构建完成 <code>Initialization</code> 阶段后, 将进入 <code>Configuration</code> 阶段. 这个阶段开始加载项目中所有模块的 <code>Build Script</code>. 所谓 “加载” 就是执行 <code>build.gradle(.kts)</code> 中的语句, 根据脚本代码创建对应的 <code>task</code>, 最终根据所有 <code>task</code> 生成对应的依赖图. 我们上面说过”<code>Gradle</code>核心模型是一个 <code>Task</code> 组成的有向无环图(<code>Directed Acyclic Graphs</code>)” 吗? 这个任务依赖图就是在这个阶段生成的.</p><p>需要注意的是，<code>Configuration</code>阶段各个模块的加载顺序是无序的，跟依赖关系与加入顺序都没有关系</p><h2 id="7-3-Execution阶段"><a href="#7-3-Execution阶段" class="headerlink" title="7.3 Execution阶段"></a>7.3 <code>Execution</code>阶段</h2><p>当完成任务依赖图后, <code>Gradle</code> 就做好了一切准备, 然后进入 <code>Execution</code> 阶段. 这个阶段才真正进行编译和打包动作. 对于 <code>Java</code> 而言是调用 <code>javac</code> 编译源码, 然后打包成 <code>jar</code>. 对于 <code>Android</code> 而言则更加复杂些. 这些差异来源于我们应用的插件. 总得来说，就是开始执行<code>task</code>了</p><h2 id="7-4-生命周期-Hook"><a href="#7-4-生命周期-Hook" class="headerlink" title="7.4 生命周期 Hook"></a>7.4 生命周期 <code>Hook</code></h2><p><code>Gradle</code> 提供了丰富的生命周期 <code>Hook</code>，我们可以根据我们的需要添加各种<code>HooK</code><br> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/428ff3d7635e4dc8b16fbdca8e60e9d6~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p><p>图片来源：<a href="https://juejin.cn/book/6844733819363262472/section/6844733819421999118">juejin.cn&#x2F;book&#x2F;684473…</a></p><p>根据图中生命周期的位置, 可以清楚地了解到 “生命周期的最晚注册时机”. 比如, <code>settingsEvaluated</code> 是在 <code>setting script</code> 被 <code>evaluated</code> 完毕后回调, 那么在 <code>init script</code> 和 <code>setting script</code> 中注册都是没问题的. 但是如果注册在 <code>build script</code> 中, 则无法发挥作用.</p><p>同时关于生命周期<code>Hook</code>，还有下面几点需要注意</p><ol><li><code>projectsLoaded</code>之前<code>Project</code>还没有创建，因此只能使用<code>gradle</code> 和 <code>settings</code> 对象</li><li><code>projectsLoaded</code> 回调时已经根据 <code>setting script</code> 创建了各个模块的 <code>Project</code> 对象, 我们可以引用 <code>project</code> 对象从而设置一些 <code>hook</code>，便是<code>build script</code>还没有被配置，因此拿不到配置信息</li><li>每当一个 <code>build.gradle(.kts)</code> 被执行完毕, 都会产生 <code>afterEvaluate</code> 回调, 代表着 <code>project</code> 被 <code>evaluate</code> 完成. 从此, <code>project</code> 对象内容完整了, 即: 当前 <code>build.gradle(.kts)</code> 中所有的配置项都能够被访问.</li><li>所有的<code>Project</code>配置结束，会回调<code>projectsEvaluated</code></li><li><code>Gradle</code> 的核心逻辑就是根据 <code>task</code> 的依赖关系生成有向无环图, 然后依次执行图中的 <code>task</code>，<code>task graph</code>生成后会回调<code>graphPopulated</code></li><li>当所有<code>task</code>都执行完毕, 整个构建也宣告结束，这个时候会回调<code>buildFinished</code></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要本文主要介绍<code>Gradle</code>的一些基础知识与原理，包括<code>Gradle</code>各个文件的作用，以及生命周期，构建总体流程，以及生命周期<code>Hook</code>方法等<br> 了解<code>Gradle</code>的这些基础原理，可以帮助我们更好的了解<code>Android</code>构建打包的过程，也方便我们利用<code>Gradle</code>生命周期做一些<code>Hook</code>工作，提升开发效率。<br> 如果本文对你有所帮助，欢迎点赞，收藏，评论~</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>作者：程序员江同学<br>链接：<a href="https://juejin.cn/post/7064350945756332040">https://juejin.cn/post/7064350945756332040</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;对于&lt;code&gt;Android&lt;/code&gt;开发者来说，&lt;code&gt;Gradle&lt;/code&gt;也可以说是熟悉的陌生人了，可以说天天会用到&lt;c</summary>
      
    
    
    
    <category term="Gradle" scheme="https://stevezhangzl.github.io/categories/Gradle/"/>
    
    
  </entry>
  
  <entry>
    <title>密码学-对称加密</title>
    <link href="https://stevezhangzl.github.io/2023/01/06/%E5%AF%86%E7%A0%81%E5%AD%A6-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    <id>https://stevezhangzl.github.io/2023/01/06/%E5%AF%86%E7%A0%81%E5%AD%A6-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/</id>
    <published>2023-01-06T05:07:59.000Z</published>
    <updated>2023-01-16T22:23:55.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>流加密算法</li><li>分组加密算法</li></ul><h2 id="分组加密算法"><a href="#分组加密算法" class="headerlink" title="分组加密算法"></a>分组加密算法</h2><p>又称块加密算法，就一组一组进行加解密。它将明文分成多个等长的块(block，或称分组)，使用确定的算法和对称密钥对每组分别加解密。通俗地讲，就是一组一组地进行加解密，而且每组数据长度相同。</p><h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><table><thead><tr><th>加密模式</th><th>特点</th></tr></thead><tbody><tr><td>ECB（电子密码本模式）</td><td>分组之间没有关联，简单快速，可并行计算</td></tr><tr><td>CBC（密码分组链接模式）</td><td>仅解密支持并行计算</td></tr><tr><td>CFB（加密反馈模式）</td><td>仅解密支持并行计算</td></tr><tr><td>OFB（输出反馈模式）</td><td>不支持并行运算</td></tr><tr><td>CTR（计算器模式）</td><td>支持并行计算</td></tr></tbody></table><h4 id="1-ECB模式"><a href="#1-ECB模式" class="headerlink" title="1.ECB模式"></a>1.ECB模式</h4><p><img src="/../images/image-20230116101308288.png" alt="image-20230116101308288"></p><p>每个分组的运算（加密或解密）都是<code>独立</code>的，每个分组加密只加密只需要<code>密钥</code>和该<code>明文分组</code>即可，每个分组解密只需要密钥和该密文分组即可。这就产生了一个问题，即<code>加密时相同内容的明文块将得到相同的密文块</code>（密钥相同，输入相同，得到结果也就相同了），这样就难以抵抗统计分析攻击了。ECB每组没关系也促成其优点，比如有利于<code>并行计算</code>、<code>误差不会被传送</code>、<code>运算简单</code>、<code>不需要初始向量（IV）</code>。</p><p>该模式的特点是：简单、快速，加密和解密过程支持并行计算；明文中的重复排列会反映在密文中；通过删除、替换密文分组可以对明文进行操作（即可攻击），无法抵御重放攻击；对包含某些比特错误的密文进行解密时，对应的分组会出错。</p><h4 id="2-CBC模式"><a href="#2-CBC模式" class="headerlink" title="2.CBC模式"></a>2.CBC模式</h4><p><img src="/../images/image-20230116081228476.png" alt="image-20230116081228476"></p><p>初始向量(IV) 也称为初向量，是一个固定长度的比特串。一般使用用上会要求它是随机数或伪随机数。使用<code>随机数产生的初始向量</code>使得同一个密钥加密的结果每次都不同，这样攻击者难以对同一把密钥的密文进行破解。</p><p>加密时，第一个明文块和初始向量（IV）进行异或后，再用key进行加密，以后每个明文块与前一个分组结果（密文）块进行异或，再用key进行加密。解密时，第一个密文块先用key解密，得到中间结果再与初始向量（IV）进行异或得到第一个明文分组（第一个分组的最终明文结果），后面每个密文块也是先用key解密，得到的中间结果再与前一个密文分组（注意是解密之前的密文分组），进行异或后得到本次明文分组。在这种方法中，每个分组的结果都依赖于它前面的分组。同时，第一个分组也依赖于IV，IV的长度和分组相同。需要注意的是，加密时的IV和解密时的IV必须相同。</p><p>CBC模式需要初始化向量IV（长度与分组大小相同），参与计算第一组密文，第一组密文当作向量与第二组数据一起计算后再进行加密以产生第二组密文，后面以此类推。</p><p>CBC是最常用的工作模式，主要缺点在于加密过程是串行的，无法被并行化（因为后一个运算要等到前一个运算的结果后才能开始）。另外，明文中的微小改变会导致其后的全部密文块发生改变，这是其又一个缺点：加密时可能会有误差传递。</p><p>在解密时，因为是把前一个密文分组作为当前向量，不必等前一个分组运算完毕，所以解密时可以并行化。解密时，密文中一位的改变只会导致其对应的明文块发生改变和下一个明文块中对应位（因为是异或运算）发生改变，不会影响到其他明文的内容，所以解密时不会误差传递。</p><p>该模式的特点是：明文的重复排列不会反映在密文中；只有解密过程可以并行计算，加密过程需要前一个密文组，无法进行并行计算；能够解密任意密文分组；对包含某些错误bite的密文进行解密，第一个分组的全部bite（全部是由于密文参与了解密算法）和后一个分组的相应的bite会出错（相应是由于出错的密文在后一组中只参与了XOR运算）；填充提示攻击。</p><h3 id="短块加密"><a href="#短块加密" class="headerlink" title="短块加密"></a>短块加密</h3><p>分组密码一次只能对一个固定长度的明文（密文）块进行加（解）密。当最后一次要处理的数据小于分组长度时，就要进行特殊处理。这里把长度小于分组长度的数据称为<code>短块</code>。<code>短块</code>因为不足一个分组，所以不能直接进行加解密，必须采用合适的技术手段解决短块加解密问题。比如，要加密33个字节，前面32个字节是16的整数倍，可以直接加密，剩下的1个字节就不能直接加密了，因为不足一个分组的长度。</p><p>对于短块的处理，通常有3种技术方案：</p><p>（1）填充技术</p><p>填充技术就是用无用的数据填充短块，使之成为标准块（长度为一个分组的数据块）。填充的方式可以自定义，比如填0、填充的数据长度值、随机数等。严格来讲，为了确保加密强度，填充的数据应是随机数。<code>但是收信者如何知道哪些数字是填充的呢？</code>这就需要增加指示信息了，通常是用<code>最后8位</code>作为<code>填充指示符</code>，比如最后一个字节存放填充的数据的长度。</p><blockquote><p>值得注意的是，填充可能引起存储器溢出，因而可能不适合文件和数据块加密。填充加密后，密文长度就跟明文长度不一样的。</p></blockquote><p>（2）密文挪用技术</p><p>（3）序列加密</p><h3 id="DES和3DES算法"><a href="#DES和3DES算法" class="headerlink" title="DES和3DES算法"></a>DES和3DES算法</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>DES是一种分组加密算法，该算法每次处理固定长度的数据段，称之为分组。DES分组的大小是64位（8字节），如果加密的数据长度不是64位的倍数，就可以按照某种具体的规则来填充位。DES算法保密性依赖于密钥，保护密钥异常重要。</p><p>DES加密技术是一种常用的对称加密技术。算法公开，加密强度大，运算速度快。</p><h4 id="DES算法的密钥"><a href="#DES算法的密钥" class="headerlink" title="DES算法的密钥"></a>DES算法的密钥</h4><p>严格来讲，DES算法的密钥长度为<code>56位</code>，通常用一个64位的数来表示密钥，然后经过转换得到56位的密钥，而第8、16、24、32、40、48、56、64位是校验位（<code>共8个较验位</code>），不参与DES加解密运算，所以这些位上的数值不能算密钥。为了方便区分，我们把64位的数称为从用户处取得的<code>用户密钥</code>，而56位的数称为<code>初始密钥</code>（或<code>工作密钥</code>，或<code>有效输入密钥</code>）。</p><p>DES的安全性首先取决于密钥的长度。密钥越长，破译者利用穷举法搜索密钥的难度就越大。目前，根据当今计算机的处理速度和能力，56位长度的密钥已经能够被破解，128位的密钥则被认为是安全的，随着时间的推移，这个数字迟早会被突破。</p><p>具体加解密运算前，DES算法的密钥还要通过等分、移位、选取、迭代形成<code>16个子密钥</code>，分别供每一轮运算使用，每个子密钥为48bit。计算出子密钥是进行DES加密的前提条件。</p><h4 id="3DES"><a href="#3DES" class="headerlink" title="3DES"></a>3DES</h4><p>3DES为DES向AES过渡的加密算法，使用3条56位密钥对数据进行3次加解密。</p><h3 id="实现DES算法（OpenSSL版）"><a href="#实现DES算法（OpenSSL版）" class="headerlink" title="实现DES算法（OpenSSL版）"></a>实现DES算法（OpenSSL版）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/des.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>**)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//转换schedule</span></span><br><span class="line"><span class="comment">//DES密钥结构体</span></span><br><span class="line">   DES_cblock key;</span><br><span class="line">    <span class="comment">//生成随机密钥</span></span><br><span class="line">   <span class="built_in">DES_random_key</span>(&amp;key);</span><br><span class="line"></span><br><span class="line">   DES_key_schedule schedule;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转换成schedule</span></span><br><span class="line">   <span class="built_in">DES_set_key_checked</span>(&amp;key,&amp;schedule);</span><br><span class="line"></span><br><span class="line">   const_DES_cblock input=  <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">   DES_cblock output;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;cleartext:%s\n&quot;</span>,input);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//加密 input指向输入缓冲区，加密时表示明文，解密时表示密文；output表示输出缓冲区，加密时表示密文，解密时表示明文 schedule指向密钥缓冲区，最后一个参数表示加密还是解密</span></span><br><span class="line">   <span class="built_in">DES_ecb_encrypt</span>(&amp;input,&amp;output,&amp;schedule,DES_ENCRYPT);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Encrypted\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;ciphertext:&quot;</span>);</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in"><span class="keyword">sizeof</span></span>(input); i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%02x&quot;</span>,output[i]);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   <span class="comment">//解密</span></span><br><span class="line">   <span class="built_in">DES_ecb_encrypt</span>(&amp;output,&amp;input,&amp;schedule,DES_DECRYPT);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Decrypted.\n&quot;</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;clearText:%s\n&quot;</span>,input);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SM4算法"><a href="#SM4算法" class="headerlink" title="SM4算法"></a>SM4算法</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>SM4算法（全称为SM4分组密码算法），该算法适用于无线局域网的安全领域，优点是软件和破件实现容易，运算速度快。</p><p>SM4分组密码算法是一个迭代分组密码算法，由加解密算法和密钥扩展算法组成。SM4分组密码算法采用非平衡Feistel结构，明文分组长度为128bit，密钥长度为128bit。加密算法与密钥扩展算法都采用32轮非线性迭代结构。解密算法与加密算法的结构相同，只是轮密钥的使用顺序相反，解密轮密钥是加密轮密钥的逆序。</p><h2 id="利用OpenSSL进行对称加解密"><a href="#利用OpenSSL进行对称加解密" class="headerlink" title="利用OpenSSL进行对称加解密"></a>利用OpenSSL进行对称加解密</h2><h3 id="对称加解密相关的函数"><a href="#对称加解密相关的函数" class="headerlink" title="对称加解密相关的函数"></a>对称加解密相关的函数</h3><h4 id="1-上下文初始化函数EVP-CLPHER-CTX-init"><a href="#1-上下文初始化函数EVP-CLPHER-CTX-init" class="headerlink" title="1.上下文初始化函数EVP_CLPHER_CTX_init"></a>1.上下文初始化函数<code>EVP_CLPHER_CTX_init</code></h4><p>该函数用于初始化密码算法上下文结构体，即<code>EVP_CIPHER_CTX</code>结构体，只有经过初始化的<code>EVP_CIPHER_CTX</code>结构体才能在后续函数中使用。该函数声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EVP_CIPHER_CTX_init</span><span class="params">(EVP_CIPHER_CTX *a)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，参数a是要初始化的密码算法上下文结构体指针，该结构体定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evp_cipher_ctx_st</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> EVP_CIPHER *cipher;</span><br><span class="line">    ENGINE *engine;             <span class="comment">/* functional reference if &#x27;cipher&#x27; is</span></span><br><span class="line"><span class="comment">                                 * ENGINE-provided */</span></span><br><span class="line">    <span class="keyword">int</span> encrypt;                <span class="comment">/* encrypt or decrypt */</span></span><br><span class="line">    <span class="keyword">int</span> buf_len;                <span class="comment">/* number we have left */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> oiv[EVP_MAX_IV_LENGTH]; <span class="comment">/* original iv */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> iv[EVP_MAX_IV_LENGTH]; <span class="comment">/* working iv */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buf[EVP_MAX_BLOCK_LENGTH]; <span class="comment">/* saved partial block */</span></span><br><span class="line">    <span class="keyword">int</span> num;                    <span class="comment">/* used by cfb/ofb/ctr mode */</span></span><br><span class="line">    <span class="comment">/* <span class="doctag">FIXME:</span> Should this even exist? It appears unused */</span></span><br><span class="line">    <span class="keyword">void</span> *app_data;             <span class="comment">/* application stuff */</span></span><br><span class="line">    <span class="keyword">int</span> key_len;                <span class="comment">/* May change for variable length cipher */</span></span><br><span class="line">    <span class="keyword">int</span> iv_len;                 <span class="comment">/* IV length */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;        <span class="comment">/* Various flags */</span></span><br><span class="line">    <span class="keyword">void</span> *cipher_data;          <span class="comment">/* per EVP data */</span></span><br><span class="line">    <span class="keyword">int</span> final_used;</span><br><span class="line">    <span class="keyword">int</span> block_mask;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="keyword">final</span>[EVP_MAX_BLOCK_LENGTH]; <span class="comment">/* possible final block */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Opaque ctx returned from a providers cipher algorithm implementation</span></span><br><span class="line"><span class="comment">     * OSSL_FUNC_cipher_newctx()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> *algctx;</span><br><span class="line">    EVP_CIPHER *fetched_cipher;</span><br><span class="line">&#125; <span class="comment">/* EVP_CIPHER_CTX */</span> ;</span><br></pre></td></tr></table></figure><h4 id="2-加密初始化函数EVP-EncryptInit-ex"><a href="#2-加密初始化函数EVP-EncryptInit-ex" class="headerlink" title="2.加密初始化函数EVP_EncryptInit_ex"></a>2.加密初始化函数<code>EVP_EncryptInit_ex</code></h4><p>该函数用于加密初始化，设置具体加密算法、加密引擎、密钥、初始向量等参数。该函数声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_EncryptInit_ex</span><span class="params">(EVP_CIPHER_CTX *ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="keyword">const</span> EVP_CIPHER *cipher, ENGINE *impl,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *key,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *iv)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>ctx</strong>：是已经被函数EVP_CIPHER_CTX_init初始化过的算法上下文结构体指针。</li><li><strong>impl</strong>：指向ENGINE结构体的指针，表示加密算法的引擎，可以理解为加密算法的提供者，比如是硬件加密卡提供者、软件算法提供者等，如果取值为NULL，就使用默认引擎。</li><li><strong>key</strong>：表示加密密钥，长度根据不同的加密算法而定。</li><li><strong>iv</strong>：初始向量，当cipher所指向的算法为CBC模式的算法才有效，因为CBC模式需要初始向量的输入，长度是对称算法分组长度。</li><li><strong>返回值</strong>：如果函数执行成功返回1，否则返回0。</li><li><strong>cipher</strong>：表示具体的加密函数，它是一个指向EVP_CIPHER结构体的指针，指向一个EVP_CIPHER*类型的函数。在OpenSSL中，对称加密算法的格式都以函数形式提供，其实该函数返回一个该算法的结构体，其形式一般如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVP_CIPHER* EVP_*(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure><p>常用的加密算法如下</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><strong>NULL算法函数</strong></td><td></td></tr><tr><td>const EVP_CIPHER* EVP_enc_null(void);</td><td>该算法不做任何事情，也就是没有进行加密处理</td></tr><tr><td><strong>DES 算法函数</strong></td><td></td></tr><tr><td>const EVP_CIPHER* EVP_des_cbc(void);</td><td>CBC方式的DES算法</td></tr><tr><td>const EVP_CIPHER* EVP_des_ecb(void);</td><td>ECB方式的DES算法</td></tr><tr><td>const EVP_CIPHER* EVP_des_cfb(void);</td><td>CFB方式的DES算法</td></tr><tr><td>const EVP_CIPHER* EVP_des_ofb(void);</td><td>OFB方式的DES算法</td></tr><tr><td><strong>使用两个密钥的3DES算法</strong></td><td></td></tr><tr><td>const EVP_CIPHER *EVP_des_ede_cbc(void);</td><td>CBC方式的3DES算法，算法的第一个密钥和最后一<br />个密钥相同，这样实际上就只需要两个密钥</td></tr><tr><td>const EVP_CIPHER *EVP_des_ede_ecb(void);</td><td>ECB方式的3DES算法，算法的第一个密钥和最后一<br />个密钥相同，这样实际上就只需要两个密钥</td></tr><tr><td>const EVP_CIPHER *EVP_des_ede_ofb(void);</td><td>OFB方式的3DES算法，算法的第一个密钥和最后一<br />个密钥相同，这样实际上就只需要两个密钥</td></tr><tr><td>const EVP_CIPHER *EVP_des_ede_cfb(void);</td><td>CFB方式的3DES算法，算法的第一个密钥和最后一<br />个密钥相同，这样实际上就只需要两个密钥</td></tr><tr><td><strong>使用三个密钥的3DES算法</strong></td><td></td></tr><tr><td>const EVP_CIPHER *EVP_des_ede3_cbc(void);</td><td>CBC方式的3DES算法，算法的三个密钥都不相同</td></tr><tr><td>const EVP_CIPHER *EVP_des_ede3_ecb(void);</td><td>ECB方式的3DES算法，算法的三个密钥都不相同</td></tr><tr><td>const EVP_CIPHER *EVP_des_ede3_ofb(void);</td><td>OFB方式的3DES算法，算法的三个密钥都不相同</td></tr><tr><td>const EVP_CIPHER *EVP_des_ede3_cfb(void);</td><td>CFB方式的3DES算法，算法的三个密钥都不相同</td></tr><tr><td><strong>DESX算法</strong></td><td></td></tr><tr><td>const EVP_CIPHER *EVP_desx_cbc(void);</td><td>CBC方式的DESX算法</td></tr><tr><td><strong>RC4算法</strong></td><td></td></tr><tr><td>const EVP_CIPHER *EVP_rc4(void);</td><td>RC4流加密算法。该算法的密钥长度可以改变，默认是128位</td></tr><tr><td><strong>40位RC4算法</strong></td><td></td></tr><tr><td>const EVP_CIPHER *EVP_rc4_40(void);</td><td>密钥长度40位的RC4流加密算法。该函数可以使用<br />EVP_rc4和EVP_CHIPHER_CTX_set_key_length函数代替</td></tr><tr><td><strong>128位AES算法</strong></td><td></td></tr><tr><td>const EVP_CIPHER *EVP_aes_128_cbc(void);</td><td>CBC方式的128位AES算法</td></tr><tr><td>const EVP_CIPHER *EVP_aes_128_ecb(void);</td><td>ECB方式的128位AES算法</td></tr><tr><td>const EVP_CIPHER *EVP_aes_128_cfb(void);</td><td>CFB方式的128位AES算法</td></tr><tr><td>const EVP_CIPHER *EVP_aes_128_ofb(void);</td><td>OFB方式的128位AES算法</td></tr><tr><td><strong>256位AES算法</strong></td><td></td></tr><tr><td>const EVP_CIPHER *EVP_aes_256_cbc(void);</td><td>CBC方式的256位AES算法</td></tr><tr><td>const EVP_CIPHER *EVP_aes_256_ecb(void);</td><td>ECB方式的256位AES算法</td></tr><tr><td>const EVP_CIPHER *EVP_aes_256_cfb(void);</td><td>CFB方式的256位AES算法</td></tr><tr><td>const EVP_CIPHER *EVP_aes_256_ofb(void);</td><td>OFB方式的256位AES算法</td></tr><tr><td></td><td></td></tr></tbody></table><p><code>**值得注意提，key和iv的长度都是根据不同算法而有默认值的，比DES算法的key和iv都是8字节长度；3DES算法的key的长度是24字节，iv是8字节；128位的AES算法的key和iv都是16字节。使用时要先根据算法分配好key和iv的长度空间。**</code></p><h4 id="3-加密update函数EVP-EncryptUpdate"><a href="#3-加密update函数EVP-EncryptUpdate" class="headerlink" title="3.加密update函数EVP_EncryptUpdate"></a>3.加密update函数EVP_EncryptUpdate</h4><p>该函数执行对数据的加密。该函数加密从参数in输入的长度为inl的数据，并将加密好的数据写入参数out中。可以通过反复调用该函数来处理一个连续的数据块（也就是所谓的分组加密，一组一组地加密）。写入out的数据数量是由已经加密的数据的对齐关系决定的，理论上来说，从0到(inl + cipher_blocc_size-1)的任何一个数字都有可能（单位是字节），所以输出的参数out要有足够的空间存储数据。函数声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_EncryptUpdate</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="keyword">int</span> *outl, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *in, <span class="keyword">int</span> inl)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>ctx：指向EVP_CIPHER_CTX的指针，应该已经初始化过了。</li><li>out：指向存放输出密文的缓冲区指针</li><li>outl：输出密文的长度</li><li>in：指向存放明文的缓冲区指针</li><li>inl：要加密的明文长度</li><li>返回值：如果函数执行成功就返回1，否则返回0。</li></ul><h4 id="4-加密结束函数EVP-EncryptFinal-ex"><a href="#4-加密结束函数EVP-EncryptFinal-ex" class="headerlink" title="4.加密结束函数EVP_EncryptFinal_ex"></a>4.加密结束函数<code>EVP_EncryptFinal_ex</code></h4><p>函数EVP_EncryptFinal_ex用于结束数据加密，并输出最后剩余的密文。由于分组对称算法是对数据块（分组）操作的，原文数据（明文）的长度不一定为分组长度的倍数，因此存在数据补齐（就是在原文数据的基础上进行填充，填充到整个数据长度为分组的倍数），那么最后输出的密文就是补齐后的分组密文。比如使用DES算法加密10个字节的长度的数据，由于DES算法的分组长度是8个字节，因为原文将补齐到16字节。当调用EVP_EncryptUpdate函数时返回8个字节密文，EVP_EncryptFinal_ctx函数返回最后剩余的8字节密文。函数EVP_EncryptFinal_ex声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_EncryptFinal_ex</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">int</span> *outl)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>ctx：EVP_CIPHER_CTX结构体。</li><li>out：指向输出密文缓冲区的指针</li><li>outl：指向一个整形变量，该变量存储输出的密文数据长度</li><li>返回值：如果函数执行成功返回1，否则返回0。</li></ul><h4 id="5-解密初始化函数EVP-DecryptInit-ex"><a href="#5-解密初始化函数EVP-DecryptInit-ex" class="headerlink" title="5.解密初始化函数EVP_DecryptInit_ex"></a>5.解密初始化函数<code>EVP_DecryptInit_ex</code></h4><p>和加密一样，解密时也要先初始化，用于设置密码算法、加密引擎、密钥、初始向量等参数。函数EVP_DecryptInit_ex声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_DecryptInit_ex</span><span class="params">(EVP_CIPHER_CTX *ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="keyword">const</span> EVP_CIPHER *cipher, ENGINE *impl,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *key,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *iv)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>ctx</strong>：是已经被函数EVP_CIPHER_CTX_init初始化过的算法上下文结构体指针。</li><li><strong>impl</strong>：指向ENGINE结构体的指针，表示加密算法的引擎，可以理解为加密算法的提供者，比如是硬件加密卡提供者、软件算法提供者等，如果取值为NULL，就使用默认引擎。</li><li><strong>key</strong>：表示加密密钥，长度根据不同的加密算法而定。</li><li><strong>iv</strong>：初始向量，当cipher所指向的算法为CBC模式的算法才有效，因为CBC模式需要初始向量的输入，长度是对称算法分组长度。</li><li><strong>返回值</strong>：如果函数执行成功返回1，否则返回0。</li><li><strong>cipher</strong>：表示具体的解密函数，它是一个指向EVP_CIPHER结构体的指针，指向一个EVP_CIPHER*类型的函数。在OpenSSL中，对称加密算法的格式都以函数形式提供，其实该函数返回一个该算法的结构体。</li></ul><h4 id="6-解密update函数EVP-DecryptUpdate"><a href="#6-解密update函数EVP-DecryptUpdate" class="headerlink" title="6.解密update函数EVP_DecryptUpdate"></a>6.解密update函数EVP_DecryptUpdate</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_DecryptUpdate</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="keyword">int</span> *outl, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *in, <span class="keyword">int</span> inl)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="7-解密结束函数EVP-DecryptFinal-ex"><a href="#7-解密结束函数EVP-DecryptFinal-ex" class="headerlink" title="7.解密结束函数EVP_DecryptFinal_ex"></a>7.解密结束函数EVP_DecryptFinal_ex</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_DecryptFinal_ex</span><span class="params">(EVP_CIPHER_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *outm,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">int</span> *outl)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="具体使用流程："><a href="#具体使用流程：" class="headerlink" title="具体使用流程："></a>具体使用流程：</h4><ol><li>EVP_CIPHER_CTX_init：初始化对称计算上下文。</li><li>EVP_des_ede3_ecb：返回一个EVP_CIPHER，假设现在使用DES算法。</li><li>EVP_EncryptInit_ex：加密初始化函数，本函数调用具体算法的init回调函数，将外送密钥key转换为内部密钥形式，将初始向量iv复制到CTX结构中。</li><li>EVP_EncryptUpdate：加密函数，用于多将计算，它调用了具体算法的do_cipher回调函数。</li><li>EVP_EncryptFinal_ex：获取加密结果，函数可能涉及填充，它调用了具体算法的do_cipher回调函数</li><li>EVP_DecryptInit_ex：解密初始化</li><li>EVP_DecryptUpdate：解密函数，用于多将计算，它调用了具体算法的do_cipher回调函数。</li><li>EVP_DecryptFinal和EVP_DecryptFinal_ex：获取解密结果，函数可能涉及填充，它调用了具体算法的do_cipher回调函数</li><li>EVP_CIPHER_CTX_cleanup：清除对称算法上下文数据，它调用用户提供的销毁函数清除内存中的内部密钥以及其他数据。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;流加密算法&lt;/li&gt;
&lt;li&gt;分组加密算法&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;分组加密算法&quot;&gt;&lt;a href=&quot;#分组加密算法&quot; class=&quot;headerlink&quot; title=&quot;分组加密算法&quot;&gt;&lt;/a&gt;分组加密算法&lt;/h2&gt;&lt;p&gt;又称块加密算法，就一组一</summary>
      
    
    
    
    <category term="密码学" scheme="https://stevezhangzl.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>气象数据-第2章如何保证服务程序永不停机-8-进程的心跳机制</title>
    <link href="https://stevezhangzl.github.io/2022/12/23/%E6%B0%94%E8%B1%A1%E6%95%B0%E6%8D%AE-%E7%AC%AC2%E7%AB%A0%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E6%B0%B8%E4%B8%8D%E5%81%9C%E6%9C%BA-8-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6/"/>
    <id>https://stevezhangzl.github.io/2022/12/23/%E6%B0%94%E8%B1%A1%E6%95%B0%E6%8D%AE-%E7%AC%AC2%E7%AB%A0%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E6%B0%B8%E4%B8%8D%E5%81%9C%E6%9C%BA-8-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6/</id>
    <published>2022-12-23T00:53:44.000Z</published>
    <updated>2023-01-16T22:23:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><ul><li>服务程序由调度程序启动（procctl）。</li><li>如果服务程序死机（挂起），守护进程将终止它。</li><li>服务程序被终止后，调度程序（procctl）将重新启动它。</li></ul><h2 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h2><p><img src="/../images/image-20221223085846598.png" alt="image-20221223085846598"></p><p>每个服务程序往共享内存刷新自己的心跳信息，守护进程监控共享内存的心跳信息，如果当前时间 - 最后一次心跳时间&gt; 超时时间，则判断程序异常</p><ul><li>服务程序在共享内存中维护自己的心跳信息。</li><li>开发守户程序，终止已经死机的服务程序。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;_public.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXNUMP_    1000            <span class="comment">//最大的进程数量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHMEKEYP_   0X5095          <span class="comment">//共享内存的key</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEMKEYP_    0x4099          <span class="comment">//信号量的key</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st_pinfo</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> pid;                    <span class="comment">//进程id</span></span><br><span class="line">    <span class="keyword">char</span> pname[<span class="number">51</span>];             <span class="comment">//进程名称，可以为空</span></span><br><span class="line">    <span class="keyword">int</span> timeout;                <span class="comment">//超时时间，单位：秒</span></span><br><span class="line">    <span class="keyword">time_t</span> atime;               <span class="comment">//最后一次心跳时间，用整数表示</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Example:\n./csemdemo1 www\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建/获取共享内存，大小为n*sizeof(struct st_pinfo)</span></span><br><span class="line">    <span class="keyword">int</span> m_shmid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>((m_shmid= <span class="built_in">shmget</span>(SHMEKEYP_,MAXNUMP_* <span class="built_in"><span class="keyword">sizeof</span></span>(struct st_pinfo),<span class="number">0640</span>|IPC_CREAT)) == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;shmget(%x) failed\n&quot;</span>,SHMEKEYP_); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CSEM m_sem;</span><br><span class="line">    <span class="keyword">if</span>(!m_sem.<span class="built_in">init</span>(SEMKEYP_))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;m_sem.init(%x) failed\n&quot;</span>,SEMKEYP_);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将共享内存连接到当前进程的地址空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">st_pinfo</span> *<span class="title">m_shm</span>;</span></span><br><span class="line">    m_shm = (struct st_pinfo *)<span class="built_in">shmat</span>(m_shmid,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建当前进程心跳信息结构体变量，把本进程的信息填进去。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">st_pinfo</span> <span class="title">stpinfo</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;stpinfo,<span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(struct st_pinfo));</span><br><span class="line">    stpinfo.pid = <span class="built_in">getpid</span>();</span><br><span class="line">    <span class="built_in">STRNCPY</span>(stpinfo.pname, <span class="built_in"><span class="keyword">sizeof</span></span>(stpinfo.pname),argv[<span class="number">1</span>],<span class="number">50</span>);</span><br><span class="line">    stpinfo.timeout=<span class="number">30</span>;</span><br><span class="line">    stpinfo.atime = <span class="built_in">time</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m_pos = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//进程id是循环使用的，如果曾经有一个进程异常退出，没有清理自己的心跳信息。</span></span><br><span class="line">    <span class="comment">//它的进程信息将残留在共享内存中，不巧的是，当前进程重用了上述进程的id,</span></span><br><span class="line">    <span class="comment">//这样就会在共享内存中存在两个进程id相同的记录，守护进程检查到残留进程的</span></span><br><span class="line">    <span class="comment">//心跳时，会向进程id发送退出信息，这个信号将误杀当前进程。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果共享内存中存在当前进程编号，一定是其他进程残留的数据，当前进程就重用该位置。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ii =<span class="number">0</span>;ii&lt;MAXNUMP_;ii++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_shm[ii].pid == stpinfo.pid)&#123;</span><br><span class="line">            m_pos = ii;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    m_sem.<span class="built_in">P</span>();   <span class="comment">//加锁</span></span><br><span class="line">    <span class="comment">//在共享内存中查找一个空位置，把当前进程的心跳信息存入共享内存中。</span></span><br><span class="line">    <span class="comment">//如果已经找到位置就不找了</span></span><br><span class="line">    <span class="keyword">if</span>(m_pos == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">0</span>;ii&lt;MAXNUMP_;ii++)&#123;</span><br><span class="line">            <span class="comment">//if((m_shm[ii].pid) ==0)</span></span><br><span class="line">            <span class="keyword">if</span>((m_shm +ii)-&gt;pid == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//找到一个空位置。</span></span><br><span class="line">                m_pos = ii; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(m_pos == <span class="number">-1</span>)&#123;</span><br><span class="line">        m_sem.<span class="built_in">V</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;共享内存空间已用完。\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(m_shm+m_pos,&amp;stpinfo, <span class="built_in"><span class="keyword">sizeof</span></span>(struct st_pinfo));</span><br><span class="line"></span><br><span class="line">    m_sem.<span class="built_in">V</span>();</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">//更新共享内存中本进程的心跳时间。</span></span><br><span class="line">        m_shm[m_pos].atime = <span class="built_in">time</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把当前进程从共享内存中移去。</span></span><br><span class="line">    <span class="comment">//m_shm[m_pos].pid = 0;</span></span><br><span class="line">    <span class="built_in">memset</span>(m_shm+m_pos,<span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(struct st_pinfo));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把共享内存从当前进程中分离。</span></span><br><span class="line">    <span class="built_in">shmdt</span>(m_shm);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;守护进程&quot;&gt;&lt;a href=&quot;#守护进程&quot; class=&quot;headerlink&quot; title=&quot;守护进程&quot;&gt;&lt;/a&gt;守护进程&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;服务程序由调度程序启动（procctl）。&lt;/li&gt;
&lt;li&gt;如果服务程序死机（挂起），守护进程将终止它。&lt;/l</summary>
      
    
    
    
    <category term="C项目" scheme="https://stevezhangzl.github.io/categories/C%E9%A1%B9%E7%9B%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>气象数据-第2章如何保证服务程序永不停机-7-Linux信号量</title>
    <link href="https://stevezhangzl.github.io/2022/12/19/%E6%B0%94%E8%B1%A1%E6%95%B0%E6%8D%AE-%E7%AC%AC2%E7%AB%A0%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E6%B0%B8%E4%B8%8D%E5%81%9C%E6%9C%BA-7-Linux%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    <id>https://stevezhangzl.github.io/2022/12/19/%E6%B0%94%E8%B1%A1%E6%95%B0%E6%8D%AE-%E7%AC%AC2%E7%AB%A0%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E6%B0%B8%E4%B8%8D%E5%81%9C%E6%9C%BA-7-Linux%E4%BF%A1%E5%8F%B7%E9%87%8F/</id>
    <published>2022-12-19T01:04:37.000Z</published>
    <updated>2023-01-16T22:23:55.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>1.学习信号量的封装类CSEM的操作</p><p>2.掌握信号量的机制</p></blockquote><ul><li>信号量本质上是一个非负数（&gt;&#x3D;0）的计数器</li><li>给共享资源建立一个标志，表示该共享资源被占用情况</li><li>P操作（申请资源-1），V操作（释放资源+1）</li></ul><ol><li>二值信号量是信号量的一种特殊形式，表示资源只有可用和不可用两种状态：0-不可用；1-可用</li><li>互斥锁。</li></ol><p>借助于前面共享内存的demo我们给它加锁</p><blockquote><p>CSEM调用流程</p><ol><li>csem.init()  如果信号量已存在，获取信号量；如果信号量不存在，则创建它并初始化为value  默认锁的数量为1 是互斥锁</li><li>csem.P() 加锁</li><li>csem.V() 解锁</li></ol></blockquote><p>csemdemo1.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;_public.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CSEM sem;<span class="comment">//用于给共享内存加锁的信号量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st_pid</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> pid;<span class="comment">//进程编号</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">51</span>]; <span class="comment">//进程名称</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Example:\n./csemdemo1 www\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//共享内存的标志。</span></span><br><span class="line">    <span class="keyword">int</span> shmid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取或者创建共享内存，键值为0x5005</span></span><br><span class="line">    <span class="keyword">if</span>((shmid = <span class="built_in">shmget</span>(<span class="number">0x5005</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(struct st_pid),<span class="number">0640</span>|IPC_CREAT)) == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;错误提示&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果信号量已存在，获取信号量；如果信号量不存在，则创建它并初始化为value</span></span><br><span class="line">    <span class="keyword">if</span>(!sem.<span class="built_in">init</span>(<span class="number">0x5005</span>))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sem.init(0x5005) failed\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于指向共享内存的结构体变量。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">st_pid</span> *<span class="title">stpid</span> =</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把共享内存连接到当前进程的地址空间。这种写法要会啊，  void* -&gt; 任意指针     int -&gt; void * 然后才能进行比较</span></span><br><span class="line">    <span class="keyword">if</span>((stpid =(struct st_pid *)<span class="built_in">shmat</span>(shmid,<span class="number">0</span>,<span class="number">0</span>)) == (<span class="keyword">void</span> *)<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;shmat 0x5005 failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//在加锁前后，把当前时间和信号量的值显示出来</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;aaa time=%d,val=%d\n&quot;</span>,<span class="built_in">time</span>(<span class="number">0</span>),sem.<span class="built_in">value</span>());</span><br><span class="line">    sem.<span class="built_in">P</span>();<span class="comment">//加锁</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bbb time=%d,val=%d\n&quot;</span>,<span class="built_in">time</span>(<span class="number">0</span>),sem.<span class="built_in">value</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid=%d,name=%s\n&quot;</span>,stpid-&gt;pid,stpid-&gt;name);</span><br><span class="line">    stpid-&gt;pid = <span class="built_in">getpid</span>();<span class="comment">//进程编号</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(stpid-&gt;name,argv[<span class="number">1</span>]);<span class="comment">//进程名称</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid=%d,name=%s\n&quot;</span>,stpid-&gt;pid,stpid-&gt;name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ccc time=%d,val=%d\n&quot;</span>,<span class="built_in">time</span>(<span class="number">0</span>),sem.<span class="built_in">value</span>());</span><br><span class="line">    sem.<span class="built_in">V</span>(); <span class="comment">//解锁</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ddd time=%d,val=%d\n&quot;</span>,<span class="built_in">time</span>(<span class="number">0</span>),sem.<span class="built_in">value</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把共享内存从当前进程中分离</span></span><br><span class="line">    <span class="built_in">shmdt</span>(stpid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">shmctl</span>(shmid,IPC_RMID,<span class="number">0</span>) == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;shmctl failed\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="/../images/image-20221222094047186.png" alt="image-20221222094047186"></p><p>通过<code>ipcs -s</code>查看信号量</p><p><img src="/../images/image-20221222094202736.png" alt="image-20221222094202736"></p><p>通过<code>ipcrm sem id</code> 删除对应semid的信号量</p><p>ipcrm sem 0</p><p>已经没有了</p><p><img src="/../images/image-20221222094315543.png" alt="image-20221222094315543"></p><p>模拟多进程的情况</p><p>进程一：</p><p><img src="/../images/image-20221222133124753.png" alt="image-20221222133124753"></p><p>进程二：</p><p><img src="/../images/image-20221222133139555.png" alt="image-20221222133139555"></p><p>进程三</p><p><img src="/../images/image-20221222133154461.png" alt="image-20221222133154461"></p><p>进程四</p><p><img src="/../images/image-20221222133218521.png" alt="image-20221222133218521"></p><p>发现进程二获取锁的时间是进程一释放锁的同时，进程三依次类推</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;1.学习信号量的封装类CSEM的操作&lt;/p&gt;
&lt;p&gt;2.掌握信号量的机制&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;信号量本质上是一个非负数（&amp;gt;&amp;#x3D;0）的计数器&lt;/li&gt;
&lt;li&gt;给共享资源建立一个标志，表示该共享资源被占</summary>
      
    
    
    
    <category term="C项目" scheme="https://stevezhangzl.github.io/categories/C%E9%A1%B9%E7%9B%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>程序员的自我修养读书笔记-第6章-可执行文件的装载与进程</title>
    <link href="https://stevezhangzl.github.io/2022/12/13/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC6%E7%AB%A0-%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%A3%85%E8%BD%BD%E4%B8%8E%E8%BF%9B%E7%A8%8B/"/>
    <id>https://stevezhangzl.github.io/2022/12/13/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC6%E7%AB%A0-%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%A3%85%E8%BD%BD%E4%B8%8E%E8%BF%9B%E7%A8%8B/</id>
    <published>2022-12-13T02:37:36.000Z</published>
    <updated>2023-01-16T22:23:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>介绍ELF文件在Linux下的装载过程，看看可执行文件装载的本质是什么？什么是进程的虚拟地址空间？为什么进程要有自己独立的虚拟地址空间？进程虚拟地址空间的分布情况，比如代码段、数据段、BSS段、堆、栈分别在进程地址空间怎么分布，它们的位置和长度如何决定。</p><h2 id="进程虚拟地址空间"><a href="#进程虚拟地址空间" class="headerlink" title="进程虚拟地址空间"></a>进程虚拟地址空间</h2><p>每个程序被运行起来以后，它将拥有自己独立的<strong>虚拟地址空间</strong>。由硬件决定地址空间的最大<strong>理论</strong>上限，即硬件的寻址空间大小，比如32位的硬件平台决定了虚拟地址空间的地址为0到 2^32 -1 即0x00000000 ~ 0xFFFFFFFF，也就是我们常说的4GB虚拟空间大小；而64位的硬件平台具有64位寻址能力，它的虚拟地址空间达到了2^64字节。</p><p>一般来说，C语言指针大小的位数与虚拟空间的位数相同，如32位平台的指针为32位，即4个字节；64位平台下的指针为64位，即8字节。</p><img src="../images/image-20221213131124041.png" alt="image-20221213131124041" style="zoom:50%;" /><p>我们进程最多可以使用3GB的虚拟空间，也就是说整个进程在执行的时候，所有的代码、数据包括通过C语言malloc等方法申请的虚拟空间之和不可以超过3GB。</p><p>扩展物理物理地址空间，只有32位的虚拟地址空间，应用程序该如何使用这些大于常规的内容空间呢？一个很常见的方法就是操作系统提供一个窗口映射的方法，把这些额外的内存映射到进程地址空间中来。应用程序可以根据需要来选择申请和映射，比如一个应用程序中0x10000000<del>0x20000000这一段256MB的虚拟地址空间来做窗口，程序可以从高于4GB的物理空间中申请多个大小为256MB的物理空间，编号成A&#x2F;B&#x2F;C等，然后根据需要将这个窗口映射到不同的物理空间块，用到A时将0x10000000</del>0x20000000映射到A，用到B、C时再映射过去，如此重复操作即可。像Linux等UNIX类操作系统采用mmap()系统调用来实现。</p><h2 id="装载的方式"><a href="#装载的方式" class="headerlink" title="装载的方式"></a>装载的方式</h2><p>最简单的静态装入方法：将程序所需要的指令和数据全都装入内存中。</p><p>动态装入：将程序最常用的部分驻留在内存中，而将一些不太常用的数据存入在磁盘里。<strong>覆盖装入</strong>和<strong>页映射</strong>两种典型的动态装载方法，原则上都是利用了程序的局部性原理。动态装入的思想是程序用到哪个模块，就将哪个模块装入内存，如果不用就暂时不装入，存入在磁盘中。</p><h3 id="覆盖装入"><a href="#覆盖装入" class="headerlink" title="覆盖装入"></a>覆盖装入</h3><p>几乎被淘汰了</p><h3 id="页映射"><a href="#页映射" class="headerlink" title="页映射"></a>页映射</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;介绍ELF文件在Linux下的装载过程，看看可执行文件装载的本质是什么？什么是进程的虚拟地址空间？为什么进程要有自己独立的虚拟地址空间？进程虚拟地址空间的分布情况，比如代码段、数据段、BSS段、堆、栈分别在进程地址空间怎么分布，它们的位置和长度如何决定。&lt;/p&gt;
&lt;h2 i</summary>
      
    
    
    
    <category term="c原理" scheme="https://stevezhangzl.github.io/categories/c%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>程序员的自我修养读书笔记-第4章-静态链接</title>
    <link href="https://stevezhangzl.github.io/2022/12/11/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC4%E7%AB%A0-%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/"/>
    <id>https://stevezhangzl.github.io/2022/12/11/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC4%E7%AB%A0-%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/</id>
    <published>2022-12-10T23:06:33.000Z</published>
    <updated>2023-01-16T22:23:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>当我们有两个目标文件时</p><p>如何将它们链接起来形成一个可执行文件？</p><p>这个过程发生了什么？</p><p>—静态链接</p><p>a.c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> shared;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">swap</span>(&amp;a,&amp;shared);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b.c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> shared = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span>&#123;</span><br><span class="line">*a ^= *b ^= *a ^= *b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gcc -c -fno-stack-protector a.c b.c</p><blockquote><p>因为下面要使用ld裸链接器去链接，没有链接到__statck_chk_fail所在库文件，链接过程会报错，所以编译源码到目标文件时，一定要加”-fno-stack-protector” 不去调用函数__stack_chk_fail进行栈相关检查。强制gcc不进行栈检查</p></blockquote><p>生成a.o b.o两个目标文件，怎么链接这两个文件呢？</p><h2 id="空间与地址分配"><a href="#空间与地址分配" class="headerlink" title="空间与地址分配"></a>空间与地址分配</h2><p>对于链接器来说，整个链接过程中，它就是将几个输入目标文件加工合并成一个输出文件。</p><h3 id="相似段合并"><a href="#相似段合并" class="headerlink" title="相似段合并"></a>相似段合并</h3><p>将相同性质的段合并到一起，</p><p><img src="/../images/image-20221211160737942.png" alt="image-20221211160737942"></p><p>.bss段在目标文件和可执行文件中并不占用文件的空间，但是它在装载时占用地址空间。所以链接器在合并各个段的同时，也将.bss合并，并且分配虚拟空间。</p><p>链接器为目标文件分配<strong>地址和空间</strong></p><ul><li><p>输出的可执行文件中的空间</p></li><li><p>在装载后的虚拟地址中的虚拟地址空间</p></li></ul><p>对于.text 和.data来说，它们在文件中和虚拟地址中都要分配空间，因为它们在这两者中都存在；而对于.bss段，分配空间的意义只局限于虚拟地址空间，因为它在文件中并没有内容。</p><p><strong>事实上，我们在这里谈到的空间分配只关注于虚拟地址空间的分配</strong>，这个关系到链接器后面的关于地址计算的步骤，而可执行文件本身的空间与链接过程关系并不是很大。</p><h4 id="两步链接"><a href="#两步链接" class="headerlink" title="两步链接"></a>两步链接</h4><p>第一步 空间与地址分配</p><p>扫描所有的输入目标文件，并且获得它们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局符号表。</p><p>第二步 符号解析与重定义</p><p>读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等，事实上第二步是链接过程的核心，特别是重定位过程。</p><p>使用ld链接器将a.o和b.o链接起来</p><p><code>ld a.o b.o -e main -o ab</code></p><ul><li>-e main 表示将main函数作为程序入口，ld链接器默认的程序入口为_start。</li><li>-o ab 表示链接输出文件名为ab，默认为a.out</li></ul><p><code>objdump -h a.o</code></p><p><img src="/../images/image-20221212090531471.png" alt="image-20221212090531471"></p><p><code>objdump -h b.o</code></p><p><img src="/../images/image-20221212090941018.png" alt="image-20221212090941018"></p><p><code>objdump -h ab</code></p><p><img src="/../images/image-20221212091135206.png" alt="image-20221212091135206"></p><blockquote><p>VMA 虚拟地址</p><p>LMA 加载地址</p><p>正常情况下两个值应该是一样的，但是有些嵌入式系统中，特别是在那些程序放在ROM的系统中，LMA和VMA是不相同的。只需要关注VMA即可。</p></blockquote><p>链接前后的程序中所使用的地址已经是程序在进程中的虚拟地址，即我们关心上面各个段中的<strong>VMA</strong>和<strong>Size</strong>，而忽略**文件偏移(File off)**。</p><ul><li>链接之前，目标文件中的所有段的VMA都是0，因为虚拟空间还没有被分配，默认都是0.</li><li>链接之后，可执行文件ab中的各段都被分配到了相应的虚拟。</li></ul><p>合并和映射的关系如图</p><img src="../images/image-20221212094549192.png" alt="image-20221212094549192" style="zoom:50%;" /><p>​                                                                                    第一步  空间分配阶段                                                                                            </p><h3 id="符号地址的确定"><a href="#符号地址的确定" class="headerlink" title="符号地址的确定"></a>符号地址的确定</h3><p>在第一步的描述和空间分配阶段，链接器按照前面介绍的空间分配方法进行分配，这时候输入文件中的各个段在链接后的虚拟地址就已经确定了，比如.text段起始地址为0x0401000  .data段起始地址为0x0404000</p><p>第一步完成后，链接器开始计算各个<strong>符号的虚拟地址</strong>。因为各个符号在<strong>各自的段内</strong>的相对位置是固定的，所以这时候其实main shared swap的地址已经确定的了，只不过链接器需要给每个符号加上一个<strong>偏移量</strong>，使它们能够调整到正确的虚拟地址。</p><p>比如我们假设a.o中的main函数相对于.ao的.text段的偏移是X，但是经过链接合并以后a.o的.text段位于虚拟地址0x0401000，那么main的地址应该是0x0401000 + X。main位于a.o的.text段的最开始，也就是偏移为0，所以main这个符号在最终的输出文件中的地址应该是0x0401000 + 0，即0x0401000。</p><p>可以通过完全一样的计算方法得知所有符号的地址，这个例子只有三个全局符号。</p><p><code>objdump -s -x -d ab</code></p><p><img src="/../images/image-20221212100737875.png" alt="image-20221212100737875"></p><p>main的大小是0x32 所以 swap的起始地址是0x0401032而swap的大小正好就是b.o中.text的长度4f</p><p>再看shared</p><p><img src="/../images/image-20221212100921945.png" alt="image-20221212100921945"></p><p>起始地址是0x0404000 值是0x01  大小 0x04个字节</p><table><thead><tr><th>符号</th><th>类型</th><th>虚拟地址</th></tr></thead><tbody><tr><td>main</td><td>函数</td><td>0x0401000</td></tr><tr><td>swap</td><td>函数</td><td>0x0401032</td></tr><tr><td>shared</td><td>变量</td><td>0x0404000</td></tr></tbody></table><p>或者直接看这个图</p><p><img src="/../images/image-20221212101028136.png" alt="image-20221212101028136"></p><h2 id="符号解析与重定位"><a href="#符号解析与重定位" class="headerlink" title="符号解析与重定位"></a>符号解析与重定位</h2><h3 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h3><p>在完成空间和地址的分配步骤以后，链接器就进入了符号解析与重定位的步骤，这也是静态链接的核心内容。</p><p>先看看a.o里面怎么使用这两个外部符号的，a.c中使用了shared变量和swap函数，编译器在将a.c编译成指令时，如何访问shared变量？如何调用 swap函数？</p><p><code>objdump -d a.o</code></p><p><img src="/../images/image-20221212105818746.png" alt="image-20221212105818746"></p><p>这里看到main的起始地址为0x0000,0000,0000,0000 这是因为在未进行第一步空间分配之前，目标文件代码段中的起始地址以0x0000,0000,0000,0000开始，等空间分配完成之后，各个函数才会确定自己在虚拟地址空间中的位置。</p><p>当a.c在被编译成目标文件时，编译器并不知道shared和swap的地址，因为它们定义在其他目标文件中，所以编译器就暂时把地址0看作是shared和swap的地址，可以看0x17这行  lea 是近址相对位移调用指令，后面的4个字节是shared相对于调用指令下一条指令的偏移量</p><p>后面也提示了&lt;main + 0x1e&gt; 因为现在还不知道偏移量是多少，所以是0 在 ld成ab文件后</p><p><img src="/../images/image-20221212110239243.png" alt="image-20221212110239243"></p><p>1e的虚拟地址为0x40101e 指令后面偏移量也给出了，是0x2f 0xef ，我们用0x40101e + 0x2fe2 &#x3D; 0x404000 正好是shared的合并后的地址</p><p>再来看调用 a.o中的swap</p><p><img src="/../images/image-20221212110434485.png" alt="image-20221212110434485"></p><p>callq e8后面也是0 跟 shared一样，也是callq也是近址相对位移调用指令，call下一条是mov指令 偏移量，看ab文件</p><p><img src="/../images/image-20221212110618527.png" alt="image-20221212110618527"></p><p>0x40102b  + 0x07 &#x3D; 0x401032 所以swap的地址是0x401032</p><p>这就是指令修正的方式，也就是给符号重定位的过程</p><h3 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h3><p>那么链接器是怎么知道哪些指令需要被调整呢？这些指令的哪些部分需要被调整？怎么调整？</p><p>ELF文件中，有一个重定位表的结构专门用来保存这些与重定位相关的信息，在ELF文件中往往是一个或多个段。</p><p>对于可重定位的ELF文件来说，它必须包含有重定位表，用来描述如何修改相应的段里的内容。对于每个要被重定位的ELF段都配有一个对应的重定位表。比如.text 要被重定位，那么就有一个.rel.text段</p><p><code>objdump -r a.o</code></p><p><img src="/../images/image-20221212130602053.png" alt="image-20221212130602053"></p><p>用于查看a.o里面要重定位的地方，即a.o所有引用到外部符号的地址。每个要被重定位的地方叫一个重定位入口，我们看到a.o里面有两个重定位入口。</p><p>偏移对应于要被重定位的段中的位置，这里1a 27 就是 lea和callq指令的地址部分</p><p><img src="/../images/image-20221212130818448.png" alt="image-20221212130818448"></p><p>重定位表的结构是一个Elf64_Rel结构的数组，每个数组元素就对应一个<strong>重定位入口</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_rel</span> &#123;</span></span><br><span class="line">  Elf64_Addr r_offset;<span class="comment">/* Location at which to apply the action */</span></span><br><span class="line">  Elf64_Xword r_info;<span class="comment">/* index and type of relocation */</span></span><br><span class="line">&#125; Elf64_Rel;</span><br></pre></td></tr></table></figure><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>r_offset</td><td>重定位入口的偏移。对于可重定位文件来说，这个值是该重定位入口所要修正的位置的第一个字节相对于段起始的偏移；对于可执行文件或共享对象文件来说，这个值是该重定位入口所要修正的位置的第一个字节的虚拟地址。</td></tr><tr><td>r_info</td><td>重定位入口的类型和符号。这个成员的低8位表示重定位入口的类型，高24位表示重定位入口的符号在符号表中的下标。</td></tr></tbody></table><h3 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h3><p>之所以要链接是因为我们目标文件中用到的符号被定义在其他目标文件，所以要将它们链接起来。比如使用ld a.o 链接器会发现shared和swap两个符号没有被定义，没有办法完成链接工作</p><p><img src="/../images/image-20221212131531080.png" alt="image-20221212131531080"></p><p>链接时符号未定义。导致这个问题的原因很多，最常见的一般都是链接时缺少了某个库，或者输入目标文件路径不正确或符号的声明与定义不一样。</p><p>重定位的过程中，每个重定位的入口都是对一个符号的引用，那么当链接器需要对某个符号引用进行重定位时，它就要确定这个符号的目标地址。这时候链接器就会去查找由所有输入目标文件的符号表组成的全局符号表，找到相应的符号后进行重定位。</p><p><code>readelf -s a.o</code> 查看a.o的符号表</p><p><img src="/../images/image-20221212131955461.png" alt="image-20221212131955461"></p><p>看到GLOBAL类型 只有main定义在.text段里 shared和swap都是UND 也就是undefined未定义类型，这种未定义的符号都是因为该目标文件中有关于它们的重定位项。在链接器扫描扫描完所有的输入目标文件之后，所有这些未定义的符号都应该能够在某个目标文件的符号表中找到，否则链接器就报符号未定义错误。</p><p>比如</p><p><code>readelf -s b.o</code></p><p><img src="/../images/image-20221212132409883.png" alt="image-20221212132409883"></p><p>在b.o中指明了GLOBAL shared和swap定义的段</p><h3 id="指令修正方式-略"><a href="#指令修正方式-略" class="headerlink" title="指令修正方式(略)"></a>指令修正方式(略)</h3><p>指令修正方式和每个处理器相关，需要相阅手册</p><ul><li>近址寻址或远址寻址</li><li>绝对寻址或相对寻址</li></ul><h2 id="COMMON块"><a href="#COMMON块" class="headerlink" title="COMMON块"></a>COMMON块</h2><p>弱符号机制允许同一个符号的定义存在于多个文件中，如果一个弱符号定义在多个目标文件中，而它们的类型又不同，怎么办？</p><ul><li>两个或两个以上强符号类型不一致；</li><li>有一个强符号，其他都是弱符号，出现类型不一致；</li><li>两个或两个以上弱符号类型不致。</li></ul><p>多个强符号定义本身就是非法的，链接器会报符号多重定义错误，所以链接器要处理的就是后两种情况。</p><p>编译器将<strong>未初始化的全局变量定义</strong>作为弱符号处理。</p><p>比如SimpleSection.c中的global_uninit_var 它在符号表中 readelf -s</p><p><img src="/../images/image-20221212135246549.png" alt="image-20221212135246549"></p><p>那么如果我们在另外一个文件中也定义了global_uninit_var变量，且未初始化，类型为double，占8个字节，按COMMON类型的链接规则，以最大的那个为准。即这两个文件链接后输出文件中global_uninit_var所占的空间为8个字节。</p><p>COMMON链接规则是针对都是弱符号的情况，如果其中有一个符号为强符号，最终输出结果中符号所占空间与强符号相同。</p><blockquote><p>在目标文件中，编译器为什么不直接把<strong>未初始化的全局变量</strong>也当作<strong>未初始化的局部静态变量</strong>一样处理，为它在BSS段分配空间，而是将其标记为一个COMMON类型的变量？</p><p>因为很多弱符号，编译器无法像未初始的局部静态变量一样确定它的大小，放在BSS段，编译器必须扫描完全部目标文件后，才能最终确定弱符号的最终大小，所以无法在BSS段分配空间，因为所需要空间的小未知。所以不能放在BSS段</p></blockquote><p>GCC的 -fno-common允许我们把所有未初始化的全局变量不以COMMON块的形式处理，或者使用__attribute__扩展：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> global <span class="constructor">__attribute__((<span class="params">nocommon</span>)</span>);</span><br></pre></td></tr></table></figure><p>一旦一个未初始化的全局变量不以COMMON块的形式存在，就相当于强符号，如果其他目标还有同一个变量的强符号定义，链接时就会发生符号重复的定义错误。</p><h2 id="C-相关问题"><a href="#C-相关问题" class="headerlink" title="C++相关问题"></a>C++相关问题</h2><ul><li>C++重复代码消除</li><li>全局构造与析构</li></ul><h3 id="重复代码消除"><a href="#重复代码消除" class="headerlink" title="重复代码消除"></a>重复代码消除</h3><h4 id="函数级别链接"><a href="#函数级别链接" class="headerlink" title="函数级别链接"></a>函数级别链接</h4><h3 id="全局构造与析构"><a href="#全局构造与析构" class="headerlink" title="全局构造与析构"></a>全局构造与析构</h3><h3 id="C-与ABI"><a href="#C-与ABI" class="headerlink" title="C++与ABI"></a>C++与ABI</h3><h2 id="静态库链接"><a href="#静态库链接" class="headerlink" title="静态库链接"></a>静态库链接</h2><p>静态库可以简单地看成一组目标文件的集合，即很多目标文件经过压缩打包后形成的一个文件。经如我们在Linux中最常用的C语言静态库libc位于&#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.a它属于glibc项目的一部分。</p><p>很多目标文件零散的提供给库的使用者，很大程序会造成文件传输、管理和组织方面的不便，于是通常人们使用ar压缩程序将这些目标文件压缩到一起，并且对其进行编号和索引，以便于查找和检索，就形成了libc.a这个静态库文件。</p><p><code>ar -t lic.a</code>   查看.a文件中包含的目标文件</p><p><img src="/../images/image-20221213093540461.png" alt="image-20221213093540461"></p><p>libc.a 有1000多个目标文件，如何在目标文件中找到printf函数所在的的目标文件？使用objdump或readelf 加上文件查找工具grep</p><p><img src="/../images/image-20221213094503847.png" alt="image-20221213094503847"></p><p>Hello World程序编译出来的目标文件只要和libc.a里面的printf.o链接在一起，最后就可以形成一个可用的可执行文件了。我们使用如下方法编译：</p><p><code>gcc -c -fno-builtin hello.c</code></p><blockquote><p>为什么使用-fno-builtin参数？</p><p>因为默认GCC为将Hello World程序中只使用了一个字符串参数的printf替换成puts函数，以提高运行速度，使用-fno-builtin关闭这个内置函数优化选项。</p></blockquote><p>我们使用ar工具解压出printf.o</p><p><code>ar -x /usr/lib/x86-gnu/libc.a</code></p><p>这个命令会将libc.a中所有目标文件‘解压’至当前目录，我们就可以得到printf.o，然后将其与hello.o链接在一起</p><p><code>ld hello.o printf.o</code></p><p><img src="/../images/image-20221213100254068.png" alt="image-20221213100254068"></p><p>链接失败，缺少几个未定义的符号，其实看objdump 的时候，也可以看到printf.o中的符号引用，有几个是UND，需要依赖外部其他的目标文件</p><p>stdio.o还依赖其他文件，所以我们使用ld链接器不断的链接，自动寻找所有需要的符号及它们所在的目标文件，将这些目标文件从libc.a中解压出来，最终将它们链接在一起成为一个可执行文件。但实际上hello.o和libc.a链接起来也不会得到可执行文件，还要其他一些辅助性质的目标文件和库</p><p><code>gcc -static --verbose -fno-builtin hello.c</code></p><p><img src="/../images/image-20221213102002818.png" alt="image-20221213102002818"></p><ul><li>第一步 使用ccl程序，这个程序实际上就是GCC的C语言编译器，它将hello.c编译成一个临时的汇编文件&#x2F;tmp&#x2F;cc8MewmB.s</li><li>第二步，使用as程序，as程序是GNU的汇编器，它将&#x2F;tmp&#x2F;cc8MewmB.s汇编成目标文件&#x2F;tmp&#x2F;ccYNbExD.o这个.o实际上就是前面的hello.o</li><li>第三步，最关键的步骤，调用 collect2程序来完成最后的链接，可以理解collect2是ld链接器的封装</li></ul><p>看最后一步，链接的目标文件</p><p>crt1.o</p><p>crtbeginT.o</p><p>..</p><p>crtend.o</p><p>crtn.o</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当我们有两个目标文件时&lt;/p&gt;
&lt;p&gt;如何将它们链接起来形成一个可执行文件？&lt;/p&gt;
&lt;p&gt;这个过程发生了什么？&lt;/p&gt;
&lt;p&gt;—静态链接&lt;/p&gt;
&lt;p&gt;a.c&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;</summary>
      
    
    
    
    <category term="c原理" scheme="https://stevezhangzl.github.io/categories/c%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>程序员的自我修养读书笔记-第3章-目标文件(二)</title>
    <link href="https://stevezhangzl.github.io/2022/12/10/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6(%E4%BA%8C)/"/>
    <id>https://stevezhangzl.github.io/2022/12/10/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6(%E4%BA%8C)/</id>
    <published>2022-12-09T22:55:11.000Z</published>
    <updated>2023-01-16T22:23:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>接上（一）继续</p><h2 id="链接的接口—符号"><a href="#链接的接口—符号" class="headerlink" title="链接的接口—符号"></a>链接的接口—符号</h2><p>链接过程的本质就是把多个不同的目标文件之间粘在一起，或者说像玩齿根积木一样，可以拼装形成一个整体。在链接中，目标文件之间相互拼合实际上是<strong>目标文件之间对地址的引用</strong>，<strong>即对函数和变量的地址的引用</strong>。</p><p>比如目标文件B要用到目标文件A的函数[foo]，那么我们就称目标文件A<strong>定义</strong>了函数[foo]，称目标文件B<strong>引用</strong>了目标文件A中的函数[foo]，这两个概念同样适用于变量。</p><p>每个函数或变量都有自己独特的名字，才能避免链接过程中不同变量和函数之间的混淆。</p><blockquote><p>在链接中，我们将函数和变量统称为<strong>符号(Symbol)</strong>,函数名或变量名就是**符号名(Symbol Name)**。</p></blockquote><p>每一个目标文件都会有一个相应的符号表(Symbol Table)，这个表里记录了目标文件 中所用到的所有符号。每个定义的符号有一个对应的值，叫做符号值(Symbol Value)，对于变量和函数来说，符号值就是它们的地址。</p><ul><li>定义在本目标文件的全局符号，可以被其他目标文件引用。比如SimpleSection.o里面的func1，main，和global_init_var</li><li>在本目标文件中引用的全局符号，却没有定义在本目标文件，这一般叫做外部符号（External Symbol），也就是我们所说的符号引用。比如SimpleSection.o里面的printf</li><li>局部符号，这类符号只在编译单元内部可见。比如SimpleSection.o里面的static_var和static_var2。调试器可以使用这些符号来分析程序或崩溃时的核心转储文件 。这些局部符号对于链接过程没有作用，链接器往往也忽略它们。</li><li>行号信息，即目标文件指令与源代码行的对应关系，它也是可选的。</li></ul><p>对于我们来说，最关注的就是全局符号，即上面分类中的第一类和第二类。因为链接过程只关心全局符号的相互‘粘合’，局部符号、段名、行号等都是次要的，它们对于其他目标文件来说是‘不可见的’，链接过程中也无关紧要的。可以使用很多工具来查看ELF文件的符号表，比如readelf、objdump、nm等</p><p><code>nm SimpleSection.o</code></p><p><img src="/../images/image-20221210113230525.png" alt="image-20221210113230525"></p><h3 id="ELF符号表结构"><a href="#ELF符号表结构" class="headerlink" title="ELF符号表结构"></a>ELF符号表结构</h3><p>符号表也是一个段，段名一般叫.symtab 符号表的结构是一个Elf64_Sym的<strong>数组</strong>，每个Elf64_Sym结构对应一个符号。数组第一个元素，下标为0的元素为无效的‘未定义’符号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_sym</span> &#123;</span></span><br><span class="line">  Elf64_Word st_name;<span class="comment">/* Symbol name, index in string tbl */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>st_info;<span class="comment">/* Type and binding attributes */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>st_other;<span class="comment">/* No defined meaning, 0 */</span></span><br><span class="line">  Elf64_Half st_shndx;<span class="comment">/* Associated section index */</span></span><br><span class="line">  Elf64_Addr st_value;<span class="comment">/* Value of the symbol */</span></span><br><span class="line">  Elf64_Xword st_size;<span class="comment">/* Associated symbol size */</span></span><br><span class="line">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure><p><code>readelf -s SimpleSection.o</code></p><p><img src="/../images/image-20221210122802514.png" alt="image-20221210122802514"></p><table><thead><tr><th>字段名</th><th>描述</th></tr></thead><tbody><tr><td>st_name</td><td>符号名。这成员包含了该符号该符号名在字符串表中的下标（字符串表）</td></tr><tr><td>st_value</td><td>符号相对应的值。这个值跟符号有关，可能是一个绝对值，也可能是一个地址等，不同的符号，它所对应的值含义不同</td></tr><tr><td>st_size</td><td>符号大小。对于包含数据的符号，这个值是该数据类型的大小。比如一个double型的符号它占用8个字节。如果该值为0，则表示该符号大小为0或未知</td></tr><tr><td>st_info</td><td>符号类型和绑定信息</td></tr><tr><td>st_other</td><td>该成员目前为0，没用</td></tr><tr><td>st_shndx</td><td>符号所在的段</td></tr></tbody></table><h4 id="符号类型和绑定信息-st-info"><a href="#符号类型和绑定信息-st-info" class="headerlink" title="符号类型和绑定信息(st_info)"></a>符号类型和绑定信息(st_info)</h4><p>该成员低4位表示符号的<strong>类型(Symbol Type)<strong>，高28位表示符号的</strong>绑定信息（Symbol Binding）</strong></p><p><strong>符号的绑定信息</strong></p><table><thead><tr><th>宏定义名</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>STB_LOCAL</td><td>0</td><td>局部符号，对于目标文件的外部不可见</td></tr><tr><td>STB_GLOBAL</td><td>1</td><td>全局符号，外部可见</td></tr><tr><td>STB_WEAK</td><td>2</td><td>弱引用</td></tr></tbody></table><p><strong>符号类型</strong></p><table><thead><tr><th>宏定义名</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>STT_NOTYPE</td><td>0</td><td>未知类型符号</td></tr><tr><td>STT_OBJECT</td><td>1</td><td>该符号是个数据对象，比如变量、数组等</td></tr><tr><td>STT_FUNC</td><td>2</td><td>该符号是个函数或其他可执行代码</td></tr><tr><td>STT_SECTION</td><td>3</td><td>该符号表示一个段，这种符号必须是STB_LOCAL的</td></tr><tr><td>STT_FILE</td><td>4</td><td>该符号表示文件名，一般都是该目标文件所对应的源文件名，它一定是STB_LOCAL类型的，并且它的st_shndx一定是SHN_ABS</td></tr></tbody></table><p><strong>符号所在的段(st_shndx)</strong></p><p>如果符号定义在本目标文件中，那么这个成员表示符号所在的段在段表中的下标(会显示具体的1，2，3数字)；但是如果符号不是定义在本目标文件中，或者对于有些特殊符号，sh_shndx的值有些特殊</p><p><strong>符号所在段特殊常量</strong></p><table><thead><tr><th>宏定义名</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>SHN_ABS</td><td>0xfff1</td><td>表示该符号包含了一个绝对的值。比如表示文件名的符号就属于这种类型</td></tr><tr><td>SHN_COMMON</td><td>0xfff2</td><td>表示该符号是一个COMMON块类型的符号，一般来说未初始化的全局符号定义就是这种类型的，比如simplesection.o里面的global_uninit_var。</td></tr><tr><td>SHN_UNDEF</td><td>0</td><td>表示该符号未定义。这个符号表示该符号在本目标文件被引用到，但是定义在其他目标文件中</td></tr></tbody></table><h4 id="符号值-st-value"><a href="#符号值-st-value" class="headerlink" title="符号值(st_value)"></a>符号值(st_value)</h4><p>每个符号都有一个对应的值，如果这个符号是一个函数或变量的定义，那么符号的值就是这个函数或变量的地址。</p><ul><li>在目标文件中，如果是符号的定义并且该符号不是COMMON块类型（即st_shndx不为SHN_COMMON）则st_value表示该符号在段中的偏移。即符号所对应的函数或变量位于由st_shndx指定的段，偏移st_value的位置。这也是目标文件中定义全局变量的符号的最常见情况，比如SimpleSection.o中的func1、main和global_init_var。</li><li>在目标文件中，如果符号是COMMON块类型的，则st_value表示该符号的对齐属性。比如Simple.Section.o中的global_uninit_var</li><li>在可执行文件中，st_value表示符号的虚拟地址。这个虚拟地址对于动态链接器来说十分有用</li></ul><p><img src="/../images/image-20221210170100970.png" alt="image-20221210170100970"></p><p><img src="/../images/image-20221210170152853.png" alt="image-20221210170152853"></p><p>readelf -s 的输出格式与Elf64_Sym的各个成员几首一一对应</p><ul><li>func1和main函数都是定义在SimpleSection.c里面的，它们所在的位置 都是代码段，所以Ndx为1。它们是函数，所以类型是STT_FUNC；它们是全局可见的，所以是STB_GLOBAL；Size表示函数指令所占有的字节数；Value表示函数相对于代码段起始位置的偏移量。</li><li>printf这个符号，该符号在SimpleSection.c里面被引用，但是没被定义。所以Ndx是SHN_UNDEF</li><li>global_init_var是已经初始化的全局变量，它被定义在.bss段，即下标为3</li><li>global_imomot_var是未初始化的全局变量，它是一个COMMEN块</li><li>static_var.1920 static_var2.1921 是两个静态变量，它们绑定属性是LOCAL，即只是编译单元内部可见</li><li>对于SECTION类型的符号，表示下标为Ndx的段的段名，符号名没有显示，其实符号名就是段名。比如2号符号的Ndx为1，那么就是.text段的段名，符号名就是.text 可以用<code>objdump -t</code> 看到这些段名符号。</li><li>SimpleSection.c这个符号表示编译单元的源文件名。</li></ul><h3 id="符号修饰与函数签名"><a href="#符号修饰与函数签名" class="headerlink" title="符号修饰与函数签名"></a>符号修饰与函数签名</h3><p>以前，编译器编译源代码产生目标文件时，符号名与相应的变量和函数的名字是一样的。后来为了防止符号冲突。C++这样后来设计的语言开始考虑到这个问题，增加了<strong>名称空间</strong>的方法来解决多模块的符号冲突问题。</p><h4 id="C-符号修饰"><a href="#C-符号修饰" class="headerlink" title="C++符号修饰"></a>C++符号修饰</h4><p>C++拥有类、继承、虚机制、重载、名称空间等这些特性，使得符号管理更为复杂。比如func(int)和func(double)那么编译器和链接器在链接过程如何区分？人们发明了<strong>符号修饰</strong>或<strong>符号改编</strong>的机制。</p><p><code>c++filt _ZN1N1C4funcEi</code></p><p><img src="/../images/image-20221210172126748.png" alt="image-20221210172126748"></p><p><img src="/../images/image-20221210172142423.png" alt="image-20221210172142423"></p><h3 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h3><p>c++为了与C兼容，在符号的管理上，c++有一个用来声明或定义一个C的符号的extern “C”关键字用法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">  <span class="keyword">int</span> var;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用如下格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">int</span> var;</span><br></pre></td></tr></table></figure><p>很多时候我们会碰到有些头文件声明了一些C语言的函数和全局变量，但是这个头文件可能会被C语言代码或C++代码包含。比如很常见的，我们的C语言库函数中的string.h中声明了memset这个函数，它的原型如下：</p><p><code>void *memset(void *,int,size_t);</code></p><p>如果不加任何处理，当我们的C语言程序包含string.h的时候，并且用到了memset这个函数，编译器会将memset符号引用正确处理；但是在c++中，编译器会认为这个memset函数是一个c++函数，将memset符号修饰成_Z6memsetPvvii，这样链接器就无法与C语言库中的这个memset符号进行链接。所以对于c++来说，必须使用extern “C”来声明memeset这个函数。但是C语言又不支持extern “C”语法，为了兼容，使用C++的宏”__cplusplus”，C++编译器会在编译C++的程序时默认定义这个宏</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span>*,<span class="keyword">int</span>,<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>如果当前编译单元是C++代码，那么memset会在extern “C”里面被声明；如果是C代码，就直接声明。这个技巧几乎在所有的系统头文件里面被用到。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;接上（一）继续&lt;/p&gt;
&lt;h2 id=&quot;链接的接口—符号&quot;&gt;&lt;a href=&quot;#链接的接口—符号&quot; class=&quot;headerlink&quot; title=&quot;链接的接口—符号&quot;&gt;&lt;/a&gt;链接的接口—符号&lt;/h2&gt;&lt;p&gt;链接过程的本质就是把多个不同的目标文件之间粘在一起，或者说像玩</summary>
      
    
    
    
    <category term="c原理" scheme="https://stevezhangzl.github.io/categories/c%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>数字证书相关知识扫盲</title>
    <link href="https://stevezhangzl.github.io/2022/12/06/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%89%AB%E7%9B%B2/"/>
    <id>https://stevezhangzl.github.io/2022/12/06/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%89%AB%E7%9B%B2/</id>
    <published>2022-12-06T05:57:07.000Z</published>
    <updated>2023-01-16T22:23:56.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>摘要、签名、证书是什么？</li><li>摘要、签名、证书的用途和关系？</li><li>签名是怎么生成的？</li><li>签名是怎么校验的？</li><li>证书是怎么生成的？</li><li>证书是怎么校验的？</li></ol><h2 id="消息摘要（Digest）"><a href="#消息摘要（Digest）" class="headerlink" title="消息摘要（Digest）"></a>消息摘要（Digest）</h2><h3 id="什么是消息摘要？"><a href="#什么是消息摘要？" class="headerlink" title="什么是消息摘要？"></a>什么是消息摘要？</h3><p>对一份数据，进行一个单向的Hash函数，生成一个固定长度的Hash值，这个值就是这份数据的摘要，也称为指纹。</p><h3 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h3><p>常见的摘要算法有MD5、SHA-1、SHA-256等。他们的特点：</p><ul><li>对于同一个摘要算法，无论输入的数据是什么，输出都是相同长度的值。例如MD5，无论数据有多大，输出总是128位的散列值。</li><li>摘要算法是单向的，只能根据原始数据计算出它的摘要值，但是不能根据摘要值反算出原始数据。</li><li>越优秀的摘要算法越难找到Hash碰撞。虽然长内容生成的短摘要是必定会产生碰撞的，但一个优秀的摘要算法很难主动构造出两条数据，使他们的摘要值相同。</li><li>消息摘要的用途：可以用于校验数据的完整性。例如我们在下载文件时，数据源会提供一个文件MD5。文件下载之后，我们本地计算出文件的MD5，和数据源提供的MD5做对比，如果相同则文件是完整的。但独立使用消息摘要时，无法确保数据没有被篡改，因为无法保证从数据源获取的MD5有没有被路途篡改。</li><li>相比加密算法，摘要算法速度都相对较快。</li></ul><h2 id="数字签名（Signature）"><a href="#数字签名（Signature）" class="headerlink" title="数字签名（Signature）"></a>数字签名（Signature）</h2><p>在了解签名之前，需要了解什么是公开密钥体系：</p><h3 id="公开密钥体系"><a href="#公开密钥体系" class="headerlink" title="公开密钥体系"></a>公开密钥体系</h3><p>基于大整数的因数分解可以生成一对公钥和私钥。公钥和私钥是一一对应关系，一把私钥有着和它唯一对应的公钥，反之亦然。用公钥加密的数据，只能用和它对应的私钥解密，用私钥加密也只能同与之对应的公钥解密。密钥对的生成很快速，但根据公钥反推私钥极其困难。</p><p>根据公开密钥体体系，我们有了非对称加密。常见的非对称加密是RSA加密。</p><p>如果用公钥对数据加密，用私钥去解密，这是加密；反之用私钥对数据加密，用公钥去解密，这是签名。</p><p>简单地看，似乎没有区别，只是换了个名字。但实际上，两者的用途完全不一样。由于所有人都持有公钥，所以签名并不能保证数据的安全性，因为所有人都可以用公钥去解密。但签名却能用于保证消息的准确性和不可否认性。<strong>因为公钥和私钥是一一对应的，所以当一个公钥能解密某个密文时，说明这个密文一定来自于私钥持有者。</strong></p><h3 id="签名和验证过程"><a href="#签名和验证过程" class="headerlink" title="签名和验证过程"></a>签名和验证过程</h3><p>我们来看一下具体签名和验证的过程：</p><ol><li>消息发送者持有私钥和加密算法，称为信源；信源用私钥加密算法对明文数据进行加密，得到密文数据，称为签体；</li><li>接着把明文数据和密文数据同时给到消息接收者；</li><li>消息接收者收到后，先取出密文数据，用公钥对密文解密，得到一份明文数据；</li><li>再将这份明文数据和收到的明文数据做对比，如果盯同则数据完整且可信。</li></ol><img src="../images/image-20221206142749614.png" alt="image-20221206142749614" style="zoom:50%;" /><p>即使他人截获并篡改了明文数据，由于私钱是保密的，篡改者也无法生成正确的签体。所以签名能保证消息的准确性。但在单独使用非对称加密的数字签名方案时，要对所有的明文消息进行加密，效率很低。怎么提高效率呢？</p><h3 id="更高效的数字签名方案"><a href="#更高效的数字签名方案" class="headerlink" title="更高效的数字签名方案"></a>更高效的数字签名方案</h3><p>将摘要算法和非对称加密结合使用。</p><p>如何签名：先用摘要算法计算明文数据的摘要值，再对这个摘要值使用私钥加密。这样就能较快速地得到原始的摘要值，再对这个摘要值用私钥加密。这样就能较快速地得到原始信息的签名；</p><p>如何验证：先用相同的摘要算法计算原始信息的摘要值，再用公钥对签名解密，得到收到的摘要值，最后对比这两个值判断是否相等。如果不相等说明数据不可信。</p><h3 id="数据签名方案的问题"><a href="#数据签名方案的问题" class="headerlink" title="数据签名方案的问题"></a>数据签名方案的问题</h3><p>数据接收者如何获取正确的公钥呢？如果公钥本身都被篡改了，这个签名方案就不正确了。所以需要有某种方式确保公钥的正确性，这就是数字证书。</p><h2 id="数字证书（Certificate）"><a href="#数字证书（Certificate）" class="headerlink" title="数字证书（Certificate）"></a>数字证书（Certificate）</h2><h3 id="数据证书的作用"><a href="#数据证书的作用" class="headerlink" title="数据证书的作用"></a>数据证书的作用</h3><p>确保数据接收者的公钥是没有被算改过的。</p><h3 id="数据证书通常包含以下内容"><a href="#数据证书通常包含以下内容" class="headerlink" title="数据证书通常包含以下内容"></a>数据证书通常包含以下内容</h3><ol><li>证书所有人的<strong>公钥</strong></li><li>证书发行者对证书的数字<strong>签名</strong></li><li>证书所用的签名算法</li><li>证书发布机构、有效期、所有者信息等其他信息</li></ol><p>数字证书的验证过程需要用到<strong>CA根证书</strong>和<strong>业务相关证书</strong>，<strong>根证书</strong>是预装在操作系统中的。</p><p>在理解数字证书工作原理之前，我们需要先理解这两种证书是怎么生成的：</p><h3 id="CA根证书的生成"><a href="#CA根证书的生成" class="headerlink" title="CA根证书的生成"></a>CA根证书的生成</h3><img src="../images/image-20221206154446266.png" alt="image-20221206154446266" style="zoom:40%;" /><p>步骤：</p><ol><li>权威机构利用RSA等算法，生成一对公钥PK1&#x2F;私钥SK1</li><li>将公钥PK1和证书发布机构、有效期等信息组成一份原始的证书内容，设为C1</li><li>利用某种摘要算法，计算原始内容C1的数字摘要，设为H1</li><li>用第一步生成的私钥SK1，对摘要H1签名，得到签名内容S1</li><li>将原始内容C1和签名内容S1合在一起，就得到了证书</li></ol><p>根证书安装在操作系统中，我们认为根证书是一定正确的</p><h3 id="业务相关证书的生成"><a href="#业务相关证书的生成" class="headerlink" title="业务相关证书的生成"></a>业务相关证书的生成</h3><img src="../images/image-20221206154821975.png" alt="image-20221206154821975" style="zoom:40%;" /><p>步骤：</p><ol><li>权威机构利用RSA等算法，生成一对公钥PK2&#x2F;私钥SK2</li><li>将公钥PK2和证书发布机构、有效期等信息组成一份原始的证书内容，设为C2，给到权威机构</li><li>机构拿到C2，利用某种摘要算法，计算原始内容C2的数字摘要，设为H2</li><li>权威机构用自己的私钥SK1（关键点），对摘要H2签名，得到签名内容S2</li><li>将原始内容C2和签名内容S2合在一起，就得到了证书，交给企业</li></ol><p>区别点：业务申请的证书，在签名时用的私钥是CA机构的私钥。这个私钥是和根证书中的公钥对应的。</p><h3 id="数字证书的真伪验证"><a href="#数字证书的真伪验证" class="headerlink" title="数字证书的真伪验证"></a>数字证书的真伪验证</h3><p>有了根证书，我们就能校验其他证书的真伪了：</p><img src="../images/image-20221206160350286.png" alt="image-20221206160350286" style="zoom:40%;" /><p>用根证书的公钥，可以验证其他证书的签名是否正确。如果签名正确，则证书是可信的、没有被篡改的。后续就可以使用这个被信任证书中包含的公钥，去验证收到的消息是否可信了。</p><p>用CA证书去证明另外一个证书是否可信，我们可以称之为证书的递归验证。类似地，我们也可以用一个受信任的证书，去验证其他证书是否可信。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;摘要、签名、证书是什么？&lt;/li&gt;
&lt;li&gt;摘要、签名、证书的用途和关系？&lt;/li&gt;
&lt;li&gt;签名是怎么生成的？&lt;/li&gt;
&lt;li&gt;签名是怎么校验的？&lt;/li&gt;
&lt;li&gt;证书是怎么生成的？&lt;/li&gt;
&lt;li&gt;证书是怎么校验的？&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id</summary>
      
    
    
    
    <category term="密码学" scheme="https://stevezhangzl.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>一篇文件看懂v1/v2/v3签名机制[转]</title>
    <link href="https://stevezhangzl.github.io/2022/12/06/%E4%B8%80%E7%AF%87%E6%96%87%E4%BB%B6%E7%9C%8B%E6%87%82v1-v2-v3%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6-%E8%BD%AC/"/>
    <id>https://stevezhangzl.github.io/2022/12/06/%E4%B8%80%E7%AF%87%E6%96%87%E4%BB%B6%E7%9C%8B%E6%87%82v1-v2-v3%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6-%E8%BD%AC/</id>
    <published>2022-12-06T02:23:26.000Z</published>
    <updated>2023-01-16T22:23:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>作者：彭旭锐<br>链接：<a href="https://juejin.cn/post/6906882748909092871">https://juejin.cn/post/6906882748909092871</a><br>来源：稀土掘金</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0dd9c73a2d12414abfab39fe45cf4e3a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><hr><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>这篇文章的内容会涉及以下前置 &#x2F; 相关知识，贴心的我都帮你准备好了，请享用~</p><ul><li><a href="https://juejin.cn/post/6995549209348816909">加密、摘要、签名、证书，一次说明白! </a></li></ul><hr><h1 id="1-什么是应用签名？"><a href="#1-什么是应用签名？" class="headerlink" title="1. 什么是应用签名？"></a>1. 什么是应用签名？</h1><h4 id="1-1-数字签名模型"><a href="#1-1-数字签名模型" class="headerlink" title="1.1 数字签名模型"></a>1.1 数字签名模型</h4><p><strong>数字签名（Digital Signature）也叫作数字指纹（Digital Fingerprint），它是消息摘要算法和非对称加密算法的结合体，能够验证数据的完整性，并且认证数据的来源</strong>。</p><p>数据签名算法的模型分为两个主要阶段：</p><ul><li><strong>1、签名：</strong> 先计算数据的 [摘要]，再使用私钥对 [摘要] 进行加密生成 [签名]，将 [数据 + 签名] 一并发送给接收方；</li><li><strong>2、验证：</strong> 先使用相同的摘要算法计算接收数据的 [摘要]，再使用预先得到的公钥解密 [签名]，对比 [解密的签名] 和 [计算的摘要] 是否一致。若一致，则说明数据没有被篡改。</li></ul><p>需要注意的是，Android 目前不对应用证书进行 CA 认证，应用可以由第三方（OEM、运营商、其他应用市场）签名，也可以自行签名。</p><h4 id="1-2-为什么要给应用签名？"><a href="#1-2-为什么要给应用签名？" class="headerlink" title="1.2 为什么要给应用签名？"></a>1.2 为什么要给应用签名？</h4><p>应用 APK 其实是一种特殊的 Zip 压缩包，无法避免恶意破解者解压 &#x2F; 反编译修改内容，针对这个问题有何解决方案呢？他山之石，可以攻玉 ——数字签名算法。应用签名正是数字签名算法的应用场景之一，与其他应用场景类似，目的无非是：</p><ul><li><strong>认证</strong></li></ul><p>Android 平台上运行的每个应用都必须有开发者的签名。在安装应用时，软件包管理器会验证 APK 是否已经过适当签名，安装程序会拒绝没有获得签名就尝试安装的应用。</p><ul><li><strong>验证完整性</strong></li></ul><p>软件包管理器在安装应用前会验证应用摘要，如果破解者修改了 apk 里的内容，那么摘要就不再匹配，验证失败（验证流程见下文方案）。</p><blockquote><p><strong>提示：</strong> 使用数字签名的优点是验证过程无须复杂的接口和权限，只需要在本机验证。</p></blockquote><h4 id="1-3-应用签名方案演进"><a href="#1-3-应用签名方案演进" class="headerlink" title="1.3 应用签名方案演进"></a>1.3 应用签名方案演进</h4><p>截止至 Android 11，Android 支持以下三种应用签名方案：</p><ul><li>v1 签名方案：基于 Jar 签名；</li><li>v2 签名方案：提高验证速度和覆盖度（在 Android 7.0  Nougat 中引入）；</li><li>v3 签名方案：实现密钥轮转（在 Android 9.0 Pie 中引入）。</li></ul><p>为了提高兼容性，必须按照 v1、v2、v3 的先后顺序采用签名方案，低版本平台会忽略高版本的签名方案在 APK 中添加的额外数据。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1df46bdecd74f44ab1046b7a17544a4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><p>引用自 <a href="https://link.juejin.cn/?target=https://source.android.com/security/apksigning/v2">source.android.com&#x2F;security&#x2F;ap…</a> —— Android Developers</p><hr><h1 id="2-签名方案-v1"><a href="#2-签名方案-v1" class="headerlink" title="2. 签名方案 v1"></a>2. 签名方案 v1</h1><p>v1 签名方案是基于 Jar 的签名。</p><h4 id="2-1-签名产物"><a href="#2-1-签名产物" class="headerlink" title="2.1 签名产物"></a>2.1 签名产物</h4><p>首先，我们先来分析其签名产物。<strong>v1 签名后会增加 META-INF 文件夹</strong>，其中会有如下三个文件。考虑到使用不同的证书和签名方式，得到的文件名可能不同，因此你只要留意文件的后缀即可：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">META-INF</span><br><span class="line">├── MANIFEST<span class="selector-class">.MF</span></span><br><span class="line">├── CERT<span class="selector-class">.SF</span></span><br><span class="line">├── CERT<span class="selector-class">.RSA</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><table><thead><tr><th>文件</th><th>描述</th></tr></thead><tbody><tr><td><strong>MANIFEST.MF</strong></td><td>记录「apk 中每一个文件对应的摘要」（除了 META-INF 文件夹）</td></tr><tr><td>***.SF**</td><td>记录「MANIFEST.MF 文件的摘要」和「MANIFEST.MF 中每个数据块的摘要」</td></tr><tr><td>***.RSA**</td><td>包含了「*.SF 文件的签名」和「包含公钥的开发者证书」</td></tr></tbody></table><blockquote><p><strong>提示：</strong> 如果 apk 中文件数很多，而且文件名很长，那么 <strong>MANIFEST.MF</strong> 和 ***.SF** 两个文件会变得很大。有没有办法优化呢？见 <strong>第 5.1 节 优化摘要记录文件大小</strong>。</p></blockquote><h4 id="2-2-签名流程"><a href="#2-2-签名流程" class="headerlink" title="2.2 签名流程"></a>2.2 签名流程</h4><p>v1 签名流程如下：</p><ul><li>1、计算每个文件的 SHA-1 摘要，进行 BASE64 编码后写入 MANIFEST.MF 文件；</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MANIFEST.MF（Message <span class="keyword">Digest </span>File，摘要文件）</span><br><span class="line">Manifest-Version: <span class="number">1</span>.<span class="number">0</span></span><br><span class="line"><span class="keyword">Built-By: </span>Generated-<span class="keyword">by-ADT</span></span><br><span class="line"><span class="keyword"></span>Created-<span class="keyword">By: </span><span class="keyword">Android </span>Gradle <span class="number">3</span>.<span class="number">1</span>.<span class="number">0</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">Name:</span> <span class="keyword">AndroidManifest.xml</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">SHA1-Digest: </span><span class="number">9</span>hTSmRfzHEeQc7V2wxBbTT3DmCY= 【文件的摘要】</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>2、计算整个 MANIFEST.MF 文件的 SHA-1 摘要，进行 BASE64 编码后写入 *.SF 文件；</li><li>3、计算 MANIFEST.MF 文件中每一块摘要的 SHA-1 摘要，进行 BASE64 编码后写入 *.SF 文件；</li></ul><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\*.SF（Signature File，签名文件）</span><br><span class="line"><span class="attribute">Signature-Version</span>: 1.0</span><br><span class="line"><span class="attribute">Created-By</span>: 1.0 (Android)</span><br><span class="line"><span class="attribute">SHA1-Digest-Manifest</span>: MJQyZ0dc4dv7G9nlJPAMQLwEwbU= 【MANIFEST.MF 文件的摘要】</span><br><span class="line"><span class="attribute">X-Android-APK-Signed</span>: 2</span><br><span class="line"></span><br><span class="line"><span class="attribute">Name</span>: AndroidManifest.xml</span><br><span class="line"><span class="attribute">SHA1-Digest</span>: IJioMmfD693T4qnUJcPKhq9woHQ= 【摘要的摘要】</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>4、计算整个 *.SF 文件的数字签名（先摘要再私钥加密）；</li><li>5、将数字签名和 X.509 开发者数字证书（公钥）写入 *.RSA 文件。</li></ul><blockquote><p><strong>提示：</strong>*.RSA 文件加密了，需要使用 openssl 工具打开。</p></blockquote><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61256c2282f14bc19fa96b3af6010a4c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><p>引用自 <a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/108034286">zhuanlan.zhihu.com&#x2F;p&#x2F;108034286</a> —— 木质的旋律 著</p><h4 id="2-3-验证流程"><a href="#2-3-验证流程" class="headerlink" title="2.3 验证流程"></a>2.3 验证流程</h4><p>验证流程可以分为验证签名和验证完整性两个步骤：</p><p>验证签名步骤：</p><ul><li>1、取出 *.RSA 中包含的开发者证书；</li><li>2、【注意：这里不向 CA 认证开发者证书合法性】；</li><li>3、用证书中的公钥解密 *.RSA 中包含的签名，得到摘要；</li><li>4、计算 *.SF 的摘要；</li><li>5、对比 (3) 和 (4) 的摘要是否一致；</li></ul><p>如果上述签名验证结果正确，才会验证完整性：</p><ul><li>1、计算 MANIFEST.MF 的摘要；</li><li>2、对比 *.SF 记录中的文件摘要和 (1) 的摘要是否一致；</li><li>3、如果一致，再用 MANIFEST.MF 中的每一块数据去校验每一个文件是否被修改。</li></ul><p>以上任何步骤验证失败，则整个 APK 验证失败。</p><h4 id="2-4-存在的问题"><a href="#2-4-存在的问题" class="headerlink" title="2.4 存在的问题"></a>2.4 存在的问题</h4><ul><li><strong>完整性覆盖范围不足</strong>：Zip 文件中部分内容不在验证范围，例如 META-INF 文件夹；</li><li><strong>验证速度较差</strong>：验证程序必须解压所有压缩的条目，这需要花费更多时间和内存。</li></ul><p>为了解决这些问题，Android 7.0 中引入了 APK 签名方案 v2。</p><hr><h1 id="3-签名方案-v2"><a href="#3-签名方案-v2" class="headerlink" title="3. 签名方案 v2"></a>3. 签名方案 v2</h1><p>v2 签名方案是一种 <strong>全文件签名方案</strong>，该方案能够发现对 APK 的受保护部分进行的所有更改，相对于 v1 签名方案验证速度更快，完整性覆盖范围更广。</p><blockquote><p><strong>提示：</strong> 为了兼容低版本，使用 v2 签名方案的同时，还需要使用 v1 签名方案。</p></blockquote><h4 id="3-1-Zip-文件简介"><a href="#3-1-Zip-文件简介" class="headerlink" title="3.1 Zip 文件简介"></a>3.1 Zip 文件简介</h4><p>在分析 v2 签名方案之前，我们先简单了解一下 Zip 文件格式：</p><ul><li>Zip 文件主体结构分为三个部分：<strong>「条目内容区」&amp;「中央目录区」&amp;「中央目录结尾区（EoCD）」</strong>。</li><li>EoCD 中记录了中央目录的起始位置，<strong>在「条目内容区」和「中央目录区」之间插入了其他数据不会影响 Zip 解压。</strong></li></ul><h4 id="3-2-签名产物"><a href="#3-2-签名产物" class="headerlink" title="3.2 签名产物"></a>3.2 签名产物</h4><p>首先，我们先来分析其签名产物。v2 签名后会在 <strong>「条目内容区」和「中央目录区」之间插入「APK 签名分块（APK Signing Block）」</strong>。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94f99b9849394e89b90d9228c38f85b1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><p>引用自 <a href="https://link.juejin.cn/?target=https://source.android.com/security/apksigning/v2">source.android.com&#x2F;security&#x2F;ap…</a> —— Android Developers</p><p>从左到右边，我们定义为区块 1~4。</p><h4 id="3-2-签名流程"><a href="#3-2-签名流程" class="headerlink" title="3.2 签名流程"></a>3.2 签名流程</h4><p>相对与 v1 签名方案，v2 签名方案不再以文件为单位计算摘要了，而是以 1 MB 为单位将文件拆分为多个连续的块（chunk），每个分区的最后一个块可能会小于 1 MB。</p><p>v2 签名流程如下：</p><ul><li>1、对区块 1、3、4，按照 1MB 大小分割为多个块（chunk）；</li><li>2、计算每个块的摘要；</li><li>3、计算 (2) 中所有摘要的签名。</li><li>4、添加 X.509 开发者数字证书（公钥）</li></ul><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89e90a7220234852acca987092185f1c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><p>引用自 <a href="https://link.juejin.cn/?target=https://source.android.com/security/apksigning/v2">source.android.com&#x2F;security&#x2F;ap…</a> —— Android Developers</p><h4 id="3-3-验证流程"><a href="#3-3-验证流程" class="headerlink" title="3.3 验证流程"></a>3.3 验证流程</h4><p>验证流程可以分为验证签名和验证完整性两个步骤：</p><ul><li>验证签名步骤：用公钥验证区块 2 的签名；</li><li>验证完整性步骤：用「APK数据摘要集」验证每一块数据的摘要。</li></ul><hr><h1 id="4-签名方案-v3"><a href="#4-签名方案-v3" class="headerlink" title="4. 签名方案 v3"></a>4. 签名方案 v3</h1><p>签名方案 v3 支持密钥轮换，应用能够在 APK 更新过程中更改其签名密钥。</p><p>【累了，后面先不写了…】</p><hr><h1 id="5-衍生应用场景"><a href="#5-衍生应用场景" class="headerlink" title="5. 衍生应用场景"></a>5. 衍生应用场景</h1><p>这一节，我们介绍基于 Android 应用签名机制的衍生应用场景。</p><h4 id="5-1-优化摘要记录文件大小"><a href="#5-1-优化摘要记录文件大小" class="headerlink" title="5.1 优化摘要记录文件大小"></a>5.1 优化摘要记录文件大小</h4><p>在 v1 方案中，<strong>MANIFEST.MF</strong> 和 ***.SF** 这两个文件会记录大量的文件名和文件摘要。如果 apk 中文件数很多，而且文件名很长，那么这两个文件会变得很大。使用 AndResGuard 工具，可以将文件名转换为短路径文件名，从而减少这两个文件的大小。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49fa8101870b4bb8b70b80d83a7a89c9~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><p>引用自 <a href="https://link.juejin.cn/?target=https://time.geekbang.org/column/article/81483">time.geekbang.org&#x2F;column&#x2F;arti…</a> —— 张绍文 著</p><h4 id="5-2-多渠道打包方案"><a href="#5-2-多渠道打包方案" class="headerlink" title="5.2 多渠道打包方案"></a>5.2 多渠道打包方案</h4><p>在实际生产中，往往需要生成多个渠道的 APK 包，传统的方法是使用 APKTool 逆向工具、Flavor + BuildType 等方案，这一类多渠道打包方案的缺点是耗时严重。随着 Android 应用签名方案的演进，演变出了不同的多渠道打包方案：</p><h4 id="v1-方案时代下的多渠道打包"><a href="#v1-方案时代下的多渠道打包" class="headerlink" title="v1 方案时代下的多渠道打包"></a>v1 方案时代下的多渠道打包</h4><ul><li>添加空文件</li></ul><p>在 v1 方案中，我们提到了完整性校验不覆盖到 META-INF 文件夹的问题。有些多渠道打包方案就是利用了这个问题，在 META-INF 文件夹下添加空文件，<strong>用空文件的名称来作为渠道的唯一标识</strong>，就可以节省打包的时间，提高打渠道包的速度。</p><ul><li>Zip Comment</li></ul><p>除了添加空文件的方法，还可以向 APK 添加 Zip Comment 来生成多渠道包（APK 本身就是特殊的 Zip 包）。</p><h4 id="v2-方案时代下的多渠道打包"><a href="#v2-方案时代下的多渠道打包" class="headerlink" title="v2 方案时代下的多渠道打包"></a>v2 方案时代下的多渠道打包</h4><p>在 v2 签名方案中，几乎整个 APK 都纳入保护范围，如果向 APK 添加空文件或 Zip Comment 的话，在安装时会报以下错误：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Failure [INSTALL_PARSE_FAILED_NO_CERTIFICATES: </span><br><span class="line">Failed to collect certificates <span class="keyword">from</span> <span class="keyword">base</span>.apk: META-INF/CERT.SF indicates <span class="keyword">base</span>.apk <span class="keyword">is</span> signed <span class="keyword">using</span> APK Signature Scheme v2, </span><br><span class="line">but no such signature was found. Signature stripped?]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>新背景下的多渠道打包方案，则是利用了 <strong>APK 签名分块（区块 2）不受保护 &amp; 字段可扩展的特点</strong>，向区块中添加多渠道信息（ID-Value），例如 <a href="https://link.juejin.cn/?target=https://github.com/Meituan-Dianping/walle">美团多渠道打包方案 Walle</a>。</p><hr><h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h1><ul><li>签名应用是处于两个目的：认证 &amp; 验证完整性，即：认证 APK 的开发者以及验证 APK 内容是否被篡改。截止到 Android 11，一共有 v1、v2、v3 三种签名方案。</li><li>v1 是基于 Jar 的签名方案，它存在完整性覆盖范围不足 &amp; 验证速度较差两个问题。</li><li>Android 7.0 推出的 v2 签名方案优化了这两个问题，通过「条目内容区」和「中央目录区」之间插入「APK 签名分块（APK Signing Block）」，优化了 v1 方案的两大问题。</li><li>Android 9.0 推出的 v3 方案是 v2 方案的优化版本，满足了密钥轮换的需求。</li></ul><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://link.juejin.cn/?target=https://docs.oracle.com/javase/8/docs/technotes/guides/jar/jar.html%23Signed_JAR_File">《Signed_JAR_File》</a> —— Oracle</li><li><a href="https://link.juejin.cn/?target=https://source.android.com/security/apksigning">《应用签名》</a> —— Android Developers</li><li><a href="https://link.juejin.cn/?target=https://developer.android.google.cn/studio/publish/app-signing">《对应用进行签名》</a> —— Android Developers</li><li><a href="https://link.juejin.cn/?target=https://source.android.com/security/apksigning/v2">《APK 签名方案 v2》</a> —— Android Developers</li><li><a href="https://link.juejin.cn/?target=https://source.android.com/security/apksigning/v3">《APK 签名方案 v3》</a> —— Android Developers</li><li><a href="https://link.juejin.cn/?target=https://weread.qq.com/web/reader/6ef32f805e0b836efa707cbk6f4322302126f4922f45dec">《Android 应用安全防护和逆向分析》</a>（第 12 章）—— 姜维 著</li><li><a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/108034286">《Android 端 V1&#x2F;V2&#x2F;V3 签名的原理》</a> —— 木质的旋律 著（阿里巴巴技术团队）</li><li><a href="https://link.juejin.cn/?target=https://mp.weixin.qq.com/s?__biz=MzI1NjEwMTM4OA==&mid=2651232457&idx=1&sn=90b16c3868a341272b8f1aa26d6c0122&chksm=f1d9e5aac6ae6cbcfaecb07bdd280abf81a46f1937c43f61e69d7f78d64350943356f5443d58&scene=27%23wechat_redirect">《分析Android V2新签名打包机制》</a> —— pisazzpan 著（腾讯音乐技术团队）</li><li><a href="https://link.juejin.cn/?target=https://tech.meituan.com/2017/01/13/android-apk-v2-signature-scheme.html">《新一代开源Android渠道包生成工具Walle》</a> —— 建帅 陈潼 著（美团技术团队）</li><li><a href="https://juejin.cn/post/6844903839745720333">《Android V1及V2签名原理简析》</a> —— 看书的蜗牛 著（网易技术团队）</li><li><a href="https://link.juejin.cn/?target=https://tech.meituan.com/2017/04/07/android-shrink-overall-solution.html">《Android App包瘦身优化实践》</a> —— 建帅 著（美团技术团队）</li><li><a href="https://link.juejin.cn/?target=https://time.geekbang.org/column/article/81483">《Android 开发高手课 · 包体积优化（下）》</a> —— 张绍文 著（微信技术团队），极客时间 出品</li><li>《深入理解 Android 内核设计思想》（第 20 章） —— 林学森 著</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;作者：彭旭锐&lt;br&gt;链接：&lt;a href=&quot;https://juejin.cn/post/6906882748909092871&quot;&gt;https://juejin.cn/post/6906882748909092871&lt;/a&gt;&lt;br&gt;来源：稀土掘金&lt;/p&gt;
&lt;h1 id=&quot;目</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>程序员的自我修养读书笔记-第3章 目标文件(一)</title>
    <link href="https://stevezhangzl.github.io/2022/12/05/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6(%E4%B8%80)/"/>
    <id>https://stevezhangzl.github.io/2022/12/05/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6(%E4%B8%80)/</id>
    <published>2022-12-05T07:49:36.000Z</published>
    <updated>2023-01-16T22:23:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>编译器编译源代码后生成的文件叫做目标文件。</p><p>目标文件从结构上讲，这是已经编译后的<strong>可执行文件格式</strong>，<strong>只是还没有经过链接的过程</strong>，其中可能有些符号或有些地址还没有被调整。其实它本身就是按照<strong>可执行文件格式</strong>存储的，只是跟真正的可执行文件在结构上稍有不同。</p><p>可执行文件格式涵盖了程序的编译、链接、装载和执行的各个方面。了解它的结构并深入剖析它对于认识系统、了解背后的机理大有好处。</p><h2 id="目标文件的格式"><a href="#目标文件的格式" class="headerlink" title="目标文件的格式"></a>目标文件的格式</h2><p>现在PC平台流行的可执行文件格式主要是windows下的PE和Linux的ELF，它们都是COFF格式的变种。目标文件 就是源代码编译后未进行链接的那些<strong>中间文件</strong>，它跟可执行文件的内容与结构很相似，所以一般可执行文件格式一起采用一种格式存储。从广义上看，目标文件与可执行文件的格式其实几乎是一样的，所以我们可以广义地将目标文件与可执行文件看成是一种类型的文件。</p><p>不光是可执行文件按照可执行文件格式存储。动态链接库及静态链接库文件都是按照可执行文件格式存储。静态链接库稍有不同，它是把很多目标文件捆绑在一起形成一个文件，再加上一些索引，你可以简单地把它理解为一个包含有很多目标文件的文件包。</p><table><thead><tr><th>ELF文件类型</th><th>说明</th><th>实例</th></tr></thead><tbody><tr><td>可重定位文件(Relocatable File)</td><td>这类文件包含了代码和数据，可以被用来链接成可执行文件或共享目标文件，静态库也可以归为这一类</td><td>Linux的.o</td></tr><tr><td>可执行文件(Executable File)</td><td>这类文件包含了可以直接执行的程序，它的代表就是ELF可执行文，它们一般都没有扩展名</td><td>比如&#x2F;bin&#x2F;bash文件</td></tr><tr><td>共享目标文件(shared object file)</td><td>这种文件包含了代码和数据，可以在以下两种情况下使用。第一种是链接器可以全名用这种文件跟其他的可重定位文件和共享目标文件链接，产生新的目标文件。第二种是动态链接器可以将几种这种共享目标文件与可执行文件结合，作为进程映像的一部分来运行。</td><td>Linux的.so</td></tr></tbody></table><p><code>file foobar.o</code></p><p>查看相应的文件格式</p><h2 id="目标文件是什么样的"><a href="#目标文件是什么样的" class="headerlink" title="目标文件是什么样的"></a>目标文件是什么样的</h2><p>程序源代码编译后的<strong>机器指令</strong>经常被放在<strong>代码段</strong>里，代码段常见的名字有**.code<strong>和</strong>.text** ，<strong>全局变量</strong>和<strong>局部静态变量数</strong>据经常放在<strong>数据段</strong>，数据段的一般名字都叫**.data**</p><img src="../images/image-20221208132834056.png" alt="image-20221208132834056" style="zoom:50%;" /><ul><li>ELF文件的开头是一个“文件头”，它描述了整个文件的文件属性，包括文件是否可执行、是静态链接还是动态链接及入口地址（如果可执行文件）、目标硬件、目标操作系统等信息，文件头还有一个<strong>段表</strong></li><li><strong>段表</strong>是一个<strong>描述</strong>文件中各个段的<strong>数组</strong>。描述了文件中各个段在文件中的<strong>偏移位置</strong>及段的<strong>属性</strong>，从段表里面可以得到每个段的所有信息。文件头后面就是各个段的内容，代码段保存的是程序的指令，数据段保存的是程序的静态变量。</li><li>编译后的语句编译成机器代码，保存在.text段</li><li>已初始化的全局变量和局部静态变量保存在.data段</li><li>未初始化的全局变量和局部静态变量一般放在.bss段，未初始化的默认值都为0，放在.bss段，在文件中不占据空间。</li></ul><blockquote><p>总体来说，程序源代码被编译以后主要分成两种段：程序指令和程序数据。代码段属于程序指令，而数据段和.bss段属于程序数据。</p></blockquote><h2 id="挖掘SimpleSection-o"><a href="#挖掘SimpleSection-o" class="headerlink" title="挖掘SimpleSection.o"></a>挖掘SimpleSection.o</h2><p>SimpleSection.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> global_inti_var = <span class="number">84</span>;</span><br><span class="line"><span class="keyword">int</span>  global_unint_var;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> static_var = <span class="number">85</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> static_var2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">func1(a + b + static_var + static_var2 );</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>参数-c 表示只编译不链接</strong></p><p><code>gcc -c SimpleSection.c</code></p><p>得到SimpleSection.o目标文件</p><p><code>objdump -h SimpleSection.o</code></p><p><img src="/../images/image-20221208135133311.png" alt="image-20221208135133311"></p><p>.comment 注释信息段</p><p>.note.gnu-stack 堆栈提示段</p><p>横向看</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Size</td><td>段的长度</td></tr><tr><td>File Offset</td><td>段所在的位置</td></tr><tr><td>CONTENTS</td><td>表示该段在文件中存在</td></tr><tr><td>ALLOC</td><td>该段具有某种属性</td></tr><tr><td>LOAD</td><td>该段具有某种属性</td></tr><tr><td>RELOC</td><td>该段具有某种属性</td></tr><tr><td>READONLY</td><td>该段具有某种属性</td></tr><tr><td>CODE</td><td>该段具有某种属性</td></tr><tr><td>DATA</td><td>该段具有某种属性</td></tr></tbody></table><p>size SimpleSection.o   查看ELF文件的代码段、数据段和BSS段的长度（dec表示3个段长度和的十进制，hex表示长度和的十六进制）</p><p><img src="/../images/image-20221208140242825.png" alt="image-20221208140242825"></p><p><img src="/../images/image-20221208145813757.png" alt="image-20221208145813757"></p><p>用size看的text的长度还包含的.note.gnu.property和.eh_frame的长度，刚好加起来是189</p><h3 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h3><p>objdump </p><ul><li><p>-s  参数可以将所有段的内容以十六进制的方式打印出来</p></li><li><p>-d  参数可以将所有的包含指令的段反汇编</p></li></ul><p><code>objdump -s -d SimpleSection.o</code></p><p><img src="/../images/image-20221208150615895.png" alt="image-20221208150615895"></p><p>Contents of section .text 就是.text的数据以十六进制方式打印出来的内容，总共0x45字节，跟 .text段的长度符合，左边是偏移量，中间4例是十六进制内容，最后面是.text段的ASCII码。</p><p>下面是反汇编结果 -d 可以看到 .text段里，包含的就是SimpeSection.c里两个函数func1和main的指令。左面已经把各条指令分别对应的汇编指令输出来了。</p><h3 id="数据段和只读数据段"><a href="#数据段和只读数据段" class="headerlink" title="数据段和只读数据段"></a>数据段和只读数据段</h3><p>如果我们在代码里加入一句话printf</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global_inti_var = <span class="number">84</span>;</span><br><span class="line"><span class="keyword">int</span>  global_unint_var;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> static_var = <span class="number">85</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> static_var2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">func1(a + b + static_var + static_var2 );</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为用到了一个字符串常量 %d\n，是一种只读数据，所以会放在.rodata段，我们再来用</p><p><code>objdump -h SimpleSection.o</code></p><p><img src="/../images/image-20221208152110539.png" alt="image-20221208152110539"></p><ul><li>.data段保存的是那些已经<strong>初始化了的全局变量和局部静态变量</strong>。SimpleSection.c中一个是global_inti_var和static_var这两个变量每个4个字节，刚好是8个字节，所以.data这个段的大小为8个字节。</li></ul><p><code>objdump -s SimpleSection.o</code></p><p><img src="/../images/image-20221208153039103.png" alt="image-20221208153039103"></p><ul><li>printf里用了一个字符串常量“%d\n” 是一个只读数据，这4个字节刚好是这个字符常量 的ASCII字节充，最后以\0x结尾，放在.rodata段，.rodata段存放的是只读数据，一般是程序里面的只读变量（如const修饰的变量）和字符串常量。</li></ul><p><code>objdump -x -s -d SimpleSection.o</code></p><ul><li>-x 输出<strong>文件体系结构</strong> <strong>文件格式</strong> <strong>节信息</strong>  <strong>符号表</strong></li><li>-s  参数可以将所有段的内容以十六进制的方式打印出来</li><li>-d 参数可以将所有的包含指令的段反汇编</li></ul><p><img src="/../images/image-20221208153832399.png" alt="image-20221208153832399"></p><p>我们重点是验证前面.data的结论</p><p><img src="/../images/image-20221208153904864.png" alt="image-20221208153904864"></p><p>可以看到.data段里前4个字节，从低到高 0x54 0x00 0x00 0x00  刚好是global_init_var 即十进制的84，而最后4个字节刚好是static_init_var 的值即85。</p><blockquote><p>为什么存放次序为0x54 0x00 0x00 0x00而不是 00 00 00 54？</p><p>涉及CPU的字节序问题，即所谓的大端序（Big-endian）和小端序（Little-endian）问题</p></blockquote><h3 id="BSS段"><a href="#BSS段" class="headerlink" title="BSS段"></a>BSS段</h3><p>.bss段放的是未初始化的全局变量和局部静态变量，上述代码中global_uninit_Var和static_var2就是存放在.bss段，其实更准确的说法是.bss段为它们预留了空间</p><p>但我们发现该段只有4字节，和两个变量大小8个字节不符。</p><p>通过符号表看到</p><p><img src="/../images/image-20221208160024230.png" alt="image-20221208160024230"></p><p>确实只有static_var2放在.bss段，而global_uninit_var却没有存放在任何段，跟编译器的实现有关，有的会把<strong>全局未初始化变量</strong>存放在.bss段，有些则不存放，只是一个未定义的全局变量符号 这里是COMMON符号，等最终链接成可执行文件再在.bss段分配空间。可以把.c文件换成.cpp文件再编译，发现放在.bss段，我们现在全当它们放在.bss段。</p><h3 id="其他段"><a href="#其他段" class="headerlink" title="其他段"></a>其他段</h3><p>除了.text .data .bss 3个最常用段之外，还有一些常见的段。</p><table><thead><tr><th>常用的段名</th><th>说明</th></tr></thead><tbody><tr><td>.rodata1</td><td>Read only Data，这种段里存放的是只读数据，比如字符串常量、全局const变量。跟.rodata一样</td></tr><tr><td>.comment</td><td>存放的是编译器版本信息，比如字符串：GCC:(GNU)4.2.0</td></tr><tr><td>.debug</td><td>调试信息</td></tr><tr><td>.dynamic</td><td>动态链接信息</td></tr><tr><td>.hash</td><td>符号哈希表</td></tr><tr><td>.line</td><td>调试时的行号表，即源代码行号与编译后指令的对应表</td></tr><tr><td>.note</td><td>额外的编译器信息。比如程序的公司名、发布版本号等</td></tr><tr><td>.strtab</td><td>String Table 字符串表，用于存储ELF文件中用到的各种字符串</td></tr><tr><td>.symtab</td><td><strong>Symbol Table符号表</strong></td></tr><tr><td>.shstrtab</td><td>Section String Table 段名表</td></tr><tr><td>.plt</td><td>动态链接跳转表和全局入口表</td></tr><tr><td>.got</td><td>动态链接跳转表和全局入口表</td></tr><tr><td>.init</td><td>程序初始化与终结代码段</td></tr><tr><td>.fini</td><td>程序初始化与终结代码段</td></tr></tbody></table><p><strong>这些表的名字是系统保留的</strong>，应用程序也可以使用一些非系统保留的名字作为段名。比如可以在ELF文件中插入一个music的段，里面放一道mp3音乐，当ELF文件运行起来以后可以读取这个段播放mp3。<strong>但是应用程序自定义的段名不能使用.作为前缀，否则容易跟系统保留段名冲突。</strong></p><blockquote><p>怎么把一个图片、MP3音乐一类的东西作为目标文件中的一个段，要怎么做？</p><p><code>objcopy -I binary -O elf64-x86-64 -B i386 awsl12.jpg awsl12.o</code></p><p>把jpg转成.o</p><p><code>objdump -ht awsl12.o</code> 查看目标文件的格式和符号表</p></blockquote><p><img src="/../images/image-20221209093804930.png" alt="image-20221209093804930"></p><p>它有符号 _binary_awsl12_jpg_start  _binary_awsl12_jpg_end 和_binary_awsl12_jpg_size 分别表示该图片在内存中的起始地址、结束地址和大小、可以在程序里面直接声明并使用它们。</p><h3 id="自定义段"><a href="#自定义段" class="headerlink" title="自定义段"></a>自定义段</h3><p>通常代码会放在.text段，全局变量和静态变量会放到.data和.bss段，但你可能希望变量或某些部分代码能够放到你所指定的段中去，实现某些特定的功能。比如为了满足某些硬件的内存和IO地址布局</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format,...)</span></span>;</span><br><span class="line"></span><br><span class="line">__attribute__((section(<span class="string">&quot;FOO&quot;</span>))) <span class="keyword">int</span> global_inti_var = <span class="number">84</span>;</span><br><span class="line"><span class="keyword">int</span>  global_unint_var;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__attribute__((section(<span class="string">&quot;BAR&quot;</span>))) <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> static_var = <span class="number">85</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> static_var2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">func1(a + b + static_var + static_var2 );</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>添加_<em>attribute</em>_((section(“name”)))属性就可以把相应的变量或函数以“name”作为段名的段中。注意自定义段不是.开头的</p></blockquote><p><img src="/../images/image-20221209094547202.png" alt="image-20221209094547202"></p><h2 id="ELF文件结构描述"><a href="#ELF文件结构描述" class="headerlink" title="ELF文件结构描述"></a>ELF文件结构描述</h2><img src="../images/image-20221209095037002.png" alt="image-20221209095037002" style="zoom:50%;" /><p>ELF文件中与段关的重要结构就是<strong>段表</strong>（Section Header Table），该表描述了ELF文件包含的所有段的信息，比如每个段的<strong>段名</strong>、<strong>段的长度</strong>、在文件中的<strong>偏移</strong>、<strong>读写权限</strong>及段的其他属性。</p><h3 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h3><p><code>readelf -h SimpelSection.o</code> 查看ELF文件的文件头</p><p><img src="/../images/image-20221209105004038.png" alt="image-20221209105004038"></p><p>ELF文件头结构及相关常数被定义在 <code>/user/include/elf.h</code>里，ELF文件在各平台下都通用，有32位和64位版本。32和64位版本的ELF文件的文件头内容是一样的，只不过有些成员大小不一样。用<strong>typedef</strong>定义了一套自己的变量体系。</p><table><thead><tr><th>自定义类型</th><th>描述</th><th>原始类型</th><th>长度（字节）</th></tr></thead><tbody><tr><td>Elf64_Addr</td><td>64位版本程序地址</td><td>uint64_t</td><td>8</td></tr><tr><td>Elf64_Half</td><td>..无符号短整形</td><td>uint16_t</td><td>2</td></tr><tr><td>Elf64_Off</td><td>..偏移地址</td><td>uint64_t</td><td>8</td></tr><tr><td>Elf64_Sword</td><td>..有符号整形</td><td>int32_t</td><td>4</td></tr><tr><td>Elf64_Word</td><td>..无符号整形</td><td>uint32_t</td><td>4</td></tr></tbody></table><p>文件头的结构，定义 Elf64_Ehdr 结构体中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_hdr</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>e_ident[<span class="number">16</span>];<span class="comment">/* ELF &quot;magic number&quot; */</span></span><br><span class="line">  Elf64_Half e_type;</span><br><span class="line">  Elf64_Half e_machine;</span><br><span class="line">  Elf64_Word e_version;</span><br><span class="line">  Elf64_Addr e_entry;<span class="comment">/* Entry point virtual address */</span></span><br><span class="line">  Elf64_Off e_phoff;<span class="comment">/* Program header table file offset */</span></span><br><span class="line">  Elf64_Off e_shoff;<span class="comment">/* Section header table file offset */</span></span><br><span class="line">  Elf64_Word e_flags;</span><br><span class="line">  Elf64_Half e_ehsize;</span><br><span class="line">  Elf64_Half e_phentsize;</span><br><span class="line">  Elf64_Half e_phnum;</span><br><span class="line">  Elf64_Half e_shentsize;</span><br><span class="line">  Elf64_Half e_shnum;</span><br><span class="line">  Elf64_Half e_shstrndx;</span><br><span class="line">&#125; Elf64_Ehdr;</span><br></pre></td></tr></table></figure><ul><li>e_ident 对应 <strong>类别</strong> &#x2F;<strong>数据</strong>&#x2F; <strong>Version &#x2F;OS&#x2F;ABI</strong>&#x2F; <strong>ABI版本</strong></li></ul><p><img src="/../images/image-20221209110615180.png" alt="image-20221209110615180"></p><p>剩下的参数与Elf64_Ehdr中的成员一一对应</p><ul><li>e_type    类型</li></ul><p><img src="/../images/image-20221209110741748.png" alt="image-20221209110741748"></p><ul><li>e_machine    系统架构</li></ul><p><img src="/../images/image-20221209110824065.png" alt="image-20221209110824065"></p><ul><li>e_version 版本    一般为常数1</li></ul><p><img src="/../images/image-20221209110837646.png" alt="image-20221209110837646"></p><ul><li>e_entry    入口点地址    可重入文件一般没有入口地址，则这个值为0</li></ul><p><img src="/../images/image-20221209110917620.png" alt="image-20221209110917620"></p><ul><li>e_phoff  程序头起点  暂不关系，要看”ELF链接视图和执行视图”</li></ul><p><img src="/../images/image-20221209111116053.png" alt="image-20221209111116053"></p><ul><li>e_shoff  段表在文件中的偏移（ELF文件头会指出段表 Section Header Table在文件中的偏移地址，很重要，通过这个可以找到段表的位置）</li></ul><p><img src="/../images/image-20221209111205539.png" alt="image-20221209111205539"></p><ul><li>e_word    标志位</li></ul><p><img src="/../images/image-20221209111321412.png" alt="image-20221209111321412"></p><ul><li>e_ehsize    ELF文件头本身大小这里是64个字节</li></ul><p><img src="/../images/image-20221209111408212.png" alt="image-20221209111408212"></p><ul><li>e_phentsize    看后面ELF链接视图和执行视图一节</li></ul><p><img src="/../images/image-20221209111451191.png" alt="image-20221209111451191"></p><ul><li>e_phnum  看后面ELF链接视图和执行视图一节</li></ul><p><img src="/../images/image-20221209111527639.png" alt="image-20221209111527639"></p><ul><li>e_shentsize    段表描述符的大小    一般等于sizeof(Elf64_Ehdr)</li></ul><p><img src="/../images/image-20221209111625057.png" alt="image-20221209111625057"></p><ul><li>e_shnum    段表描述符数量。这个值等于ELF文件中拥有的段的数量，这里是14</li></ul><p><img src="/../images/image-20221209111715664.png" alt="image-20221209111715664"></p><ul><li>e_shstrndx    段表字符串表所在的段在段表中的下标</li></ul><p><img src="/../images/image-20221209111802059.png" alt="image-20221209111802059"></p><h4 id="ELF魔数"><a href="#ELF魔数" class="headerlink" title="ELF魔数"></a>ELF魔数</h4><p><img src="/../images/image-20221209130235027.png" alt="image-20221209130235027"></p><p>0x7f 0x45 0x4c 0x46  ELF文件的魔数，表示这是一个ELF文件</p><p>0x02 表示是64位的 0x01是32位 0  是无效文件</p><p>0x01 小端序 0x02 大端序 0 无效格式 </p><p>0x01 主版本号  一般是1</p><p>后面9个字节  没有定义  一般填0</p><h4 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h4><table><thead><tr><th>常量</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>ET_REL</td><td>1</td><td>可重定位文件，一般为.o文件</td></tr><tr><td>ET_EXEC</td><td>2</td><td>可执行文件</td></tr><tr><td>ET_DYN</td><td>3</td><td>共享目标文件，一般为.so文件</td></tr></tbody></table><h3 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h3><p>Section Header Table 段表是保存这些段的基本属性的结构。ELF文件的段结构就是由段表决定的，每个段的段名、段的长度、在文件中的偏移、读写权限及段的其他属性。</p><blockquote><p>编译器、链接器和装载器都是依靠段表来定位和访问各个段的属性的。</p></blockquote><p>段表在ELF文件中位置由e_shoff成员决定。</p><p>objdump -h 命令只是把ELF文件中的关键段显示出来，省略了其他的辅助性的段，比如符号表、字符串表、段名字符串表、重定位表等。</p><p>用readelf来看ELF的真正段表结构：</p><p><code>readelf -S SimpleSection.o</code></p><p><img src="/../images/image-20221209131413041.png" alt="image-20221209131413041"></p><p>段表的结构体为<strong>Elf64_Shdr</strong>的数组，数组元素为段的个数，每个shdr结构体对应一个段。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_shdr</span> &#123;</span></span><br><span class="line">  Elf64_Word sh_name;<span class="comment">/* Section name, index in string tbl */</span></span><br><span class="line">  Elf64_Word sh_type;<span class="comment">/* Type of section */</span></span><br><span class="line">  Elf64_Xword sh_flags;<span class="comment">/* Miscellaneous section attributes */</span></span><br><span class="line">  Elf64_Addr sh_addr;<span class="comment">/* Section virtual addr at execution */</span></span><br><span class="line">  Elf64_Off sh_offset;<span class="comment">/* Section file offset */</span></span><br><span class="line">  Elf64_Xword sh_size;<span class="comment">/* Size of section in bytes */</span></span><br><span class="line">  Elf64_Word sh_link;<span class="comment">/* Index of another section */</span></span><br><span class="line">  Elf64_Word sh_info;<span class="comment">/* Additional section information */</span></span><br><span class="line">  Elf64_Xword sh_addralign;<span class="comment">/* Section alignment */</span></span><br><span class="line">  Elf64_Xword sh_entsize;<span class="comment">/* Entry size if section holds table */</span></span><br><span class="line">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure><p>段表是有14个元素的数组，第一个元素是无效的，类型为NULL，共有13个有效的段</p><table><thead><tr><th>成员</th><th>描述</th></tr></thead><tbody><tr><td>sh_name</td><td>Section name 段名<br />段名是字符串，它位于一个叫做.shstrtab的字符串表。sh_name是段名字符串在.shstrtab中的偏移</td></tr><tr><td>sh_type</td><td>Section type 段的类型</td></tr><tr><td>sh_flags</td><td>Section flag 段的标志位</td></tr><tr><td>sh_addr</td><td>Section Address 段虚拟地址<br />如果该段可以被加载，则sh_addr为该段被加载后在进程地址空间中的虚拟地址；否则sh_addr为0</td></tr><tr><td>sh_offset</td><td>Section Offset 段偏移<br />如果该段存在于文件中，则表示该段在文件中的偏移；否则无意义。比如sh_offset对于BSS段来说就没有意义</td></tr><tr><td>sh_size</td><td>Section Size 段的长度</td></tr><tr><td>sh_link和<br />sh_info</td><td>Section Link and Section Information段链接信息</td></tr><tr><td>sh_addralign</td><td>段地址对齐</td></tr><tr><td>sh_entsize</td><td>Section Entry Size项的长度<br />有些段包含固定大小的项，比如符号表它包含的每个符号所占的大小都一样的。表示每个项的大小，如果为0，则表示该段不包含固定大小的项</td></tr></tbody></table><blockquote><p>readelf -S 的输出结果从第二列名称开始的每一列，对应于结构体中的每个成员</p></blockquote><h4 id="段的类型"><a href="#段的类型" class="headerlink" title="段的类型"></a>段的类型</h4><p>段的名字只是链接和编译过程有意义，不能真正地表示段的类型。我们可以将一个数据段命名为.text 决定段的属性的是段的类型sh_type和段的标志位sh_flags </p><img src="../images/image-20221209185728928.png" alt="image-20221209185728928" style="zoom:50%;" /><p>以SHT_开头</p><table><thead><tr><th>常量</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>SHT_NULL</td><td>0</td><td>无效段</td></tr><tr><td>SHT_PROGBITS</td><td>1</td><td>程序段，代码段，数据段都是这种类型的</td></tr><tr><td>SHT_SYMTAB</td><td>2</td><td>表示该段的内容为符号表</td></tr><tr><td>SHT_STRTAB</td><td>3</td><td>表示该段的内容为字符串表</td></tr><tr><td>SHT_RELA</td><td>4</td><td>重定位表。该段包含了重定位信息</td></tr><tr><td>SHT_HASH</td><td>5</td><td>符号表的哈希表</td></tr><tr><td>SHT_DYNAMIC</td><td>6</td><td>动态链接信息</td></tr><tr><td>SHT_NOTE</td><td>7</td><td>提示性信息</td></tr><tr><td>SHT_NOBITS</td><td>8</td><td>表示该段在文件中没内容</td></tr><tr><td>SHT_REL</td><td>9</td><td>该段包含了重定位信息</td></tr><tr><td>SHT_SHLIB</td><td>10</td><td>保留</td></tr><tr><td>SHT_DNYSYM</td><td>11</td><td>动态链接的符号表</td></tr></tbody></table><h4 id="段的标志位"><a href="#段的标志位" class="headerlink" title="段的标志位"></a>段的标志位</h4><p>是否可写，是否可执行，以SHF_开头</p><table><thead><tr><th>常量</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>SHF_WRITE</td><td>1</td><td>表示该段在进程空间中可写</td></tr><tr><td>SHF_ALLOC</td><td>2</td><td>表示该段在进程空间中须要分配空间。有些包含指示或控制信息的段不需要在进程空间中被分配空间，它们一般不会有这个标志。像代码段、数据段和.bss段都会有这个标志位</td></tr><tr><td>SHF_EXECINSTR</td><td>4</td><td>表示该段在进程空间中可以被执行，一般指代码段</td></tr></tbody></table><h4 id="段的链接信息（sh-link、sh-info）"><a href="#段的链接信息（sh-link、sh-info）" class="headerlink" title="段的链接信息（sh_link、sh_info）"></a>段的链接信息（sh_link、sh_info）</h4><p>如果段的类型是与链接相关的（不论是动态链接或静态链接），比如重定位表、符号表等，那么sh_link和sh_info这两个成员所包含的意义如下，对于其他类型的段，这两个成员没有意义。</p><p>链接信息要配合着sh_type一起看的</p><table><thead><tr><th>sh_type</th><th>sh_link</th><th>sh_info</th></tr></thead><tbody><tr><td>SHT_DYNAMIC</td><td>该段所使用的字符串表在段表中的下标</td><td>0</td></tr><tr><td>SHT_HASH</td><td>该段所使用的符号表在段表中的下标</td><td>0</td></tr><tr><td>SHT_REL<br />SHT_RELA</td><td>该段所使用的相应符号表在段表中的下标</td><td>该重定位表所作用的段在段表中的下标</td></tr><tr><td>SHT_SYMTAB<br />SHT_DYNSYM</td><td>操作系统相关的</td><td>操作系统相关的</td></tr><tr><td>other</td><td>SHN_UNDEF</td><td>0</td></tr></tbody></table><p>比如</p><p><img src="/../images/image-20221210062408633.png" alt="image-20221210062408633"></p><h3 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h3><p>SimpleSection.o有一个叫 .rel.text的段，类型是SHT_RELA 也就是说它是一个重定位表。正如我们前面所说的，链接器在处理目标文件时，需要对目标文件中某些部位进行重定位，即代码段和数据段中那些对绝对地址的引用的位置。这些重定位的信息都记录在ELF文件的重定位表里面，对于每个需要重定位的代码段或数据段，都会有一个相应的重定位表。比如SimpleSection.o中的.rel.text就是针对.text段的重定位表，因为.text段中至少有一个绝对地址的引用，那就是对printf函数的调用；而.data段则没有对绝对地址的引用，它只包含了几个常量，所以没有针对.data段的重定位表.rel.data</p><p>一个重定位表同时也是ELF的一个段，那么这个段的类型sh_type就是SHT_RELA类型的</p><ul><li>sh_link：表示符号表的下标，这里是11 也就是.symtab</li><li>sh_info：表示它作用于哪个段，比如这里是1就是.text段</li></ul><h3 id="字符串表"><a href="#字符串表" class="headerlink" title="字符串表"></a>字符串表</h3><p>ELF文件中用到很多字符串，比如段名、变量名等。因为字符串的长度往往是不定的，所以用固定的结构来表示它比较困难。一种很常见的做法是把字符串集中起来存放到一个表，然后使用字符串在表中的偏移来引用字符串。</p><table><thead><tr><th>偏移</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>0</td><td>\0</td><td>h</td><td>e</td><td>l</td><td>l</td><td>o</td><td>w</td><td>o</td><td>r</td><td>l</td></tr><tr><td>10</td><td>d</td><td>\0</td><td>M</td><td>y</td><td>v</td><td>a</td><td>r</td><td>i</td><td>a</td><td>b</td></tr><tr><td>20</td><td>l</td><td>e</td><td>\0</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>那么偏移与它们对应的字符串如下</p><table><thead><tr><th>偏移</th><th>字符串</th></tr></thead><tbody><tr><td>0</td><td>空字符串</td></tr><tr><td>1</td><td>helloworld</td></tr><tr><td>6</td><td>world</td></tr><tr><td>12</td><td>Myvariable</td></tr></tbody></table><p>通过这种方法，在ELF文件中引用字符串只需要给出一个数字下标即可，不用考虑字符串长度的问题。一般字符串表在ELF文件中也以段的形式保存，常见的段名为.strtab或.shstrtab 这两个字符串表分别为<strong>字符串表</strong>和<strong>段表字符串表</strong>。顾名思义，<strong>字符串表</strong>用来保存普通的字符串，比如<strong>符号的名字</strong>；<strong>段表字符串表</strong>用来保存段表中用到的字符串，最常见的就是<strong>段名</strong>(sh_name)</p><p>回头看ELF文件头e_shstrndx含义，是ELF64_Ehdr的最后一个成员，它是Section header string table index的缩写。段表字符串表本身也是ELF文件中的一个普通的段，它的名字是.shstrtab。那么这个e_shstrndx就是.shstrtab在段表中的下标。</p><p><img src="/../images/image-20221210065104164.png" alt="image-20221210065104164"></p><p>readelf -S SimpleSection.o 看一下，确实是13</p><p><img src="/../images/image-20221210065115607.png" alt="image-20221210065115607"></p><p>只有分析ELF文件头，就可以得到段表和段表字符串表的位置，从而解析整个ELF文件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;编译器编译源代码后生成的文件叫做目标文件。&lt;/p&gt;
&lt;p&gt;目标文件从结构上讲，这是已经编译后的&lt;strong&gt;可执行文件格式&lt;/strong&gt;，&lt;strong&gt;只是还没有经过链接的过程&lt;/strong&gt;，其中可能有些符号或有些地址还没有被调整。其实它本身就是按照&lt;stron</summary>
      
    
    
    
    <category term="c原理" scheme="https://stevezhangzl.github.io/categories/c%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>程序员的自我修养读书笔记-第2章 编译和链接</title>
    <link href="https://stevezhangzl.github.io/2022/12/05/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E7%AB%A0-%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5/"/>
    <id>https://stevezhangzl.github.io/2022/12/05/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E7%AB%A0-%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5/</id>
    <published>2022-12-05T03:04:38.000Z</published>
    <updated>2023-01-16T22:23:56.000Z</updated>
    
    <content type="html"><![CDATA[<img src="../images/image-20221205142824934.png" alt="image-20221205142824934" style="zoom:50%;" /><h2 id="被隐藏了的过程"><a href="#被隐藏了的过程" class="headerlink" title="被隐藏了的过程"></a>被隐藏了的过程</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以直接执行</p><p>gcc hello.c 生成a.out</p><p>.&#x2F;a.out</p><p>Hello World</p><h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><p>预编译后的文件扩展名是.i</p><p><code>gcc -E hello.c -o hello.i</code></p><p>生成hello.i文件</p><p>预编译过程主要处理那些源代码文件中的以“#”开始的预编译指令。比如#include、#define等</p><p>经过预编译后的.i文件不包含任何宏定义，因为所有的宏已经被展开，并且包含的文件已经被插入到.i文件中。<strong>所以当我们无法判断宏定义是否正确或头文件是否正确时，可以查看预编译后的文件来确定问题。</strong></p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>把预处理完的文件进行一系列<strong>词法分析</strong>、<strong>语法分析</strong>、<strong>语义分析</strong>及<strong>优化</strong>后生产相应的<strong>汇编代码</strong>文件，是整个程序构建的核心部分，最复杂部分之一。</p><p>gcc -S hello.i -o hello.s</p><p>gcc -S hello.c -o hello.s</p><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>将汇编代码转变成机器指令。只是根据汇编指令和机器指令的对照表一一翻译就可以</p><p>as hello.s -o hello.o</p><p>gcc -c hello.s -o hello.o</p><p>gcc -c hello.c -o hello.o</p><p>经过预编译、编译和汇编直接输出<strong>目标文件</strong></p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ul><li>1.为什么汇编器不直接输出可执行文件而是输出一个<strong>目标文件</strong>？</li><li>2.为什么要链接？</li></ul><p>我们需要将一大堆文件 crtlo crti.o … hello.o 链接起来才可以得到a.out 即最终的可执行文件。</p><h2 id="编译器做了什么"><a href="#编译器做了什么" class="headerlink" title="编译器做了什么"></a>编译器做了什么</h2><p>6步：</p><ul><li>扫描</li><li>语法分析</li><li>语义分析</li><li>源代码优化</li><li>代码生成</li><li>目标代码优化</li></ul><p>具体每个过程参见书中42 - 47</p><p>经过这些扫描、语法分析、语义分年、源代码优化、代码生成和目标代码优化，编译器忙活了这么多个步骤以后，源代码终于被编译成了目标代码。但是这个目标代码中有一个问题是：符号的地址还没有确定。如果把目标代码使和汇编器编译成真正能够在机器上执行的指令。</p><p>1.那么符号的地址应该从哪得到呢？</p><p>2.如果符号定义在其他程序模块呢？又怎么知道它们的地址？</p><p><strong>事实上，定义其他模块的全局变量和函数在最终运行时的绝对地址都要在最终链接的时候才能确定。</strong>所以编译器可以将一个源代码文件编译成一个<strong>未链接的目标文件</strong>，然后由<strong>链接器</strong>最终将这些目标文件链接起来形成<strong>可执行文件</strong>。</p><h2 id="链接器历史更长"><a href="#链接器历史更长" class="headerlink" title="链接器历史更长"></a>链接器历史更长</h2><p>重新计算各个目标的地址过程被叫做<strong>重定位</strong></p><p>**符号(Symbol)**这个概念随着汇编语言的普及迅速被使用，它用来表示一个地址，这个地址可能是一段子程序(后来发展成函数)的起始地址，也可以是一个变量的起始地址。</p><p>属于静态语言的C&#x2F;C++模块之间通信有两种方式</p><ul><li>一种是模块间的函数调用</li><li>一种是模块间的变量访问</li></ul><p>函数访问须知道目标函数的地址，变量访问也须知道目标变量的地址，所以这两种方式都可以归结为一种方式，那就是模块间<strong>符号</strong>的引用</p><h2 id="模块拼装—静态链接"><a href="#模块拼装—静态链接" class="headerlink" title="模块拼装—静态链接"></a>模块拼装—静态链接</h2><p>链接的主要内容就是把各个模块之间相互相用的部分都处理好，使得各个模块之间都能够正确地衔接。链接器所要做的工作其实跟前面所描述的“程序员人工调整地址”本质上没有两样。</p><p>链接过程主要包括了</p><ul><li><strong>地址和空间分配</strong></li><li><strong>符号决议</strong></li><li><strong>重定位</strong></li></ul><p>每个模块的源代码文件（如.c）文件经过编译器编译成目标文件（.o）目标文件和库一起链接形成最终可执行文件。而最常见的库就是<strong>运行时库</strong>，它是支持程序运行的基本函数的集合。<strong>库其实就是一组目标文件的包，就是一些最常用的代码编译成目标后打包存放</strong></p><blockquote><p>.o文件叫做中间目标文件比较合适，简称为目标文件，很多时候我们也把目标文件称为模块。</p></blockquote><p><strong>静态链接的最基本过程和作用：</strong></p><p>比如我们在程序模块main.c中使用另外一个模块func.c中的函数foo() 我们在main.c模块中每一处调用foo的时候都必须确切知道foo这个函数的地址，但是由于每个模块都是单独编译的，在编译器编译main.c的时候它并不知道foo函数的地址，所以它暂时把这些调用 foo的指令的目标地址搁置，等待最后链接的时候由链接器去将这些指令的目标地址修正。如果没有链接器，需要我们手工把每个调用foo的指令进行修正，则填入正确的foo函数地址。当func.c模块被重新编译，foo函数的地址有可能改变时，那么我们在main.c中所有使用到foo的地址的指令将要全部重新调整。这些繁琐的工作将成为程序员的噩梦。使用链接器，你可以直接引用其他模块的函数和全局变量而无需知道它的地址，因为链接器在链接的时候，会根据你所引用的符号foo,自动去相应的func.c模块查找foo的地址，然后将main.c模块中的所有引用到foo的指令重新修正，让它们的目标地址为真正的foo函数的地址。</p><p><strong>重定位过程：</strong></p><p>假设我们有个全局变量叫var，它在目标文件A里面。我们在目标文件B里面要访问这个全局变量，比如我们在目标文件B里有这么一条指令：</p><p>movl  $0x2a,var</p><p>这条指令就是给这个var变量赋值0x2a，相当于C语言中的var &#x3D;42。然后我们编译目标文件B，得到这条指令机器码</p><img src="../images/image-20221205142040647.png" alt="image-20221205142040647" style="zoom:50%;" /><p>由于在编译目标文件B的时候，编译器并不知道变量var的目标地址，所以编译器在没法确定地址的情况下，将这条mov指令的目标地址设为0，等待链接器在将目标文件 A和B链接起来的时候再将其修正。我们假设A和B链接后，变量var地址确定下来0x1000，那么链接器将会把这个指令的目标地址部分修改成0x1000。这个地址修正的过程被叫做重定位。每个要被修正的地方叫一个得重定位入口。重定位所做的就是给程序中每个这样的绝对地址引用的位置“打补丁”，使它们指向正确的址。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;../images/image-20221205142824934.png&quot; alt=&quot;image-20221205142824934&quot; style=&quot;zoom:50%;&quot; /&gt;



&lt;h2 id=&quot;被隐藏了的过程&quot;&gt;&lt;a href=&quot;#被隐藏了的过程&quot; c</summary>
      
    
    
    
    <category term="c原理" scheme="https://stevezhangzl.github.io/categories/c%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>JNI开发笔记</title>
    <link href="https://stevezhangzl.github.io/2022/11/25/JNI%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    <id>https://stevezhangzl.github.io/2022/11/25/JNI%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</id>
    <published>2022-11-25T06:26:22.000Z</published>
    <updated>2023-01-16T22:23:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用javah-生成头文件"><a href="#使用javah-生成头文件" class="headerlink" title="使用javah 生成头文件"></a>使用javah 生成头文件</h2><p>目录结构如下</p><p><img src="/../images/image-20221128092326115.png" alt="image-20221128092326115"></p><p><code>MainActivity.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Used to load the &#x27;jnistudy1128&#x27; library on application startup.</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;jnistudy1128&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ActivityMainBinding binding;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        binding = ActivityMainBinding.inflate(getLayoutInflater());</span><br><span class="line">        setContentView(binding.getRoot());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Example of a call to a native method</span></span><br><span class="line">        TextView tv = binding.sampleText;</span><br><span class="line">        tv.setText(stringFromJNI());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A native method that is implemented by the &#x27;jnistudy1128&#x27; native library,</span></span><br><span class="line"><span class="comment">     * which is packaged with this application.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">stringFromJNI</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在命令行到java目录下，注意在包名外面</p><p><img src="/../images/image-20221128092417568.png" alt="image-20221128092417568"></p><p>执行javah</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javah -o MainActivity.h cn.com.jit.jnistudy1128.MainActivity</span><br></pre></td></tr></table></figure><p>注意：后面的输入文件要带上全类名信息</p><p>执行这句后，会在java目录下生成一个MainActivity.h文件</p><p><img src="/../images/image-20221128092554003.png" alt="image-20221128092554003"></p><p><code>MainActivity.h</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Header for class cn_com_jit_jnistudy1128_MainActivity */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _Included_cn_com_jit_jnistudy1128_MainActivity</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Included_cn_com_jit_jnistudy1128_MainActivity</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     cn_com_jit_jnistudy1128_MainActivity</span></span><br><span class="line"><span class="comment"> * Method:    stringFromJNI</span></span><br><span class="line"><span class="comment"> * Signature: ()Ljava/lang/String;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL <span class="title">Java_cn_com_jit_jnistudy1128_MainActivity_stringFromJNI</span></span></span><br><span class="line"><span class="function">  <span class="params">(JNIEnv *, jobject)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们把生成的jni方法拷贝到cpp文件中就可以使用了，别忘了引入头文件</p><h2 id="JNIEnv-在c和c-的区别"><a href="#JNIEnv-在c和c-的区别" class="headerlink" title="JNIEnv 在c和c++的区别"></a>JNIEnv 在c和c++的区别</h2><h3 id="在c-中调用"><a href="#在c-中调用" class="headerlink" title="在c++中调用"></a>在c++中调用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env-&gt;<span class="built_in">GetIntArrayElements</span>(i_, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><p>直接把它当指针，使用箭头符调用即可</p><p>我们看JNIEnv是什么？c++中是_JNIEnv</p><p><img src="/../images/image-20221128140805129.png" alt="image-20221128140805129"></p><p>再点进去</p><p><img src="/../images/image-20221128140833824.png" alt="image-20221128140833824"></p><p>它是一个结构体，我们传入方法的参数JNIEnv *env 相当于是这个结构体的指针，我们的GetIntArrayElements这些方法都封装在这个结构体里，所以直接使用结构体的指针去调用方法即可</p><p>比如GetIntArrayElements这个函数在_JNIEnv中是这样的</p><p><img src="/../images/image-20221128141645545.png" alt="image-20221128141645545"></p><p>实际上最后调用的还是JNINativeInterface的GetIntArrayElements函数，只不过帮我们封了一层</p><h3 id="在c中调用"><a href="#在c中调用" class="headerlink" title="在c中调用"></a>在c中调用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*env)-&gt;<span class="built_in">GetIntArrayElements</span>(env,i_,<span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><p>在c中要先去解引用，然后才能指针调用，为什么？</p><p>先看如果是c</p><p><img src="/../images/image-20221128141258937.png" alt="image-20221128141258937"></p><p>它本身就是一个指针，我们传入的JNIEnv *env 就成了 二级指针了，相当于这样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JNINativeInterface** JNIEnv</span><br></pre></td></tr></table></figure><p>所以必须要先去解指针，才能拿到JNINativeInterface这个结构体的指针，然后才能调用结构体里的方法</p><p>我们再来看为什么第一个参数都需要传env</p><p>和c++不同的是，我们这里调用的是 JNINativeInterface 这个结构体里的函数</p><p><img src="/../images/image-20221128141518328.png" alt="image-20221128141518328"></p><p>可以看到每个函数的第一个参数都是JNIEnv * 所以需要把env传进去，和c++的结构体是不一样的</p><h2 id="Java向native传递参数—基本数据类型的数组"><a href="#Java向native传递参数—基本数据类型的数组" class="headerlink" title="Java向native传递参数—基本数据类型的数组"></a>Java向native传递参数—基本数据类型的数组</h2><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>[] i,String[] j)</span></span>;</span><br></pre></td></tr></table></figure><p>cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_cn_com_jit_jnistudy1128_MainActivity_test</span><span class="params">(JNIEnv *env, jobject thiz, jintArray i,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               jobjectArray j)</span> </span>&#123;</span><br><span class="line">  jint *i = env-&gt;<span class="built_in">GetIntArrayElements</span>(i_, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>jobject第二个参数，代表着声明native方法的MainActivity的实例，也就是thisz</li><li>int[] 在naitve对应的是jintArray 是一个对象，是jobject的子类，通过这个类是不能直接访问数组中的元素的，需要通过这个对象找到指向数组首元素的地址，也就是指针</li></ul><h3 id="获取数组的指针"><a href="#获取数组的指针" class="headerlink" title="获取数组的指针"></a>获取数组的指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jint *i = env-&gt;<span class="built_in">GetIntArrayElements</span>(i_, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><ul><li>jint *i 指向数组首元素的地址</li><li>第二个参数，传递的是指针，一般c++中传递指针进去，是为了给指针指向的内存地址进行赋值，然后后面再去判断这个值是true还是false，如果不关心这个值是赋成什么，直接传null进去就行了</li><li>true：是拷贝的一个新数据(新申请内存)</li><li>false：就是使用的java的数组(地址) 不进行拷贝</li></ul><h3 id="获取数组的长度"><a href="#获取数组的长度" class="headerlink" title="获取数组的长度"></a>获取数组的长度</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jsize length = env-&gt;<span class="built_in">GetArrayLength</span>(i_);</span><br></pre></td></tr></table></figure><ul><li>返回jsize 就是 jint  也是int32_t 就是32位的int</li></ul><h3 id="遍历数组中的元素"><a href="#遍历数组中的元素" class="headerlink" title="遍历数组中的元素"></a>遍历数组中的元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; length; ++k) &#123;</span><br><span class="line">__android_log_print(ANDROID_LOG_ERROR,<span class="string">&quot;JNI&quot;</span>,<span class="string">&quot;获取java的参数：%d&quot;</span>,*(i+k));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><p>使用get和new的方法都需要进行释放</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env-&gt;<span class="built_in">ReleaseIntArrayElements</span>(i_,i,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li>第一个参数是jintarray对象</li><li>第二个参数是jint数组指针</li><li>第三个参数是mode模式<ul><li>0 ：刷新java数组 并 释放 c&#x2F;c++ 数组</li><li>1 &#x3D; JNI_COMMIT : 只刷新java数组</li><li>2 &#x3D; JNI_ABORT：只释放c&#x2F;c++数组</li></ul></li></ul><p>不同的传值有不同的结果，一般传0  在native层修改了数组，也会同步到java层的数组，并释放掉c&#x2F;c++的指针</p><h2 id="Java向native传递参数—字符串-object-的数组"><a href="#Java向native传递参数—字符串-object-的数组" class="headerlink" title="Java向native传递参数—字符串(object)的数组"></a>Java向native传递参数—字符串(object)的数组</h2><p>基本数据类型和object数组的操作方式不一样</p><p>cpp </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_cn_com_jit_jnistudy1128_MainActivity_test</span><span class="params">(JNIEnv *env, jobject thiz, jintArray i,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               jobjectArray j)</span> </span>&#123;</span><br><span class="line">  jint *i = env-&gt;<span class="built_in">GetIntArrayElements</span>(i_, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看j  是jobjectArray跟前面的使用不太一样，基本数据类型可以直接拿到jint 的指针，jobjectArray里面每一项都是jobject 这里是jstring</p><h3 id="获取数组大小"><a href="#获取数组大小" class="headerlink" title="获取数组大小"></a>获取数组大小</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jint strLength = env-&gt;<span class="built_in">GetArrayLength</span>(j_);</span><br></pre></td></tr></table></figure><h3 id="遍历数组，获得jstring"><a href="#遍历数组，获得jstring" class="headerlink" title="遍历数组，获得jstring"></a>遍历数组，获得jstring</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; strLength; ++m) &#123;</span><br><span class="line">jstring strObj = <span class="keyword">static_cast</span>&lt;jstring&gt;(env-&gt;<span class="built_in">GetObjectArrayElement</span>(j_, m));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是jstring可以直接进行强转，新式强转得到每一个jstring</p><h3 id="把jstring转成c-x2F-c-可以操作的字符串"><a href="#把jstring转成c-x2F-c-可以操作的字符串" class="headerlink" title="把jstring转成c&#x2F;c++可以操作的字符串"></a>把jstring转成c&#x2F;c++可以操作的字符串</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* s  =env-&gt;<span class="built_in">GetStringUTFChars</span>(strObj,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>把jstring进行了转化char *</p><h2 id="Java向native传递参数—传递自定义的对象class引用类型"><a href="#Java向native传递参数—传递自定义的对象class引用类型" class="headerlink" title="Java向native传递参数—传递自定义的对象class引用类型"></a>Java向native传递参数—传递自定义的对象class引用类型</h2><p>其实就是反射去调用</p><h3 id="获取java对应的class对象"><a href="#获取java对应的class对象" class="headerlink" title="获取java对应的class对象"></a>获取java对应的class对象</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jclass beanCls = env-&gt;<span class="built_in">GetObjectClass</span>(bean);</span><br></pre></td></tr></table></figure><h3 id="获取methodId，知道要调用的是哪个方法"><a href="#获取methodId，知道要调用的是哪个方法" class="headerlink" title="获取methodId，知道要调用的是哪个方法"></a>获取methodId，知道要调用的是哪个方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmethodID getI = env-&gt;<span class="built_in">GetMethodID</span>(beanCls,<span class="string">&quot;getI&quot;</span>,<span class="string">&quot;()I&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>第一个参数是class</li><li>第二个参数是方法名</li><li>第三个参数是方法签名，可以通过javap来获取</li></ul><h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jint i = env-&gt;<span class="built_in">CallIntMethod</span>(bean,getI);</span><br></pre></td></tr></table></figure><h2 id="反射调用，传递的参数也是引用类型的"><a href="#反射调用，传递的参数也是引用类型的" class="headerlink" title="反射调用，传递的参数也是引用类型的"></a>反射调用，传递的参数也是引用类型的</h2><h3 id="1-反射静态方法，调用-printfInfo-需要传入java的字符串-也就是jstring"><a href="#1-反射静态方法，调用-printfInfo-需要传入java的字符串-也就是jstring" class="headerlink" title="1.反射静态方法，调用 printfInfo 需要传入java的字符串 也就是jstring"></a>1.反射静态方法，调用 printfInfo 需要传入java的字符串 也就是jstring</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jmethodID printInfo = env-&gt;<span class="built_in">GetStaticMethodID</span>(beanCls,<span class="string">&quot;printfInfo&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建java字符串 也就是jstring</span></span><br><span class="line">jstring str2 = env-&gt;<span class="built_in">NewStringUTF</span>(<span class="string">&quot;我是bean类的静态方法，被c++调用&quot;</span>);</span><br><span class="line"></span><br><span class="line">env-&gt;<span class="built_in">CallStaticVoidMethod</span>(beanCls,printInfo,str2);</span><br></pre></td></tr></table></figure><p>注意释放</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env-&gt;<span class="built_in">DeleteLocalRef</span>(str2);</span><br></pre></td></tr></table></figure><blockquote><p>像这种new出来的，find出来的是局部引用，需要delete掉</p></blockquote><h3 id="2-反射调用修改属性-注意这里是属性的签名"><a href="#2-反射调用修改属性-注意这里是属性的签名" class="headerlink" title="2.反射调用修改属性(注意这里是属性的签名)"></a>2.反射调用修改属性(注意这里是属性的签名)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jfieldID fieldI = env-&gt;<span class="built_in">GetFieldID</span>(beanCls,<span class="string">&quot;i&quot;</span>,<span class="string">&quot;I&quot;</span>);</span><br><span class="line">env-&gt;<span class="built_in">SetIntField</span>(bean,fieldI,<span class="number">300</span>);</span><br></pre></td></tr></table></figure><h3 id="3-反射调用方法，方法的参数是引用类型对象"><a href="#3-反射调用方法，方法的参数是引用类型对象" class="headerlink" title="3.反射调用方法，方法的参数是引用类型对象"></a>3.反射调用方法，方法的参数是引用类型对象</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">jmethodID printInfoNew = env-&gt;<span class="built_in">GetStaticMethodID</span>(beanCls,<span class="string">&quot;printfInfo&quot;</span>, <span class="string">&quot;(Lcn/com/jit/jnistudy1128/BeanNew;)V&quot;</span>);</span><br><span class="line"></span><br><span class="line">jclass beanNewCls = env-&gt;<span class="built_in">FindClass</span>(<span class="string">&quot;cn/com/jit/jnistudy1128/BeanNew&quot;</span>);</span><br><span class="line">jmethodID constructonr = env-&gt;<span class="built_in">GetMethodID</span>(beanNewCls,<span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(I)V&quot;</span>);</span><br><span class="line"></span><br><span class="line">jobject beanNew = env-&gt;<span class="built_in">NewObject</span>(beanNewCls,constructonr,<span class="number">88</span>);</span><br><span class="line"></span><br><span class="line">env-&gt;<span class="built_in">CallStaticVoidMethod</span>(beanCls,printInfoNew,beanNew);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">env-&gt;<span class="built_in">DeleteLocalRef</span>(beanNewCls);</span><br><span class="line">env-&gt;<span class="built_in">DeleteLocalRef</span>(beanNew);</span><br></pre></td></tr></table></figure><p>这样就在printInfo(BeanNew bean)调用了</p><p>唯一不同的就是在调用传参的时候，传入的了一个在c层new出来的java对象，要注意这种使用方式，以及new和find的方法都要进行delete回收释放</p><blockquote><p>有一个点很有意思，就是如果Bean2传到java层去了，native层回收了对象，对java层有没有影响，是不是就不能使用了呢？</p><p>最好的验证方法就是在调用 printInfo传入BeanNew对象，把对象赋值给this.bean &#x3D; bean 我们把对象传递给java 发现这个对象是一直可以使用的，为什么会这样呢？</p><p>其实这里回传的时候发生的是拷贝传递，java中的一个副本，不是同一内存空间，native中回收的对象，不会影响java层继续使用</p></blockquote><h2 id="Jni中的引用类型"><a href="#Jni中的引用类型" class="headerlink" title="Jni中的引用类型"></a>Jni中的引用类型</h2><h3 id="局部引用"><a href="#局部引用" class="headerlink" title="局部引用"></a>局部引用</h3><p>太多数JNI函数会创建局部引用，NewObject&#x2F;FindClass&#x2F;NewStringUTF等都是局部引用。</p><blockquote><p>局部引用只有在创建它的本地方法返回前有效，本地方法返回后，局部引用会被自动释放。</p><p>因此无法跨线程、跨方法使用。</p></blockquote><p>释放一个局部引用有两种方式：</p><p>1.本地方法执行完毕后VM自动释放；</p><p>2.通过DeleteLocalRef手动释放；</p><blockquote><p>VM会自动释放局部引用，为什么还需要手动释放呢？</p><p>因为局部引用会阻止它所引用的对象被GC回收</p></blockquote><p>其实也就是为了好习惯，尽快的回收掉不用的对象，是一种好习惯，不写也没事。</p><h3 id="全局引用"><a href="#全局引用" class="headerlink" title="全局引用"></a>全局引用</h3><blockquote><p>全局引用可以跨方法，跨线程使用，直到它被手动释放才会失效。</p><p>由NewGlobalRef函数创建</p></blockquote><p>先来看一个例子，为什么需要全局引用，全局引用和局部引用的区别是什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jclass beanNewCls;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_cn_com_jit_jnistudy1128_MainActivity_invokeBeanNew</span><span class="params">(JNIEnv *env, jobject thiz, jobject bean)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beanNewCls == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        beanNewCls = env-&gt;<span class="built_in">FindClass</span>(<span class="string">&quot;cn/com/jit/jnistudy1128/BeanNew&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    jmethodID construct = env-&gt;<span class="built_in">GetMethodID</span>(beanNewCls,<span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(I)V&quot;</span>);</span><br><span class="line">    env-&gt;<span class="built_in">NewObject</span>(beanNewCls,construct,<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这样写会不会有问题？</p><p>会。因为beanNewCls是局部引用，出了方法就被回收了，然后指针是有值的，也就是不等于NULL，但是指向的地址数据被释放了，等于悬空指针</p></blockquote><p>怎么修改？——改为全局引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">jclass beanNewCls;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_cn_com_jit_jnistudy1128_MainActivity_invokeBeanNew</span><span class="params">(JNIEnv *env, jobject thiz, jobject bean)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beanNewCls == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">      <span class="comment">//先声明一个本地的</span></span><br><span class="line">        jclass cls = env-&gt;<span class="built_in">FindClass</span>(<span class="string">&quot;cn/com/jit/jnistudy1128/BeanNew&quot;</span>);</span><br><span class="line">      <span class="comment">//把本地的转成全局的</span></span><br><span class="line">        beanNewCls = <span class="keyword">static_cast</span>&lt;jclass&gt;(env-&gt;<span class="built_in">NewGlobalRef</span>(cls));</span><br><span class="line">      <span class="comment">//释放本地的</span></span><br><span class="line">        env-&gt;<span class="built_in">DeleteLocalRef</span>(cls);</span><br><span class="line">    &#125;</span><br><span class="line">    jmethodID construct = env-&gt;<span class="built_in">GetMethodID</span>(beanNewCls,<span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(I)V&quot;</span>);</span><br><span class="line">    env-&gt;<span class="built_in">NewObject</span>(beanNewCls,construct,<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局引用可以跨方法，跨线程使用，而且需要手动的调用env-&gt;DeleteGlobalRef(ref) 进行回收。不会随着方法结束而自动回收。</p><blockquote><p>这里一定要区别于Java的固有印象，认为beanNewCls声明在外部就是全局的，为什么还要声明全局，局部引用？这里c++和java不一样，指针有值，指针指向的地址不一定有内容。</p></blockquote><blockquote><p>Tips:</p><p>1.在个cpp文件中引用另一个cpp文件中的变量和方法，需要extern 如果没有头文件，需要这么去引用</p><p>2.在同一个函数中有bean2 但我要引用函数外部声明的bean2 要加::bean2域作用符，防止混用</p><p>3.比如想返回java层一个int *a(){} 指针，怎么返回给java层，jni封装一层，int java_xxxx(){ return a();}</p></blockquote><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><blockquote><p>全称弱全局引用，与全局引用类似，弱引用可以跨方法，跨线程使用，与全局引用不同的是，弱引用不会阻止GC回收它所指向的VM内部的对象。</p><p>在对class进行弱引用是非常合适的(FindClass)，因为Class一般直到程序进程结束才会卸载。</p><p>在使用弱引用时，必须先检查缓存过的弱引用是指向活动的对象，还是指向一个已经被GC的对象。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于一个弱引用与NULL相比较</span></span><br><span class="line"><span class="comment">//true:释放了</span></span><br><span class="line"><span class="comment">//false:还可以使用</span></span><br><span class="line"></span><br><span class="line">jobject beanLocal = env-&gt;<span class="built_in">NewObject</span>(beanNewCls,construct,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">beanNew = env-&gt;<span class="built_in">NewWeakGlobalRef</span>(beanLocal);</span><br><span class="line">jboolean isEqual = env-&gt;<span class="built_in">IsSameObject</span>(beanNew, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><h2 id="JNI-OnLoad"><a href="#JNI-OnLoad" class="headerlink" title="JNI_OnLoad"></a>JNI_OnLoad</h2><blockquote><p>调用System.loadLibrary()函数时，内部就会去查找so中的JNI_OnLoad函数，如果存在此函数调用。</p><p>JNI_OnLoad会：</p><p>告诉VM此native组件使用的JNI版本。</p><p>​    对应Java版本，android只支持JNI_VERSION_1_2 JNI_VERSION_1_4 JNI_VERSION_1_6</p><p>​    在JDK1.8中有JNI_VERSION_1_8</p></blockquote><h3 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h3><blockquote><p>动态注册的好处</p><p>1.方法名变短</p><p>2.产生的符号小</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">JavaVM *vm;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dynamicTest</span><span class="params">(JNIEnv *env,jobject thisz)</span></span>&#123;</span><br><span class="line">    <span class="built_in">DLOGD</span>(<span class="string">&quot;执行了dynamicTest&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册的对应数组    &#123;java方法名，方法签名，native方法&#125;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> JNINativeMethod method[] = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;dynamicJava&quot;</span>,<span class="string">&quot;()V&quot;</span>,(<span class="keyword">void</span>*)dynamicTest&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//注册的绑定的java类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *className = <span class="string">&quot;cn/com/jit/jnistudy1129/MainActivity&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM *_vm, <span class="keyword">void</span> *unused)</span> </span>&#123;</span><br><span class="line">    vm = _vm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取JNIEnv  线程相关</span></span><br><span class="line">    JNIEnv *env = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//小于0 失败  等于0 成功</span></span><br><span class="line">    <span class="keyword">int</span> res = vm-&gt;<span class="built_in">GetEnv</span>(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> **&gt;(&amp;env), JNI_VERSION_1_4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res!=JNI_OK)&#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意不能混淆，要不反射找不到</span></span><br><span class="line">    jclass cls = env-&gt;<span class="built_in">FindClass</span>(<span class="string">&quot;cn/com/jit/jnistudy1129/MainActivity&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> registerRes = env-&gt;<span class="built_in">RegisterNatives</span>(cls,method,<span class="built_in"><span class="keyword">sizeof</span></span>(method)/<span class="built_in"><span class="keyword">sizeof</span></span>(JNINativeMethod));</span><br><span class="line">    <span class="comment">//注册成功返回0</span></span><br><span class="line">    <span class="keyword">if</span> (registerRes!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> JNI_ERR;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JNI_VERSION_1_4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="native线程调用Java"><a href="#native线程调用Java" class="headerlink" title="native线程调用Java"></a>native线程调用Java</h3><p>比如有一个需求我们在native中开启子线程去下载视频或者解码，然后下载进度，下载完成，下载失败这失败信息需要回调给java层的方法，怎么回调？</p><blockquote><p>创建并启动线程的流程</p><ol><li>pthread_t pid;  &#x2F;&#x2F;创建线程id</li><li>定义一个线程执行的函数 void* threadTask(void* args)</li><li>定义结构体，传入threadTask中的参数  struct Context{  jobject instance  JNIEnv *env  };  这样可以多传一些信息</li><li>pthread_create(&amp;pid,0, threadTask,context)  &#x2F;&#x2F;启动线程 传入结构体  最后一个参数是传入threadTask的参数</li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Context</span>&#123;</span></span><br><span class="line">    jobject instance;</span><br><span class="line">    JNIEnv *env;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">threadTask</span><span class="params">(<span class="keyword">void</span>* args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1 下载完成  调用java的回调</span></span><br><span class="line">    <span class="comment">//2 下载失败</span></span><br><span class="line">    Context *context = <span class="keyword">static_cast</span>&lt;Context *&gt;(args);</span><br><span class="line">    <span class="comment">//获取MainActivity的class对象</span></span><br><span class="line">    jclass cls = context-&gt;env-&gt;<span class="built_in">GetObjectClass</span>(context-&gt;instance);</span><br><span class="line"></span><br><span class="line">    jmethodID updateUI = context-&gt;env-&gt;<span class="built_in">GetMethodID</span>(cls,<span class="string">&quot;updateUI&quot;</span>,<span class="string">&quot;()V&quot;</span>);</span><br><span class="line">    context-&gt;env-&gt;<span class="built_in">CallVoidMethod</span>(context-&gt;instance,updateUI);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dynamicTest</span><span class="params">(JNIEnv *env,jobject thisz)</span></span>&#123;</span><br><span class="line">    <span class="built_in">DLOGD</span>(<span class="string">&quot;执行了dynamicTest&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程id</span></span><br><span class="line">    <span class="keyword">pthread_t</span> pid;</span><br><span class="line">    <span class="comment">//启动线程，解码 下载视频</span></span><br><span class="line">    Context *context = <span class="keyword">new</span> Context;</span><br><span class="line">    context-&gt;env = env;</span><br><span class="line">    context-&gt;instance = env-&gt;<span class="built_in">NewGlobalRef</span>(thisz);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;pid,<span class="number">0</span>, threadTask,context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>我们需要在子线程中反射去调用 Java的方法</p><p>我们需要方法所有的类的对象，及class 所以我们需要jobect和env 我们直接把dynamicTest 的JNIEnv传入给子线程看看</p><p>结果：报错了</p><p>原因：JNIEnv 是线程相关的对象，我们的dynamicTest调用的时候传入的是主线程的JNIEnv 是不能跨 线程给子线程使用的，会报错</p><p>解决：使用VM子线程绑定的JNIEnv    vm-&gt;AttachCurrentThread(&amp;env,0);</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">threadTask</span><span class="params">(<span class="keyword">void</span>* args)</span></span>&#123;</span><br><span class="line">    JNIEnv *env = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//第二个参数一般传0  是一些线程的分组的 版本 名字</span></span><br><span class="line">    jint i = vm-&gt;<span class="built_in">AttachCurrentThread</span>(&amp;env,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (i != JNI_OK)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 下载完成  调用java的回调</span></span><br><span class="line">    <span class="comment">//2 下载失败</span></span><br><span class="line">    Context *context = <span class="keyword">static_cast</span>&lt;Context *&gt;(args);</span><br><span class="line">    <span class="comment">//获取MainActivity的class对象</span></span><br><span class="line">   </span><br><span class="line">    jclass cls = env-&gt;<span class="built_in">GetObjectClass</span>(context-&gt;instance);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    jmethodID updateUI = env-&gt;<span class="built_in">GetMethodID</span>(cls,<span class="string">&quot;updateUI&quot;</span>,<span class="string">&quot;()V&quot;</span>);</span><br><span class="line">   </span><br><span class="line">    env-&gt;<span class="built_in">CallVoidMethod</span>(context-&gt;instance,updateUI);</span><br><span class="line"></span><br><span class="line">    vm-&gt;<span class="built_in">DetachCurrentThread</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：结束时要记得DetachCurrentThread</p><p>还有一个问题：为什么传入的是JNIEnv的二级指针，如果传入一级指针会如何？</p></blockquote><h3 id="什么时候需要传递二级指针？"><a href="#什么时候需要传递二级指针？" class="headerlink" title="什么时候需要传递二级指针？"></a>什么时候需要传递二级指针？</h3><p>通过上述例子，我们可以看到，在某些情况下，函数参数传递一级指针时，在函数体内对指针做变动，也不会对原始指针产生变化，而传递二级指针时，则可以，这是为什么呢？</p><p>在传递一级指针时，只有对指针所指向的内存变量做操作才是有效的；</p><p>在传递二级指针时，只有对指针的指向做改变才是有效的；</p><p>下面做简单的分析：</p><p><strong>在函数传递参数时，编译器总会为每个函数参数制作一个副本，即拷贝；</strong></p><p>例如：</p><p>void fun(int *p)，指针参数p的副本为_p，编译器使_p&#x3D;p，_p和p指向相同的内存空间，如果在函数内修改了_p所指向的内容，就会导致p的内容也做相应的改变；</p><p>但如果在函数内_p申请了新的内存空间或者指向其他内存空间，则_p指向了新的内存空间，而p依旧指向原来的内存空间，因此函数返回后p还是原来的p。</p><p><em>这样的话，不但没有实现功能，反而每次都申请新的内存空间，而又得不到释放，因为没有将该内存空间的地址传递出来，容易造成内存泄露。</em></p><p>void fun(int **p)，如果函数参数是指针的地址，则可以通过该参数p将新分配或新指向的内存地址传递出来，这样就实现了有效的指针操作。</p><p>如果觉得二级指针比较难理解，<strong>也可以通过函数返回值的形式来传递动态内存（</strong>切记不能返回栈内存），如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">myMalloc</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> *s=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">     <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span>  *p=<span class="literal">NULL</span>;</span><br><span class="line">     p=<span class="built_in">myMalloc</span>();</span><br><span class="line">     <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;P is not changed!\n&quot;</span>);</span><br><span class="line">     <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;P has been changed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;使用javah-生成头文件&quot;&gt;&lt;a href=&quot;#使用javah-生成头文件&quot; class=&quot;headerlink&quot; title=&quot;使用javah 生成头文件&quot;&gt;&lt;/a&gt;使用javah 生成头文件&lt;/h2&gt;&lt;p&gt;目录结构如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/.</summary>
      
    
    
    
    <category term="NDK" scheme="https://stevezhangzl.github.io/categories/NDK/"/>
    
    
  </entry>
  
  <entry>
    <title>c++-容器</title>
    <link href="https://stevezhangzl.github.io/2022/11/24/c-%E5%AE%B9%E5%99%A8/"/>
    <id>https://stevezhangzl.github.io/2022/11/24/c-%E5%AE%B9%E5%99%A8/</id>
    <published>2022-11-24T02:21:13.000Z</published>
    <updated>2023-01-16T22:23:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>容器</p><p>序列式  与 关联式</p><p>序列式容器 stl :元素排列顺序与元素本身无关，由添加顺序决定的</p><p>vector list dequeue queue  stack priority_queue</p><p>前三种的api操作差不多</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//vector 支持快速随机访问 </span></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; vec_1;</span><br><span class="line">  <span class="comment">//声明有一个元素空间</span></span><br><span class="line">  <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vec_2</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="comment">//声明6个元素 值都是1</span></span><br><span class="line">  <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vec_3</span><span class="params">(<span class="number">6</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="comment">//用vec_3来初始化</span></span><br><span class="line">  <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vec_4</span><span class="params">(vec_3)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//增加一个元素</span></span><br><span class="line">  vec_1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  vec_1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//删除元素</span></span><br><span class="line">  vec_1.<span class="built_in">pop_back</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//通过下标来获得元素</span></span><br><span class="line">  cout &lt;&lt; vec_1[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//vector是一个模板类，为什么可以使用[0]来操作元素，因为操作符重载了</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//也能获取元素</span></span><br><span class="line">  vec_1.<span class="built_in">at</span>(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//直接获得队首与队尾元素</span></span><br><span class="line">  vec_1.<span class="built_in">front</span>();</span><br><span class="line">  vec_1.<span class="built_in">back</span>();</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  vec_1.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="comment">//删除区间元素，删除某个元素</span></span><br><span class="line">  vec_1.<span class="built_in">erase</span>(vec_1.<span class="built_in">begin</span>(),vec_1.<span class="built_in">end</span>());</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//只增不减 </span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;获得容器vec的容量大小：&quot;</span> &lt;&lt; vec_1.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果vec_1是全局的变量，clear后容量不回收，所以用一个临时的vector进行swap替换，v是栈上分配，方法执行后被回收，而全局的vec容量也被清空</span></span><br><span class="line"> vector&lt;<span class="keyword">int</span>&gt;().<span class="built_in">swap</span>(vec_1);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>queue stack</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Type</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="built_in">Type</span>(<span class="keyword">int</span> i):<span class="built_in">i</span>(i);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TypeLess</span>&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Type&amp; _Left,<span class="keyword">const</span> Type&amp; _Right)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (_Left.i &lt; _Right.i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//队列</span></span><br><span class="line">  queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//加入队列</span></span><br><span class="line">  q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//弹出队列</span></span><br><span class="line">  q.<span class="built_in">pop</span>();</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//栈 stack</span></span><br><span class="line">  stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//优先级队列</span></span><br><span class="line">  priority_queue&lt;<span class="keyword">int</span>&gt; pq;</span><br><span class="line">  pq.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">  pq.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">  pq.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">  </span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;默认优先级队列，队首：&quot;</span> &lt;&lt; pq.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//第二个参数是基于什么来实现 只能是vector</span></span><br><span class="line">  <span class="function">priority_queue&lt;<span class="keyword">int</span>&gt; <span class="title">pq1</span><span class="params">(<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt;)</span></span>;</span><br><span class="line">  <span class="comment">//less:最大的元素在前面</span></span><br><span class="line">  <span class="comment">//greater:最小的元素在前面</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//不知道如何给 Type 排序 要指定排序规则</span></span><br><span class="line">  <span class="comment">//TypeLess:自定义TypeLess结构体  注：结构体在c++中是可以写函数的和类是一样的只不过一个是私有，一个是public</span></span><br><span class="line">  priority_queue&lt;Type,vector&lt;Type&gt;,TypeLess&gt; pq_type;</span><br><span class="line">  </span><br><span class="line">  pq_type.<span class="built_in">push</span>(<span class="built_in">Type</span>(<span class="number">2</span>));</span><br><span class="line">  pq_type.<span class="built_in">push</span>(<span class="built_in">Type</span>(<span class="number">1</span>));</span><br><span class="line">  pq_type.<span class="built_in">push</span>(<span class="built_in">Type</span>(<span class="number">3</span>));</span><br><span class="line">  </span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Type 优先级队列，队首：&quot;</span> &lt;&lt; pq_type.<span class="built_in">top</span>().i &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//要对自己的类进行排序，也要依照Less写一个结构体</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关联式容器</p><p>就是里面的元素是有关系的</p><p>通过一个关键字保存和访问元素的 map set    </p><p>set 集合 红黑树的实现 元素不可重复</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  set&lt;<span class="keyword">int</span>&gt; set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">  set1.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">  <span class="comment">//插入失败 元素不可重复</span></span><br><span class="line">  set1.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">  set1.<span class="built_in">erase</span>(<span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//使用迭代器</span></span><br><span class="line">  set&lt;<span class="keyword">int</span>&gt;::iterator it = set1.<span class="built_in">begin</span>(); <span class="comment">//指向容器第0个元素</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//指向容器中最后一个元素的下一个元素</span></span><br><span class="line">  set1.<span class="built_in">end</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//vector&lt;int&gt;(6,1);</span></span><br><span class="line">  <span class="comment">//跟java一样，不能在迭代的时候对容器进行增删</span></span><br><span class="line">  <span class="keyword">for</span>(;it&lt;vec_3.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;使用迭代器遍历：&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;容器&lt;/p&gt;
&lt;p&gt;序列式  与 关联式&lt;/p&gt;
&lt;p&gt;序列式容器 stl :元素排列顺序与元素本身无关，由添加顺序决定的&lt;/p&gt;
&lt;p&gt;vector list dequeue queue  stack priority_queue&lt;/p&gt;
&lt;p&gt;前三种的api操作差不多&lt;</summary>
      
    
    
    
    <category term="C++" scheme="https://stevezhangzl.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>PKI系统与数字证书结构[转]</title>
    <link href="https://stevezhangzl.github.io/2022/11/23/PKI%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%BB%93%E6%9E%84-%E8%BD%AC/"/>
    <id>https://stevezhangzl.github.io/2022/11/23/PKI%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%BB%93%E6%9E%84-%E8%BD%AC/</id>
    <published>2022-11-23T07:15:27.000Z</published>
    <updated>2023-01-16T22:23:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>PKI（Public Key Infrastructure）翻译过来就是公钥基础设施，可以理解为利用公钥技术为网络应用提供加密和数字签名等密码服务以及必需的密钥和证书管理体系。它是一个提供安全服务的基础设施，PKI技术是信息安全技术的核心，同时也是电子商务的关键和基础技术。</p><blockquote><p>PKI既不是一个协议，也不是一个软件，它是一个标准，在这个标准之下发展出的为了实现安全基础服务目的的技术统称为PKI。</p></blockquote><h3 id="PKI的组成"><a href="#PKI的组成" class="headerlink" title="PKI的组成"></a>PKI的组成</h3><p>PKI是一个标准，它包括一些基本的组件，不同的组件提供不同的服务，主要由一下几个组件组成：</p><ol><li>**认证中心CA(证书签发)**：CA机构，又称为证书授证 (Certificate Authority) 中心，是PKI的”核心”，即数字证书的申请及签发机关，CA必须具备权威性的特征，它负责管理PKI结构下的所有用户(包括各种应用程序)的证书，把用户的公钥和用户的其他信息捆绑在一起，在网上验证用户的身份，CA还要负责用户证书的黑名单登记和黑名单发布。</li><li>**X.500目录服务器(证书保存)**：X.500目录服务器用于”发布”用户的证书和黑名单信息，用户可通过标准的LDAP协议查询自己或其他人的证书和下载黑名单信息。</li><li>**具有高强度密码算法(SSL)的安全WWW服务器(即配置了HTTPS的apache)**：Secure socket layer(SSL)协议最初由Netscape 企业发展，现已成为网络用来鉴别网站和网页浏览者身份，以及在浏览器使用者及网页服务器之间进行加密通讯的全球化标准。</li><li>**Web(安全通信平台)**：Web有Web Client端和Web Server端两部分，分别安装在客户端和服务器端，通过具有高强度密码算法的SSL 协议保证客户端和服务器端数据的机密性、完整性、身份验证。</li><li><strong>自开发安全应用系统</strong>：自开发安全应用系统是指各行业自开发的各种具体应用系统，例如银行、证券的应用系统等。</li></ol><h3 id="CA机构"><a href="#CA机构" class="headerlink" title="CA机构"></a>CA机构</h3><p>CA 机构，又称为证书授证 (Certificate Authority) 中心，是一个负责发放和管理数字证书的权威机构 , 它作为电子商务交易中受信任的第三方，承担公钥体系中公钥的合法性检验的责任。 CA 中心为每个使用公开密钥的用户发放一个数字证书，以实现公钥的分发并证明其合法性。数字证书是一个经证书授权中心数字签名的包含公开密钥拥有者信息以及公开密钥的文件 , 作用是证明证书中列出的用户合法拥有证书中列出的公开密钥。 CA 机构的数字签名使得攻击者不能伪造和篡改证书。在 SET 交易中， CA 不仅对持卡人、商户发放证书，还要对获款的银行、网关发放证书。它负责产生、分配并管理所有参与网上交易的个体所需的数字证书，因此是安全电子交易的核心环节。认证中心CA作为PKI的核心部分，CA实现了PKI 中一些很重要的功能：</p><ol><li>接收验证最终用户数字证书的申请</li><li>确定是否接受最终用户数字证书的申请-证书的审批</li><li>向申请者颁发、拒绝颁发数字证书-证书的发放</li><li>接收、处理最终用户的数字证书更新请求-证书的更新</li><li>接收最终用户数字证书的查询、撤销</li><li>产生和发布证书废止列表(CRL)</li><li>数字证书的归档</li><li>密钥归档</li><li>历史数据归档</li></ol><h3 id="X-509标准"><a href="#X-509标准" class="headerlink" title="X.509标准"></a>X.509标准</h3><p>X.509是一种非常通用的证书格式。所有的证书都符合ITU-T X.509国际标准；因此(理论上)为一种应用创建的证书可以用于任何其他符合X.509标准的应用。在一份证书中，必须证明公钥及其所有者的姓名是一致的。对X.509证书来说，认证者总是 CA或由CA指定的人，一份X.509证书是一些标准字段的集合，这些字段包含有关用户或设备及其相应公钥的信息。X.509标准定义了证书中应该包含哪些信息，并描述了这些信息是如何编码的(即数据格式)，所有的X.509证书包含以下数据。</p><ul><li><strong>版本号：</strong>指出该证书使用了哪种版本的X.509标准（版本1、版本2或是版本3），版本号会影响证书中的一些特定信息，目前的版本为3</li><li><strong>序列号：</strong> 标识证书的唯一整数，由证书颁发者分配的本证书的唯一标识符</li><li><strong>签名算法标识符：</strong> 用于签证书的算法标识，由对象标识符加上相关的参数组成，用于说明本证书所用的数字签名算法。例如，SHA-1和RSA的对象标识符就用来说明该数字签名是利用RSA对SHA-1杂凑加密</li><li><strong>认证机构的数字签名：</strong>这是使用发布者私钥生成的签名，以确保这个证书在发放之后没有被撰改过</li><li><strong>认证机构：</strong> 证书颁发者的可识别名（DN），是签发该证书的实体唯一的CA的X.500名字。使用该证书意味着信任签发证书的实体。(注意：在某些情况下，比如根或顶级CA证书，发布者自己签发证书)</li><li><strong>有效期限：</strong> 证书起始日期和时间以及终止日期和时间；指明证书在这两个时间内有效</li><li><strong>主题信息：</strong>证书持有人唯一的标识符(或称DN-distinguished name)这个名字在 Internet上应该是唯一的</li><li><strong>公钥信息：</strong> 包括证书持有人的公钥、算法(指明密钥属于哪种密码系统)的标识符和其他相关的密钥参数</li><li><strong>颁发者唯一标识符：</strong>标识符—证书颁发者的唯一标识符，仅在版本2和版本3中有要求，属于可选项</li></ul><h4 id="X-509证书扩展部分"><a href="#X-509证书扩展部分" class="headerlink" title="X.509证书扩展部分"></a>X.509证书扩展部分</h4><p>可选的标准和专用的扩展（仅在版本2和版本3中使用），扩展部分的元素都有这样的结构：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="keyword">Extension</span> ::= <span class="keyword">SEQUENCE</span> &#123;</span><br><span class="line"></span><br><span class="line">　　extnID <span class="keyword">OBJECT</span> IDENTIFIER,</span><br><span class="line"></span><br><span class="line">　　critical <span class="type">BOOLEAN</span> <span class="keyword">DEFAULT</span> <span class="keyword">FALSE</span>,</span><br><span class="line"></span><br><span class="line">　　extnValue OCTET STRING &#125;</span><br><span class="line"></span><br><span class="line">　　extnID：表示一个扩展元素的<span class="type">OID</span></span><br><span class="line"></span><br><span class="line">　　critical：表示这个扩展元素是否极重要</span><br><span class="line"></span><br><span class="line">　　extnValue：表示这个扩展元素的值，字符串类型。</span><br></pre></td></tr></table></figure><p>扩展部分包括：</p><ul><li><strong>发行者密钥标识符：</strong>证书所含密钥的唯一标识符，用来区分同一证书拥有者的多对密钥。</li><li><strong>密钥使用：</strong>一个比特串，指明（限定）证书的公钥可以完成的功能或服务，如：证书签名、数据加密等。如果某一证书将 KeyUsage 扩展标记为“极重要”，而且设置为“keyCertSign”，则在 SSL 通信期间该证书出现时将被拒绝，因为该证书扩展表示相关私钥应只用于签写证书，而不应该用于 SSL。</li><li><strong>CRL分布点：</strong>指明CRL的分布地点</li><li><strong>私钥的使用期：</strong>指明证书中与公钥相联系的私钥的使用期限，它也有Not Before和Not After组成。若此项不存在时，公私钥的使用期是一样的。</li><li><strong>证书策略：</strong>由对象标识符和限定符组成，这些对象标识符说明证书的颁发和使用策略有关。</li><li><strong>策略映射：</strong>表明两个CA域之间的一个或多个策略对象标识符的等价关系，仅在CA证书里存在</li><li><strong>主体别名：</strong>指出证书拥有者的别名，如电子邮件地址、IP地址等，别名是和DN绑定在一起的。</li><li><strong>颁发者别名：</strong>指出证书颁发者的别名，如电子邮件地址、IP地址等，但颁发者的DN必须出现在证书的颁发者字段。</li><li><strong>主体目录属性：</strong>指出证书拥有者的一系列属性。可以使用这一项来传递访问控制信息。</li></ul><p>百度的SSL数字证书：</p><p><a href="http://www.enkichen.com/uploads/baidudigitalcertificate.png"><img src="http://www.enkichen.com/uploads/baidudigitalcertificate.png" alt="百度的SSL数字证书"></a></p><h4 id="数字证书格式"><a href="#数字证书格式" class="headerlink" title="数字证书格式"></a>数字证书格式</h4><p>数字证书体现为一个或一系列相关经过加密的数据文件。常见格式有：</p><ul><li>符合PKI ITU-T X509标准，传统标准（.DER .PEM .CER .CRT）</li><li>符合PKCS#7 加密消息语法标准(.P7B .P7C .SPC .P7R)</li><li>符合PKCS#10 证书请求标准(.p10)</li><li>符合PKCS#12 个人信息交换标准（.pfx *.p12）</li></ul><p>当然，这只是常用的几种标准，其中，X509证书还分两种编码形式：</p><ul><li>X.509 DER(Distinguished Encoding Rules)编码，后缀为：.DER .CER .CRT</li><li>X.509 BASE64编码，后缀为：.PEM .CER .CRT</li></ul><p>X509是数字证书的基本规范，而P7和P12则是两个实现规范，P7用于数字信封，P12则是带有私钥的证书实现规范。采用的标准不同，生成的数字证书，包含内容也可能不同。下面就证书包含&#x2F;可能包含的内容做个汇总，一般证书特性有：</p><ul><li>存储格式：二进制还是ASCII</li><li>是否包含公钥、私钥</li><li>包含一个还是多个证书</li><li>是否支持密码保护（针对当前证书）</li></ul><p>其中：</p><ul><li>DER、CER、CRT以二进制形式存放证书，只有公钥，不包含私钥</li><li>CSR证书请求</li><li>PEM以Base64编码形式存放证书，以”—–BEGIN CERTIFICATE—–” 和 “—–END CERTIFICATE—–”封装，只有公钥</li><li>PFX、P12也是以二进制形式存放证书，包含公钥、私钥，包含保护密码。PFX和P12存储格式完全相同只是扩展名不同</li><li>P10证书请求</li><li>P7R是CA对证书请求回复，一般做数字信封</li><li>P7B&#x2F;P7C证书链，可包含一个或多个证书</li></ul><p>理解关键点：凡是包含私钥的，一律必须添加密码保护（加密私钥），因为按照习惯，公钥是可以公开的，私钥必须保护，所以明码证书以及未加保护的证书都不可能包含私钥，只有公钥，不用加密。</p><p>上文描述中，DER均表示证书且有签名，实际使用中，还有DER编码的私钥不用签名，实际上只是个“中间件”。另外：证书请求一般采用CSR扩展名，但是其格式有可能是PEM也可能是DER格式，但都代表证书请求，只有经过CA签发后才能得到真正的证书。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://www.enkichen.com/2016/02/26/digital-certificate-based/">数字证书的基础知识</a><br><a href="http://www.360doc.com/content/10/0401/23/633992_21238907.shtml">X.509标准</a><br><a href="http://www.cnblogs.com/watertao/archive/2012/04/08/2437720.html">X.509 数字证书结构简介</a><br><a href="http://kb.cnblogs.com/page/194742/">数字证书及CA的扫盲介绍</a><br><a href="http://www.cnblogs.com/littlehann/p/3738141.html">openSSL命令、PKI、CA、SSL证书原理</a></p><ul><li><strong>本文作者：</strong> Enki</li><li><strong>本文链接：</strong> <a href="http://enkichen.com/2016/04/12/certification-and-pki/">http://enkichen.com/2016/04/12/certification-and-pki/</a></li><li><strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;PKI（Public Key Infrastructure）翻译过来就是公钥基础设施，可以理解为利用公钥技术为网络应用提供加密和数字签名等密码服务以及必需的密钥和证书管理体系。它是一个提供安全服务的基础设施，PKI技术是信息安全技术的核心，同时也是电子商务的关键和基础技术。</summary>
      
    
    
    
    <category term="密码学" scheme="https://stevezhangzl.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>数字证书的基础知识[转]</title>
    <link href="https://stevezhangzl.github.io/2022/11/23/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E8%BD%AC/"/>
    <id>https://stevezhangzl.github.io/2022/11/23/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E8%BD%AC/</id>
    <published>2022-11-23T06:49:41.000Z</published>
    <updated>2023-01-16T22:23:56.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Enki</p><p>原文链接： <a href="http://enkichen.com/2016/02/26/digital-certificate-based/">http://enkichen.com/2016/02/26/digital-certificate-based/</a></p></blockquote><p>在讲数字证书之前必须要讲<strong>非对称加密算法</strong>和<strong>摘要算法</strong>，因为数字证书的基础就是各种加解密算法（非对称加密、摘要算法），而其中的核心就是非对称加密算法了。目前而言加密方法可以分为两大类。一类是<strong>单钥加密</strong>（private key cryptography）也可以称为对称加密，还有一类叫做<strong>双钥加密</strong>（public key cryptography）也可称为非对称加密。前者的加密和解密过程都用同一套密码，后者的加密和解密过程用的是不同的密码。下面来看看对称加密、非对称加密以及摘要算法，他们是怎样应用在数字证书中的。</p><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>对称加密(也叫私钥加密)指加密和解密使用相同密钥的加密算法。有时又叫传统密码算法，就是加密密钥能够从解密密钥中推算出来，同时解密密钥也可以从加密密钥中推算出来。而在大多数的对称算法中，加密密钥和解密密钥是相同的，所以也称这种加密算法为秘密密钥算法或单密钥算法。</p><p>在应用该算法时，它要求发送方和接收方在安全通信之前，商定一个密钥。对称算法的安全性依赖于密钥，泄漏密钥就意味着任何人都可以对他们发送或接收的消息解密，所以密钥的保密性对通信性至关重要。对称加密算法的特点是算法公开、计算量小、加密速度快、加密效率高。对称加密有很多种算法，由于它效率很高，所以被广泛使用在很多加密协议的核心当中。不足之处是，交易双方都使用同样钥匙，安全性得不到保证。</p><h4 id="常见的对称加密算法"><a href="#常见的对称加密算法" class="headerlink" title="常见的对称加密算法"></a>常见的对称加密算法</h4><ul><li><strong>DES</strong>：数据加密标准（DES，Data Encryption Standard）是一种使用密钥加密的块密码，它基于使用<strong>56位密钥</strong>的对称算法，这个算法因为包含一些机密设计元素，相对短的密钥长度以及被怀疑内含美国国家安全局（NSA）的后门而在开始时是有争议的，DES现在已经不被视为一种安全的加密算法，主要因为它使用的56位密钥过短，导致容易被破解。为了提供实用所需的安全性，可以使用DES的派生算法3DES来进行加密，虽然3DES也存在理论上的攻击方法。</li><li><strong>AES</strong>：高级加密标准（英语：Advanced Encryption Standard，缩写：AES），这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用，2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。AES的区块长度固定为128比特，<strong>密钥长度则可以是128，192或256比特</strong>。</li><li><strong>RC4</strong>：RC4加密算法是大名鼎鼎的RSA三人组中的头号人物Ronald Rivest在1987年设计的密钥长度可变的流加密算法簇。该算法的速度可以达到DES加密的10倍左右，且具有很高级别的非线性。RC4起初是用于保护商业机密的。但是在1994年9月，它的算法被发布在互联网上，也就不再有什么商业机密了。</li><li><strong>IDEA</strong>：是旅居瑞士中国青年学者来学嘉和著名密码专家J.Massey于1990年提出的。它在1990年正式公布并在以后得到增强。这种算法是在DES算法的基础上发展出来的，类似于三重DES，和DES一样IDEA也是属于对称密钥算法。发展IDEA也是因为感到DES具有密钥太短等缺点，已经过时。<strong>IDEA的密钥为128位</strong>，这么长的密钥在今后若干年内应该是安全的。</li></ul><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）；并且加密密钥和解密密钥是成对出现的。非对称加密算法在加密和解密过程使用了不同的密钥，非对称加密也称为公钥加密，在密钥对中，其中一个密钥是对外公开的，所有人都可以获取到，称为公钥，其中一个密钥是不公开的称为私钥。</p><h4 id="非对称加密的特性"><a href="#非对称加密的特性" class="headerlink" title="非对称加密的特性"></a>非对称加密的特性</h4><ul><li>对于一个公钥，有且只有一个对应的私钥。</li><li>公钥是公开的，并且不能通过公钥反推出私钥。</li><li>通过私钥加密的密文只能通过公钥能解密，通过公钥加密的密文也只能通过私钥能解密。</li></ul><blockquote><p>通过公钥是极难推算出私钥的，只能通过穷举，所以只要密钥足够长，要想从公钥推算出私钥几乎不可能的。</p></blockquote><h4 id="非对称加密的主要用途"><a href="#非对称加密的主要用途" class="headerlink" title="非对称加密的主要用途"></a>非对称加密的主要用途</h4><ul><li><strong>对信息保密，防止中间人攻击</strong>：将明文使用公钥加密，传输给接收者，这样确保信息只能被有私钥的拥有者解密，其他人无法获得明文信息，因为没有私钥无法进行解密。该方法一般用于交换**<code>对称密钥</code>**。</li><li><strong>身份验证和防止信息篡改</strong>：私钥拥有者使用私钥加密一段授权明文，并将授权明文和加密后的密文，以及公钥一并发送出来，接收方只需要通过公钥将密文解密后与授权明文对比是否一致，就可以判断明文在中途是否被篡改过。此方法用于**<code>数字签名</code>**。</li></ul><h4 id="常见的非对称加密算法"><a href="#常见的非对称加密算法" class="headerlink" title="常见的非对称加密算法"></a>常见的非对称加密算法</h4><ul><li><strong>RSA</strong>：1977年，三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做RSA算法。从那时直到现在，RSA算法一直是最广为使用的”非对称加密算法”。毫不夸张地说，只要有计算机网络的地方，就有RSA算法。这种算法非常可靠，密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长RSA密钥是768个二进制位。也就是说，长度超过768位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，<strong>1024位的RSA密钥基本安全，2048位的密钥极其安全</strong>。适用于数字签名和密钥交换。 该算法是目前应用最广泛的公钥加密算法，特别适用于通过 Internet 传送的数据。</li><li><strong>DSA</strong>：数字签名算法 (Digital Signature Algorithm, DSA) 由美国国家安全署 (United States National Security Agency, NSA) 发明，已作为数字签名的标准。在DSA数字签名和认证中，发送者使用自己的私钥对文件或消息进行签名，接受者收到消息后使用发送者的公钥来验证签名的真实性。DSA只是一种算法，和RSA不同之处在于它不能用作加密和解密，也不能进行密钥交换，只用于签名，它比RSA要快很多。DSA 算法的安全性取决于自计算离散算法的困难。这种算法，不适用于数据加密，仅适用于数字签名。</li><li><strong>Diffie-Hellman</strong>：一种确保共享KEY安全穿越不安全网络的方法。Whitefield与Martin Hellman在1976年提出了一个奇妙的密钥交换协议，称为Diffie-Hellman密钥交换协议&#x2F;算法(Diffie-Hellman Key Exchange&#x2F;Agreement Algorithm)。这个机制的巧妙在于需要安全通信的双方可以用这个方法确定对称密钥。然后可以用这个密钥进行加密和解密。但是注意，这个密钥交换协议&#x2F;算法只能用于密钥的交换，而不能进行消息的加密和解密。双方确定要用的密钥后，要使用其他对称密钥操作加密算法实际加密和解密消息。该算法仅适用于密钥交换。</li><li><strong>ECC</strong>：椭圆加密算法（ECC）是一种公钥加密体制，最初由Koblitz和Miller两人于1985年提出，与经典的RSA，DSA等公钥密码体制相比，椭圆密码体制有以下优点：160位的椭圆密钥与1024位的RSA密钥安全性相同；在私钥的加密解密速度上，ECC算法比RSA、DSA速度更快；存储空间占用小；带宽要求低；ECC算法的数学理论非常深奥和复杂，在工程应用中比较难于实现，但它的单位安全强度相对较高。</li></ul><p>非对称加密算法可能是世界上最重要的算法，它是当今电子商务等领域的基石。非对称加密算法如此强大可靠，却有一个弊端，就是加解密比较耗时。因此，在实际使用中，往往与对称加密和摘要算法结合使用。列如在实体之间交换对称密钥时，或者在签署一封邮件的散列时（数字签名）。</p><blockquote><p>散列是通过应用一种单向数学函数获得的一个定长结果，对于数据而言，叫做散列算法。</p></blockquote><h3 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h3><p>摘要算法是一个神奇的算法，也称为散列或者散列值。是一种与基于密钥（对称密钥或公钥）的加密不同的数据转换类型。散列就是通过把一个叫做散列算法的单向数学函数应用于数据，将任意长度的一块数据转换为一个定长的、不可逆转的数字，其长度通常在128～256位之间。所产生的散列值的长度应足够长，因此使找到两块具有相同散列值的数据的机会很少。</p><h4 id="摘要算法具有以下特性："><a href="#摘要算法具有以下特性：" class="headerlink" title="摘要算法具有以下特性："></a>摘要算法具有以下特性：</h4><ul><li>只要源文本不同，计算得到的结果，必然不同（或者说机会很少）。</li><li>无法从结果反推出源数据（那是当然的，不然就能量不守恒了）。</li></ul><h4 id="常见的摘要算法："><a href="#常见的摘要算法：" class="headerlink" title="常见的摘要算法："></a>常见的摘要算法：</h4><ul><li><strong>MD5</strong>：是RSA数据安全公司开发的一种单向散列算法，MD5被广泛使用，可以用来把不同长度的数据块进行暗码运算成一个固定位位的数值（通常是128位）。</li><li><strong>SHA-1</strong>：与 DSA 公钥算法相似，安全散列算法1（SHA-1）也是由 NSA 设计的，并由 NIST 将其收录到 FIPS 中，作为散列数据的标准。它可产生一个 160 位的散列值。SHA-1 是流行的用于创建数字签名的单向散列算法。</li><li><strong>MAC（Message Authentication Code）</strong>：消息认证代码，是一种使用密钥的单向函数，可以用它们在系统上或用户之间认证文件或消息，常见的是HMAC（用于消息认证的密钥散列算法）。</li><li><strong>CRC（Cyclic Redundancy Check）</strong>：循环冗余校验码，CRC校验由于实现简单，检错能力强，被广泛使用在各种数据校验应用中。占用系统资源少，用软硬件均能实现，是进行数据传输差错检测地一种很好的手段（CRC 并不是严格意义上的散列算法，但它的作用与散列算法大致相同，所以归于此类）。</li></ul><p>摘要算法用于对比信息源是否一致，因为只要源数据发生变化，得到的摘要必然不同。因为通常结果比源数据要短很多，所以称为“摘要”。</p><p>应用场景，如发件人生成邮件的散列值并加密它，然后将它与邮件本身一起发送。而收件人同时解密邮件和散列值，并由接收到的邮件产生另外一个散列值，然后将两个散列值进行比较。如果两者相同，邮件极有可能在传输期间没有发生任何改变。</p><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>数字签名就是对非对称加密和摘要算法的一种应用，能够确保信息在发布后不会被篡改（摘要算法特性），保证数据的完整性和可信性；同时也可以防止数据被他人伪造（非对称加密算法特性）；列如，我们有一段授权文本需要发布时，为了防止中途篡改发布的内容，保证发布文本的完整性，以及文本是由指定的发布者发布的。那么，可以通过摘要算法得到发布内容的摘要，得到摘要之后，发布者使用私钥加密得到密文（签名），这时候将源文本、密文（签名）以及公钥一起发布出去即可。</p><p>验证过程为：首先验证公钥是否是发布者的公钥，然后用公钥对密文进行解密，得到摘要，使用发布者对文本同样的摘要算法得到摘要文本，比对摘要是否一致即可确认信息是否被篡改或者是指定发布者发布的。</p><p><a href="http://www.enkichen.com/uploads/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.jpg"><img src="http://www.enkichen.com/uploads/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.jpg" alt="数字签名"></a></p><p>数字签名可以快速验证文本的完整性和合法性，已广泛应用于各个领域。</p><blockquote><p>公钥的验证在后续数字证书的授权链中提到验证方法。</p></blockquote><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><h4 id="现实生活中的证书"><a href="#现实生活中的证书" class="headerlink" title="现实生活中的证书"></a>现实生活中的证书</h4><p>在现实生活中，证书顾名思义，就是权限机构颁发的证明。比如英语6级证书，就是教育部门颁发给通过了6级考核的个人的证明，证明这个人的英语能力。我们来看一下这个证书的组成：</p><ul><li>被证明人：老王</li><li>内容：通过了英语六级</li><li>盖章：教育部门的公章或钢印</li></ul><p>当老王用这张证书找工作时，用人单位会通过查看证书的各项内容（尤其是公章），来验证证书的合法性和老王的能力。在现实生活中经常有假的6级证书，这些假证书最重要的就是有一个假公章。现实生活中使用法律法规来约束私刻假公章的行为，但是用人单位可能不能十分准确的判断公章是真是假。而数字签字可以来解决该类问题。</p><h4 id="数字证书-1"><a href="#数字证书-1" class="headerlink" title="数字证书"></a>数字证书</h4><p>数字证书就是通过数字签名实现的数字化的证书，在现实生活中公章可以被伪造，但是在计算数字世界中，数字签名是没办法被伪造的，比如上述证书中，在一个证书文件中写明了证书内容，颁发证书时，教育部门用他们的私钥对文件的摘要信息进行签名，将签名和证书文件一起发布，这样就能确保该证书无法被伪造。验证证书是否合法时，首先用教育部门的公钥（公钥是公开的谁都可以获取到）对签名进行解密得到一个摘要信息，使用教育部门同样的摘要算法得到证书的另一个摘要信息，对比两个摘要信息是否一致就能确定该证书是否合法。在一般的证书组成中部分中，还加入了一些其他信息，比如证书的有效期。</p><p>数字证书也有很多的签发机构，不同的签发机构签发的证书，用途也是不一样的，比如iOS开发中，使用到的ipa文件签名证书，需要到苹果申请。而在Web访问中为了防止Web内容在网络中安全传输，需要用到的SSL证书则需要向几家公认的机构签发。这些签发机构统称为CA（Certificate Authority）。</p><p>Web访问相关的证书可以向国际公认的几个机构：</p><ol><li><a href="http://www.webtrust.net/"><strong>WebTrust</strong></a></li><li><a href="http://cn.globalsign.com/"><strong>GlobalSign</strong></a></li><li><a href="http://certificate.fyicenter.com/335_Root_CA_GTE_CyberTrust_Global_Root_GTE_CyberTrust_Solutions.html"><strong>GTE</strong></a></li><li><a href="http://www.nortel.com/"><strong>Nortel</strong></a></li><li><a href="http://www.verisign.com/"><strong>Verisign</strong></a></li></ol><h4 id="数字证书的验证"><a href="#数字证书的验证" class="headerlink" title="数字证书的验证"></a>数字证书的验证</h4><p>申请证书是为了验证，比如Web应用相关的SSL证书验证方是浏览器，iOS各种证书的验证方是iOS设备。因为数字证书是基于数字签名的，所有数字证书的合法性验证就是验证数字证书的签名是否正确，对于签名的验证在是需要签发机构的公钥才能验证；</p><p>对于iOS开发证书来说，申请完签名证书后，还需要安装苹果的公钥证书（XCode安装后会自动安装），这样才能确保我们申请的证书是可以被验证通过的（合法的），可用来进行ipa文件签名的。对于Web相关的证书签名的验证，则是由浏览器来验证，对于国际公认的几个证书签发机构浏览器会内置其公钥证书，用来验证数字证书的可信性。</p><p>当数字证书通过验证后，便可以用数字证书做对应的事情，iOS开发证书可以用来对APP进行签名，SSL证书可以用来做Web内容加密处理相关的事情。所以有了这些证书之后，能保证在数据的传输过程中，数据是不会被篡改的，并且信息来源也是不能不修改的，从而确保信息安全。</p><blockquote><p>对于iOS，iOS系统已经将这个验证过程固化在系统中了，除非越狱，否则无法绕过</p></blockquote><h4 id="数字证书的授权链"><a href="#数字证书的授权链" class="headerlink" title="数字证书的授权链"></a>数字证书的授权链</h4><p>数字证书还包含一个授权链信息，举个例子：如果你要申请休假1周，需要你的上司审批，你的上司需要他的上司同意，最终需要大老板同意，那么这一层层的授权，形成了一个授权链，大老板是授权链的根(root)，中间这些环节分别是被更接近root的人授权的。</p><p>比如苹果开发者的APP签名证书，该证书可以用来对APP进行签名，该证书实际上是由苹果的Worldwide Developer Relations Certificate Authority（WDRCA）授权签名的，而它是由Apple Certificate Authority授权签名的。在这个关系链中苹果的CA是根。 苹果CA根证书默认是内置在苹果系统中的，所以WDRCA的可信性可以由苹果内置的CA根证书来验证其可信性。</p><p>Web相关的SSL证书顶部CA根，则就是上述提到的几家公认的签发机构，当我们需要Web做SSL的证书时，便可以向上述机构申请，通常向根机构申请费用都会比较高，也可以向一些二级授权机构进行申请，选择根机构证书签发的好处就是目前大多数的浏览器都会预装内置了这些权威CA的公钥证书，这样，在使用这些权威CA签发过的证书的时候，浏览器一般不会报风险提示。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>数字证书签名的基础是非对称加密算法，利用了非对称加密的身份验证和防止信息篡改的特性来实现的，在一些其他方面比如HTTPS中密钥交换用的就是非对称加密的保密特性来实现的，在非对称加密算法中RSA应用最广。非对称加密虽好，但却有一个弊端，就是加解密比较耗时，所以一般都是配合对称加密一起使用。</p><blockquote><p>本文只是对数字证书做了概要的介绍，很多细节都未涉及到，如果各位对一些细节感兴趣可以根据本文涉及的知识点进入更深入的学习。同时本文也未涉及到数字证书的管理以及数字证书的格式等知识的介绍，这些内容将在后续文章中为大家整理和介绍。</p></blockquote><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://www.cnblogs.com/vamei/p/3480994.html">RSA加密与破解</a><br><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">RSA算法原理</a><br><a href="http://www.pchou.info/ios/2015/12/14/ios-certification-and-code-sign.html">漫谈iOS程序的证书和签名机制</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;作者：Enki&lt;/p&gt;
&lt;p&gt;原文链接： &lt;a href=&quot;http://enkichen.com/2016/02/26/digital-certificate-based/&quot;&gt;http://enkichen.com/2016/02/26/digi</summary>
      
    
    
    
    <category term="密码学" scheme="https://stevezhangzl.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>记一次jni实践学习笔记</title>
    <link href="https://stevezhangzl.github.io/2022/11/22/%E8%AE%B0%E4%B8%80%E6%AC%A1jni%E5%AE%9E%E8%B7%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://stevezhangzl.github.io/2022/11/22/%E8%AE%B0%E4%B8%80%E6%AC%A1jni%E5%AE%9E%E8%B7%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-11-22T01:26:15.000Z</published>
    <updated>2023-01-16T22:23:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>本次jni是落叶大神的对于函数抽取壳的实现，记录下学习jni过程的笔记和心得</p><h2 id="动态注册的使用过程"><a href="#动态注册的使用过程" class="headerlink" title="动态注册的使用过程"></a>动态注册的使用过程</h2><h3 id="这里使用了动态注册的方式，首先是java层"><a href="#这里使用了动态注册的方式，首先是java层" class="headerlink" title="这里使用了动态注册的方式，首先是java层"></a>这里使用了动态注册的方式，首先是<code>java</code>层</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JniBridge</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = JniBridge.class.getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">craoc</span><span class="params">(String applicationClassName)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">craa</span><span class="params">(Context context, String applicationClassName)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">ia</span><span class="params">(Context context,ClassLoader classLoader)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title">rcf</span><span class="params">(ClassLoader classLoader)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">mde</span><span class="params">(ClassLoader oldClassLoader,ClassLoader newClassLoader)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">rde</span><span class="params">(ClassLoader oldClassLoader,ClassLoader newClassLoader)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title">gap</span><span class="params">(ClassLoader classLoader)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.loadLibrary(<span class="string">&quot;dpt&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            Log.w(TAG,e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>应用启动，没执行过初始化的话，会执行 <code> JniBridge.ia(base,base.getClassLoader());</code></p><h3 id="JNI-OnLoad"><a href="#JNI-OnLoad" class="headerlink" title="JNI_OnLoad"></a>JNI_OnLoad</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个函数会被系统自动调用，注意传入的参数</span></span><br><span class="line"><span class="function">JNIEXPORT jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM *vm, <span class="keyword">void</span> *reserved)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    JNIEnv *env = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//1.获取env  把env的地址传入，通过GetEnv获取env 动态注册不会在每个函数传入env 需要自己从vm中获取</span></span><br><span class="line">    <span class="keyword">if</span> (vm-&gt;<span class="built_in">GetEnv</span>((<span class="keyword">void</span> **) &amp;env, JNI_VERSION_1_4) != JNI_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.注册jni函数  见下面registerNativeMethods</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">registerNativeMethods</span>(env) == JNI_FALSE) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">init_dpt</span>(env);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DLOGI</span>(<span class="string">&quot;JNI_OnLoad called!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> JNI_VERSION_1_4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>registerNativeMethods</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">registerNativeMethods</span><span class="params">(JNIEnv *env)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.反射java中的JniBridge类得到Class</span></span><br><span class="line">    jclass JniBridgeClass = env-&gt;<span class="built_in">FindClass</span>(<span class="string">&quot;com/luoyesiqiu/shell/JniBridge&quot;</span>);</span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//2.执行RegisterNatives 传入Class和 对应的JNINativeMethod数组，这个数组是java和c函数的对应关系，把要注册的函数都写在里面</span></span><br><span class="line">    <span class="comment">//最后一个参数是数组的size，因为c/c++里没有数组的长度函数，所以需要通过sizeof(数组)/sizeof(某项) 来获取数组的大小，这个技巧要记住</span></span><br><span class="line">    <span class="keyword">if</span> (env-&gt;<span class="built_in">RegisterNatives</span>(JniBridgeClass, gMethods, <span class="built_in"><span class="keyword">sizeof</span></span>(gMethods) / <span class="built_in"><span class="keyword">sizeof</span></span>(gMethods[<span class="number">0</span>])) ==</span><br><span class="line">        <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个数组是每一项都是对项 .name 是java函数的名字  .signature 是对应的方法签名，方法签名自行百度 后面是对应的c的函数</span></span><br><span class="line"><span class="comment">//java层的不知道怎么起名字，直接用c函数的缩写</span></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod gMethods[] = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;craoc&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>,                               (<span class="keyword">void</span> *) callRealApplicationOnCreate&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;craa&quot;</span>,  <span class="string">&quot;(Landroid/content/Context;Ljava/lang/String;)V&quot;</span>,      (<span class="keyword">void</span> *) callRealApplicationAttach&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;ia&quot;</span>,    <span class="string">&quot;(Landroid/content/Context;Ljava/lang/ClassLoader;)V&quot;</span>, (<span class="keyword">void</span> *) init_app&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;gap&quot;</span>,   <span class="string">&quot;(Ljava/lang/ClassLoader;)Ljava/lang/String;&quot;</span>,         (<span class="keyword">void</span> *) getApkPath&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;rcf&quot;</span>,   <span class="string">&quot;(Ljava/lang/ClassLoader;)Ljava/lang/String;&quot;</span>,         (<span class="keyword">void</span> *) readAppComponentFactory&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;mde&quot;</span>,   <span class="string">&quot;(Ljava/lang/ClassLoader;Ljava/lang/ClassLoader;)V&quot;</span>,        (<span class="keyword">void</span> *) mergeDexElements&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;rde&quot;</span>,   <span class="string">&quot;(Ljava/lang/ClassLoader;Ljava/lang/ClassLoader;)V&quot;</span>,        (<span class="keyword">void</span> *) replaceDexElements&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面动态注册的流程基本已经结束了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本次jni是落叶大神的对于函数抽取壳的实现，记录下学习jni过程的笔记和心得&lt;/p&gt;
&lt;h2 id=&quot;动态注册的使用过程&quot;&gt;&lt;a href=&quot;#动态注册的使用过程&quot; class=&quot;headerlink&quot; title=&quot;动态注册的使用过程&quot;&gt;&lt;/a&gt;动态注册的使用过程&lt;/h2</summary>
      
    
    
    
    <category term="NDK" scheme="https://stevezhangzl.github.io/categories/NDK/"/>
    
    
  </entry>
  
  <entry>
    <title>CMake学习笔记</title>
    <link href="https://stevezhangzl.github.io/2022/11/17/CMake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://stevezhangzl.github.io/2022/11/17/CMake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-11-17T07:51:27.000Z</published>
    <updated>2023-01-16T22:23:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="生成可执行文件"><a href="#生成可执行文件" class="headerlink" title="生成可执行文件"></a>生成可执行文件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello cpp\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>很简单的的一个demo，我们开始编写<code>CMakeLists.txt</code>文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#给工程取一个名字</span></span><br><span class="line"><span class="keyword">PROJECT</span>(HELLO)</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义一个变量</span></span><br><span class="line"><span class="keyword">SET</span>(SRC_LIST hello.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印的语句</span></span><br><span class="line"><span class="keyword">MESSAGE</span>(STATUS <span class="string">&quot;this is BINARY dir &quot;</span><span class="variable">$&#123;HELLO_BINARY_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">MESSAGE</span>(STATUS <span class="string">&quot;this is SOURCE dir &quot;</span><span class="variable">$&#123;HELLO_SOURCE_DIR&#125;</span>)</span><br><span class="line"><span class="comment">#常用</span></span><br><span class="line"><span class="keyword">MESSAGE</span>(STATUS <span class="string">&quot;this is PROJECT_SOURCE dir &quot;</span><span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#生成可执行文件  用变量SRC_LIST代替</span></span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(hello.out <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们为了保证代码文件夹的整洁，新建一个<code>build</code>文件夹，进入<code>build</code>文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake ..</span><br></pre></td></tr></table></figure><p>这时便会在<code>build</code>中生成<code>Makefile</code>文件</p><p><img src="/../images/image-20221117161749877.png" alt="image-20221117161749877"></p><p>然后执行<code>make</code>，就会生成<code>hello.out</code></p><h2 id="生成动态库"><a href="#生成动态库" class="headerlink" title="生成动态库"></a>生成动态库</h2><p>把<code>src</code>里的源文件，生成<code>.so动态库</code>，<code>libmath.so</code>    最终生成在<code>lib</code>目录下</p><p>目录结构</p><p><img src="/../images/image-20221119162153309.png" alt="image-20221119162153309"></p><p>代码在<code>src</code>下面</p><p><img src="/../images/image-20221119162230989.png" alt="image-20221119162230989"></p><p>头文件在<code>include</code>下</p><p><img src="/../images/image-20221119162256286.png" alt="image-20221119162256286"></p><p>最后要编译出来so在lib目录下</p><p><code>CMakeLists.txt</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span>(VERSION <span class="number">3.14</span>)</span><br><span class="line"><span class="keyword">PROJECT</span>(<span class="keyword">MATH</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#收集SRC目录下的所有的cpp文件</span></span><br><span class="line"><span class="comment">#SRC_LIST 收集所有的cpp文件加入SRC_LIST集合中</span></span><br><span class="line"><span class="comment">#AUX_SOURCE_DIRECTORY ($&#123;PROJECT_SOURCE_DIR&#125;/src SRC_LIST)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用FILE定义文件变量集合</span></span><br><span class="line"><span class="keyword">FILE</span>(GLOB SRC_LIST_CPP <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br><span class="line"><span class="keyword">FILE</span>(GLOB SRC_LIST_C <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/src/*.c&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定头文件在哪个目录</span></span><br><span class="line"><span class="keyword">INCLUDE_DIRECTORIES</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定so的生成的目录</span></span><br><span class="line"><span class="keyword">SET</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment">#MESSAGE (STATUS &quot;src_list : &quot;$&#123;SRC_LIST_CPP&#125;)</span></span><br><span class="line"><span class="comment">#MESSAGE (STATUS &quot;src_list : &quot;$&#123;SRC_LIST_C&#125;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定生成动态库 .so  名字 math -&gt; libmath.so 生成静态库使用STATIC,要生成动态库需要加SHARED</span></span><br><span class="line"><span class="keyword">ADD_LIBRARY</span> (<span class="keyword">math</span> SHARED <span class="variable">$&#123;SRC_LIST_CPP&#125;</span> <span class="variable">$&#123;SRC_LIST_C&#125;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>ADD_LIBRARY生成静态库使用STATIC，如果要生成动态库要加SHARED</p></blockquote><h2 id="生成静态库"><a href="#生成静态库" class="headerlink" title="生成静态库"></a>生成静态库</h2><p>目录结构</p><p><img src="/../images/image-20221119171634721.png" alt="image-20221119171634721"></p><p>源码在src 头文件在<code>include</code>生成的静态库放在lib下</p><p><code>CMakeLists.txt</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span>(VERSION <span class="number">3.14</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">PROJECT</span>(<span class="keyword">MATH</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">FILE</span>(GLOB SRC_LIST_CPP <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br><span class="line"><span class="keyword">FILE</span>(GLOB SRC_LIST_C <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/src/*.c&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">INCLUDE_DIRECTORIES</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定生成静态库</span></span><br><span class="line"><span class="keyword">ADD_LIBRARY</span> (<span class="keyword">math</span> STATIC <span class="variable">$&#123;SRC_LIST_CPP&#125;</span> <span class="variable">$&#123;SRC_LIST_C&#125;</span>)</span><br></pre></td></tr></table></figure><h2 id="可执行文件链接外部的动态库与头文件"><a href="#可执行文件链接外部的动态库与头文件" class="headerlink" title="可执行文件链接外部的动态库与头文件"></a>可执行文件链接外部的动态库与头文件</h2><p><img src="/../images/image-20221119161911016.png" alt="image-20221119161911016"></p><p><code>libmath.so</code>在<code>lib</code>目录下，<code>include</code>里面是头文件</p><p><img src="/../images/image-20221119161945535.png" alt="image-20221119161945535"></p><p>编译<code>hello.cpp</code>链接<code>lib</code>下面的<code>so</code> 引用头文件</p><p><code>hello.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;add.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sub.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;div.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mul.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">add</span>(a,b));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">sub</span>(a,b));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">mul</span>(a,b));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">div</span>(a,b));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CMakeLists.txt</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span>(VERSION <span class="number">3.14</span>)</span><br><span class="line"><span class="keyword">PROJECT</span>(HELLO)</span><br><span class="line"></span><br><span class="line"><span class="keyword">INCLUDE_DIRECTORIES</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#编译时链接lib目录下的libmath.so</span></span><br><span class="line"><span class="comment">#指定so在哪个目录下 多个lib的话 就用空格加  或者换行</span></span><br><span class="line"><span class="keyword">LINK_DIRECTORIES</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#生成可执行文件</span></span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(hello hello.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment">#为hello添加编译链接库  注意不是libmath而是math</span></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span>(hello <span class="keyword">math</span>)</span><br></pre></td></tr></table></figure><h2 id="CMake交叉编译Android动态库"><a href="#CMake交叉编译Android动态库" class="headerlink" title="CMake交叉编译Android动态库"></a>CMake交叉编译Android动态库</h2><p>想在linux上编译android的so 交叉编译</p><ul><li><p>1.下载<code>ndk</code></p></li><li><p>2.配置环境变量，这里使用的<code>ndk21</code></p></li></ul><p>linux是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p>加上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">配置NDK路径</span></span><br><span class="line">export NDK_PATH=/home/zhangsan/newdisk/newsteve/android-ndk-r21e</span><br><span class="line"><span class="meta">#</span><span class="bash">怎么配置环境变量？</span></span><br><span class="line">export PATH=$NDK_PATH:$PATH</span><br></pre></td></tr></table></figure><ul><li>3.写交叉编译脚本，如果需要其他参数还可以增加，这个是最基本参数的配置</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rm -rf build</span><br><span class="line"></span><br><span class="line">mkdir build</span><br><span class="line"></span><br><span class="line">cd build</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">设置交叉编译的参数</span></span><br><span class="line">cmake -DANDROID_NDK=$&#123;NDK_PATH&#125; \    #NDK的路径</span><br><span class="line">-DCMAKE_TOOLCHAIN_FILE=$&#123;NDK_PATH&#125;/build/cmake/android.toolchain.cmake \ #cmake交叉编译链</span><br><span class="line">-DANDROID_ABI=&quot;arm64-v8a&quot; \ #指定CPU</span><br><span class="line">-DANDROID_NATIVE_API_LEVEL=21 \ #指定最低版本</span><br><span class="line">..</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Linux使用JNI编译中间层的so"><a href="#Linux使用JNI编译中间层的so" class="headerlink" title="Linux使用JNI编译中间层的so"></a>Linux使用JNI编译中间层的so</h2><p>目录结构</p><p><img src="/../images/image-20221119172022502.png" alt="image-20221119172022502"></p><p><code>native.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">JNIEXPORT jstring JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_cn_com_jit_newndkdemo02_MainActivity_stringFromJNI</span><span class="params">(JNIEnv* env,jobject)</span></span>&#123;</span><br><span class="line">std::string hello = <span class="string">&quot;Hello Cpp&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> env-&gt;<span class="built_in">NewStringUTF</span>(hello.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>CMakeLists.txt</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>.<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(<span class="string">&quot;newndkdemo02&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#查找已经存在系统库log -&gt; log-lib 并使用别名，别名后面链接用，log是android系统库，在ndk中，可以直接拿来用</span></span><br><span class="line"><span class="keyword">find_library</span>(log-lib log)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH ./)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(newndkdemo02 SHARED native.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(newndkdemo02 <span class="variable">$&#123;log-lib&#125;</span>)</span><br></pre></td></tr></table></figure><h2 id="生成so链接外部so"><a href="#生成so链接外部so" class="headerlink" title="生成so链接外部so"></a>生成so链接外部so</h2><p>目录</p><p><img src="/../images/image-20221119200205663.png" alt="image-20221119200205663"></p><p><code>native.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//引入头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;include/add.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">JNIEXPORT jstring JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_cn_com_jit_newndkdemo02_MainActivity_stringFromJNI</span><span class="params">(JNIEnv* env,jobject)</span></span>&#123;</span><br><span class="line">std::string hello = <span class="string">&quot;Hello Cpp&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> env-&gt;<span class="built_in">NewStringUTF</span>(hello.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="function">JNIEXPORT jint JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_cn_com_jit_newndkdemo02_MainActivity_add</span><span class="params">(JNIEnv* env,jobject thiz,jint num1,jint num2)</span></span>&#123;</span><br><span class="line">  <span class="comment">//使用libmath.so中的函数</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">add</span>(num1,num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>生成so 链接so</p><p><code>CMakeLists.txt</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>.<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(<span class="string">&quot;newndkdemo02&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">find_library</span>(log-lib log)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH ./)</span><br><span class="line"></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#和生成可执行文件的区别就在这里，其它链接so是一样的</span></span><br><span class="line"><span class="keyword">add_library</span>(newndkdemo02 SHARED native.cpp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(newndkdemo02 <span class="variable">$&#123;log-lib&#125;</span> <span class="keyword">math</span>)</span><br></pre></td></tr></table></figure><h2 id="生成so使用-a合并到so"><a href="#生成so使用-a合并到so" class="headerlink" title="生成so使用.a合并到so"></a>生成so使用.a合并到so</h2><p>目录</p><p><img src="/../images/image-20221119200744020.png" alt="image-20221119200744020"></p><p>使用libmath.a 生成最后的so</p><p><code>native.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//引入头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;include/add.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">JNIEXPORT jstring JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_cn_com_jit_newndkdemo02_MainActivity_stringFromJNI</span><span class="params">(JNIEnv* env,jobject)</span></span>&#123;</span><br><span class="line">std::string hello = <span class="string">&quot;Hello Cpp&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> env-&gt;<span class="built_in">NewStringUTF</span>(hello.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="function">JNIEXPORT jint JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_cn_com_jit_newndkdemo02_MainActivity_add</span><span class="params">(JNIEnv* env,jobject thiz,jint num1,jint num2)</span></span>&#123;</span><br><span class="line">  <span class="comment">//使用libmath.a中的函数</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">add</span>(num1,num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>CMakeLists.txt</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>.<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(<span class="string">&quot;newndkdemo02&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">find_library</span>(log-lib log)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成so的路径</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH ./)</span><br><span class="line"><span class="comment">#先把.a import进来成为local_math  预编译库</span></span><br><span class="line"><span class="keyword">add_library</span>(local_math STATIC IMPORTED)</span><br><span class="line"><span class="comment">#告诉.a的地址</span></span><br><span class="line"><span class="keyword">set_target_properties</span>(local_math PROPERTIES IMPORTED_LOCATION <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/libmath.a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(newndkdemo02 SHARED native.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment">#把local_math链接进来</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(newndkdemo02 <span class="variable">$&#123;log-lib&#125;</span> local_math)</span><br></pre></td></tr></table></figure><h2 id="使用cmake的复杂场景"><a href="#使用cmake的复杂场景" class="headerlink" title="使用cmake的复杂场景"></a>使用cmake的复杂场景</h2><p>最后生成so 场景比较复杂</p><ul><li>使用了静态库.a</li></ul><p><img src="/../images/image-20221119201521430.png" alt="image-20221119201521430"></p><p>子模块自己先编译成.a 后再合成so</p><p><img src="/../images/image-20221119201827454.png" alt="image-20221119201827454"></p><p>外层统一编译成一个so</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用子模块编译的.a 这里要这么写</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(libzip)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(bhook)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>( dpt</span><br><span class="line">            <span class="variable">$&#123;log-lib&#125;</span></span><br><span class="line">        <span class="comment">#这里直接使用zip静态库</span></span><br><span class="line">        zip</span><br><span class="line">        local_dobby</span><br><span class="line">        bytehook</span><br><span class="line">        <span class="variable">$&#123;android-lib&#125;</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure><blockquote><p>注意，这里的<code>libzip</code> 和<code>bhook</code>不是静态库的名字，而是子模块目录的名字，切记</p></blockquote><p>有这两个，就会从外到内，先去执行子模块目录的编译</p><p>子模块的<code>CMakeLists.txt</code>这么写</p><p><code>libzip</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.18</span>.<span class="number">1</span>)</span><br><span class="line"><span class="keyword">project</span>(libzip)</span><br><span class="line"></span><br><span class="line"><span class="keyword">file</span>(GLOB SRC *.c)</span><br><span class="line"><span class="comment">#生成静态库</span></span><br><span class="line"><span class="keyword">add_library</span>(zip STATIC <span class="variable">$&#123;SRC&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(zip z)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;生成可执行文件&quot;&gt;&lt;a href=&quot;#生成可执行文件&quot; class=&quot;headerlink&quot; title=&quot;生成可执行文件&quot;&gt;&lt;/a&gt;生成可执行文件&lt;/h2&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g</summary>
      
    
    
    
    <category term="NDK" scheme="https://stevezhangzl.github.io/categories/NDK/"/>
    
    
  </entry>
  
</feed>
