<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"example.com",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta property="og:type" content="website"><meta property="og:title" content="SteveZhang博客"><meta property="og:url" content="http://example.com/index.html"><meta property="og:site_name" content="SteveZhang博客"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="张龙"><meta name="twitter:card" content="summary"><link rel="canonical" href="http://example.com/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!0,isPost:!1,lang:"zh-CN"}</script><title>SteveZhang博客</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="SteveZhang博客" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">SteveZhang博客</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">59</span></a></li></ul></nav></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content index posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/12/13/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC6%E7%AB%A0-%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%A3%85%E8%BD%BD%E4%B8%8E%E8%BF%9B%E7%A8%8B/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/12/13/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC6%E7%AB%A0-%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%A3%85%E8%BD%BD%E4%B8%8E%E8%BF%9B%E7%A8%8B/" class="post-title-link" itemprop="url">程序员的自我修养读书笔记-第6章-可执行文件的装载与进程</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-12-13 10:37:36" itemprop="dateCreated datePublished" datetime="2022-12-13T10:37:36+08:00">2022-12-13</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-12-19 08:51:31" itemprop="dateModified" datetime="2022-12-19T08:51:31+08:00">2022-12-19</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/NDK/" itemprop="url" rel="index"><span itemprop="name">NDK</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>介绍ELF文件在Linux下的装载过程，看看可执行文件装载的本质是什么？什么是进程的虚拟地址空间？为什么进程要有自己独立的虚拟地址空间？进程虚拟地址空间的分布情况，比如代码段、数据段、BSS段、堆、栈分别在进程地址空间怎么分布，它们的位置和长度如何决定。</p><h2 id="进程虚拟地址空间"><a href="#进程虚拟地址空间" class="headerlink" title="进程虚拟地址空间"></a>进程虚拟地址空间</h2><p>每个程序被运行起来以后，它将拥有自己独立的<strong>虚拟地址空间</strong>。由硬件决定地址空间的最大<strong>理论</strong>上限，即硬件的寻址空间大小，比如32位的硬件平台决定了虚拟地址空间的地址为0到 2^32 -1 即0x00000000 ~ 0xFFFFFFFF，也就是我们常说的4GB虚拟空间大小；而64位的硬件平台具有64位寻址能力，它的虚拟地址空间达到了2^64字节。</p><p>一般来说，C语言指针大小的位数与虚拟空间的位数相同，如32位平台的指针为32位，即4个字节；64位平台下的指针为64位，即8字节。</p><img src="../images/image-20221213131124041.png" alt="image-20221213131124041" style="zoom:50%"><p>我们进程最多可以使用3GB的虚拟空间，也就是说整个进程在执行的时候，所有的代码、数据包括通过C语言malloc等方法申请的虚拟空间之和不可以超过3GB。</p><p>扩展物理物理地址空间，只有32位的虚拟地址空间，应用程序该如何使用这些大于常规的内容空间呢？一个很常见的方法就是操作系统提供一个窗口映射的方法，把这些额外的内存映射到进程地址空间中来。应用程序可以根据需要来选择申请和映射，比如一个应用程序中0x10000000<del>0x20000000这一段256MB的虚拟地址空间来做窗口，程序可以从高于4GB的物理空间中申请多个大小为256MB的物理空间，编号成A&#x2F;B&#x2F;C等，然后根据需要将这个窗口映射到不同的物理空间块，用到A时将0x10000000</del>0x20000000映射到A，用到B、C时再映射过去，如此重复操作即可。像Linux等UNIX类操作系统采用mmap()系统调用来实现。</p><h2 id="装载的方式"><a href="#装载的方式" class="headerlink" title="装载的方式"></a>装载的方式</h2><p>最简单的静态装入方法：将程序所需要的指令和数据全都装入内存中。</p><p>动态装入：将程序最常用的部分驻留在内存中，而将一些不太常用的数据存入在磁盘里。<strong>覆盖装入</strong>和<strong>页映射</strong>两种典型的动态装载方法，原则上都是利用了程序的局部性原理。动态装入的思想是程序用到哪个模块，就将哪个模块装入内存，如果不用就暂时不装入，存入在磁盘中。</p><h3 id="覆盖装入"><a href="#覆盖装入" class="headerlink" title="覆盖装入"></a>覆盖装入</h3><p>几乎被淘汰了</p><h3 id="页映射"><a href="#页映射" class="headerlink" title="页映射"></a>页映射</h3></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/12/11/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC4%E7%AB%A0-%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/12/11/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC4%E7%AB%A0-%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/" class="post-title-link" itemprop="url">程序员的自我修养读书笔记-第4章-静态链接</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-12-11 07:06:33" itemprop="dateCreated datePublished" datetime="2022-12-11T07:06:33+08:00">2022-12-11</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-12-19 08:51:31" itemprop="dateModified" datetime="2022-12-19T08:51:31+08:00">2022-12-19</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/NDK/" itemprop="url" rel="index"><span itemprop="name">NDK</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>当我们有两个目标文件时</p><p>如何将它们链接起来形成一个可执行文件？</p><p>这个过程发生了什么？</p><p>—静态链接</p><p>a.c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> shared;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">	<span class="built_in">swap</span>(&amp;a,&amp;shared);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b.c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> shared = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span>&#123;</span><br><span class="line">	*a ^= *b ^= *a ^= *b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gcc -c -fno-stack-protector a.c b.c</p><blockquote><p>因为下面要使用ld裸链接器去链接，没有链接到__statck_chk_fail所在库文件，链接过程会报错，所以编译源码到目标文件时，一定要加”-fno-stack-protector” 不去调用函数__stack_chk_fail进行栈相关检查。强制gcc不进行栈检查</p></blockquote><p>生成a.o b.o两个目标文件，怎么链接这两个文件呢？</p><h2 id="空间与地址分配"><a href="#空间与地址分配" class="headerlink" title="空间与地址分配"></a>空间与地址分配</h2><p>对于链接器来说，整个链接过程中，它就是将几个输入目标文件加工合并成一个输出文件。</p><h3 id="相似段合并"><a href="#相似段合并" class="headerlink" title="相似段合并"></a>相似段合并</h3><p>将相同性质的段合并到一起，</p><p><img src="/../images/image-20221211160737942.png" alt="image-20221211160737942"></p><p>.bss段在目标文件和可执行文件中并不占用文件的空间，但是它在装载时占用地址空间。所以链接器在合并各个段的同时，也将.bss合并，并且分配虚拟空间。</p><p>链接器为目标文件分配<strong>地址和空间</strong></p><ul><li><p>输出的可执行文件中的空间</p></li><li><p>在装载后的虚拟地址中的虚拟地址空间</p></li></ul><p>对于.text 和.data来说，它们在文件中和虚拟地址中都要分配空间，因为它们在这两者中都存在；而对于.bss段，分配空间的意义只局限于虚拟地址空间，因为它在文件中并没有内容。</p><p><strong>事实上，我们在这里谈到的空间分配只关注于虚拟地址空间的分配</strong>，这个关系到链接器后面的关于地址计算的步骤，而可执行文件本身的空间与链接过程关系并不是很大。</p><h4 id="两步链接"><a href="#两步链接" class="headerlink" title="两步链接"></a>两步链接</h4><p>第一步 空间与地址分配</p><p>扫描所有的输入目标文件，并且获得它们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局符号表。</p><p>第二步 符号解析与重定义</p><p>读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等，事实上第二步是链接过程的核心，特别是重定位过程。</p><p>使用ld链接器将a.o和b.o链接起来</p><p><code>ld a.o b.o -e main -o ab</code></p><ul><li>-e main 表示将main函数作为程序入口，ld链接器默认的程序入口为_start。</li><li>-o ab 表示链接输出文件名为ab，默认为a.out</li></ul><p><code>objdump -h a.o</code></p><p><img src="/../images/image-20221212090531471.png" alt="image-20221212090531471"></p><p><code>objdump -h b.o</code></p><p><img src="/../images/image-20221212090941018.png" alt="image-20221212090941018"></p><p><code>objdump -h ab</code></p><p><img src="/../images/image-20221212091135206.png" alt="image-20221212091135206"></p><blockquote><p>VMA 虚拟地址</p><p>LMA 加载地址</p><p>正常情况下两个值应该是一样的，但是有些嵌入式系统中，特别是在那些程序放在ROM的系统中，LMA和VMA是不相同的。只需要关注VMA即可。</p></blockquote><p>链接前后的程序中所使用的地址已经是程序在进程中的虚拟地址，即我们关心上面各个段中的<strong>VMA</strong>和<strong>Size</strong>，而忽略**文件偏移(File off)**。</p><ul><li>链接之前，目标文件中的所有段的VMA都是0，因为虚拟空间还没有被分配，默认都是0.</li><li>链接之后，可执行文件ab中的各段都被分配到了相应的虚拟。</li></ul><p>合并和映射的关系如图</p><img src="../images/image-20221212094549192.png" alt="image-20221212094549192" style="zoom:50%"><p>​ 第一步 空间分配阶段</p><h3 id="符号地址的确定"><a href="#符号地址的确定" class="headerlink" title="符号地址的确定"></a>符号地址的确定</h3><p>在第一步的描述和空间分配阶段，链接器按照前面介绍的空间分配方法进行分配，这时候输入文件中的各个段在链接后的虚拟地址就已经确定了，比如.text段起始地址为0x0401000 .data段起始地址为0x0404000</p><p>第一步完成后，链接器开始计算各个<strong>符号的虚拟地址</strong>。因为各个符号在<strong>各自的段内</strong>的相对位置是固定的，所以这时候其实main shared swap的地址已经确定的了，只不过链接器需要给每个符号加上一个<strong>偏移量</strong>，使它们能够调整到正确的虚拟地址。</p><p>比如我们假设a.o中的main函数相对于.ao的.text段的偏移是X，但是经过链接合并以后a.o的.text段位于虚拟地址0x0401000，那么main的地址应该是0x0401000 + X。main位于a.o的.text段的最开始，也就是偏移为0，所以main这个符号在最终的输出文件中的地址应该是0x0401000 + 0，即0x0401000。</p><p>可以通过完全一样的计算方法得知所有符号的地址，这个例子只有三个全局符号。</p><p><code>objdump -s -x -d ab</code></p><p><img src="/../images/image-20221212100737875.png" alt="image-20221212100737875"></p><p>main的大小是0x32 所以 swap的起始地址是0x0401032而swap的大小正好就是b.o中.text的长度4f</p><p>再看shared</p><p><img src="/../images/image-20221212100921945.png" alt="image-20221212100921945"></p><p>起始地址是0x0404000 值是0x01 大小 0x04个字节</p><table><thead><tr><th>符号</th><th>类型</th><th>虚拟地址</th></tr></thead><tbody><tr><td>main</td><td>函数</td><td>0x0401000</td></tr><tr><td>swap</td><td>函数</td><td>0x0401032</td></tr><tr><td>shared</td><td>变量</td><td>0x0404000</td></tr></tbody></table><p>或者直接看这个图</p><p><img src="/../images/image-20221212101028136.png" alt="image-20221212101028136"></p><h2 id="符号解析与重定位"><a href="#符号解析与重定位" class="headerlink" title="符号解析与重定位"></a>符号解析与重定位</h2><h3 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h3><p>在完成空间和地址的分配步骤以后，链接器就进入了符号解析与重定位的步骤，这也是静态链接的核心内容。</p><p>先看看a.o里面怎么使用这两个外部符号的，a.c中使用了shared变量和swap函数，编译器在将a.c编译成指令时，如何访问shared变量？如何调用 swap函数？</p><p><code>objdump -d a.o</code></p><p><img src="/../images/image-20221212105818746.png" alt="image-20221212105818746"></p><p>这里看到main的起始地址为0x0000,0000,0000,0000 这是因为在未进行第一步空间分配之前，目标文件代码段中的起始地址以0x0000,0000,0000,0000开始，等空间分配完成之后，各个函数才会确定自己在虚拟地址空间中的位置。</p><p>当a.c在被编译成目标文件时，编译器并不知道shared和swap的地址，因为它们定义在其他目标文件中，所以编译器就暂时把地址0看作是shared和swap的地址，可以看0x17这行 lea 是近址相对位移调用指令，后面的4个字节是shared相对于调用指令下一条指令的偏移量</p><p>后面也提示了&lt;main + 0x1e&gt; 因为现在还不知道偏移量是多少，所以是0 在 ld成ab文件后</p><p><img src="/../images/image-20221212110239243.png" alt="image-20221212110239243"></p><p>1e的虚拟地址为0x40101e 指令后面偏移量也给出了，是0x2f 0xef ，我们用0x40101e + 0x2fe2 &#x3D; 0x404000 正好是shared的合并后的地址</p><p>再来看调用 a.o中的swap</p><p><img src="/../images/image-20221212110434485.png" alt="image-20221212110434485"></p><p>callq e8后面也是0 跟 shared一样，也是callq也是近址相对位移调用指令，call下一条是mov指令 偏移量，看ab文件</p><p><img src="/../images/image-20221212110618527.png" alt="image-20221212110618527"></p><p>0x40102b + 0x07 &#x3D; 0x401032 所以swap的地址是0x401032</p><p>这就是指令修正的方式，也就是给符号重定位的过程</p><h3 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h3><p>那么链接器是怎么知道哪些指令需要被调整呢？这些指令的哪些部分需要被调整？怎么调整？</p><p>ELF文件中，有一个重定位表的结构专门用来保存这些与重定位相关的信息，在ELF文件中往往是一个或多个段。</p><p>对于可重定位的ELF文件来说，它必须包含有重定位表，用来描述如何修改相应的段里的内容。对于每个要被重定位的ELF段都配有一个对应的重定位表。比如.text 要被重定位，那么就有一个.rel.text段</p><p><code>objdump -r a.o</code></p><p><img src="/../images/image-20221212130602053.png" alt="image-20221212130602053"></p><p>用于查看a.o里面要重定位的地方，即a.o所有引用到外部符号的地址。每个要被重定位的地方叫一个重定位入口，我们看到a.o里面有两个重定位入口。</p><p>偏移对应于要被重定位的段中的位置，这里1a 27 就是 lea和callq指令的地址部分</p><p><img src="/../images/image-20221212130818448.png" alt="image-20221212130818448"></p><p>重定位表的结构是一个Elf64_Rel结构的数组，每个数组元素就对应一个<strong>重定位入口</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_rel</span> &#123;</span></span><br><span class="line">  Elf64_Addr r_offset;	<span class="comment">/* Location at which to apply the action */</span></span><br><span class="line">  Elf64_Xword r_info;	<span class="comment">/* index and type of relocation */</span></span><br><span class="line">&#125; Elf64_Rel;</span><br></pre></td></tr></table></figure><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>r_offset</td><td>重定位入口的偏移。对于可重定位文件来说，这个值是该重定位入口所要修正的位置的第一个字节相对于段起始的偏移；对于可执行文件或共享对象文件来说，这个值是该重定位入口所要修正的位置的第一个字节的虚拟地址。</td></tr><tr><td>r_info</td><td>重定位入口的类型和符号。这个成员的低8位表示重定位入口的类型，高24位表示重定位入口的符号在符号表中的下标。</td></tr></tbody></table><h3 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h3><p>之所以要链接是因为我们目标文件中用到的符号被定义在其他目标文件，所以要将它们链接起来。比如使用ld a.o 链接器会发现shared和swap两个符号没有被定义，没有办法完成链接工作</p><p><img src="/../images/image-20221212131531080.png" alt="image-20221212131531080"></p><p>链接时符号未定义。导致这个问题的原因很多，最常见的一般都是链接时缺少了某个库，或者输入目标文件路径不正确或符号的声明与定义不一样。</p><p>重定位的过程中，每个重定位的入口都是对一个符号的引用，那么当链接器需要对某个符号引用进行重定位时，它就要确定这个符号的目标地址。这时候链接器就会去查找由所有输入目标文件的符号表组成的全局符号表，找到相应的符号后进行重定位。</p><p><code>readelf -s a.o</code> 查看a.o的符号表</p><p><img src="/../images/image-20221212131955461.png" alt="image-20221212131955461"></p><p>看到GLOBAL类型 只有main定义在.text段里 shared和swap都是UND 也就是undefined未定义类型，这种未定义的符号都是因为该目标文件中有关于它们的重定位项。在链接器扫描扫描完所有的输入目标文件之后，所有这些未定义的符号都应该能够在某个目标文件的符号表中找到，否则链接器就报符号未定义错误。</p><p>比如</p><p><code>readelf -s b.o</code></p><p><img src="/../images/image-20221212132409883.png" alt="image-20221212132409883"></p><p>在b.o中指明了GLOBAL shared和swap定义的段</p><h3 id="指令修正方式-略"><a href="#指令修正方式-略" class="headerlink" title="指令修正方式(略)"></a>指令修正方式(略)</h3><p>指令修正方式和每个处理器相关，需要相阅手册</p><ul><li>近址寻址或远址寻址</li><li>绝对寻址或相对寻址</li></ul><h2 id="COMMON块"><a href="#COMMON块" class="headerlink" title="COMMON块"></a>COMMON块</h2><p>弱符号机制允许同一个符号的定义存在于多个文件中，如果一个弱符号定义在多个目标文件中，而它们的类型又不同，怎么办？</p><ul><li>两个或两个以上强符号类型不一致；</li><li>有一个强符号，其他都是弱符号，出现类型不一致；</li><li>两个或两个以上弱符号类型不致。</li></ul><p>多个强符号定义本身就是非法的，链接器会报符号多重定义错误，所以链接器要处理的就是后两种情况。</p><p>编译器将<strong>未初始化的全局变量定义</strong>作为弱符号处理。</p><p>比如SimpleSection.c中的global_uninit_var 它在符号表中 readelf -s</p><p><img src="/../images/image-20221212135246549.png" alt="image-20221212135246549"></p><p>那么如果我们在另外一个文件中也定义了global_uninit_var变量，且未初始化，类型为double，占8个字节，按COMMON类型的链接规则，以最大的那个为准。即这两个文件链接后输出文件中global_uninit_var所占的空间为8个字节。</p><p>COMMON链接规则是针对都是弱符号的情况，如果其中有一个符号为强符号，最终输出结果中符号所占空间与强符号相同。</p><blockquote><p>在目标文件中，编译器为什么不直接把<strong>未初始化的全局变量</strong>也当作<strong>未初始化的局部静态变量</strong>一样处理，为它在BSS段分配空间，而是将其标记为一个COMMON类型的变量？</p><p>因为很多弱符号，编译器无法像未初始的局部静态变量一样确定它的大小，放在BSS段，编译器必须扫描完全部目标文件后，才能最终确定弱符号的最终大小，所以无法在BSS段分配空间，因为所需要空间的小未知。所以不能放在BSS段</p></blockquote><p>GCC的 -fno-common允许我们把所有未初始化的全局变量不以COMMON块的形式处理，或者使用__attribute__扩展：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> global <span class="constructor">__attribute__((<span class="params">nocommon</span>)</span>);</span><br></pre></td></tr></table></figure><p>一旦一个未初始化的全局变量不以COMMON块的形式存在，就相当于强符号，如果其他目标还有同一个变量的强符号定义，链接时就会发生符号重复的定义错误。</p><h2 id="C-相关问题"><a href="#C-相关问题" class="headerlink" title="C++相关问题"></a>C++相关问题</h2><ul><li>C++重复代码消除</li><li>全局构造与析构</li></ul><h3 id="重复代码消除"><a href="#重复代码消除" class="headerlink" title="重复代码消除"></a>重复代码消除</h3><h4 id="函数级别链接"><a href="#函数级别链接" class="headerlink" title="函数级别链接"></a>函数级别链接</h4><h3 id="全局构造与析构"><a href="#全局构造与析构" class="headerlink" title="全局构造与析构"></a>全局构造与析构</h3><h3 id="C-与ABI"><a href="#C-与ABI" class="headerlink" title="C++与ABI"></a>C++与ABI</h3><h2 id="静态库链接"><a href="#静态库链接" class="headerlink" title="静态库链接"></a>静态库链接</h2><p>静态库可以简单地看成一组目标文件的集合，即很多目标文件经过压缩打包后形成的一个文件。经如我们在Linux中最常用的C语言静态库libc位于&#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.a它属于glibc项目的一部分。</p><p>很多目标文件零散的提供给库的使用者，很大程序会造成文件传输、管理和组织方面的不便，于是通常人们使用ar压缩程序将这些目标文件压缩到一起，并且对其进行编号和索引，以便于查找和检索，就形成了libc.a这个静态库文件。</p><p><code>ar -t lic.a</code> 查看.a文件中包含的目标文件</p><p><img src="/../images/image-20221213093540461.png" alt="image-20221213093540461"></p><p>libc.a 有1000多个目标文件，如何在目标文件中找到printf函数所在的的目标文件？使用objdump或readelf 加上文件查找工具grep</p><p><img src="/../images/image-20221213094503847.png" alt="image-20221213094503847"></p><p>Hello World程序编译出来的目标文件只要和libc.a里面的printf.o链接在一起，最后就可以形成一个可用的可执行文件了。我们使用如下方法编译：</p><p><code>gcc -c -fno-builtin hello.c</code></p><blockquote><p>为什么使用-fno-builtin参数？</p><p>因为默认GCC为将Hello World程序中只使用了一个字符串参数的printf替换成puts函数，以提高运行速度，使用-fno-builtin关闭这个内置函数优化选项。</p></blockquote><p>我们使用ar工具解压出printf.o</p><p><code>ar -x /usr/lib/x86-gnu/libc.a</code></p><p>这个命令会将libc.a中所有目标文件‘解压’至当前目录，我们就可以得到printf.o，然后将其与hello.o链接在一起</p><p><code>ld hello.o printf.o</code></p><p><img src="/../images/image-20221213100254068.png" alt="image-20221213100254068"></p><p>链接失败，缺少几个未定义的符号，其实看objdump 的时候，也可以看到printf.o中的符号引用，有几个是UND，需要依赖外部其他的目标文件</p><p>stdio.o还依赖其他文件，所以我们使用ld链接器不断的链接，自动寻找所有需要的符号及它们所在的目标文件，将这些目标文件从libc.a中解压出来，最终将它们链接在一起成为一个可执行文件。但实际上hello.o和libc.a链接起来也不会得到可执行文件，还要其他一些辅助性质的目标文件和库</p><p><code>gcc -static --verbose -fno-builtin hello.c</code></p><p><img src="/../images/image-20221213102002818.png" alt="image-20221213102002818"></p><ul><li>第一步 使用ccl程序，这个程序实际上就是GCC的C语言编译器，它将hello.c编译成一个临时的汇编文件&#x2F;tmp&#x2F;cc8MewmB.s</li><li>第二步，使用as程序，as程序是GNU的汇编器，它将&#x2F;tmp&#x2F;cc8MewmB.s汇编成目标文件&#x2F;tmp&#x2F;ccYNbExD.o这个.o实际上就是前面的hello.o</li><li>第三步，最关键的步骤，调用 collect2程序来完成最后的链接，可以理解collect2是ld链接器的封装</li></ul><p>看最后一步，链接的目标文件</p><p>crt1.o</p><p>crtbeginT.o</p><p>..</p><p>crtend.o</p><p>crtn.o</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/12/10/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6(%E4%BA%8C)/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/12/10/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6(%E4%BA%8C)/" class="post-title-link" itemprop="url">程序员的自我修养读书笔记-第3章-目标文件(二)</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-12-10 06:55:11" itemprop="dateCreated datePublished" datetime="2022-12-10T06:55:11+08:00">2022-12-10</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-12-19 08:51:31" itemprop="dateModified" datetime="2022-12-19T08:51:31+08:00">2022-12-19</time></span></div></header><div class="post-body" itemprop="articleBody"><p>接上（一）继续</p><h2 id="链接的接口—符号"><a href="#链接的接口—符号" class="headerlink" title="链接的接口—符号"></a>链接的接口—符号</h2><p>链接过程的本质就是把多个不同的目标文件之间粘在一起，或者说像玩齿根积木一样，可以拼装形成一个整体。在链接中，目标文件之间相互拼合实际上是<strong>目标文件之间对地址的引用</strong>，<strong>即对函数和变量的地址的引用</strong>。</p><p>比如目标文件B要用到目标文件A的函数[foo]，那么我们就称目标文件A<strong>定义</strong>了函数[foo]，称目标文件B<strong>引用</strong>了目标文件A中的函数[foo]，这两个概念同样适用于变量。</p><p>每个函数或变量都有自己独特的名字，才能避免链接过程中不同变量和函数之间的混淆。</p><blockquote><p>在链接中，我们将函数和变量统称为<strong>符号(Symbol)</strong>,函数名或变量名就是**符号名(Symbol Name)**。</p></blockquote><p>每一个目标文件都会有一个相应的符号表(Symbol Table)，这个表里记录了目标文件 中所用到的所有符号。每个定义的符号有一个对应的值，叫做符号值(Symbol Value)，对于变量和函数来说，符号值就是它们的地址。</p><ul><li>定义在本目标文件的全局符号，可以被其他目标文件引用。比如SimpleSection.o里面的func1，main，和global_init_var</li><li>在本目标文件中引用的全局符号，却没有定义在本目标文件，这一般叫做外部符号（External Symbol），也就是我们所说的符号引用。比如SimpleSection.o里面的printf</li><li>局部符号，这类符号只在编译单元内部可见。比如SimpleSection.o里面的static_var和static_var2。调试器可以使用这些符号来分析程序或崩溃时的核心转储文件 。这些局部符号对于链接过程没有作用，链接器往往也忽略它们。</li><li>行号信息，即目标文件指令与源代码行的对应关系，它也是可选的。</li></ul><p>对于我们来说，最关注的就是全局符号，即上面分类中的第一类和第二类。因为链接过程只关心全局符号的相互‘粘合’，局部符号、段名、行号等都是次要的，它们对于其他目标文件来说是‘不可见的’，链接过程中也无关紧要的。可以使用很多工具来查看ELF文件的符号表，比如readelf、objdump、nm等</p><p><code>nm SimpleSection.o</code></p><p><img src="/../images/image-20221210113230525.png" alt="image-20221210113230525"></p><h3 id="ELF符号表结构"><a href="#ELF符号表结构" class="headerlink" title="ELF符号表结构"></a>ELF符号表结构</h3><p>符号表也是一个段，段名一般叫.symtab 符号表的结构是一个Elf64_Sym的<strong>数组</strong>，每个Elf64_Sym结构对应一个符号。数组第一个元素，下标为0的元素为无效的‘未定义’符号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_sym</span> &#123;</span></span><br><span class="line">  Elf64_Word st_name;	<span class="comment">/* Symbol name, index in string tbl */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>	st_info;	<span class="comment">/* Type and binding attributes */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>	st_other;	<span class="comment">/* No defined meaning, 0 */</span></span><br><span class="line">  Elf64_Half st_shndx;	<span class="comment">/* Associated section index */</span></span><br><span class="line">  Elf64_Addr st_value;	<span class="comment">/* Value of the symbol */</span></span><br><span class="line">  Elf64_Xword st_size;	<span class="comment">/* Associated symbol size */</span></span><br><span class="line">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure><p><code>readelf -s SimpleSection.o</code></p><p><img src="/../images/image-20221210122802514.png" alt="image-20221210122802514"></p><table><thead><tr><th>字段名</th><th>描述</th></tr></thead><tbody><tr><td>st_name</td><td>符号名。这成员包含了该符号该符号名在字符串表中的下标（字符串表）</td></tr><tr><td>st_value</td><td>符号相对应的值。这个值跟符号有关，可能是一个绝对值，也可能是一个地址等，不同的符号，它所对应的值含义不同</td></tr><tr><td>st_size</td><td>符号大小。对于包含数据的符号，这个值是该数据类型的大小。比如一个double型的符号它占用8个字节。如果该值为0，则表示该符号大小为0或未知</td></tr><tr><td>st_info</td><td>符号类型和绑定信息</td></tr><tr><td>st_other</td><td>该成员目前为0，没用</td></tr><tr><td>st_shndx</td><td>符号所在的段</td></tr></tbody></table><h4 id="符号类型和绑定信息-st-info"><a href="#符号类型和绑定信息-st-info" class="headerlink" title="符号类型和绑定信息(st_info)"></a>符号类型和绑定信息(st_info)</h4><p>该成员低4位表示符号的<strong>类型(Symbol Type)<strong>，高28位表示符号的</strong>绑定信息（Symbol Binding）</strong></p><p><strong>符号的绑定信息</strong></p><table><thead><tr><th>宏定义名</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>STB_LOCAL</td><td>0</td><td>局部符号，对于目标文件的外部不可见</td></tr><tr><td>STB_GLOBAL</td><td>1</td><td>全局符号，外部可见</td></tr><tr><td>STB_WEAK</td><td>2</td><td>弱引用</td></tr></tbody></table><p><strong>符号类型</strong></p><table><thead><tr><th>宏定义名</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>STT_NOTYPE</td><td>0</td><td>未知类型符号</td></tr><tr><td>STT_OBJECT</td><td>1</td><td>该符号是个数据对象，比如变量、数组等</td></tr><tr><td>STT_FUNC</td><td>2</td><td>该符号是个函数或其他可执行代码</td></tr><tr><td>STT_SECTION</td><td>3</td><td>该符号表示一个段，这种符号必须是STB_LOCAL的</td></tr><tr><td>STT_FILE</td><td>4</td><td>该符号表示文件名，一般都是该目标文件所对应的源文件名，它一定是STB_LOCAL类型的，并且它的st_shndx一定是SHN_ABS</td></tr></tbody></table><p><strong>符号所在的段(st_shndx)</strong></p><p>如果符号定义在本目标文件中，那么这个成员表示符号所在的段在段表中的下标(会显示具体的1，2，3数字)；但是如果符号不是定义在本目标文件中，或者对于有些特殊符号，sh_shndx的值有些特殊</p><p><strong>符号所在段特殊常量</strong></p><table><thead><tr><th>宏定义名</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>SHN_ABS</td><td>0xfff1</td><td>表示该符号包含了一个绝对的值。比如表示文件名的符号就属于这种类型</td></tr><tr><td>SHN_COMMON</td><td>0xfff2</td><td>表示该符号是一个COMMON块类型的符号，一般来说未初始化的全局符号定义就是这种类型的，比如simplesection.o里面的global_uninit_var。</td></tr><tr><td>SHN_UNDEF</td><td>0</td><td>表示该符号未定义。这个符号表示该符号在本目标文件被引用到，但是定义在其他目标文件中</td></tr></tbody></table><h4 id="符号值-st-value"><a href="#符号值-st-value" class="headerlink" title="符号值(st_value)"></a>符号值(st_value)</h4><p>每个符号都有一个对应的值，如果这个符号是一个函数或变量的定义，那么符号的值就是这个函数或变量的地址。</p><ul><li>在目标文件中，如果是符号的定义并且该符号不是COMMON块类型（即st_shndx不为SHN_COMMON）则st_value表示该符号在段中的偏移。即符号所对应的函数或变量位于由st_shndx指定的段，偏移st_value的位置。这也是目标文件中定义全局变量的符号的最常见情况，比如SimpleSection.o中的func1、main和global_init_var。</li><li>在目标文件中，如果符号是COMMON块类型的，则st_value表示该符号的对齐属性。比如Simple.Section.o中的global_uninit_var</li><li>在可执行文件中，st_value表示符号的虚拟地址。这个虚拟地址对于动态链接器来说十分有用</li></ul><p><img src="/../images/image-20221210170100970.png" alt="image-20221210170100970"></p><p><img src="/../images/image-20221210170152853.png" alt="image-20221210170152853"></p><p>readelf -s 的输出格式与Elf64_Sym的各个成员几首一一对应</p><ul><li>func1和main函数都是定义在SimpleSection.c里面的，它们所在的位置 都是代码段，所以Ndx为1。它们是函数，所以类型是STT_FUNC；它们是全局可见的，所以是STB_GLOBAL；Size表示函数指令所占有的字节数；Value表示函数相对于代码段起始位置的偏移量。</li><li>printf这个符号，该符号在SimpleSection.c里面被引用，但是没被定义。所以Ndx是SHN_UNDEF</li><li>global_init_var是已经初始化的全局变量，它被定义在.bss段，即下标为3</li><li>global_imomot_var是未初始化的全局变量，它是一个COMMEN块</li><li>static_var.1920 static_var2.1921 是两个静态变量，它们绑定属性是LOCAL，即只是编译单元内部可见</li><li>对于SECTION类型的符号，表示下标为Ndx的段的段名，符号名没有显示，其实符号名就是段名。比如2号符号的Ndx为1，那么就是.text段的段名，符号名就是.text 可以用<code>objdump -t</code> 看到这些段名符号。</li><li>SimpleSection.c这个符号表示编译单元的源文件名。</li></ul><h3 id="符号修饰与函数签名"><a href="#符号修饰与函数签名" class="headerlink" title="符号修饰与函数签名"></a>符号修饰与函数签名</h3><p>以前，编译器编译源代码产生目标文件时，符号名与相应的变量和函数的名字是一样的。后来为了防止符号冲突。C++这样后来设计的语言开始考虑到这个问题，增加了<strong>名称空间</strong>的方法来解决多模块的符号冲突问题。</p><h4 id="C-符号修饰"><a href="#C-符号修饰" class="headerlink" title="C++符号修饰"></a>C++符号修饰</h4><p>C++拥有类、继承、虚机制、重载、名称空间等这些特性，使得符号管理更为复杂。比如func(int)和func(double)那么编译器和链接器在链接过程如何区分？人们发明了<strong>符号修饰</strong>或<strong>符号改编</strong>的机制。</p><p><code>c++filt _ZN1N1C4funcEi</code></p><p><img src="/../images/image-20221210172126748.png" alt="image-20221210172126748"></p><p><img src="/../images/image-20221210172142423.png" alt="image-20221210172142423"></p><h3 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h3><p>c++为了与C兼容，在符号的管理上，c++有一个用来声明或定义一个C的符号的extern “C”关键字用法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">  <span class="keyword">int</span> var;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用如下格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">int</span> var;</span><br></pre></td></tr></table></figure><p>很多时候我们会碰到有些头文件声明了一些C语言的函数和全局变量，但是这个头文件可能会被C语言代码或C++代码包含。比如很常见的，我们的C语言库函数中的string.h中声明了memset这个函数，它的原型如下：</p><p><code>void *memset(void *,int,size_t);</code></p><p>如果不加任何处理，当我们的C语言程序包含string.h的时候，并且用到了memset这个函数，编译器会将memset符号引用正确处理；但是在c++中，编译器会认为这个memset函数是一个c++函数，将memset符号修饰成_Z6memsetPvvii，这样链接器就无法与C语言库中的这个memset符号进行链接。所以对于c++来说，必须使用extern “C”来声明memeset这个函数。但是C语言又不支持extern “C”语法，为了兼容，使用C++的宏”__cplusplus”，C++编译器会在编译C++的程序时默认定义这个宏</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span>*,<span class="keyword">int</span>,<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>如果当前编译单元是C++代码，那么memset会在extern “C”里面被声明；如果是C代码，就直接声明。这个技巧几乎在所有的系统头文件里面被用到。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/12/06/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%89%AB%E7%9B%B2/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/12/06/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%89%AB%E7%9B%B2/" class="post-title-link" itemprop="url">数字证书相关知识扫盲</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-12-06 13:57:07" itemprop="dateCreated datePublished" datetime="2022-12-06T13:57:07+08:00">2022-12-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-12-19 08:51:31" itemprop="dateModified" datetime="2022-12-19T08:51:31+08:00">2022-12-19</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%AF%81%E4%B9%A6%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">证书相关</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><ol><li>摘要、签名、证书是什么？</li><li>摘要、签名、证书的用途和关系？</li><li>签名是怎么生成的？</li><li>签名是怎么校验的？</li><li>证书是怎么生成的？</li><li>证书是怎么校验的？</li></ol><h2 id="消息摘要（Digest）"><a href="#消息摘要（Digest）" class="headerlink" title="消息摘要（Digest）"></a>消息摘要（Digest）</h2><h3 id="什么是消息摘要？"><a href="#什么是消息摘要？" class="headerlink" title="什么是消息摘要？"></a>什么是消息摘要？</h3><p>对一份数据，进行一个单向的Hash函数，生成一个固定长度的Hash值，这个值就是这份数据的摘要，也称为指纹。</p><h3 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h3><p>常见的摘要算法有MD5、SHA-1、SHA-256等。他们的特点：</p><ul><li>对于同一个摘要算法，无论输入的数据是什么，输出都是相同长度的值。例如MD5，无论数据有多大，输出总是128位的散列值。</li><li>摘要算法是单向的，只能根据原始数据计算出它的摘要值，但是不能根据摘要值反算出原始数据。</li><li>越优秀的摘要算法越难找到Hash碰撞。虽然长内容生成的短摘要是必定会产生碰撞的，但一个优秀的摘要算法很难主动构造出两条数据，使他们的摘要值相同。</li><li>消息摘要的用途：可以用于校验数据的完整性。例如我们在下载文件时，数据源会提供一个文件MD5。文件下载之后，我们本地计算出文件的MD5，和数据源提供的MD5做对比，如果相同则文件是完整的。但独立使用消息摘要时，无法确保数据没有被篡改，因为无法保证从数据源获取的MD5有没有被路途篡改。</li><li>相比加密算法，摘要算法速度都相对较快。</li></ul><h2 id="数字签名（Signature）"><a href="#数字签名（Signature）" class="headerlink" title="数字签名（Signature）"></a>数字签名（Signature）</h2><p>在了解签名之前，需要了解什么是公开密钥体系：</p><h3 id="公开密钥体系"><a href="#公开密钥体系" class="headerlink" title="公开密钥体系"></a>公开密钥体系</h3><p>基于大整数的因数分解可以生成一对公钥和私钥。公钥和私钥是一一对应关系，一把私钥有着和它唯一对应的公钥，反之亦然。用公钥加密的数据，只能用和它对应的私钥解密，用私钥加密也只能同与之对应的公钥解密。密钥对的生成很快速，但根据公钥反推私钥极其困难。</p><p>根据公开密钥体体系，我们有了非对称加密。常见的非对称加密是RSA加密。</p><p>如果用公钥对数据加密，用私钥去解密，这是加密；反之用私钥对数据加密，用公钥去解密，这是签名。</p><p>简单地看，似乎没有区别，只是换了个名字。但实际上，两者的用途完全不一样。由于所有人都持有公钥，所以签名并不能保证数据的安全性，因为所有人都可以用公钥去解密。但签名却能用于保证消息的准确性和不可否认性。<strong>因为公钥和私钥是一一对应的，所以当一个公钥能解密某个密文时，说明这个密文一定来自于私钥持有者。</strong></p><h3 id="签名和验证过程"><a href="#签名和验证过程" class="headerlink" title="签名和验证过程"></a>签名和验证过程</h3><p>我们来看一下具体签名和验证的过程：</p><ol><li>消息发送者持有私钥和加密算法，称为信源；信源用私钥加密算法对明文数据进行加密，得到密文数据，称为签体；</li><li>接着把明文数据和密文数据同时给到消息接收者；</li><li>消息接收者收到后，先取出密文数据，用公钥对密文解密，得到一份明文数据；</li><li>再将这份明文数据和收到的明文数据做对比，如果盯同则数据完整且可信。</li></ol><img src="../images/image-20221206142749614.png" alt="image-20221206142749614" style="zoom:50%"><p>即使他人截获并篡改了明文数据，由于私钱是保密的，篡改者也无法生成正确的签体。所以签名能保证消息的准确性。但在单独使用非对称加密的数字签名方案时，要对所有的明文消息进行加密，效率很低。怎么提高效率呢？</p><h3 id="更高效的数字签名方案"><a href="#更高效的数字签名方案" class="headerlink" title="更高效的数字签名方案"></a>更高效的数字签名方案</h3><p>将摘要算法和非对称加密结合使用。</p><p>如何签名：先用摘要算法计算明文数据的摘要值，再对这个摘要值使用私钥加密。这样就能较快速地得到原始的摘要值，再对这个摘要值用私钥加密。这样就能较快速地得到原始信息的签名；</p><p>如何验证：先用相同的摘要算法计算原始信息的摘要值，再用公钥对签名解密，得到收到的摘要值，最后对比这两个值判断是否相等。如果不相等说明数据不可信。</p><h3 id="数据签名方案的问题"><a href="#数据签名方案的问题" class="headerlink" title="数据签名方案的问题"></a>数据签名方案的问题</h3><p>数据接收者如何获取正确的公钥呢？如果公钥本身都被篡改了，这个签名方案就不正确了。所以需要有某种方式确保公钥的正确性，这就是数字证书。</p><h2 id="数字证书（Certificate）"><a href="#数字证书（Certificate）" class="headerlink" title="数字证书（Certificate）"></a>数字证书（Certificate）</h2><h3 id="数据证书的作用"><a href="#数据证书的作用" class="headerlink" title="数据证书的作用"></a>数据证书的作用</h3><p>确保数据接收者的公钥是没有被算改过的。</p><h3 id="数据证书通常包含以下内容"><a href="#数据证书通常包含以下内容" class="headerlink" title="数据证书通常包含以下内容"></a>数据证书通常包含以下内容</h3><ol><li>证书所有人的<strong>公钥</strong></li><li>证书发行者对证书的数字<strong>签名</strong></li><li>证书所用的签名算法</li><li>证书发布机构、有效期、所有者信息等其他信息</li></ol><p>数字证书的验证过程需要用到<strong>CA根证书</strong>和<strong>业务相关证书</strong>，<strong>根证书</strong>是预装在操作系统中的。</p><p>在理解数字证书工作原理之前，我们需要先理解这两种证书是怎么生成的：</p><h3 id="CA根证书的生成"><a href="#CA根证书的生成" class="headerlink" title="CA根证书的生成"></a>CA根证书的生成</h3><img src="../images/image-20221206154446266.png" alt="image-20221206154446266" style="zoom:40%"><p>步骤：</p><ol><li>权威机构利用RSA等算法，生成一对公钥PK1&#x2F;私钥SK1</li><li>将公钥PK1和证书发布机构、有效期等信息组成一份原始的证书内容，设为C1</li><li>利用某种摘要算法，计算原始内容C1的数字摘要，设为H1</li><li>用第一步生成的私钥SK1，对摘要H1签名，得到签名内容S1</li><li>将原始内容C1和签名内容S1合在一起，就得到了证书</li></ol><p>根证书安装在操作系统中，我们认为根证书是一定正确的</p><h3 id="业务相关证书的生成"><a href="#业务相关证书的生成" class="headerlink" title="业务相关证书的生成"></a>业务相关证书的生成</h3><img src="../images/image-20221206154821975.png" alt="image-20221206154821975" style="zoom:40%"><p>步骤：</p><ol><li>权威机构利用RSA等算法，生成一对公钥PK2&#x2F;私钥SK2</li><li>将公钥PK2和证书发布机构、有效期等信息组成一份原始的证书内容，设为C2，给到权威机构</li><li>机构拿到C2，利用某种摘要算法，计算原始内容C2的数字摘要，设为H2</li><li>权威机构用自己的私钥SK1（关键点），对摘要H2签名，得到签名内容S2</li><li>将原始内容C2和签名内容S2合在一起，就得到了证书，交给企业</li></ol><p>区别点：业务申请的证书，在签名时用的私钥是CA机构的私钥。这个私钥是和根证书中的公钥对应的。</p><h3 id="数字证书的真伪验证"><a href="#数字证书的真伪验证" class="headerlink" title="数字证书的真伪验证"></a>数字证书的真伪验证</h3><p>有了根证书，我们就能校验其他证书的真伪了：</p><img src="../images/image-20221206160350286.png" alt="image-20221206160350286" style="zoom:40%"><p>用根证书的公钥，可以验证其他证书的签名是否正确。如果签名正确，则证书是可信的、没有被篡改的。后续就可以使用这个被信任证书中包含的公钥，去验证收到的消息是否可信了。</p><p>用CA证书去证明另外一个证书是否可信，我们可以称之为证书的递归验证。类似地，我们也可以用一个受信任的证书，去验证其他证书是否可信。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/12/06/%E4%B8%80%E7%AF%87%E6%96%87%E4%BB%B6%E7%9C%8B%E6%87%82v1-v2-v3%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6-%E8%BD%AC/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/12/06/%E4%B8%80%E7%AF%87%E6%96%87%E4%BB%B6%E7%9C%8B%E6%87%82v1-v2-v3%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6-%E8%BD%AC/" class="post-title-link" itemprop="url">一篇文件看懂v1/v2/v3签名机制[转]</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-12-06 10:23:26" itemprop="dateCreated datePublished" datetime="2022-12-06T10:23:26+08:00">2022-12-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-12-19 08:51:31" itemprop="dateModified" datetime="2022-12-19T08:51:31+08:00">2022-12-19</time></span></div></header><div class="post-body" itemprop="articleBody"><p>作者：彭旭锐<br>链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6906882748909092871">https://juejin.cn/post/6906882748909092871</a><br>来源：稀土掘金</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0dd9c73a2d12414abfab39fe45cf4e3a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><hr><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>这篇文章的内容会涉及以下前置 &#x2F; 相关知识，贴心的我都帮你准备好了，请享用~</p><ul><li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6995549209348816909">加密、摘要、签名、证书，一次说明白!</a></li></ul><hr><h1 id="1-什么是应用签名？"><a href="#1-什么是应用签名？" class="headerlink" title="1. 什么是应用签名？"></a>1. 什么是应用签名？</h1><h4 id="1-1-数字签名模型"><a href="#1-1-数字签名模型" class="headerlink" title="1.1 数字签名模型"></a>1.1 数字签名模型</h4><p><strong>数字签名（Digital Signature）也叫作数字指纹（Digital Fingerprint），它是消息摘要算法和非对称加密算法的结合体，能够验证数据的完整性，并且认证数据的来源</strong>。</p><p>数据签名算法的模型分为两个主要阶段：</p><ul><li><strong>1、签名：</strong> 先计算数据的 [摘要]，再使用私钥对 [摘要] 进行加密生成 [签名]，将 [数据 + 签名] 一并发送给接收方；</li><li><strong>2、验证：</strong> 先使用相同的摘要算法计算接收数据的 [摘要]，再使用预先得到的公钥解密 [签名]，对比 [解密的签名] 和 [计算的摘要] 是否一致。若一致，则说明数据没有被篡改。</li></ul><p>需要注意的是，Android 目前不对应用证书进行 CA 认证，应用可以由第三方（OEM、运营商、其他应用市场）签名，也可以自行签名。</p><h4 id="1-2-为什么要给应用签名？"><a href="#1-2-为什么要给应用签名？" class="headerlink" title="1.2 为什么要给应用签名？"></a>1.2 为什么要给应用签名？</h4><p>应用 APK 其实是一种特殊的 Zip 压缩包，无法避免恶意破解者解压 &#x2F; 反编译修改内容，针对这个问题有何解决方案呢？他山之石，可以攻玉 ——数字签名算法。应用签名正是数字签名算法的应用场景之一，与其他应用场景类似，目的无非是：</p><ul><li><strong>认证</strong></li></ul><p>Android 平台上运行的每个应用都必须有开发者的签名。在安装应用时，软件包管理器会验证 APK 是否已经过适当签名，安装程序会拒绝没有获得签名就尝试安装的应用。</p><ul><li><strong>验证完整性</strong></li></ul><p>软件包管理器在安装应用前会验证应用摘要，如果破解者修改了 apk 里的内容，那么摘要就不再匹配，验证失败（验证流程见下文方案）。</p><blockquote><p><strong>提示：</strong> 使用数字签名的优点是验证过程无须复杂的接口和权限，只需要在本机验证。</p></blockquote><h4 id="1-3-应用签名方案演进"><a href="#1-3-应用签名方案演进" class="headerlink" title="1.3 应用签名方案演进"></a>1.3 应用签名方案演进</h4><p>截止至 Android 11，Android 支持以下三种应用签名方案：</p><ul><li>v1 签名方案：基于 Jar 签名；</li><li>v2 签名方案：提高验证速度和覆盖度（在 Android 7.0 Nougat 中引入）；</li><li>v3 签名方案：实现密钥轮转（在 Android 9.0 Pie 中引入）。</li></ul><p>为了提高兼容性，必须按照 v1、v2、v3 的先后顺序采用签名方案，低版本平台会忽略高版本的签名方案在 APK 中添加的额外数据。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1df46bdecd74f44ab1046b7a17544a4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><p>引用自 <a href="https://link.juejin.cn/?target=https://source.android.com/security/apksigning/v2">source.android.com&#x2F;security&#x2F;ap…</a> —— Android Developers</p><hr><h1 id="2-签名方案-v1"><a href="#2-签名方案-v1" class="headerlink" title="2. 签名方案 v1"></a>2. 签名方案 v1</h1><p>v1 签名方案是基于 Jar 的签名。</p><h4 id="2-1-签名产物"><a href="#2-1-签名产物" class="headerlink" title="2.1 签名产物"></a>2.1 签名产物</h4><p>首先，我们先来分析其签名产物。<strong>v1 签名后会增加 META-INF 文件夹</strong>，其中会有如下三个文件。考虑到使用不同的证书和签名方式，得到的文件名可能不同，因此你只要留意文件的后缀即可：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">META-INF</span><br><span class="line">├── MANIFEST<span class="selector-class">.MF</span></span><br><span class="line">├── CERT<span class="selector-class">.SF</span></span><br><span class="line">├── CERT<span class="selector-class">.RSA</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><table><thead><tr><th>文件</th><th>描述</th></tr></thead><tbody><tr><td><strong>MANIFEST.MF</strong></td><td>记录「apk 中每一个文件对应的摘要」（除了 META-INF 文件夹）</td></tr><tr><td>***.SF**</td><td>记录「MANIFEST.MF 文件的摘要」和「MANIFEST.MF 中每个数据块的摘要」</td></tr><tr><td>***.RSA**</td><td>包含了「*.SF 文件的签名」和「包含公钥的开发者证书」</td></tr></tbody></table><blockquote><p><strong>提示：</strong> 如果 apk 中文件数很多，而且文件名很长，那么 <strong>MANIFEST.MF</strong> 和 ***.SF** 两个文件会变得很大。有没有办法优化呢？见 <strong>第 5.1 节 优化摘要记录文件大小</strong>。</p></blockquote><h4 id="2-2-签名流程"><a href="#2-2-签名流程" class="headerlink" title="2.2 签名流程"></a>2.2 签名流程</h4><p>v1 签名流程如下：</p><ul><li>1、计算每个文件的 SHA-1 摘要，进行 BASE64 编码后写入 MANIFEST.MF 文件；</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MANIFEST.MF（Message <span class="keyword">Digest </span>File，摘要文件）</span><br><span class="line">Manifest-Version: <span class="number">1</span>.<span class="number">0</span></span><br><span class="line"><span class="keyword">Built-By: </span>Generated-<span class="keyword">by-ADT</span></span><br><span class="line"><span class="keyword"></span>Created-<span class="keyword">By: </span><span class="keyword">Android </span>Gradle <span class="number">3</span>.<span class="number">1</span>.<span class="number">0</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">Name:</span> <span class="keyword">AndroidManifest.xml</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">SHA1-Digest: </span><span class="number">9</span>hTSmRfzHEeQc7V2wxBbTT3DmCY= 【文件的摘要】</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>2、计算整个 MANIFEST.MF 文件的 SHA-1 摘要，进行 BASE64 编码后写入 *.SF 文件；</li><li>3、计算 MANIFEST.MF 文件中每一块摘要的 SHA-1 摘要，进行 BASE64 编码后写入 *.SF 文件；</li></ul><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\*.SF（Signature File，签名文件）</span><br><span class="line"><span class="attribute">Signature-Version</span>: 1.0</span><br><span class="line"><span class="attribute">Created-By</span>: 1.0 (Android)</span><br><span class="line"><span class="attribute">SHA1-Digest-Manifest</span>: MJQyZ0dc4dv7G9nlJPAMQLwEwbU= 【MANIFEST.MF 文件的摘要】</span><br><span class="line"><span class="attribute">X-Android-APK-Signed</span>: 2</span><br><span class="line"></span><br><span class="line"><span class="attribute">Name</span>: AndroidManifest.xml</span><br><span class="line"><span class="attribute">SHA1-Digest</span>: IJioMmfD693T4qnUJcPKhq9woHQ= 【摘要的摘要】</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>4、计算整个 *.SF 文件的数字签名（先摘要再私钥加密）；</li><li>5、将数字签名和 X.509 开发者数字证书（公钥）写入 *.RSA 文件。</li></ul><blockquote><p><strong>提示：</strong>*.RSA 文件加密了，需要使用 openssl 工具打开。</p></blockquote><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61256c2282f14bc19fa96b3af6010a4c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><p>引用自 <a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/108034286">zhuanlan.zhihu.com&#x2F;p&#x2F;108034286</a> —— 木质的旋律 著</p><h4 id="2-3-验证流程"><a href="#2-3-验证流程" class="headerlink" title="2.3 验证流程"></a>2.3 验证流程</h4><p>验证流程可以分为验证签名和验证完整性两个步骤：</p><p>验证签名步骤：</p><ul><li>1、取出 *.RSA 中包含的开发者证书；</li><li>2、【注意：这里不向 CA 认证开发者证书合法性】；</li><li>3、用证书中的公钥解密 *.RSA 中包含的签名，得到摘要；</li><li>4、计算 *.SF 的摘要；</li><li>5、对比 (3) 和 (4) 的摘要是否一致；</li></ul><p>如果上述签名验证结果正确，才会验证完整性：</p><ul><li>1、计算 MANIFEST.MF 的摘要；</li><li>2、对比 *.SF 记录中的文件摘要和 (1) 的摘要是否一致；</li><li>3、如果一致，再用 MANIFEST.MF 中的每一块数据去校验每一个文件是否被修改。</li></ul><p>以上任何步骤验证失败，则整个 APK 验证失败。</p><h4 id="2-4-存在的问题"><a href="#2-4-存在的问题" class="headerlink" title="2.4 存在的问题"></a>2.4 存在的问题</h4><ul><li><strong>完整性覆盖范围不足</strong>：Zip 文件中部分内容不在验证范围，例如 META-INF 文件夹；</li><li><strong>验证速度较差</strong>：验证程序必须解压所有压缩的条目，这需要花费更多时间和内存。</li></ul><p>为了解决这些问题，Android 7.0 中引入了 APK 签名方案 v2。</p><hr><h1 id="3-签名方案-v2"><a href="#3-签名方案-v2" class="headerlink" title="3. 签名方案 v2"></a>3. 签名方案 v2</h1><p>v2 签名方案是一种 <strong>全文件签名方案</strong>，该方案能够发现对 APK 的受保护部分进行的所有更改，相对于 v1 签名方案验证速度更快，完整性覆盖范围更广。</p><blockquote><p><strong>提示：</strong> 为了兼容低版本，使用 v2 签名方案的同时，还需要使用 v1 签名方案。</p></blockquote><h4 id="3-1-Zip-文件简介"><a href="#3-1-Zip-文件简介" class="headerlink" title="3.1 Zip 文件简介"></a>3.1 Zip 文件简介</h4><p>在分析 v2 签名方案之前，我们先简单了解一下 Zip 文件格式：</p><ul><li>Zip 文件主体结构分为三个部分：<strong>「条目内容区」&amp;「中央目录区」&amp;「中央目录结尾区（EoCD）」</strong>。</li><li>EoCD 中记录了中央目录的起始位置，<strong>在「条目内容区」和「中央目录区」之间插入了其他数据不会影响 Zip 解压。</strong></li></ul><h4 id="3-2-签名产物"><a href="#3-2-签名产物" class="headerlink" title="3.2 签名产物"></a>3.2 签名产物</h4><p>首先，我们先来分析其签名产物。v2 签名后会在 <strong>「条目内容区」和「中央目录区」之间插入「APK 签名分块（APK Signing Block）」</strong>。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94f99b9849394e89b90d9228c38f85b1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><p>引用自 <a href="https://link.juejin.cn/?target=https://source.android.com/security/apksigning/v2">source.android.com&#x2F;security&#x2F;ap…</a> —— Android Developers</p><p>从左到右边，我们定义为区块 1~4。</p><h4 id="3-2-签名流程"><a href="#3-2-签名流程" class="headerlink" title="3.2 签名流程"></a>3.2 签名流程</h4><p>相对与 v1 签名方案，v2 签名方案不再以文件为单位计算摘要了，而是以 1 MB 为单位将文件拆分为多个连续的块（chunk），每个分区的最后一个块可能会小于 1 MB。</p><p>v2 签名流程如下：</p><ul><li>1、对区块 1、3、4，按照 1MB 大小分割为多个块（chunk）；</li><li>2、计算每个块的摘要；</li><li>3、计算 (2) 中所有摘要的签名。</li><li>4、添加 X.509 开发者数字证书（公钥）</li></ul><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89e90a7220234852acca987092185f1c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><p>引用自 <a href="https://link.juejin.cn/?target=https://source.android.com/security/apksigning/v2">source.android.com&#x2F;security&#x2F;ap…</a> —— Android Developers</p><h4 id="3-3-验证流程"><a href="#3-3-验证流程" class="headerlink" title="3.3 验证流程"></a>3.3 验证流程</h4><p>验证流程可以分为验证签名和验证完整性两个步骤：</p><ul><li>验证签名步骤：用公钥验证区块 2 的签名；</li><li>验证完整性步骤：用「APK数据摘要集」验证每一块数据的摘要。</li></ul><hr><h1 id="4-签名方案-v3"><a href="#4-签名方案-v3" class="headerlink" title="4. 签名方案 v3"></a>4. 签名方案 v3</h1><p>签名方案 v3 支持密钥轮换，应用能够在 APK 更新过程中更改其签名密钥。</p><p>【累了，后面先不写了…】</p><hr><h1 id="5-衍生应用场景"><a href="#5-衍生应用场景" class="headerlink" title="5. 衍生应用场景"></a>5. 衍生应用场景</h1><p>这一节，我们介绍基于 Android 应用签名机制的衍生应用场景。</p><h4 id="5-1-优化摘要记录文件大小"><a href="#5-1-优化摘要记录文件大小" class="headerlink" title="5.1 优化摘要记录文件大小"></a>5.1 优化摘要记录文件大小</h4><p>在 v1 方案中，<strong>MANIFEST.MF</strong> 和 ***.SF** 这两个文件会记录大量的文件名和文件摘要。如果 apk 中文件数很多，而且文件名很长，那么这两个文件会变得很大。使用 AndResGuard 工具，可以将文件名转换为短路径文件名，从而减少这两个文件的大小。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49fa8101870b4bb8b70b80d83a7a89c9~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><p>引用自 <a href="https://link.juejin.cn/?target=https://time.geekbang.org/column/article/81483">time.geekbang.org&#x2F;column&#x2F;arti…</a> —— 张绍文 著</p><h4 id="5-2-多渠道打包方案"><a href="#5-2-多渠道打包方案" class="headerlink" title="5.2 多渠道打包方案"></a>5.2 多渠道打包方案</h4><p>在实际生产中，往往需要生成多个渠道的 APK 包，传统的方法是使用 APKTool 逆向工具、Flavor + BuildType 等方案，这一类多渠道打包方案的缺点是耗时严重。随着 Android 应用签名方案的演进，演变出了不同的多渠道打包方案：</p><h4 id="v1-方案时代下的多渠道打包"><a href="#v1-方案时代下的多渠道打包" class="headerlink" title="v1 方案时代下的多渠道打包"></a>v1 方案时代下的多渠道打包</h4><ul><li>添加空文件</li></ul><p>在 v1 方案中，我们提到了完整性校验不覆盖到 META-INF 文件夹的问题。有些多渠道打包方案就是利用了这个问题，在 META-INF 文件夹下添加空文件，<strong>用空文件的名称来作为渠道的唯一标识</strong>，就可以节省打包的时间，提高打渠道包的速度。</p><ul><li>Zip Comment</li></ul><p>除了添加空文件的方法，还可以向 APK 添加 Zip Comment 来生成多渠道包（APK 本身就是特殊的 Zip 包）。</p><h4 id="v2-方案时代下的多渠道打包"><a href="#v2-方案时代下的多渠道打包" class="headerlink" title="v2 方案时代下的多渠道打包"></a>v2 方案时代下的多渠道打包</h4><p>在 v2 签名方案中，几乎整个 APK 都纳入保护范围，如果向 APK 添加空文件或 Zip Comment 的话，在安装时会报以下错误：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Failure [INSTALL_PARSE_FAILED_NO_CERTIFICATES: </span><br><span class="line">Failed to collect certificates <span class="keyword">from</span> <span class="keyword">base</span>.apk: META-INF/CERT.SF indicates <span class="keyword">base</span>.apk <span class="keyword">is</span> signed <span class="keyword">using</span> APK Signature Scheme v2, </span><br><span class="line">but no such signature was found. Signature stripped?]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>新背景下的多渠道打包方案，则是利用了 <strong>APK 签名分块（区块 2）不受保护 &amp; 字段可扩展的特点</strong>，向区块中添加多渠道信息（ID-Value），例如 <a href="https://link.juejin.cn/?target=https://github.com/Meituan-Dianping/walle">美团多渠道打包方案 Walle</a>。</p><hr><h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h1><ul><li>签名应用是处于两个目的：认证 &amp; 验证完整性，即：认证 APK 的开发者以及验证 APK 内容是否被篡改。截止到 Android 11，一共有 v1、v2、v3 三种签名方案。</li><li>v1 是基于 Jar 的签名方案，它存在完整性覆盖范围不足 &amp; 验证速度较差两个问题。</li><li>Android 7.0 推出的 v2 签名方案优化了这两个问题，通过「条目内容区」和「中央目录区」之间插入「APK 签名分块（APK Signing Block）」，优化了 v1 方案的两大问题。</li><li>Android 9.0 推出的 v3 方案是 v2 方案的优化版本，满足了密钥轮换的需求。</li></ul><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://link.juejin.cn/?target=https://docs.oracle.com/javase/8/docs/technotes/guides/jar/jar.html%23Signed_JAR_File">《Signed_JAR_File》</a> —— Oracle</li><li><a href="https://link.juejin.cn/?target=https://source.android.com/security/apksigning">《应用签名》</a> —— Android Developers</li><li><a href="https://link.juejin.cn/?target=https://developer.android.google.cn/studio/publish/app-signing">《对应用进行签名》</a> —— Android Developers</li><li><a href="https://link.juejin.cn/?target=https://source.android.com/security/apksigning/v2">《APK 签名方案 v2》</a> —— Android Developers</li><li><a href="https://link.juejin.cn/?target=https://source.android.com/security/apksigning/v3">《APK 签名方案 v3》</a> —— Android Developers</li><li><a href="https://link.juejin.cn/?target=https://weread.qq.com/web/reader/6ef32f805e0b836efa707cbk6f4322302126f4922f45dec">《Android 应用安全防护和逆向分析》</a>（第 12 章）—— 姜维 著</li><li><a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/108034286">《Android 端 V1&#x2F;V2&#x2F;V3 签名的原理》</a> —— 木质的旋律 著（阿里巴巴技术团队）</li><li><a href="https://link.juejin.cn/?target=https://mp.weixin.qq.com/s?__biz=MzI1NjEwMTM4OA==&mid=2651232457&idx=1&sn=90b16c3868a341272b8f1aa26d6c0122&chksm=f1d9e5aac6ae6cbcfaecb07bdd280abf81a46f1937c43f61e69d7f78d64350943356f5443d58&scene=27%23wechat_redirect">《分析Android V2新签名打包机制》</a> —— pisazzpan 著（腾讯音乐技术团队）</li><li><a href="https://link.juejin.cn/?target=https://tech.meituan.com/2017/01/13/android-apk-v2-signature-scheme.html">《新一代开源Android渠道包生成工具Walle》</a> —— 建帅 陈潼 著（美团技术团队）</li><li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903839745720333">《Android V1及V2签名原理简析》</a> —— 看书的蜗牛 著（网易技术团队）</li><li><a href="https://link.juejin.cn/?target=https://tech.meituan.com/2017/04/07/android-shrink-overall-solution.html">《Android App包瘦身优化实践》</a> —— 建帅 著（美团技术团队）</li><li><a href="https://link.juejin.cn/?target=https://time.geekbang.org/column/article/81483">《Android 开发高手课 · 包体积优化（下）》</a> —— 张绍文 著（微信技术团队），极客时间 出品</li><li>《深入理解 Android 内核设计思想》（第 20 章） —— 林学森 著</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/12/05/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6(%E4%B8%80)/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/12/05/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6(%E4%B8%80)/" class="post-title-link" itemprop="url">程序员的自我修养读书笔记-第3章 目标文件(一)</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-12-05 15:49:36" itemprop="dateCreated datePublished" datetime="2022-12-05T15:49:36+08:00">2022-12-05</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-12-19 08:51:31" itemprop="dateModified" datetime="2022-12-19T08:51:31+08:00">2022-12-19</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/NDK/" itemprop="url" rel="index"><span itemprop="name">NDK</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>编译器编译源代码后生成的文件叫做目标文件。</p><p>目标文件从结构上讲，这是已经编译后的<strong>可执行文件格式</strong>，<strong>只是还没有经过链接的过程</strong>，其中可能有些符号或有些地址还没有被调整。其实它本身就是按照<strong>可执行文件格式</strong>存储的，只是跟真正的可执行文件在结构上稍有不同。</p><p>可执行文件格式涵盖了程序的编译、链接、装载和执行的各个方面。了解它的结构并深入剖析它对于认识系统、了解背后的机理大有好处。</p><h2 id="目标文件的格式"><a href="#目标文件的格式" class="headerlink" title="目标文件的格式"></a>目标文件的格式</h2><p>现在PC平台流行的可执行文件格式主要是windows下的PE和Linux的ELF，它们都是COFF格式的变种。目标文件 就是源代码编译后未进行链接的那些<strong>中间文件</strong>，它跟可执行文件的内容与结构很相似，所以一般可执行文件格式一起采用一种格式存储。从广义上看，目标文件与可执行文件的格式其实几乎是一样的，所以我们可以广义地将目标文件与可执行文件看成是一种类型的文件。</p><p>不光是可执行文件按照可执行文件格式存储。动态链接库及静态链接库文件都是按照可执行文件格式存储。静态链接库稍有不同，它是把很多目标文件捆绑在一起形成一个文件，再加上一些索引，你可以简单地把它理解为一个包含有很多目标文件的文件包。</p><table><thead><tr><th>ELF文件类型</th><th>说明</th><th>实例</th></tr></thead><tbody><tr><td>可重定位文件(Relocatable File)</td><td>这类文件包含了代码和数据，可以被用来链接成可执行文件或共享目标文件，静态库也可以归为这一类</td><td>Linux的.o</td></tr><tr><td>可执行文件(Executable File)</td><td>这类文件包含了可以直接执行的程序，它的代表就是ELF可执行文，它们一般都没有扩展名</td><td>比如&#x2F;bin&#x2F;bash文件</td></tr><tr><td>共享目标文件(shared object file)</td><td>这种文件包含了代码和数据，可以在以下两种情况下使用。第一种是链接器可以全名用这种文件跟其他的可重定位文件和共享目标文件链接，产生新的目标文件。第二种是动态链接器可以将几种这种共享目标文件与可执行文件结合，作为进程映像的一部分来运行。</td><td>Linux的.so</td></tr></tbody></table><p><code>file foobar.o</code></p><p>查看相应的文件格式</p><h2 id="目标文件是什么样的"><a href="#目标文件是什么样的" class="headerlink" title="目标文件是什么样的"></a>目标文件是什么样的</h2><p>程序源代码编译后的<strong>机器指令</strong>经常被放在<strong>代码段</strong>里，代码段常见的名字有**.code<strong>和</strong>.text** ，<strong>全局变量</strong>和<strong>局部静态变量数</strong>据经常放在<strong>数据段</strong>，数据段的一般名字都叫**.data**</p><img src="../images/image-20221208132834056.png" alt="image-20221208132834056" style="zoom:50%"><ul><li>ELF文件的开头是一个“文件头”，它描述了整个文件的文件属性，包括文件是否可执行、是静态链接还是动态链接及入口地址（如果可执行文件）、目标硬件、目标操作系统等信息，文件头还有一个<strong>段表</strong></li><li><strong>段表</strong>是一个<strong>描述</strong>文件中各个段的<strong>数组</strong>。描述了文件中各个段在文件中的<strong>偏移位置</strong>及段的<strong>属性</strong>，从段表里面可以得到每个段的所有信息。文件头后面就是各个段的内容，代码段保存的是程序的指令，数据段保存的是程序的静态变量。</li><li>编译后的语句编译成机器代码，保存在.text段</li><li>已初始化的全局变量和局部静态变量保存在.data段</li><li>未初始化的全局变量和局部静态变量一般放在.bss段，未初始化的默认值都为0，放在.bss段，在文件中不占据空间。</li></ul><blockquote><p>总体来说，程序源代码被编译以后主要分成两种段：程序指令和程序数据。代码段属于程序指令，而数据段和.bss段属于程序数据。</p></blockquote><h2 id="挖掘SimpleSection-o"><a href="#挖掘SimpleSection-o" class="headerlink" title="挖掘SimpleSection.o"></a>挖掘SimpleSection.o</h2><p>SimpleSection.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> global_inti_var = <span class="number">84</span>;</span><br><span class="line"><span class="keyword">int</span>  global_unint_var;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> static_var = <span class="number">85</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> static_var2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	func1(a + b + static_var + static_var2 );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>参数-c 表示只编译不链接</strong></p><p><code>gcc -c SimpleSection.c</code></p><p>得到SimpleSection.o目标文件</p><p><code>objdump -h SimpleSection.o</code></p><p><img src="/../images/image-20221208135133311.png" alt="image-20221208135133311"></p><p>.comment 注释信息段</p><p>.note.gnu-stack 堆栈提示段</p><p>横向看</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Size</td><td>段的长度</td></tr><tr><td>File Offset</td><td>段所在的位置</td></tr><tr><td>CONTENTS</td><td>表示该段在文件中存在</td></tr><tr><td>ALLOC</td><td>该段具有某种属性</td></tr><tr><td>LOAD</td><td>该段具有某种属性</td></tr><tr><td>RELOC</td><td>该段具有某种属性</td></tr><tr><td>READONLY</td><td>该段具有某种属性</td></tr><tr><td>CODE</td><td>该段具有某种属性</td></tr><tr><td>DATA</td><td>该段具有某种属性</td></tr></tbody></table><p>size SimpleSection.o 查看ELF文件的代码段、数据段和BSS段的长度（dec表示3个段长度和的十进制，hex表示长充和的十六进制）</p><p><img src="/../images/image-20221208140242825.png" alt="image-20221208140242825"></p><p><img src="/../images/image-20221208145813757.png" alt="image-20221208145813757"></p><p>用size看的text的长度还包含的.note.gnu.property和.eh_frame的长度，刚好加起来是189</p><h3 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h3><p>objdump</p><ul><li><p>-s 参数可以将所有段的内容以十六进制的方式打印出来</p></li><li><p>-d 参数可以将所有的包含指令的段反汇编</p></li></ul><p><code>objdump -s -d SimpleSection.o</code></p><p><img src="/../images/image-20221208150615895.png" alt="image-20221208150615895"></p><p>Contents of section .text 就是.text的数据以十六进制方式打印出来的内容，总共0x45字节，跟 .text段的长度符合，左边是偏移量，中间4例是十六进制内容，最后面是.text段的ASCII码。</p><p>下面是反汇编结果 -d 可以看到 .text段里，包含的就是SimpeSection.c里两个函数func1和main的指令。左面已经把各条指令分别对应的汇编指令输出来了。</p><h3 id="数据段和只读数据段"><a href="#数据段和只读数据段" class="headerlink" title="数据段和只读数据段"></a>数据段和只读数据段</h3><p>如果我们在代码里加入一句话printf</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global_inti_var = <span class="number">84</span>;</span><br><span class="line"><span class="keyword">int</span>  global_unint_var;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> static_var = <span class="number">85</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> static_var2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	func1(a + b + static_var + static_var2 );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为用到了一个字符串常量 %d\n，是一种只读数据，所以会放在.rodata段，我们再来用</p><p><code>objdump -h SimpleSection.o</code></p><p><img src="/../images/image-20221208152110539.png" alt="image-20221208152110539"></p><ul><li>.data段保存的是那些已经<strong>初始化了的全局变量和局闻静态变量</strong>。SimpleSection.c中一个是global_inti_var和static_var这两个变量每个4个字节，刚好是8个字节，所以.data这个段的大小为8个字节。</li></ul><p><code>objdump -s SimpleSection.o</code></p><p><img src="/../images/image-20221208153039103.png" alt="image-20221208153039103"></p><ul><li>printf里用了一个字符串常量“%d\n” 是一个只读数据，这4个字节刚好是这个字符常量 的ASCII字节充，最后以\0x结尾，放在.rodata段，.rodata段存放的是只读数据，一般是程序里面的只读变量（如const修饰的变量）和字符串常量。</li></ul><p><code>objdump -x -s -d SimpleSection.o</code></p><ul><li>-x 输出<strong>文件体系结构</strong> <strong>文件格式</strong> <strong>节信息</strong> <strong>符号表</strong></li><li>-s 参数可以将所有段的内容以十六进制的方式打印出来</li><li>-d 参数可以将所有的包含指令的段反汇编</li></ul><p><img src="/../images/image-20221208153832399.png" alt="image-20221208153832399"></p><p>我们重点是验证前面.data的结论</p><p><img src="/../images/image-20221208153904864.png" alt="image-20221208153904864"></p><p>可以看到.data段里前4个字节，从低到高 0x54 0x00 0x00 0x00 刚好是global_init_var 即十进制的84，而最后4个字节刚好是static_init_var 的值即85。</p><blockquote><p>为什么存放次序为0x54 0x00 0x00 0x00而不是 00 00 00 54？</p><p>涉及CPU的字节序问题，即所谓的大端序（Big-endian）和小端序（Little-endian）问题</p></blockquote><h3 id="BSS段"><a href="#BSS段" class="headerlink" title="BSS段"></a>BSS段</h3><p>.bss段放的是未初始化的全局变量和局部静态变量，上述代码中global_uninit_Var和static_var2就是存放在.bss段，其实更准确的说法是.bss段为它们预留了空间</p><p>但我们发现该段只有4字节，和两个变量大小8个字节不符。</p><p>通过符号表看到</p><p><img src="/../images/image-20221208160024230.png" alt="image-20221208160024230"></p><p>确实只有static_var2放在.bss段，而global_uninit_var却没有存放在任何段，跟编译器的实现有关，有的会把<strong>全局未初始化变量</strong>存放在.bss段，有些则不存放，只是一个未定义的全局变量符号 这里是COMMON符号，等最终链接成可执行文件再在.bss段分配空间。可以把.c文件换成.cpp文件再编译，发现放在.bss段，我们现在全当它们放在.bss段。</p><h3 id="其他段"><a href="#其他段" class="headerlink" title="其他段"></a>其他段</h3><p>除了.text .data .bss 3个最常用段之外，还有一些常见的段。</p><table><thead><tr><th>常用的段名</th><th>说明</th></tr></thead><tbody><tr><td>.rodata1</td><td>Read only Data，这种段里存放的是只读数据，比如字符串常量、全局const变量。跟.rodata一样</td></tr><tr><td>.comment</td><td>存放的是编译器版本信息，比如字符串：GCC:(GNU)4.2.0</td></tr><tr><td>.debug</td><td>调试信息</td></tr><tr><td>.dynamic</td><td>动态链接信息</td></tr><tr><td>.hash</td><td>符号哈希表</td></tr><tr><td>.line</td><td>调试时的行号表，即源代码行号与编译后指令的对应表</td></tr><tr><td>.note</td><td>额外的编译器信息。比如程序的公司名、发布版本号等</td></tr><tr><td>.strtab</td><td>String Table 字符串表，用于存储ELF文件中用到的各种字符串</td></tr><tr><td>.symtab</td><td><strong>Symbol Table符号表</strong></td></tr><tr><td>.shstrtab</td><td>Section String Table 段名表</td></tr><tr><td>.plt</td><td>动态链接跳转表和全局入口表</td></tr><tr><td>.got</td><td>动态链接跳转表和全局入口表</td></tr><tr><td>.init</td><td>程序初始化与终结代码段</td></tr><tr><td>.fini</td><td>程序初始化与终结代码段</td></tr></tbody></table><p><strong>这些表的名字是系统保留的</strong>，应用程序也可以使用一些非系统保留的名字作为段名。比如可以在ELF文件中插入一个music的段，里面放一道mp3音乐，当ELF文件运行起来以后可以读取这个段播放mp3。<strong>但是应用程序自定义的段名不能使用.作为前缀，否则容易跟系统保留段名冲突。</strong></p><blockquote><p>怎么把一个图片、MP3音乐一类的东西作为目标文件中的一个段，要怎么做？</p><p><code>objcopy -I binary -O elf64-x86-64 -B i386 awsl12.jpg awsl12.o</code></p><p>把jpg转成.o</p><p><code>objdump -ht awsl12.o</code> 查看目标文件的格式和符号表</p></blockquote><p><img src="/../images/image-20221209093804930.png" alt="image-20221209093804930"></p><p>它有符号 _binary_awsl12_jpg_start _binary_awsl12_jpg_end 和_binary_awsl12_jpg_size 分别表示该图片在内存中的起始地址、结束地址和大小、可以在程序里面直接声明并使用它们。</p><h3 id="自定义段"><a href="#自定义段" class="headerlink" title="自定义段"></a>自定义段</h3><p>通常代码会放在.text段，全局变量和静态变量会放到.data和.bss段，但你可能希望变量或某些部分代码能够放到你所指定的段中去，实现某些特定的功能。比如为了满足某些硬件的内存和IO地址布局</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format,...)</span></span>;</span><br><span class="line"></span><br><span class="line">__attribute__((section(<span class="string">&quot;FOO&quot;</span>))) <span class="keyword">int</span> global_inti_var = <span class="number">84</span>;</span><br><span class="line"><span class="keyword">int</span>  global_unint_var;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__attribute__((section(<span class="string">&quot;BAR&quot;</span>))) <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> static_var = <span class="number">85</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> static_var2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	func1(a + b + static_var + static_var2 );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>添加_<em>attribute</em>_((section(“name”)))属性就可以把相应的变量或函数以“name”作为段名的段中。注意自定义段不是.开头的</p></blockquote><p><img src="/../images/image-20221209094547202.png" alt="image-20221209094547202"></p><h2 id="ELF文件结构描述"><a href="#ELF文件结构描述" class="headerlink" title="ELF文件结构描述"></a>ELF文件结构描述</h2><img src="../images/image-20221209095037002.png" alt="image-20221209095037002" style="zoom:50%"><p>ELF文件中与段关的重要结构就是段表（Section Header Table），该表描述了ELF文件包含的所有段的信息，比如每个段的<strong>段名</strong>、<strong>段的长度</strong>、在文件中的<strong>偏移</strong>、<strong>读写权限</strong>及段的其他属性。</p><h3 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h3><p><code>readelf -h SimpelSection.o</code> 查看ELF文件的文件头</p><p><img src="/../images/image-20221209105004038.png" alt="image-20221209105004038"></p><p>ELF文件头结构及相关常数被定义在 <code>/user/include/elf.h</code>里，ELF文件在各平台下都通用，有32位和64位版本。32和64位版本的ELF文件的文件头内容是一样的，只不过有些成员大小不一样。用<strong>typedef</strong>定义了一套自己的变量体系。</p><table><thead><tr><th>自定义类型</th><th>描述</th><th>原始类型</th><th>长度（字节）</th></tr></thead><tbody><tr><td>Elf64_Addr</td><td>64位版本程序地址</td><td>uint64_t</td><td>8</td></tr><tr><td>Elf64_Half</td><td>..无符号短整形</td><td>uint16_t</td><td>2</td></tr><tr><td>Elf64_Off</td><td>..偏移地址</td><td>uint64_t</td><td>8</td></tr><tr><td>Elf64_Sword</td><td>..有符号整形</td><td>int32_t</td><td>4</td></tr><tr><td>Elf64_Word</td><td>..无符号整形</td><td>uint32_t</td><td>4</td></tr></tbody></table><p>文件头的结构，定义 Elf64_Ehdr 结构体中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_hdr</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>	e_ident[<span class="number">16</span>];	<span class="comment">/* ELF &quot;magic number&quot; */</span></span><br><span class="line">  Elf64_Half e_type;</span><br><span class="line">  Elf64_Half e_machine;</span><br><span class="line">  Elf64_Word e_version;</span><br><span class="line">  Elf64_Addr e_entry;	<span class="comment">/* Entry point virtual address */</span></span><br><span class="line">  Elf64_Off e_phoff;	<span class="comment">/* Program header table file offset */</span></span><br><span class="line">  Elf64_Off e_shoff;	<span class="comment">/* Section header table file offset */</span></span><br><span class="line">  Elf64_Word e_flags;</span><br><span class="line">  Elf64_Half e_ehsize;</span><br><span class="line">  Elf64_Half e_phentsize;</span><br><span class="line">  Elf64_Half e_phnum;</span><br><span class="line">  Elf64_Half e_shentsize;</span><br><span class="line">  Elf64_Half e_shnum;</span><br><span class="line">  Elf64_Half e_shstrndx;</span><br><span class="line">&#125; Elf64_Ehdr;</span><br></pre></td></tr></table></figure><ul><li>e_ident 对应 <strong>类别</strong> &#x2F;<strong>数据</strong>&#x2F; <strong>Version &#x2F;OS&#x2F;ABI</strong>&#x2F; <strong>ABI版本</strong></li></ul><p><img src="/../images/image-20221209110615180.png" alt="image-20221209110615180"></p><p>剩下的参数与Elf64_Ehdr中的成员一一对应</p><ul><li>e_type 类型</li></ul><p><img src="/../images/image-20221209110741748.png" alt="image-20221209110741748"></p><ul><li>e_machine 系统架构</li></ul><p><img src="/../images/image-20221209110824065.png" alt="image-20221209110824065"></p><ul><li>e_version 版本 一般为常数1</li></ul><p><img src="/../images/image-20221209110837646.png" alt="image-20221209110837646"></p><ul><li>e_entry 入口点地址 可重入文件一般没有入口地址，则这个值为0</li></ul><p><img src="/../images/image-20221209110917620.png" alt="image-20221209110917620"></p><ul><li>e_phoff 程序头起点 暂不关系，要看”ELF链接视图和执行视图”</li></ul><p><img src="/../images/image-20221209111116053.png" alt="image-20221209111116053"></p><ul><li>e_shoff 段表在文件中的偏移（ELF文件头会指出段表 Section Header Table在文件中的偏移地址，很重要，通过这个可以找到段表的位置）</li></ul><p><img src="/../images/image-20221209111205539.png" alt="image-20221209111205539"></p><ul><li>e_word 标志位</li></ul><p><img src="/../images/image-20221209111321412.png" alt="image-20221209111321412"></p><ul><li>e_ehsize ELF文件头本身大小这里是64个字节</li></ul><p><img src="/../images/image-20221209111408212.png" alt="image-20221209111408212"></p><ul><li>e_phentsize 看后面ELF链接视图和执行视图一节</li></ul><p><img src="/../images/image-20221209111451191.png" alt="image-20221209111451191"></p><ul><li>e_phnum 看后面ELF链接视图和执行视图一节</li></ul><p><img src="/../images/image-20221209111527639.png" alt="image-20221209111527639"></p><ul><li>e_shentsize 段表描述符的大小 一般等于sizeof(Elf64_Ehdr)</li></ul><p><img src="/../images/image-20221209111625057.png" alt="image-20221209111625057"></p><ul><li>e_shnum 段表描述符数量。这个值等于ELF文件中拥有的段的数量，这里是14</li></ul><p><img src="/../images/image-20221209111715664.png" alt="image-20221209111715664"></p><ul><li>e_shstrndx 段表字符串表所在的段在段表中的下标</li></ul><p><img src="/../images/image-20221209111802059.png" alt="image-20221209111802059"></p><h4 id="ELF魔数"><a href="#ELF魔数" class="headerlink" title="ELF魔数"></a>ELF魔数</h4><p><img src="/../images/image-20221209130235027.png" alt="image-20221209130235027"></p><p>0x7f 0x45 0x4c 0x46 ELF文件的魔数，表示这是一个ELF文件</p><p>0x02 表示是64位的 0x01是32位 0 是无效文件</p><p>0x01 小端序 0x02 大端序 0 无效格式</p><p>0x01 主版本号 一般是1</p><p>后面9个字节 没有定义 一般填0</p><h4 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h4><table><thead><tr><th>常量</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>ET_REL</td><td>1</td><td>可重定位文件，一般为.o文件</td></tr><tr><td>ET_EXEC</td><td>2</td><td>可执行文件</td></tr><tr><td>ET_DYN</td><td>3</td><td>共享目标文件，一般为.so文件</td></tr></tbody></table><h3 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h3><p>Section Header Table 段表是保存这些段的基本属性的结构。ELF文件的段结构就是由段表决定的，每个段的段名、段的长度、在文件中的偏移、读写权限及段的其他属性。</p><blockquote><p>编译器、链接器和装载器都是依靠段表来定位和访问各个段的属性的。</p></blockquote><p>段表在ELF文件中位置由e_shoff成员决定。</p><p>objdump -h 命令只是把ELF文件中的关键段显示出来，省略了其他的辅助性的段，比如符号表、字符串表、段名字符串表、重定位表等。</p><p>用readelf来看ELF的真正段表结构：</p><p><code>readelf -S SimpleSection.o</code></p><p><img src="/../images/image-20221209131413041.png" alt="image-20221209131413041"></p><p>段表的结构体为<strong>Elf64_Shdr</strong>的数组，数组元素为段的个数，每个shdr结构体对应一个段。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_shdr</span> &#123;</span></span><br><span class="line">  Elf64_Word sh_name;	<span class="comment">/* Section name, index in string tbl */</span></span><br><span class="line">  Elf64_Word sh_type;	<span class="comment">/* Type of section */</span></span><br><span class="line">  Elf64_Xword sh_flags;	<span class="comment">/* Miscellaneous section attributes */</span></span><br><span class="line">  Elf64_Addr sh_addr;	<span class="comment">/* Section virtual addr at execution */</span></span><br><span class="line">  Elf64_Off sh_offset;	<span class="comment">/* Section file offset */</span></span><br><span class="line">  Elf64_Xword sh_size;	<span class="comment">/* Size of section in bytes */</span></span><br><span class="line">  Elf64_Word sh_link;	<span class="comment">/* Index of another section */</span></span><br><span class="line">  Elf64_Word sh_info;	<span class="comment">/* Additional section information */</span></span><br><span class="line">  Elf64_Xword sh_addralign;	<span class="comment">/* Section alignment */</span></span><br><span class="line">  Elf64_Xword sh_entsize;	<span class="comment">/* Entry size if section holds table */</span></span><br><span class="line">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure><p>段表是有14个元素的数组，第一个元素是无效的，类型为NULL，共有13个有效的段</p><table><thead><tr><th>成员</th><th>描述</th></tr></thead><tbody><tr><td>sh_name</td><td>Section name 段名<br>段名是字符串，它位于一个叫做.shstrtab的字符串表。sh_name是段名字符串在.shstrtab中的偏移</td></tr><tr><td>sh_type</td><td>Section type 段的类型</td></tr><tr><td>sh_flags</td><td>Section flag 段的标志位</td></tr><tr><td>sh_addr</td><td>Section Address 段虚拟地址<br>如果该段可以被加载，则sh_addr为该段被加载后在进程地址空间中的虚拟地址；否则sh_addr为0</td></tr><tr><td>sh_offset</td><td>Section Offset 段偏移<br>如果该段存在于文件中，则表示该段在文件中的偏移；否则无意义。比如sh_offset对于BSS段来说就没有意义</td></tr><tr><td>sh_size</td><td>Section Size 段的长度</td></tr><tr><td>sh_link和<br>sh_info</td><td>Section Link and Section Information段链接信息</td></tr><tr><td>sh_addralign</td><td>段地址对齐</td></tr><tr><td>sh_entsize</td><td>Section Entry Size项的长度<br>有些段包含固定大小的项，比如符号表它包含的每个符号所占的大小都一样的。表示每个项的大小，如果为0，则表示该段不包含固定大小的项</td></tr></tbody></table><blockquote><p>readelf -S 的输出结果从第二列名称开始的每一列，对应于结构体中的每个成员</p></blockquote><h4 id="段的类型"><a href="#段的类型" class="headerlink" title="段的类型"></a>段的类型</h4><p>段的名字只是链接和编译过程有意义，不能真正地表示段的类型。我们可以将一个数据段命名为.text 决定段的属性的是段的类型sh_type和段的标志位sh_flags</p><img src="../images/image-20221209185728928.png" alt="image-20221209185728928" style="zoom:50%"><p>以SHT_开头</p><table><thead><tr><th>常量</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>SHT_NULL</td><td>0</td><td>无效段</td></tr><tr><td>SHT_PROGBITS</td><td>1</td><td>程序段，代码段，数据段都是这种类型的</td></tr><tr><td>SHT_SYMTAB</td><td>2</td><td>表示该段的内容为符号表</td></tr><tr><td>SHT_STRTAB</td><td>3</td><td>表示该段的内容为字符串表</td></tr><tr><td>SHT_RELA</td><td>4</td><td>重定位表。该段包含了重定位信息</td></tr><tr><td>SHT_HASH</td><td>5</td><td>符号表的哈希表</td></tr><tr><td>SHT_DYNAMIC</td><td>6</td><td>动态链接信息</td></tr><tr><td>SHT_NOTE</td><td>7</td><td>提示性信息</td></tr><tr><td>SHT_NOBITS</td><td>8</td><td>表示该段在文件中没内容</td></tr><tr><td>SHT_REL</td><td>9</td><td>该段包含了重定位信息</td></tr><tr><td>SHT_SHLIB</td><td>10</td><td>保留</td></tr><tr><td>SHT_DNYSYM</td><td>11</td><td>动态链接的符号表</td></tr></tbody></table><h4 id="段的标志位"><a href="#段的标志位" class="headerlink" title="段的标志位"></a>段的标志位</h4><p>是否可写，是否可执行，以SHF_开头</p><table><thead><tr><th>常量</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>SHF_WRITE</td><td>1</td><td>表示该段在进程空间中可写</td></tr><tr><td>SHF_ALLOC</td><td>2</td><td>表示该段在进程空间中须要分配空间。有些包含指示或控制信息的段不需要在进程空间中被分配空间，它们一般不会有这个标志。像代码段、数据段和.bss段都会有这个标志位</td></tr><tr><td>SHF_EXECINSTR</td><td>4</td><td>表示该段在进程空间中可以被执行，一般指代码段</td></tr></tbody></table><h4 id="段的链接信息（sh-link、sh-info）"><a href="#段的链接信息（sh-link、sh-info）" class="headerlink" title="段的链接信息（sh_link、sh_info）"></a>段的链接信息（sh_link、sh_info）</h4><p>如果段的类型是与链接相关的（不论是动态链接或静态链接），比如重定位表、符号表等，那么sh_link和sh_info这两个成员所包含的意义如下，对于其他类型的段，这两个成员没有意义。</p><p>链接信息要配合着sh_type一起看的</p><table><thead><tr><th>sh_type</th><th>sh_link</th><th>sh_info</th></tr></thead><tbody><tr><td>SHT_DYNAMIC</td><td>该段所使用的字符串表在段表中的下标</td><td>0</td></tr><tr><td>SHT_HASH</td><td>该段所使用的符号表在段表中的下标</td><td>0</td></tr><tr><td>SHT_REL<br>SHT_RELA</td><td>该段所使用的相应符号表在段表中的下标</td><td>该重定位表所作用的段在段表中的下标</td></tr><tr><td>SHT_SYMTAB<br>SHT_DYNSYM</td><td>操作系统相关的</td><td>操作系统相关的</td></tr><tr><td>other</td><td>SHN_UNDEF</td><td>0</td></tr></tbody></table><p>比如</p><p><img src="/../images/image-20221210062408633.png" alt="image-20221210062408633"></p><h3 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h3><p>SimpleSection.o有一个叫 .rel.text的段，类型是SHT_RELA 也就是说它是一个重定位表。正如我们前面所说的，链接器在处理目标文件时，需要对目标文件中某些部位进行重定位，即代码段和数据段中那些对绝对地址的引用的位置。这些重定位的信息都记录在ELF文件的重定位表里面，对于每个需要重定位的代码段或数据段，都会有一个相应的重定位表。比如SimpleSection.o中的.rel.text就是针对.text段的重定位表，因为.text段中至少有一个绝对地址的引用，那就是对printf函数的调用；而.data段则没有对绝对地址的引用，它只包含了几个常量，所以没有针对.data段的重定位表.rel.data</p><p>一个重定位表同时也是ELF的一个段，那么这个段的类型sh_type就是SHT_RELA类型的</p><ul><li>sh_link：表示符号表的下标，这里是11 也就是.symtab</li><li>sh_info：表示它作用于哪个段，比如这里是1就是.text段</li></ul><h3 id="字符串表"><a href="#字符串表" class="headerlink" title="字符串表"></a>字符串表</h3><p>ELF文件中用到很多字符串，比如段名、变量名等。因为字符串的长度往往是不定的，所以用固定的结构来表示它比较困难。一种很常见的做法是把字符串集中起来存放到一个表，然后使用字符串在表中的偏移来引用字符串。</p><table><thead><tr><th>偏移</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>0</td><td>\0</td><td>h</td><td>e</td><td>l</td><td>l</td><td>o</td><td>w</td><td>o</td><td>r</td><td>l</td></tr><tr><td>10</td><td>d</td><td>\0</td><td>M</td><td>y</td><td>v</td><td>a</td><td>r</td><td>i</td><td>a</td><td>b</td></tr><tr><td>20</td><td>l</td><td>e</td><td>\0</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>那么偏移与它们对应的字符串如下</p><table><thead><tr><th>偏移</th><th>字符串</th></tr></thead><tbody><tr><td>0</td><td>空字符串</td></tr><tr><td>1</td><td>helloworld</td></tr><tr><td>6</td><td>world</td></tr><tr><td>12</td><td>Myvariable</td></tr></tbody></table><p>通过这种方法，在ELF文件中引用字符串只需要给出一个数字下标即可，不用考虑字符串长度的问题。一般字符串表在ELF文件中也以段的形式保存，常见的段名为.strtab或.shstrtab 这两个字符串表分别为<strong>字符串表</strong>和<strong>段表字符串表</strong>。顾名思义，<strong>字符串表</strong>用来保存普通的字符串，比如<strong>符号的名字</strong>；<strong>段表字符串表</strong>用来保存段表中用到的字符串，最常见的就是<strong>段名</strong>(sh_name)</p><p>回头看ELF文件头e_shstrndx含义，是ELF64_Ehdr的最后一个成员，它是Section header string table index的缩写。段表字符串表本身也是ELF文件中的一个普通的段，它的名字是.shstrtab。那么这个e_shstrndx就是.shstrtab在段表中的下标。</p><p><img src="/../images/image-20221210065104164.png" alt="image-20221210065104164"></p><p>readelf -S SimpleSection.o 看一下，确实是13</p><p><img src="/../images/image-20221210065115607.png" alt="image-20221210065115607"></p><p>只有分析ELF文件头，就可以得到段表和段表字符串表的位置，从而解析整个ELF文件。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/12/05/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E7%AB%A0-%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/12/05/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E7%AB%A0-%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5/" class="post-title-link" itemprop="url">程序员的自我修养读书笔记-第2章 编译和链接</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-12-05 11:04:38" itemprop="dateCreated datePublished" datetime="2022-12-05T11:04:38+08:00">2022-12-05</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-12-19 08:51:31" itemprop="dateModified" datetime="2022-12-19T08:51:31+08:00">2022-12-19</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/NDK/" itemprop="url" rel="index"><span itemprop="name">NDK</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><img src="../images/image-20221205142824934.png" alt="image-20221205142824934" style="zoom:50%"><h2 id="被隐藏了的过程"><a href="#被隐藏了的过程" class="headerlink" title="被隐藏了的过程"></a>被隐藏了的过程</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以直接执行</p><p>gcc hello.c 生成a.out</p><p>.&#x2F;a.out</p><p>Hello World</p><h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><p>预编译后的文件扩展名是.i</p><p><code>gcc -E hello.c -o hello.i</code></p><p>生成hello.i文件</p><p>预编译过程主要处理那些源代码文件中的以“#”开始的预编译指令。比如#include、#define等</p><p>经过预编译后的.i文件不包含任何宏定义，因为所有的宏已经被展开，并且包含的文件已经被插入到.i文件中。<strong>所以当我们无法判断宏定义是否正确或头文件是否正确时，可以查看预编译后的文件来确定问题。</strong></p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>把预处理完的文件进行一系列<strong>词法分析</strong>、<strong>语法分析</strong>、<strong>语义分析</strong>及<strong>优化</strong>后生产相应的<strong>汇编代码</strong>文件，是整个程序构建的核心部分，最复杂部分之一。</p><p>gcc -S hello.i -o hello.s</p><p>gcc -S hello.c -o hello.s</p><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>将汇编代码转变成机器指令。只是根据汇编指令和机器指令的对照表一一翻译就可以</p><p>as hello.s -o hello.o</p><p>gcc -c hello.s -o hello.o</p><p>gcc -c hello.c -o hello.o</p><p>经过预编译、编译和汇编直接输出<strong>目标文件</strong></p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ul><li>1.为什么汇编器不直接输出可执行文件而是输出一个<strong>目标文件</strong>？</li><li>2.为什么要链接？</li></ul><p>我们需要将一大堆文件 crtlo crti.o … hello.o 链接起来才可以得到a.out 即最终的可执行文件。</p><h2 id="编译器做了什么"><a href="#编译器做了什么" class="headerlink" title="编译器做了什么"></a>编译器做了什么</h2><p>6步：</p><ul><li>扫描</li><li>语法分析</li><li>语义分析</li><li>源代码优化</li><li>代码生成</li><li>目标代码优化</li></ul><p>具体每个过程参见书中42 - 47</p><p>经过这些扫描、语法分析、语义分年、源代码优化、代码生成和目标代码优化，编译器忙活了这么多个步骤以后，源代码终于被编译成了目标代码。但是这个目标代码中有一个问题是：符号的地址还没有确定。如果把目标代码使和汇编器编译成真正能够在机器上执行的指令。</p><p>1.那么符号的地址应该从哪得到呢？</p><p>2.如果符号定义在其他程序模块呢？又怎么知道它们的地址？</p><p><strong>事实上，定义其他模块的全局变量和函数在最终运行时的绝对地址都要在最终链接的时候才能确定。</strong>所以编译器可以将一个源代码文件编译成一个<strong>未链接的目标文件</strong>，然后由<strong>链接器</strong>最终将这些目标文件链接起来形成<strong>可执行文件</strong>。</p><h2 id="链接器历史更长"><a href="#链接器历史更长" class="headerlink" title="链接器历史更长"></a>链接器历史更长</h2><p>重新计算各个目标的地址过程被叫做<strong>重定位</strong></p><p>**符号(Symbol)**这个概念随着汇编语言的普及迅速被使用，它用来表示一个地址，这个地址可能是一段子程序(后来发展成函数)的起始地址，也可以是一个变量的起始地址。</p><p>属于静态语言的C&#x2F;C++模块之间通信有两种方式</p><ul><li>一种是模块间的函数调用</li><li>一种是模块间的变量访问</li></ul><p>函数访问须知道目标函数的地址，变量访问也须知道目标变量的地址，所以这两种方式都可以归结为一种方式，那就是模块间<strong>符号</strong>的引用</p><h2 id="模块拼装—静态链接"><a href="#模块拼装—静态链接" class="headerlink" title="模块拼装—静态链接"></a>模块拼装—静态链接</h2><p>链接的主要内容就是把各个模块之间相互相用的部分都处理好，使得各个模块之间都能够正确地衔接。链接器所要做的工作其实跟前面所描述的“程序员人工调整地址”本质上没有两样。</p><p>链接过程主要包括了</p><ul><li><strong>地址和空间分配</strong></li><li><strong>符号决议</strong></li><li><strong>重定位</strong></li></ul><p>每个模块的源代码文件（如.c）文件经过编译器编译成目标文件（.o）目标文件和库一起链接形成最终可执行文件。而最常见的库就是<strong>运行时库</strong>，它是支持程序运行的基本函数的集合。<strong>库其实就是一组目标文件的包，就是一些最常用的代码编译成目标后打包存放</strong></p><blockquote><p>.o文件叫做中间目标文件比较合适，简称为目标文件，很多时候我们也把目标文件称为模块。</p></blockquote><p><strong>静态链接的最基本过程和作用：</strong></p><p>比如我们在程序模块main.c中使用另外一个模块func.c中的函数foo() 我们在main.c模块中每一处调用foo的时候都必须确切知道foo这个函数的地址，但是由于每个模块都是单独编译的，在编译器编译main.c的时候它并不知道foo函数的地址，所以它暂时把这些调用 foo的指令的目标地址搁置，等待最后链接的时候由链接器去将这些指令的目标地址修正。如果没有链接器，需要我们手工把每个调用foo的指令进行修正，则填入正确的foo函数地址。当func.c模块被重新编译，foo函数的地址有可能改变时，那么我们在main.c中所有使用到foo的地址的指令将要全部重新调整。这些繁琐的工作将成为程序员的噩梦。使用链接器，你可以直接引用其他模块的函数和全局变量而无需知道它的地址，因为链接器在链接的时候，会根据你所引用的符号foo,自动去相应的func.c模块查找foo的地址，然后将main.c模块中的所有引用到foo的指令重新修正，让它们的目标地址为真正的foo函数的地址。</p><p><strong>重定位过程：</strong></p><p>假设我们有个全局变量叫var，它在目标文件A里面。我们在目标文件B里面要访问这个全局变量，比如我们在目标文件B里有这么一条指令：</p><p>movl $0x2a,var</p><p>这条指令就是给这个var变量赋值0x2a，相当于C语言中的var &#x3D;42。然后我们编译目标文件B，得到这条指令机器码</p><img src="../images/image-20221205142040647.png" alt="image-20221205142040647" style="zoom:50%"><p>由于在编译目标文件B的时候，编译器并不知道变量var的目标地址，所以编译器在没法确定地址的情况下，将这条mov指令的目标地址设为0，等待链接器在将目标文件 A和B链接起来的时候再将其修正。我们假设A和B链接后，变量var地址确定下来0x1000，那么链接器将会把这个指令的目标地址部分修改成0x1000。这个地址修正的过程被叫做重定位。每个要被修正的地方叫一个得重定位入口。重定位所做的就是给程序中每个这样的绝对地址引用的位置“打补丁”，使它们指向正确的址。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/11/25/JNI%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/11/25/JNI%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">JNI开发笔记</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-11-25 14:26:22" itemprop="dateCreated datePublished" datetime="2022-11-25T14:26:22+08:00">2022-11-25</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-12-19 08:51:30" itemprop="dateModified" datetime="2022-12-19T08:51:30+08:00">2022-12-19</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/NDK/" itemprop="url" rel="index"><span itemprop="name">NDK</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="使用javah-生成头文件"><a href="#使用javah-生成头文件" class="headerlink" title="使用javah 生成头文件"></a>使用javah 生成头文件</h2><p>目录结构如下</p><p><img src="/../images/image-20221128092326115.png" alt="image-20221128092326115"></p><p><code>MainActivity.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Used to load the &#x27;jnistudy1128&#x27; library on application startup.</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;jnistudy1128&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ActivityMainBinding binding;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        binding = ActivityMainBinding.inflate(getLayoutInflater());</span><br><span class="line">        setContentView(binding.getRoot());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Example of a call to a native method</span></span><br><span class="line">        TextView tv = binding.sampleText;</span><br><span class="line">        tv.setText(stringFromJNI());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A native method that is implemented by the &#x27;jnistudy1128&#x27; native library,</span></span><br><span class="line"><span class="comment">     * which is packaged with this application.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">stringFromJNI</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在命令行到java目录下，注意在包名外面</p><p><img src="/../images/image-20221128092417568.png" alt="image-20221128092417568"></p><p>执行javah</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javah -o MainActivity.h cn.com.jit.jnistudy1128.MainActivity</span><br></pre></td></tr></table></figure><p>注意：后面的输入文件要带上全类名信息</p><p>执行这句后，会在java目录下生成一个MainActivity.h文件</p><p><img src="/../images/image-20221128092554003.png" alt="image-20221128092554003"></p><p><code>MainActivity.h</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Header for class cn_com_jit_jnistudy1128_MainActivity */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _Included_cn_com_jit_jnistudy1128_MainActivity</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Included_cn_com_jit_jnistudy1128_MainActivity</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     cn_com_jit_jnistudy1128_MainActivity</span></span><br><span class="line"><span class="comment"> * Method:    stringFromJNI</span></span><br><span class="line"><span class="comment"> * Signature: ()Ljava/lang/String;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL <span class="title">Java_cn_com_jit_jnistudy1128_MainActivity_stringFromJNI</span></span></span><br><span class="line"><span class="function">  <span class="params">(JNIEnv *, jobject)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们把生成的jni方法拷贝到cpp文件中就可以使用了，别忘了引入头文件</p><h2 id="JNIEnv-在c和c-的区别"><a href="#JNIEnv-在c和c-的区别" class="headerlink" title="JNIEnv 在c和c++的区别"></a>JNIEnv 在c和c++的区别</h2><h3 id="在c-中调用"><a href="#在c-中调用" class="headerlink" title="在c++中调用"></a>在c++中调用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env-&gt;<span class="built_in">GetIntArrayElements</span>(i_, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><p>直接把它当指针，使用箭头符调用即可</p><p>我们看JNIEnv是什么？c++中是_JNIEnv</p><p><img src="/../images/image-20221128140805129.png" alt="image-20221128140805129"></p><p>再点进去</p><p><img src="/../images/image-20221128140833824.png" alt="image-20221128140833824"></p><p>它是一个结构体，我们传入方法的参数JNIEnv *env 相当于是这个结构体的指针，我们的GetIntArrayElements这些方法都封装在这个结构体里，所以直接使用结构体的指针去调用方法即可</p><p>比如GetIntArrayElements这个函数在_JNIEnv中是这样的</p><p><img src="/../images/image-20221128141645545.png" alt="image-20221128141645545"></p><p>实际上最后调用的还是JNINativeInterface的GetIntArrayElements函数，只不过帮我们封了一层</p><h3 id="在c中调用"><a href="#在c中调用" class="headerlink" title="在c中调用"></a>在c中调用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*env)-&gt;<span class="built_in">GetIntArrayElements</span>(env,i_,<span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><p>在c中要先去解引用，然后才能指针调用，为什么？</p><p>先看如果是c</p><p><img src="/../images/image-20221128141258937.png" alt="image-20221128141258937"></p><p>它本身就是一个指针，我们传入的JNIEnv *env 就成了 二级指针了，相当于这样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JNINativeInterface** JNIEnv</span><br></pre></td></tr></table></figure><p>所以必须要先去解指针，才能拿到JNINativeInterface这个结构体的指针，然后才能调用结构体里的方法</p><p>我们再来看为什么第一个参数都需要传env</p><p>和c++不同的是，我们这里调用的是 JNINativeInterface 这个结构体里的函数</p><p><img src="/../images/image-20221128141518328.png" alt="image-20221128141518328"></p><p>可以看到每个函数的第一个参数都是JNIEnv * 所以需要把env传进去，和c++的结构体是不一样的</p><h2 id="Java向native传递参数—基本数据类型的数组"><a href="#Java向native传递参数—基本数据类型的数组" class="headerlink" title="Java向native传递参数—基本数据类型的数组"></a>Java向native传递参数—基本数据类型的数组</h2><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>[] i,String[] j)</span></span>;</span><br></pre></td></tr></table></figure><p>cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_cn_com_jit_jnistudy1128_MainActivity_test</span><span class="params">(JNIEnv *env, jobject thiz, jintArray i,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               jobjectArray j)</span> </span>&#123;</span><br><span class="line">  jint *i = env-&gt;<span class="built_in">GetIntArrayElements</span>(i_, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>jobject第二个参数，代表着声明native方法的MainActivity的实例，也就是thisz</li><li>int[] 在naitve对应的是jintArray 是一个对象，是jobject的子类，通过这个类是不能直接访问数组中的元素的，需要通过这个对象找到指向数组首元素的地址，也就是指针</li></ul><h3 id="获取数组的指针"><a href="#获取数组的指针" class="headerlink" title="获取数组的指针"></a>获取数组的指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jint *i = env-&gt;<span class="built_in">GetIntArrayElements</span>(i_, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><ul><li>jint *i 指向数组首元素的地址</li><li>第二个参数，传递的是指针，一般c++中传递指针进去，是为了给指针指向的内存地址进行赋值，然后后面再去判断这个值是true还是false，如果不关心这个值是赋成什么，直接传null进去就行了</li><li>true：是拷贝的一个新数据(新申请内存)</li><li>false：就是使用的java的数组(地址) 不进行拷贝</li></ul><h3 id="获取数组的长度"><a href="#获取数组的长度" class="headerlink" title="获取数组的长度"></a>获取数组的长度</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jsize length = env-&gt;<span class="built_in">GetArrayLength</span>(i_);</span><br></pre></td></tr></table></figure><ul><li>返回jsize 就是 jint 也是int32_t 就是32位的int</li></ul><h3 id="遍历数组中的元素"><a href="#遍历数组中的元素" class="headerlink" title="遍历数组中的元素"></a>遍历数组中的元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; length; ++k) &#123;</span><br><span class="line">	__android_log_print(ANDROID_LOG_ERROR,<span class="string">&quot;JNI&quot;</span>,<span class="string">&quot;获取java的参数：%d&quot;</span>,*(i+k));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><p>使用get和new的方法都需要进行释放</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env-&gt;<span class="built_in">ReleaseIntArrayElements</span>(i_,i,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li>第一个参数是jintarray对象</li><li>第二个参数是jint数组指针</li><li>第三个参数是mode模式<ul><li>0 ：刷新java数组 并 释放 c&#x2F;c++ 数组</li><li>1 &#x3D; JNI_COMMIT : 只刷新java数组</li><li>2 &#x3D; JNI_ABORT：只释放c&#x2F;c++数组</li></ul></li></ul><p>不同的传值有不同的结果，一般传0 在native层修改了数组，也会同步到java层的数组，并释放掉c&#x2F;c++的指针</p><h2 id="Java向native传递参数—字符串-object-的数组"><a href="#Java向native传递参数—字符串-object-的数组" class="headerlink" title="Java向native传递参数—字符串(object)的数组"></a>Java向native传递参数—字符串(object)的数组</h2><p>基本数据类型和object数组的操作方式不一样</p><p>cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_cn_com_jit_jnistudy1128_MainActivity_test</span><span class="params">(JNIEnv *env, jobject thiz, jintArray i,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               jobjectArray j)</span> </span>&#123;</span><br><span class="line">  jint *i = env-&gt;<span class="built_in">GetIntArrayElements</span>(i_, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看j 是jobjectArray跟前面的使用不太一样，基本数据类型可以直接拿到jint 的指针，jobjectArray里面每一项都是jobject 这里是jstring</p><h3 id="获取数组大小"><a href="#获取数组大小" class="headerlink" title="获取数组大小"></a>获取数组大小</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jint strLength = env-&gt;<span class="built_in">GetArrayLength</span>(j_);</span><br></pre></td></tr></table></figure><h3 id="遍历数组，获得jstring"><a href="#遍历数组，获得jstring" class="headerlink" title="遍历数组，获得jstring"></a>遍历数组，获得jstring</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; strLength; ++m) &#123;</span><br><span class="line">	jstring strObj = <span class="keyword">static_cast</span>&lt;jstring&gt;(env-&gt;<span class="built_in">GetObjectArrayElement</span>(j_, m));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是jstring可以直接进行强转，新式强转得到每一个jstring</p><h3 id="把jstring转成c-x2F-c-可以操作的字符串"><a href="#把jstring转成c-x2F-c-可以操作的字符串" class="headerlink" title="把jstring转成c&#x2F;c++可以操作的字符串"></a>把jstring转成c&#x2F;c++可以操作的字符串</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* s  =env-&gt;<span class="built_in">GetStringUTFChars</span>(strObj,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>把jstring进行了转化char *</p><h2 id="Java向native传递参数—传递自定义的对象class引用类型"><a href="#Java向native传递参数—传递自定义的对象class引用类型" class="headerlink" title="Java向native传递参数—传递自定义的对象class引用类型"></a>Java向native传递参数—传递自定义的对象class引用类型</h2><p>其实就是反射去调用</p><h3 id="获取java对应的class对象"><a href="#获取java对应的class对象" class="headerlink" title="获取java对应的class对象"></a>获取java对应的class对象</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jclass beanCls = env-&gt;<span class="built_in">GetObjectClass</span>(bean);</span><br></pre></td></tr></table></figure><h3 id="获取methodId，知道要调用的是哪个方法"><a href="#获取methodId，知道要调用的是哪个方法" class="headerlink" title="获取methodId，知道要调用的是哪个方法"></a>获取methodId，知道要调用的是哪个方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmethodID getI = env-&gt;<span class="built_in">GetMethodID</span>(beanCls,<span class="string">&quot;getI&quot;</span>,<span class="string">&quot;()I&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>第一个参数是class</li><li>第二个参数是方法名</li><li>第三个参数是方法签名，可以通过javap来获取</li></ul><h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jint i = env-&gt;<span class="built_in">CallIntMethod</span>(bean,getI);</span><br></pre></td></tr></table></figure><h2 id="反射调用，传递的参数也是引用类型的"><a href="#反射调用，传递的参数也是引用类型的" class="headerlink" title="反射调用，传递的参数也是引用类型的"></a>反射调用，传递的参数也是引用类型的</h2><h3 id="1-反射静态方法，调用-printfInfo-需要传入java的字符串-也就是jstring"><a href="#1-反射静态方法，调用-printfInfo-需要传入java的字符串-也就是jstring" class="headerlink" title="1.反射静态方法，调用 printfInfo 需要传入java的字符串 也就是jstring"></a>1.反射静态方法，调用 printfInfo 需要传入java的字符串 也就是jstring</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jmethodID printInfo = env-&gt;<span class="built_in">GetStaticMethodID</span>(beanCls,<span class="string">&quot;printfInfo&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建java字符串 也就是jstring</span></span><br><span class="line">jstring str2 = env-&gt;<span class="built_in">NewStringUTF</span>(<span class="string">&quot;我是bean类的静态方法，被c++调用&quot;</span>);</span><br><span class="line"></span><br><span class="line">env-&gt;<span class="built_in">CallStaticVoidMethod</span>(beanCls,printInfo,str2);</span><br></pre></td></tr></table></figure><p>注意释放</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env-&gt;<span class="built_in">DeleteLocalRef</span>(str2);</span><br></pre></td></tr></table></figure><blockquote><p>像这种new出来的，find出来的是局部引用，需要delete掉</p></blockquote><h3 id="2-反射调用修改属性-注意这里是属性的签名"><a href="#2-反射调用修改属性-注意这里是属性的签名" class="headerlink" title="2.反射调用修改属性(注意这里是属性的签名)"></a>2.反射调用修改属性(注意这里是属性的签名)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jfieldID fieldI = env-&gt;<span class="built_in">GetFieldID</span>(beanCls,<span class="string">&quot;i&quot;</span>,<span class="string">&quot;I&quot;</span>);</span><br><span class="line">env-&gt;<span class="built_in">SetIntField</span>(bean,fieldI,<span class="number">300</span>);</span><br></pre></td></tr></table></figure><h3 id="3-反射调用方法，方法的参数是引用类型对象"><a href="#3-反射调用方法，方法的参数是引用类型对象" class="headerlink" title="3.反射调用方法，方法的参数是引用类型对象"></a>3.反射调用方法，方法的参数是引用类型对象</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">jmethodID printInfoNew = env-&gt;<span class="built_in">GetStaticMethodID</span>(beanCls,<span class="string">&quot;printfInfo&quot;</span>, <span class="string">&quot;(Lcn/com/jit/jnistudy1128/BeanNew;)V&quot;</span>);</span><br><span class="line"></span><br><span class="line">jclass beanNewCls = env-&gt;<span class="built_in">FindClass</span>(<span class="string">&quot;cn/com/jit/jnistudy1128/BeanNew&quot;</span>);</span><br><span class="line">jmethodID constructonr = env-&gt;<span class="built_in">GetMethodID</span>(beanNewCls,<span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(I)V&quot;</span>);</span><br><span class="line"></span><br><span class="line">jobject beanNew = env-&gt;<span class="built_in">NewObject</span>(beanNewCls,constructonr,<span class="number">88</span>);</span><br><span class="line"></span><br><span class="line">env-&gt;<span class="built_in">CallStaticVoidMethod</span>(beanCls,printInfoNew,beanNew);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">env-&gt;<span class="built_in">DeleteLocalRef</span>(beanNewCls);</span><br><span class="line">env-&gt;<span class="built_in">DeleteLocalRef</span>(beanNew);</span><br></pre></td></tr></table></figure><p>这样就在printInfo(BeanNew bean)调用了</p><p>唯一不同的就是在调用传参的时候，传入的了一个在c层new出来的java对象，要注意这种使用方式，以及new和find的方法都要进行delete回收释放</p><blockquote><p>有一个点很有意思，就是如果Bean2传到java层去了，native层回收了对象，对java层有没有影响，是不是就不能使用了呢？</p><p>最好的验证方法就是在调用 printInfo传入BeanNew对象，把对象赋值给this.bean &#x3D; bean 我们把对象传递给java 发现这个对象是一直可以使用的，为什么会这样呢？</p><p>其实这里回传的时候发生的是拷贝传递，java中的一个副本，不是同一内存空间，native中回收的对象，不会影响java层继续使用</p></blockquote><h2 id="Jni中的引用类型"><a href="#Jni中的引用类型" class="headerlink" title="Jni中的引用类型"></a>Jni中的引用类型</h2><h3 id="局部引用"><a href="#局部引用" class="headerlink" title="局部引用"></a>局部引用</h3><p>太多数JNI函数会创建局部引用，NewObject&#x2F;FindClass&#x2F;NewStringUTF等都是局部引用。</p><blockquote><p>局部引用只有在创建它的本地方法返回前有效，本地方法返回后，局部引用会被自动释放。</p><p>因此无法跨线程、跨方法使用。</p></blockquote><p>释放一个局部引用有两种方式：</p><p>1.本地方法执行完毕后VM自动释放；</p><p>2.通过DeleteLocalRef手动释放；</p><blockquote><p>VM会自动释放局部引用，为什么还需要手动释放呢？</p><p>因为局部引用会阻止它所引用的对象被GC回收</p></blockquote><p>其实也就是为了好习惯，尽快的回收掉不用的对象，是一种好习惯，不写也没事。</p><h3 id="全局引用"><a href="#全局引用" class="headerlink" title="全局引用"></a>全局引用</h3><blockquote><p>全局引用可以跨方法，跨线程使用，直到它被手动释放才会失效。</p><p>由NewGlobalRef函数创建</p></blockquote><p>先来看一个例子，为什么需要全局引用，全局引用和局部引用的区别是什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jclass beanNewCls;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_cn_com_jit_jnistudy1128_MainActivity_invokeBeanNew</span><span class="params">(JNIEnv *env, jobject thiz, jobject bean)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beanNewCls == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        beanNewCls = env-&gt;<span class="built_in">FindClass</span>(<span class="string">&quot;cn/com/jit/jnistudy1128/BeanNew&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    jmethodID construct = env-&gt;<span class="built_in">GetMethodID</span>(beanNewCls,<span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(I)V&quot;</span>);</span><br><span class="line">    env-&gt;<span class="built_in">NewObject</span>(beanNewCls,construct,<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这样写会不会有问题？</p><p>会。因为beanNewCls是局部引用，出了方法就被回收了，然后指针是有值的，也就是不等于NULL，但是指向的地址数据被释放了，等于悬空指针</p></blockquote><p>怎么修改？——改为全局引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">jclass beanNewCls;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_cn_com_jit_jnistudy1128_MainActivity_invokeBeanNew</span><span class="params">(JNIEnv *env, jobject thiz, jobject bean)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beanNewCls == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">      	<span class="comment">//先声明一个本地的</span></span><br><span class="line">        jclass cls = env-&gt;<span class="built_in">FindClass</span>(<span class="string">&quot;cn/com/jit/jnistudy1128/BeanNew&quot;</span>);</span><br><span class="line">      	<span class="comment">//把本地的转成全局的</span></span><br><span class="line">        beanNewCls = <span class="keyword">static_cast</span>&lt;jclass&gt;(env-&gt;<span class="built_in">NewGlobalRef</span>(cls));</span><br><span class="line">      	<span class="comment">//释放本地的</span></span><br><span class="line">        env-&gt;<span class="built_in">DeleteLocalRef</span>(cls);</span><br><span class="line">    &#125;</span><br><span class="line">    jmethodID construct = env-&gt;<span class="built_in">GetMethodID</span>(beanNewCls,<span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(I)V&quot;</span>);</span><br><span class="line">    env-&gt;<span class="built_in">NewObject</span>(beanNewCls,construct,<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局引用可以跨方法，跨线程使用，而且需要手动的调用env-&gt;DeleteGlobalRef(ref) 进行回收。不会随着方法结束而自动回收。</p><blockquote><p>这里一定要区别于Java的固有印象，认为beanNewCls声明在外部就是全局的，为什么还要声明全局，局部引用？这里c++和java不一样，指针有值，指针指向的地址不一定有内容。</p></blockquote><blockquote><p>Tips:</p><p>1.在个cpp文件中引用另一个cpp文件中的变量和方法，需要extern 如果没有头文件，需要这么去引用</p><p>2.在同一个函数中有bean2 但我要引用函数外部声明的bean2 要加::bean2域作用符，防止混用</p><p>3.比如想返回java层一个int *a(){} 指针，怎么返回给java层，jni封装一层，int java_xxxx(){ return a();}</p></blockquote><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><blockquote><p>全称弱全局引用，与全局引用类似，弱引用可以跨方法，跨线程使用，与全局引用不同的是，弱引用不会阻止GC回收它所指向的VM内部的对象。</p><p>在对class进行弱引用是非常合适的(FindClass)，因为Class一般直到程序进程结束才会卸载。</p><p>在使用弱引用时，必须先检查缓存过的弱引用是指向活动的对象，还是指向一个已经被GC的对象。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于一个弱引用与NULL相比较</span></span><br><span class="line"><span class="comment">//true:释放了</span></span><br><span class="line"><span class="comment">//false:还可以使用</span></span><br><span class="line"></span><br><span class="line">jobject beanLocal = env-&gt;<span class="built_in">NewObject</span>(beanNewCls,construct,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">beanNew = env-&gt;<span class="built_in">NewWeakGlobalRef</span>(beanLocal);</span><br><span class="line">jboolean isEqual = env-&gt;<span class="built_in">IsSameObject</span>(beanNew, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><h2 id="JNI-OnLoad"><a href="#JNI-OnLoad" class="headerlink" title="JNI_OnLoad"></a>JNI_OnLoad</h2><blockquote><p>调用System.loadLibrary()函数时，内部就会去查找so中的JNI_OnLoad函数，如果存在此函数调用。</p><p>JNI_OnLoad会：</p><p>告诉VM此native组件使用的JNI版本。</p><p>​ 对应Java版本，android只支持JNI_VERSION_1_2 JNI_VERSION_1_4 JNI_VERSION_1_6</p><p>​ 在JDK1.8中有JNI_VERSION_1_8</p></blockquote><h3 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h3><blockquote><p>动态注册的好处</p><p>1.方法名变短</p><p>2.产生的符号小</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">JavaVM *vm;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dynamicTest</span><span class="params">(JNIEnv *env,jobject thisz)</span></span>&#123;</span><br><span class="line">    <span class="built_in">DLOGD</span>(<span class="string">&quot;执行了dynamicTest&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册的对应数组    &#123;java方法名，方法签名，native方法&#125;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> JNINativeMethod method[] = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;dynamicJava&quot;</span>,<span class="string">&quot;()V&quot;</span>,(<span class="keyword">void</span>*)dynamicTest&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//注册的绑定的java类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *className = <span class="string">&quot;cn/com/jit/jnistudy1129/MainActivity&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM *_vm, <span class="keyword">void</span> *unused)</span> </span>&#123;</span><br><span class="line">    vm = _vm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取JNIEnv  线程相关</span></span><br><span class="line">    JNIEnv *env = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//小于0 失败  等于0 成功</span></span><br><span class="line">    <span class="keyword">int</span> res = vm-&gt;<span class="built_in">GetEnv</span>(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> **&gt;(&amp;env), JNI_VERSION_1_4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res!=JNI_OK)&#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意不能混淆，要不反射找不到</span></span><br><span class="line">    jclass cls = env-&gt;<span class="built_in">FindClass</span>(<span class="string">&quot;cn/com/jit/jnistudy1129/MainActivity&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> registerRes = env-&gt;<span class="built_in">RegisterNatives</span>(cls,method,<span class="built_in"><span class="keyword">sizeof</span></span>(method)/<span class="built_in"><span class="keyword">sizeof</span></span>(JNINativeMethod));</span><br><span class="line">    <span class="comment">//注册成功返回0</span></span><br><span class="line">    <span class="keyword">if</span> (registerRes!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> JNI_ERR;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JNI_VERSION_1_4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="native线程调用Java"><a href="#native线程调用Java" class="headerlink" title="native线程调用Java"></a>native线程调用Java</h3><p>比如有一个需求我们在native中开启子线程去下载视频或者解码，然后下载进度，下载完成，下载失败这失败信息需要回调给java层的方法，怎么回调？</p><blockquote><p>创建并启动线程的流程</p><ol><li>pthread_t pid; &#x2F;&#x2F;创建线程id</li><li>定义一个线程执行的函数 void* threadTask(void* args)</li><li>定义结构体，传入threadTask中的参数 struct Context{ jobject instance JNIEnv *env }; 这样可以多传一些信息</li><li>pthread_create(&amp;pid,0, threadTask,context) &#x2F;&#x2F;启动线程 传入结构体 最后一个参数是传入threadTask的参数</li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Context</span>&#123;</span></span><br><span class="line">    jobject instance;</span><br><span class="line">    JNIEnv *env;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">threadTask</span><span class="params">(<span class="keyword">void</span>* args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1 下载完成  调用java的回调</span></span><br><span class="line">    <span class="comment">//2 下载失败</span></span><br><span class="line">    Context *context = <span class="keyword">static_cast</span>&lt;Context *&gt;(args);</span><br><span class="line">    <span class="comment">//获取MainActivity的class对象</span></span><br><span class="line">    jclass cls = context-&gt;env-&gt;<span class="built_in">GetObjectClass</span>(context-&gt;instance);</span><br><span class="line"></span><br><span class="line">    jmethodID updateUI = context-&gt;env-&gt;<span class="built_in">GetMethodID</span>(cls,<span class="string">&quot;updateUI&quot;</span>,<span class="string">&quot;()V&quot;</span>);</span><br><span class="line">    context-&gt;env-&gt;<span class="built_in">CallVoidMethod</span>(context-&gt;instance,updateUI);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dynamicTest</span><span class="params">(JNIEnv *env,jobject thisz)</span></span>&#123;</span><br><span class="line">    <span class="built_in">DLOGD</span>(<span class="string">&quot;执行了dynamicTest&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程id</span></span><br><span class="line">    <span class="keyword">pthread_t</span> pid;</span><br><span class="line">    <span class="comment">//启动线程，解码 下载视频</span></span><br><span class="line">    Context *context = <span class="keyword">new</span> Context;</span><br><span class="line">    context-&gt;env = env;</span><br><span class="line">    context-&gt;instance = env-&gt;<span class="built_in">NewGlobalRef</span>(thisz);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;pid,<span class="number">0</span>, threadTask,context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>我们需要在子线程中反射去调用 Java的方法</p><p>我们需要方法所有的类的对象，及class 所以我们需要jobect和env 我们直接把dynamicTest 的JNIEnv传入给子线程看看</p><p>结果：报错了</p><p>原因：JNIEnv 是线程相关的对象，我们的dynamicTest调用的时候传入的是主线程的JNIEnv 是不能跨 线程给子线程使用的，会报错</p><p>解决：使用VM子线程绑定的JNIEnv vm-&gt;AttachCurrentThread(&amp;env,0);</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">threadTask</span><span class="params">(<span class="keyword">void</span>* args)</span></span>&#123;</span><br><span class="line">    JNIEnv *env = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//第二个参数一般传0  是一些线程的分组的 版本 名字</span></span><br><span class="line">    jint i = vm-&gt;<span class="built_in">AttachCurrentThread</span>(&amp;env,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (i != JNI_OK)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 下载完成  调用java的回调</span></span><br><span class="line">    <span class="comment">//2 下载失败</span></span><br><span class="line">    Context *context = <span class="keyword">static_cast</span>&lt;Context *&gt;(args);</span><br><span class="line">    <span class="comment">//获取MainActivity的class对象</span></span><br><span class="line">   </span><br><span class="line">    jclass cls = env-&gt;<span class="built_in">GetObjectClass</span>(context-&gt;instance);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    jmethodID updateUI = env-&gt;<span class="built_in">GetMethodID</span>(cls,<span class="string">&quot;updateUI&quot;</span>,<span class="string">&quot;()V&quot;</span>);</span><br><span class="line">   </span><br><span class="line">    env-&gt;<span class="built_in">CallVoidMethod</span>(context-&gt;instance,updateUI);</span><br><span class="line"></span><br><span class="line">    vm-&gt;<span class="built_in">DetachCurrentThread</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：结束时要记得DetachCurrentThread</p><p>还有一个问题：为什么传入的是JNIEnv的二级指针，如果传入一级指针会如何？</p></blockquote><h3 id="什么时候需要传递二级指针？"><a href="#什么时候需要传递二级指针？" class="headerlink" title="什么时候需要传递二级指针？"></a>什么时候需要传递二级指针？</h3><p>通过上述例子，我们可以看到，在某些情况下，函数参数传递一级指针时，在函数体内对指针做变动，也不会对原始指针产生变化，而传递二级指针时，则可以，这是为什么呢？</p><p>在传递一级指针时，只有对指针所指向的内存变量做操作才是有效的；</p><p>在传递二级指针时，只有对指针的指向做改变才是有效的；</p><p>下面做简单的分析：</p><p><strong>在函数传递参数时，编译器总会为每个函数参数制作一个副本，即拷贝；</strong></p><p>例如：</p><p>void fun(int *p)，指针参数p的副本为_p，编译器使_p&#x3D;p，_p和p指向相同的内存空间，如果在函数内修改了_p所指向的内容，就会导致p的内容也做相应的改变；</p><p>但如果在函数内_p申请了新的内存空间或者指向其他内存空间，则_p指向了新的内存空间，而p依旧指向原来的内存空间，因此函数返回后p还是原来的p。</p><p><em>这样的话，不但没有实现功能，反而每次都申请新的内存空间，而又得不到释放，因为没有将该内存空间的地址传递出来，容易造成内存泄露。</em></p><p>void fun(int **p)，如果函数参数是指针的地址，则可以通过该参数p将新分配或新指向的内存地址传递出来，这样就实现了有效的指针操作。</p><p>如果觉得二级指针比较难理解，<strong>也可以通过函数返回值的形式来传递动态内存（</strong>切记不能返回栈内存），如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">myMalloc</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> *s=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">     <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span>  *p=<span class="literal">NULL</span>;</span><br><span class="line">     p=<span class="built_in">myMalloc</span>();</span><br><span class="line">     <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;P is not changed!\n&quot;</span>);</span><br><span class="line">     <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;P has been changed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/11/24/c-%E5%AE%B9%E5%99%A8/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/11/24/c-%E5%AE%B9%E5%99%A8/" class="post-title-link" itemprop="url">c++-容器</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-11-24 10:21:13" itemprop="dateCreated datePublished" datetime="2022-11-24T10:21:13+08:00">2022-11-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-12-19 08:51:31" itemprop="dateModified" datetime="2022-12-19T08:51:31+08:00">2022-12-19</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>容器</p><p>序列式 与 关联式</p><p>序列式容器 stl :元素排列顺序与元素本身无关，由添加顺序决定的</p><p>vector list dequeue queue stack priority_queue</p><p>前三种的api操作差不多</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//vector 支持快速随机访问 </span></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; vec_1;</span><br><span class="line">  <span class="comment">//声明有一个元素空间</span></span><br><span class="line">  <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vec_2</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="comment">//声明6个元素 值都是1</span></span><br><span class="line">  <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vec_3</span><span class="params">(<span class="number">6</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="comment">//用vec_3来初始化</span></span><br><span class="line">  <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vec_4</span><span class="params">(vec_3)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//增加一个元素</span></span><br><span class="line">  vec_1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  vec_1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//删除元素</span></span><br><span class="line">  vec_1.<span class="built_in">pop_back</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//通过下标来获得元素</span></span><br><span class="line">  cout &lt;&lt; vec_1[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//vector是一个模板类，为什么可以使用[0]来操作元素，因为操作符重载了</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//也能获取元素</span></span><br><span class="line">  vec_1.<span class="built_in">at</span>(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//直接获得队首与队尾元素</span></span><br><span class="line">  vec_1.<span class="built_in">front</span>();</span><br><span class="line">  vec_1.<span class="built_in">back</span>();</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  vec_1.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="comment">//删除区间元素，删除某个元素</span></span><br><span class="line">  vec_1.<span class="built_in">erase</span>(vec_1.<span class="built_in">begin</span>(),vec_1.<span class="built_in">end</span>());</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//只增不减 </span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;获得容器vec的容量大小：&quot;</span> 	&lt;&lt; vec_1.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果vec_1是全局的变量，clear后容量不回收，所以用一个临时的vector进行swap替换，v是栈上分配，方法执行后被回收，而全局的vec容量也被清空</span></span><br><span class="line"> 	vector&lt;<span class="keyword">int</span>&gt;().<span class="built_in">swap</span>(vec_1);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>queue stack</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Type</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="built_in">Type</span>(<span class="keyword">int</span> i):<span class="built_in">i</span>(i);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TypeLess</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Type&amp; _Left,<span class="keyword">const</span> Type&amp; _Right)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> (_Left.i &lt; _Right.i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//队列</span></span><br><span class="line">  queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//加入队列</span></span><br><span class="line">  q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//弹出队列</span></span><br><span class="line">  q.<span class="built_in">pop</span>();</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//栈 stack</span></span><br><span class="line">  stack&lt;<span class="keyword">int</span>&gt;	 s;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//优先级队列</span></span><br><span class="line">  priority_queue&lt;<span class="keyword">int</span>&gt; pq;</span><br><span class="line">  pq.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">  pq.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">  pq.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">  </span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;默认优先级队列，队首：&quot;</span> &lt;&lt; pq.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//第二个参数是基于什么来实现 只能是vector</span></span><br><span class="line">  <span class="function">priority_queue&lt;<span class="keyword">int</span>&gt; <span class="title">pq1</span><span class="params">(<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt;)</span></span>;</span><br><span class="line">  <span class="comment">//less:最大的元素在前面</span></span><br><span class="line">  <span class="comment">//greater:最小的元素在前面</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//不知道如何给 Type 排序 要指定排序规则</span></span><br><span class="line">  <span class="comment">//TypeLess:自定义TypeLess结构体  注：结构体在c++中是可以写函数的和类是一样的只不过一个是私有，一个是public</span></span><br><span class="line">  priority_queue&lt;Type,vector&lt;Type&gt;,TypeLess&gt; pq_type;</span><br><span class="line">  </span><br><span class="line">  pq_type.<span class="built_in">push</span>(<span class="built_in">Type</span>(<span class="number">2</span>));</span><br><span class="line">  pq_type.<span class="built_in">push</span>(<span class="built_in">Type</span>(<span class="number">1</span>));</span><br><span class="line">  pq_type.<span class="built_in">push</span>(<span class="built_in">Type</span>(<span class="number">3</span>));</span><br><span class="line">  </span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Type 优先级队列，队首：&quot;</span> &lt;&lt; pq_type.<span class="built_in">top</span>().i &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//要对自己的类进行排序，也要依照Less写一个结构体</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关联式容器</p><p>就是里面的元素是有关系的</p><p>通过一个关键字保存和访问元素的 map set</p><p>set 集合 红黑树的实现 元素不可重复</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  set&lt;<span class="keyword">int</span>&gt; set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">  set1.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">  <span class="comment">//插入失败 元素不可重复</span></span><br><span class="line">  set1.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">  set1.<span class="built_in">erase</span>(<span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//使用迭代器</span></span><br><span class="line">  set&lt;<span class="keyword">int</span>&gt;::iterator it = set1.<span class="built_in">begin</span>(); <span class="comment">//指向容器第0个元素</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//指向容器中最后一个元素的下一个元素</span></span><br><span class="line">  set1.<span class="built_in">end</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//vector&lt;int&gt;(6,1);</span></span><br><span class="line">  <span class="comment">//跟java一样，不能在迭代的时候对容器进行增删</span></span><br><span class="line">  <span class="keyword">for</span>(;it&lt;vec_3.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;使用迭代器遍历：&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/11/23/PKI%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%BB%93%E6%9E%84-%E8%BD%AC/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/11/23/PKI%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%BB%93%E6%9E%84-%E8%BD%AC/" class="post-title-link" itemprop="url">PKI系统与数字证书结构[转]</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-11-23 15:15:27" itemprop="dateCreated datePublished" datetime="2022-11-23T15:15:27+08:00">2022-11-23</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-12-19 08:51:31" itemprop="dateModified" datetime="2022-12-19T08:51:31+08:00">2022-12-19</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%AF%81%E4%B9%A6%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">证书相关</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"></div><footer class="post-footer"><div class="post-eof"></div></footer></article><nav class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a></nav></div><script>window.addEventListener("tabs:register",()=>{let e=CONFIG.comments["activeClass"];if(CONFIG.comments.storage&&(e=localStorage.getItem("comments_active")||e),e){let t=document.querySelector(`a[href="#comment-${e}"]`);t&&t.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">张龙</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">59</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">12</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">2</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">张龙</span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script></body></html>