<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"example.com",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta property="og:type" content="website"><meta property="og:title" content="SteveZhang博客"><meta property="og:url" content="http://example.com/index.html"><meta property="og:site_name" content="SteveZhang博客"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="张龙"><meta name="twitter:card" content="summary"><link rel="canonical" href="http://example.com/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!0,isPost:!1,lang:"zh-CN"}</script><title>SteveZhang博客</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="SteveZhang博客" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">SteveZhang博客</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">18</span></a></li></ul></nav></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content index posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/05/17/Gradle%E5%9F%BA%E7%A1%80/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/05/17/Gradle%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Gradle基础</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-05-17 11:51:37" itemprop="dateCreated datePublished" datetime="2022-05-17T11:51:37+08:00">2022-05-17</time></span></div></header><div class="post-body" itemprop="articleBody"><p>讲解Gradle基础知识，语法及生命周期</p><div class="post-button"><a class="btn" href="/2022/05/17/Gradle%E5%9F%BA%E7%A1%80/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/05/17/okhttp%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81(kotlin)/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/05/17/okhttp%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81(kotlin)/" class="post-title-link" itemprop="url">okhttp网络框架原理</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-05-17 11:51:37" itemprop="dateCreated datePublished" datetime="2022-05-17T11:51:37+08:00">2022-05-17</time></span></div></header><div class="post-body" itemprop="articleBody"><p>okhttp网络框架原理</p><div class="post-button"><a class="btn" href="/2022/05/17/okhttp%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81(kotlin)/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/05/17/%E8%AE%B0%E4%B8%80%E6%AC%A1vpn%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%AE%9E%E8%B7%B5/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/05/17/%E8%AE%B0%E4%B8%80%E6%AC%A1vpn%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%AE%9E%E8%B7%B5/" class="post-title-link" itemprop="url">借助v2ray,记一次VPN内网穿透实践</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-05-17 11:51:37" itemprop="dateCreated datePublished" datetime="2022-05-17T11:51:37+08:00">2022-05-17</time></span></div></header><div class="post-body" itemprop="articleBody"><p>花了一天搞了下公司的内网穿透，先给出参考的链接原文及原理，再给出自己的实践记录，可以直接拷贝，换下端口和你们阿里云(或者自己使用的云，这里都以阿里云做例子)的外网IP就OK了</p><div class="post-button"><a class="btn" href="/2022/05/17/%E8%AE%B0%E4%B8%80%E6%AC%A1vpn%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%AE%9E%E8%B7%B5/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/05/17/Jetpack%E7%B3%BB%E5%88%97%E2%80%94%E5%BA%95%E9%83%A8%E5%AF%BC%E8%88%AA%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/05/17/Jetpack%E7%B3%BB%E5%88%97%E2%80%94%E5%BA%95%E9%83%A8%E5%AF%BC%E8%88%AA%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Jetpack系列—底部导航路由BottomNavigationView原理</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-05-17 11:51:37" itemprop="dateCreated datePublished" datetime="2022-05-17T11:51:37+08:00">2022-05-17</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Jetpack%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Jetpack系列</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>主要介绍BottomNavigationView及其实现原理</p><div class="post-button"><a class="btn" href="/2022/05/17/Jetpack%E7%B3%BB%E5%88%97%E2%80%94%E5%BA%95%E9%83%A8%E5%AF%BC%E8%88%AA%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/05/16/MVVM%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/05/16/MVVM%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">MVVM及Databinding使用及原理解析(更新中)</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-05-16 06:35:47" itemprop="dateCreated datePublished" datetime="2022-05-16T06:35:47+08:00">2022-05-16</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-05-17 11:51:37" itemprop="dateModified" datetime="2022-05-17T11:51:37+08:00">2022-05-17</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="什么是MVVM"><a href="#什么是MVVM" class="headerlink" title="什么是MVVM"></a>什么是MVVM</h2><ul><li>双向绑定。数据变更<code>UI</code>会自动刷新，<code>UI</code>变化了数据也会自动同步到最新的值</li><li>数据驱动UI：比如<code>User</code>中的字段，数据变化了，可以做到自动刷新UI。</li><li>UI同步数据：比如<code>EditText</code>、<code>CheckBox</code>、<code>ToggleButton</code>具有状态的<code>View</code>，当状态变化后，数据模型中与之关联的字段的值也会自动同步最新状态</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开启databinding</span></span><br><span class="line">android&#123;</span><br><span class="line">	dataBinding&#123;</span><br><span class="line">		enable = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="传统的MVVM"><a href="#传统的MVVM" class="headerlink" title="传统的MVVM"></a>传统的MVVM</h3><p><img src="/../images/image-20220516064045932.png" alt="image-20220516064045932"></p><ul><li><p>此时<code>view</code>层的定义比较广泛，可以指<code>Activity/Fragment/xml</code>实例化出来的<code>view</code>对象或者自定义<code>view</code>对象</p></li><li><p><code>VM</code>就是这里的<code>viewmodel</code>,但是这并不是<code>Jetpack</code>组件里的<code>viewmodel</code>,18年，<code>livedata</code>和<code>viewmodel</code>没有出来前，这里的<code>viewmodel</code>只是一个普通的类，用于从<code>model</code>中获取数据，从<code>Model</code>中获取数据成功后会通过<code>callback</code>回传给<code>viewmodel</code>，而<code>viewmodel</code>中的数据更新后，并不是通过<code>view</code>接口(区别于<code>MVP</code>)回传给<code>view</code>更新的，而是通过<code>Databinding</code>，利用它观察者的特性，实现<code>UI</code>的更新</p></li></ul><p>定义<code>ViewModel</code>用于处理数据相关的业务逻辑。并通过<code>ObserverableField</code> 观察者把结果回传出去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeViewModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ObservableField&lt;User&gt; userField = <span class="keyword">new</span> ObservableField&lt;&gt;();</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryUserInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.nickName = <span class="string">&quot;nickName&quot;</span>;</span><br><span class="line">        user.address = <span class="string">&quot;address&quot;</span>;</span><br><span class="line">        <span class="comment">//自动通知与之关联的观察者</span></span><br><span class="line">        userField.set(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><blockquote><p>注意一定要给<code>userField.set(user)</code> 把对象set给<code>userField</code> 这步不调用，是无法从<code>userField</code>中取数据的，会报NPE</p></blockquote><p>基于<code>DataBinding</code>在xml中进行数据绑定，可以实现数据&amp;UI双向绑定&#x3D;&gt;数据变更ui自动刷新，UI变动自动同步数据</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">&quot;viewModel&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;com.steve.mvvmdemo.test.HomeViewModel&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--单向绑定@--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/nick_name&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;@&#123;viewModel.userField.nickName&#125;&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--双向绑定@=--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/edit_address&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;@=&#123;viewModel.userField.address&#125;&quot;</span></span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>只要<code>userField</code>中的<code>nickName</code>发生变化，UI会刷新，这是单向的</p><p>编写完<code>xml</code>后<code>rebuild</code>一个项目</p><p><code>Activity</code>控制数据的获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> <span class="meta">@org</span>.jetbrains.annotations.Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">      </span><br><span class="line">        ActivityHomeBinding binding = DataBindingUtil.setContentView(<span class="keyword">this</span>, R.layout.activity_home);</span><br><span class="line"></span><br><span class="line">        HomeViewModel vm = <span class="keyword">new</span> HomeViewModel();</span><br><span class="line">        binding.setViewModel(vm);</span><br><span class="line">      </span><br><span class="line">      	model.queryUserInfo();</span><br><span class="line"></span><br><span class="line">        binding.editAddress.addTextChangedListener(<span class="keyword">new</span> TextWatcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeTextChanged</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> count, <span class="keyword">int</span> after)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTextChanged</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> before, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterTextChanged</span><span class="params">(Editable s)</span> </span>&#123;</span><br><span class="line">              <span class="comment">//当输入框文本变更后，userField的address数据会自动更新，变成输入框输入的内容</span></span><br><span class="line">                Log.e(<span class="string">&quot;zzl&quot;</span>,<span class="string">&quot;after:&quot;</span> + vm.userField.get().address);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过<code>DataBindingUtil.setContentView</code>完成<code>Activity</code>和xml布局文件的绑定工作，返回一个<code>Databinding</code>对象，这个<code>databinding</code>对象是根据xml的名称在编译阶段生成的，我们可以直接拿来使用。</li><li>把vm通过<code>setViewModel</code>设置给<code>databinding</code></li><li>然后在<code>Activity</code>中调用 <code>model.queryUserInfo()</code>去获取数据，可能是网络上的数据，然后<code>activity</code>就不管数据获取后UI的更新了</li></ul><p>这就是传统的MVVM，它着重利用了<code>Databinding</code>的能力，大部分的数据都是在xml中进行绑定，当然也会根据场景，具体问题具体分析。如果需要用户交互复杂的逻辑控制，可能还是需要在<code>activity</code>中进行控制更为方便。</p><p>但是这种写法已经过时了，后面出现了<code>Jetpack</code>，在<code>Jetpack</code>模式下，我们通常会利用<code>VieModel + LiveData</code>的组件结合。</p><p>这样做的目的是既能保证数据不会无缘无故丢失，还能<strong>自动关联宿主的生命周期</strong>，避免空指针的问题。<code>Activity</code>，<code>Fragment UI</code>逻辑和用户交互控制就可以了。数据的绑定可以交给<code>Databindging</code></p><h3 id="Jetpack-Viewmodel-livedata使用"><a href="#Jetpack-Viewmodel-livedata使用" class="headerlink" title="Jetpack Viewmodel + livedata使用"></a>Jetpack Viewmodel + livedata使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LiveData <span class="title">getUserInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        MutableLiveData&lt;User&gt; liveData = <span class="keyword">new</span> MutableLiveData&lt;&gt;();</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.nickName = <span class="string">&quot;zzl&quot;</span>;</span><br><span class="line">        user.address = <span class="string">&quot;changchun&quot;</span>;</span><br><span class="line"></span><br><span class="line">        liveData.postValue(user);</span><br><span class="line">        <span class="keyword">return</span> liveData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li>注意这里既不是使用观察者<code>ObservableField</code>包裹对象，也不是使用<code>view</code>的接口回调<code>callback</code>去回传数据，而是使用了<code>livedata</code>，通过<code>liveData.postValue(user)</code>并返回<code>liveData</code>，去通知观察者</li></ul><p>下面看下xml文件的变化</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">&quot;user&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;com.steve.mvvmdemo.test.User&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--单向绑定@--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/nick_name&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;@&#123;user.nickName&#125;&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--双向绑定@=--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/edit_address&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;@=&#123;user.address&#125;&quot;</span></span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>这里注意绑定的对象不再是<code>viewmodel</code>而直接是<code>user</code>对象</li><li>直接使用<code>user.nickName</code> <code>user.address</code>访问对象的值</li></ul><p>看下<code>Activity</code>里的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeActivity3</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> <span class="meta">@org</span>.jetbrains.annotations.Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        ActivityHome2Binding binding = DataBindingUtil.setContentView(<span class="keyword">this</span>, R.layout.activity_home2);</span><br><span class="line">        ViewModelProvider provider = <span class="keyword">new</span> ViewModelProvider(<span class="keyword">this</span>,<span class="keyword">new</span> ViewModelProvider.NewInstanceFactory());</span><br><span class="line">        HomeViewModel vm = provider.get(HomeViewModel.class);</span><br><span class="line"></span><br><span class="line">        vm.getUserInfo().observe(<span class="keyword">this</span>, (Observer&lt;User&gt;) user -&gt; &#123;</span><br><span class="line">            binding.setUser(user);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Jetpack里的api使用会有一点点不同</p><ul><li><code>DataBindingUtil.setContentView</code>把xml和<code>activity</code>进行绑定，生成<code>databinding</code></li><li>通过<code>ViewModelProvider</code>获取具体的<code>HomeViewModel</code>对象</li><li>通过vm获取发送数据的<code>liveData</code>，注册观察者，在回调里进行<code>binding.setUser(user);</code>绑定</li></ul><h2 id="DataBinding的高频用法及注意事项"><a href="#DataBinding的高频用法及注意事项" class="headerlink" title="DataBinding的高频用法及注意事项"></a>DataBinding的高频用法及注意事项</h2><h3 id="什么是dataBinding"><a href="#什么是dataBinding" class="headerlink" title="什么是dataBinding?"></a>什么是dataBinding?</h3><ul><li>可以理解为<code>dataBinding</code>只是一种工具，它解决了view和数据之间的双向绑定</li></ul><h3 id="dataBinding的优势？"><a href="#dataBinding的优势？" class="headerlink" title="dataBinding的优势？"></a>dataBinding的优势？</h3><ul><li>双向数据绑定 数据发生改变后，自动通知刷新UI页面，不再需要人工绑定最新数据到view上。UI改变后也能同步给数据。</li><li>减少模板代码 有了dataBinding，从此不用再写<code>findViewById</code>,<code>setOnClickListener</code>等枯燥生硬的代码，大大提高工作效率。从此<code>Butterknife</code>靠边站。</li><li>释放<code>Activitty/Fragment</code>压力 我们可以直接在xml布局文件中完成数据，事件绑定工作。<code>Activity</code>,<code>Fragment</code>让它更加只关注核心业务。</li><li>数据绑定空安全 在xml中绑定数据它是空安全的，因为<code>dataBinding</code>在数据绑定上会自动装箱和空判断，所以大大减少了数据绑定带来的<code>NPE</code>问题</li></ul><h3 id="dataBinding如何使用？"><a href="#dataBinding如何使用？" class="headerlink" title="dataBinding如何使用？"></a>dataBinding如何使用？</h3><ul><li>在布局文件中，选中根布局的标签，按住 <code>alt + 回车</code> ，点击<code>convert to data binding layout</code> 即可转换成<code>dataBinding</code>布局。</li><li>转换后的布局，最外层变成了<code>layout</code>标签，里面包裹了<code>data</code>标签和常规的布局元素。data元素用来声明在此布局使用到的变量和变量类型，以及类引用。最不是所有的属性都能用<code>dataBinding</code>来绑定呢？当然不是！如果一个属性<code>xxx</code>，在该类中有<code>setXXX</code>方法，我们才能使用<code>dataBinding</code>来绑定。比如<code>android:layout_width</code>，<code>android_height</code>就不能使用<code>dataBinding</code>来绑定值，而<code>android:paddingLeft</code>，<code>android:textSize</code>都是可以的。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">&quot;user&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;com.steve.mvvmdemo.test.User&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">&quot;com.steve.mvvmdemo.test.UserManager&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">import</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/tvName&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>  //不能使用<span class="attr">dataBinding</span>动态绑定</span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;@&#123;user.name&#125;&quot;</span> //单向绑定数据变更自动通知<span class="attr">UI</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">&quot;@&#123;@dimen/16sp&#125;&quot;</span> //资源引用</span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;@&#123;user.nickName + @string/suffix&#125;&quot;</span> //字符串拼接需要引用资源</span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;@&#123;UserManager.getUserName()&#125;&quot;</span> //调用静态方法，类必须先导入</span></span><br><span class="line"><span class="tag">            <span class="attr">android:onClick</span>=<span class="string">&quot;@&#123;()-&gt;UserManager.login()&#125;&quot;</span></span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>android:text=&quot;@&#123;user.name&#125;&quot;</code>等价于<code>tvName.text = user.name</code>这样就将数据和<code>view</code>相关联了。那么如何实现<code>view</code>和数据的双向绑定呢？我们除了上面提到的让<code>ObservableField</code>持有外，还可以让实体类<code>User</code>继承<code>BaseObservable</code>。当user中字段发生变更，只需要调用<code>user.notifyPropertyChanged</code>就可以让<code>UI刷新</code>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">BaseObservable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当使用name字段发生变更后，若想UI自动刷新，我们需要给它写个get方法并且标记为Bindable注解</span></span><br><span class="line">    <span class="comment">//最后调用 notifyPropertyChanged方法即可</span></span><br><span class="line">    <span class="meta">@Bindable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        notifyPropertyChanged(BR.user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>dataBinding</code> 也支持在布局文件中使用<code>数组、List、Set和Map</code>，且在布局文件中都可以通过<code>list[index]</code>的形式来获取元素，因为xml的特性，在声明<code>List&lt;String&gt;</code>之类的类型时，需要使用尖括号的<code>转义字符</code>，如下</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">&quot;java.util.List&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">&quot;java.util.Set&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">&quot;java.util.Map&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">&quot;android.util.SparseArray&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">&quot;array&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;String[]&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--List&lt;String&gt; 需要转义--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">&quot;list&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;List<span class="symbol">&amp;lt;</span>String<span class="symbol">&amp;gt;</span>&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--Map&lt;String&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">&quot;map&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;Map<span class="symbol">&amp;lt;</span>String,String<span class="symbol">&amp;gt;</span>&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--Set&lt;Strin&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">&quot;set&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;Set<span class="symbol">&amp;lt;</span>String<span class="symbol">&amp;gt;</span>&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--SparseArray&lt;String&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">&quot;sparse&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;SparseArray<span class="symbol">&amp;lt;</span>String<span class="symbol">&amp;gt;</span>&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">&quot;index&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">&quot;key&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;String&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;@&#123;array[1]&#125;&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;@&#123;sparse[index]&#125;&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;@&#123;list[index]&#125;&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;@&#123;map[key]&#125;&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&#x27;@&#123;map[&quot;移动端架构师&quot;]&#125;&#x27;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&#x27;@&#123;set.contains(&quot;xxx&quot;)?&quot;移动端架构师&quot;:key&#125;&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>dataBinding</code>在xml中数据绑定支持的语法表达式也是非常丰富的，支持在布局文件中使用以下运算符、表达式和关键字</li></ul><p><img src="/../images/image-20220516091030481.png" alt="image-20220516091030481"></p><p><img src="/../images/image-20220516091050642.png" alt="image-20220516091050642"></p><ul><li>dataBinding 拓展view属性</li></ul><p>我们知道，以前想要给ImageView增加几个属性，必须要写个自定义的ImageView在构造函数中一顿解析。那看看使用dataBinding如何拓展view属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HiImageView</span> <span class="keyword">extends</span> <span class="title">ImageView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BindingAdapter(value = &#123;&quot;image_url&quot;,&quot;isCircle&quot;,&quot;radius&quot;&#125;,requireAll = false)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setImageUrl</span><span class="params">(ImageView view,String imageUrl,<span class="keyword">boolean</span> isCircle,<span class="keyword">int</span> radius)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>需要定义成<code>public static</code> 使用<code>BindingAdapter</code>注解并标记</li><li><code>value</code>中的字段随意添加和方法参数一一对应即可。</li><li>requirAll &#x3D; false代表是否以下三个属性在xml中同时使用才会调用该方法，为<code>flase</code>的话，只要有一个属性被使用就能调用到该方法</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.steve.mvvmdemo.jetpackmvvm.HiImageView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:image_url</span>=<span class="string">&quot;@&#123;user.avatar&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:radius</span>=<span class="string">&quot;@&#123;50&#125;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在布局文件中如下使用，便能实现图片圆角和资源url绑定的功能</li></ul><h3 id="dataBinding使用建议"><a href="#dataBinding使用建议" class="headerlink" title="dataBinding使用建议"></a>dataBinding使用建议</h3><ul><li>不建议在列表中乱用，因为dataBinding数据绑定是延迟一帧的，如果列表中的ItemView的宽高需要计算后才能正确展示，或者显隐控制，不建议使用databinding操作，否则会看到列表itemview有可能撑开的动画，体验不好。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">requestRebind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mContainingBinding != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mContainingBinding.requestRebind();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> LifecycleOwner owner = <span class="keyword">this</span>.mLifecycleOwner;</span><br><span class="line">        <span class="keyword">if</span> (owner != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Lifecycle.State state = owner.getLifecycle().getCurrentState();</span><br><span class="line">            <span class="keyword">if</span> (!state.isAtLeast(Lifecycle.State.STARTED)) &#123;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// wait until lifecycle owner is started</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mPendingRebind) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingRebind = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//这里下一次屏幕绘制才会进行绑定</span></span><br><span class="line">        <span class="keyword">if</span> (USE_CHOREOGRAPHER) &#123;</span><br><span class="line">            mChoreographer.postFrameCallback(mFrameCallback);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mUIThreadHandler.post(mRebindRunnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SDK_INT&gt;&#x3D;16 都会执行这里，在下一次绘制时，才会重新绑定数据</p></blockquote><ul><li>如fragment_layout_my.xml布局，在编译时会生成FragmentLayoutMyImpl.class我们可以搜索这种类debug跟进解决问题。</li></ul><p>build&#x2F;intermediates&#x2F;javac&#x2F;debug&#x2F;clasees&#x2F;org&#x2F;…&#x2F;databinding&#x2F;FragmentLayoutMyImpl.class</p><h2 id="dataBinding与ViewBinding的区别"><a href="#dataBinding与ViewBinding的区别" class="headerlink" title="dataBinding与ViewBinding的区别"></a>dataBinding与ViewBinding的区别</h2><ul><li>viewbinding可以看做是一个databinding的一部分功能 最主要的表现就是可以通过绑定后不用findviewbyid了，但不能进行双向绑定</li><li>相对来说databinding的功能更强大一些，不只是可以直接获取控件对象，并且可以通过数据绑定的形式实时更新页面UI</li><li>从编译效率来讲viewBinding的效率更快一些，databinding的效率要慢一些</li><li>viewbinding优点也是明显的不需要对原有的xml文件进行侵入</li></ul><h2 id="DataBinding原理与编译时绑定布局对象"><a href="#DataBinding原理与编译时绑定布局对象" class="headerlink" title="DataBinding原理与编译时绑定布局对象"></a>DataBinding原理与编译时绑定布局对象</h2><p><img src="/../images/image-20220516120558811.png" alt="image-20220516120558811"></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><ul><li>1.通过源码我们要知道databinding如何实现M-V V-M的双向刷新机制</li><li>2.databinding内存开销过大的原因是什么？</li></ul><p>1.rebuild后，生成两个xml文件</p><p><img src="/../images/image-20220516122044224.png" alt="image-20220516122044224"></p><p>这两个xml文件分别有各自的用处 xxx-layout 用于Databinding处理，正常的xml文件中也会有tab</p><p>activity_home-layout.xml文件的路径是</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app<span class="regexp">/build/i</span>ntermediates<span class="regexp">/data_binding_layout_info_type_merge/</span>debug<span class="regexp">/out/</span>activity_home-layout.xml</span><br></pre></td></tr></table></figure><p>activity_home.xml文件的路径是</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app<span class="regexp">/build/i</span>ntermediates<span class="regexp">/incremental/m</span>ergeDebugResources<span class="regexp">/stripped.dir/</span>layout/activity_home.xml</span><br></pre></td></tr></table></figure><p>我们看下acitivty_home-layout.xml文件的内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;yes&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Layout</span> <span class="attr">directory</span>=<span class="string">&quot;layout&quot;</span> <span class="attr">filePath</span>=<span class="string">&quot;app/src/main/res/layout/activity_home.xml&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">isBindingData</span>=<span class="string">&quot;true&quot;</span> <span class="attr">isMerge</span>=<span class="string">&quot;false&quot;</span> <span class="attr">layout</span>=<span class="string">&quot;activity_home&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">modulePackage</span>=<span class="string">&quot;com.steve.mvvmdemo&quot;</span> <span class="attr">rootNodeType</span>=<span class="string">&quot;android.widget.LinearLayout&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Targets</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Target</span> <span class="attr">tag</span>=<span class="string">&quot;layout/activity_home_0&quot;</span> <span class="attr">view</span>=<span class="string">&quot;LinearLayout&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Expressions</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">location</span> <span class="attr">endLine</span>=<span class="string">&quot;30&quot;</span> <span class="attr">endOffset</span>=<span class="string">&quot;18&quot;</span> <span class="attr">startLine</span>=<span class="string">&quot;10&quot;</span> <span class="attr">startOffset</span>=<span class="string">&quot;4&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Target</span> <span class="attr">id</span>=<span class="string">&quot;@+id/nick_name&quot;</span> <span class="attr">tag</span>=<span class="string">&quot;binding_1&quot;</span> <span class="attr">view</span>=<span class="string">&quot;TextView&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Expressions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Expression</span> <span class="attr">attribute</span>=<span class="string">&quot;android:text&quot;</span> <span class="attr">text</span>=<span class="string">&quot;viewModel.userField.nickName&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">Location</span> <span class="attr">endLine</span>=<span class="string">&quot;20&quot;</span> <span class="attr">endOffset</span>=<span class="string">&quot;57&quot;</span> <span class="attr">startLine</span>=<span class="string">&quot;20&quot;</span> <span class="attr">startOffset</span>=<span class="string">&quot;12&quot;</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">TwoWay</span>&gt;</span>false<span class="tag">&lt;/<span class="name">TwoWay</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">ValueLocation</span> <span class="attr">endLine</span>=<span class="string">&quot;20&quot;</span> <span class="attr">endOffset</span>=<span class="string">&quot;55&quot;</span> <span class="attr">startLine</span>=<span class="string">&quot;20&quot;</span> <span class="attr">startOffset</span>=<span class="string">&quot;28&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">Expression</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Expressions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">location</span> <span class="attr">endLine</span>=<span class="string">&quot;20&quot;</span> <span class="attr">endOffset</span>=<span class="string">&quot;59&quot;</span> <span class="attr">startLine</span>=<span class="string">&quot;16&quot;</span> <span class="attr">startOffset</span>=<span class="string">&quot;8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Target</span> <span class="attr">id</span>=<span class="string">&quot;@+id/edit_address&quot;</span> <span class="attr">tag</span>=<span class="string">&quot;binding_2&quot;</span> <span class="attr">view</span>=<span class="string">&quot;EditText&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Expressions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Expression</span> <span class="attr">attribute</span>=<span class="string">&quot;android:text&quot;</span> <span class="attr">text</span>=<span class="string">&quot;viewModel.userField.address&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">Location</span> <span class="attr">endLine</span>=<span class="string">&quot;27&quot;</span> <span class="attr">endOffset</span>=<span class="string">&quot;57&quot;</span> <span class="attr">startLine</span>=<span class="string">&quot;27&quot;</span> <span class="attr">startOffset</span>=<span class="string">&quot;12&quot;</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">TwoWay</span>&gt;</span>true<span class="tag">&lt;/<span class="name">TwoWay</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">ValueLocation</span> <span class="attr">endLine</span>=<span class="string">&quot;27&quot;</span> <span class="attr">endOffset</span>=<span class="string">&quot;55&quot;</span> <span class="attr">startLine</span>=<span class="string">&quot;27&quot;</span> <span class="attr">startOffset</span>=<span class="string">&quot;29&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">Expression</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Expressions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">location</span> <span class="attr">endLine</span>=<span class="string">&quot;28&quot;</span> <span class="attr">endOffset</span>=<span class="string">&quot;13&quot;</span> <span class="attr">startLine</span>=<span class="string">&quot;23&quot;</span> <span class="attr">startOffset</span>=<span class="string">&quot;8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Targets</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Variables</span> <span class="attr">name</span>=<span class="string">&quot;viewModel&quot;</span> <span class="attr">declared</span>=<span class="string">&quot;true&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.steve.mvvmdemo.test.HomeViewModel&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">location</span> <span class="attr">endLine</span>=<span class="string">&quot;6&quot;</span> <span class="attr">endOffset</span>=<span class="string">&quot;58&quot;</span> <span class="attr">startLine</span>=<span class="string">&quot;4&quot;</span> <span class="attr">startOffset</span>=<span class="string">&quot;8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Variables</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Layout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再看下activity_home.xml文件的内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line">                                                                   </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">                 </span><br><span class="line">                            </span><br><span class="line">                                                           </span><br><span class="line"></span><br><span class="line">           </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span> <span class="attr">android:tag</span>=<span class="string">&quot;layout/activity_home_0&quot;</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--单向绑定@--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/nick_name&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:tag</span>=<span class="string">&quot;binding_1&quot;</span>                       /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--双向绑定@=--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/edit_address&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:tag</span>=<span class="string">&quot;binding_2&quot;</span>                       </span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">         </span><br></pre></td></tr></table></figure><ul><li>它会把layout标签去掉，然后在每个标签下打上tag</li></ul><p>rebuild后发生了啥</p><p><img src="/../images/image-20220516122508848.png" alt="image-20220516122508848"></p><p>2.从setContentView开始看源码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.必须先ReBuilder 2.书写代码绑定</span></span><br><span class="line"><span class="keyword">val</span> contentView = DataBindingUtil.setContentView&lt;ActivityLoginBinding&gt;(<span class="keyword">this</span>, R.layout.activity_login)</span><br></pre></td></tr></table></figure><p>Databinding为什么还要去setContentView</p><p><img src="file://../images/image-20220516122354494.png?lastModify=1652754461" alt="image-20220516122354494"></p><p>因为需要activity去获取根布局root 这样binding才能去更改布局刷新</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends ViewDataBinding&gt; <span class="function">T <span class="title">setContentView</span><span class="params">(<span class="meta">@NonNull</span> Activity activity,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> layoutId, <span class="meta">@Nullable</span> DataBindingComponent bindingComponent)</span> </span>&#123;</span><br><span class="line">    activity.setContentView(layoutId);</span><br><span class="line">    View decorView = activity.getWindow().getDecorView();</span><br><span class="line">    ViewGroup contentView = (ViewGroup) decorView.findViewById(android.R.id.content);</span><br><span class="line">    <span class="keyword">return</span> bindToAddedViews(bindingComponent, contentView, <span class="number">0</span>, layoutId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>activity.getWindow().getDecorView() 获取根布局view 由decorView 获取contentView 然后发生bind绑定，执行bindToAddedViews</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T extends ViewDataBinding&gt; <span class="function">T <span class="title">bindToAddedViews</span><span class="params">(DataBindingComponent component,</span></span></span><br><span class="line"><span class="params"><span class="function">        ViewGroup parent, <span class="keyword">int</span> startChildren, <span class="keyword">int</span> layoutId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> endChildren = parent.getChildCount();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childrenAdded = endChildren - startChildren;</span><br><span class="line">    <span class="keyword">if</span> (childrenAdded == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> View childView = parent.getChildAt(endChildren - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> bind(component, childView, layoutId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> View[] children = <span class="keyword">new</span> View[childrenAdded];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childrenAdded; i++) &#123;</span><br><span class="line">            children[i] = parent.getChildAt(i + startChildren);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bind(component, children, layoutId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>所有的view子view都会执行bind函数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T extends ViewDataBinding&gt; <span class="function">T <span class="title">bind</span><span class="params">(DataBindingComponent bindingComponent, View[] roots,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> layoutId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (T) sMapper.getDataBinder(bindingComponent, roots, layoutId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getDataBinder 是一个抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DataBinderMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ViewDataBinding <span class="title">getDataBinder</span><span class="params">(DataBindingComponent bindingComponent, View view,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">int</span> layoutId)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ViewDataBinding <span class="title">getDataBinder</span><span class="params">(DataBindingComponent bindingComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">            View[] view, <span class="keyword">int</span> layoutId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看它具体的实现类DataBinderMapperImpl 注意要找自己包名下的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataBinderMapperImpl</span> <span class="keyword">extends</span> <span class="title">DataBinderMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ViewDataBinding <span class="title">getDataBinder</span><span class="params">(DataBindingComponent component, View view, <span class="keyword">int</span> layoutId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> localizedLayoutId = INTERNAL_LAYOUT_ID_LOOKUP.get(layoutId);</span><br><span class="line">    <span class="keyword">if</span>(localizedLayoutId &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> Object tag = view.getTag();</span><br><span class="line">      <span class="keyword">if</span>(tag == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;view must have a tag&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">switch</span>(localizedLayoutId) &#123;</span><br><span class="line">        <span class="keyword">case</span>  LAYOUT_ACTIVITYHOME: &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="string">&quot;layout/activity_home_0&quot;</span>.equals(tag)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ActivityHomeBindingImpl(component, view);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;The tag for activity_home is invalid. Received: &quot;</span> + tag);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span>  LAYOUT_ACTIVITYLOGIN: &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="string">&quot;layout/activity_login_0&quot;</span>.equals(tag)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ActivityLoginBindingImpl(component, view);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;The tag for activity_login is invalid. Received: &quot;</span> + tag);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>之前说把所有的view都打上了tag 这里通过获取tag 开始匹配不同的bindingimpl，layout&#x2F;activity_home_0 和之前的xml中的LineanerLayout标签的tag对应上了，走ActivityHomeBindingImpl的构造方法的逻辑</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ActivityHomeBindingImpl</span><span class="params">(<span class="meta">@Nullable</span> androidx.databinding.DataBindingComponent bindingComponent, <span class="meta">@NonNull</span> View root)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(bindingComponent, root, mapBindings(bindingComponent, root, <span class="number">3</span>, sIncludes, sViewsWithIds));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ActivityHomeBindingImpl</span><span class="params">(androidx.databinding.DataBindingComponent bindingComponent, View root, Object[] bindings)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(bindingComponent, root, <span class="number">1</span></span><br><span class="line">        , (android.widget.EditText) bindings[<span class="number">2</span>]</span><br><span class="line">        , (android.widget.TextView) bindings[<span class="number">1</span>]</span><br><span class="line">        );</span><br><span class="line">    <span class="keyword">this</span>.editAddress.setTag(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">this</span>.mboundView0 = (android.widget.LinearLayout) bindings[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">this</span>.mboundView0.setTag(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">this</span>.nickName.setTag(<span class="keyword">null</span>);</span><br><span class="line">    setRootTag(root);</span><br><span class="line">    <span class="comment">// listeners</span></span><br><span class="line">    invalidateAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>第一个内存占用过高的原因来了，注意看</p></li><li><p>Object[] 这个对象数组缓存了控件，这块内存是额外的，通过执行mapBindings方法传入，我们看mapBindings怎么填充的这个对象数组</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mapBindings</span><span class="params">(DataBindingComponent bindingComponent, View view,</span></span></span><br><span class="line"><span class="params"><span class="function">        Object[] bindings, IncludedLayouts includes, SparseIntArray viewsWithIds,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">boolean</span> isRoot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> indexInIncludes;</span><br><span class="line">    <span class="keyword">final</span> ViewDataBinding existingBinding = getBinding(view);</span><br><span class="line">    <span class="keyword">if</span> (existingBinding != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Object objTag = view.getTag();</span><br><span class="line">    <span class="keyword">final</span> String tag = (objTag <span class="keyword">instanceof</span> String) ? (String) objTag : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> isBound = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (isRoot &amp;&amp; tag != <span class="keyword">null</span> &amp;&amp; tag.startsWith(<span class="string">&quot;layout&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> underscoreIndex = tag.lastIndexOf(<span class="string">&#x27;_&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (underscoreIndex &gt; <span class="number">0</span> &amp;&amp; isNumeric(tag, underscoreIndex + <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = parseTagInt(tag, underscoreIndex + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (bindings[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                bindings[index] = view;</span><br><span class="line">            &#125;</span><br><span class="line">            indexInIncludes = includes == <span class="keyword">null</span> ? -<span class="number">1</span> : index;</span><br><span class="line">            isBound = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            indexInIncludes = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag != <span class="keyword">null</span> &amp;&amp; tag.startsWith(BINDING_TAG_PREFIX)) &#123;</span><br><span class="line">        <span class="keyword">int</span> tagIndex = parseTagInt(tag, BINDING_NUMBER_START);</span><br><span class="line">        <span class="keyword">if</span> (bindings[tagIndex] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            bindings[tagIndex] = view;</span><br><span class="line">        &#125;</span><br><span class="line">        isBound = <span class="keyword">true</span>;</span><br><span class="line">        indexInIncludes = includes == <span class="keyword">null</span> ? -<span class="number">1</span> : tagIndex;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Not a bound view</span></span><br><span class="line">        indexInIncludes = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isBound) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> id = view.getId();</span><br><span class="line">        <span class="keyword">if</span> (id &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> index;</span><br><span class="line">            <span class="keyword">if</span> (viewsWithIds != <span class="keyword">null</span> &amp;&amp; (index = viewsWithIds.get(id, -<span class="number">1</span>)) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    bindings[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                bindings[index] = view;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (view <span class="keyword">instanceof</span>  ViewGroup) &#123;</span><br><span class="line">        <span class="keyword">final</span> ViewGroup viewGroup = (ViewGroup) view;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> count = viewGroup.getChildCount();</span><br><span class="line">        <span class="keyword">int</span> minInclude = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = viewGroup.getChildAt(i);</span><br><span class="line">            <span class="keyword">boolean</span> isInclude = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (indexInIncludes &gt;= <span class="number">0</span> &amp;&amp; child.getTag() <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                String childTag = (String) child.getTag();</span><br><span class="line">                <span class="keyword">if</span> (childTag.endsWith(<span class="string">&quot;_0&quot;</span>) &amp;&amp;</span><br><span class="line">                        childTag.startsWith(<span class="string">&quot;layout&quot;</span>) &amp;&amp; childTag.indexOf(<span class="string">&#x27;/&#x27;</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// This *could* be an include. Test against the expected includes.</span></span><br><span class="line">                    <span class="keyword">int</span> includeIndex = findIncludeIndex(childTag, minInclude,</span><br><span class="line">                            includes, indexInIncludes);</span><br><span class="line">                    <span class="keyword">if</span> (includeIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        isInclude = <span class="keyword">true</span>;</span><br><span class="line">                        minInclude = includeIndex + <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> index = includes.indexes[indexInIncludes][includeIndex];</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> layoutId = includes.layoutIds[indexInIncludes][includeIndex];</span><br><span class="line">                        <span class="keyword">int</span> lastMatchingIndex = findLastMatching(viewGroup, i);</span><br><span class="line">                        <span class="keyword">if</span> (lastMatchingIndex == i) &#123;</span><br><span class="line">                            bindings[index] = DataBindingUtil.bind(bindingComponent, child,</span><br><span class="line">                                    layoutId);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">final</span> <span class="keyword">int</span> includeCount =  lastMatchingIndex - i + <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">final</span> View[] included = <span class="keyword">new</span> View[includeCount];</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; includeCount; j++) &#123;</span><br><span class="line">                                included[j] = viewGroup.getChildAt(i + j);</span><br><span class="line">                            &#125;</span><br><span class="line">                            bindings[index] = DataBindingUtil.bind(bindingComponent, included,</span><br><span class="line">                                    layoutId);</span><br><span class="line">                            i += includeCount - <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isInclude) &#123;</span><br><span class="line">                mapBindings(bindingComponent, child, bindings, includes, viewsWithIds, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>对标签进行了解析，以layout开头的，以binding开头的 把view填充到object[]数组里</p></li><li><p>这样内存中就了textview edittext的副本，这是内存的额外开销</p></li></ul><p>这是第一个为什么内存大的原因</p><p>我们来看看M-V V-M更新的机制</p><p>ActivityHomeBinding继承自ViewDataBinding ，看下ViewDataBinding的static静态代码块初始都做了啥</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (VERSION.SDK_INT &lt; VERSION_CODES.KITKAT) &#123;</span><br><span class="line">        ROOT_REATTACHED_LISTENER = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ROOT_REATTACHED_LISTENER = <span class="keyword">new</span> OnAttachStateChangeListener() &#123;</span><br><span class="line">            <span class="meta">@TargetApi(VERSION_CODES.KITKAT)</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewAttachedToWindow</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// execute the pending bindings.</span></span><br><span class="line">                <span class="keyword">final</span> ViewDataBinding binding = getBinding(v);</span><br><span class="line">                binding.mRebindRunnable.run();</span><br><span class="line">                v.removeOnAttachStateChangeListener(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewDetachedFromWindow</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始就注册了一个对view attachtowindow的监听</p><p>binding.mRebindRunnable是个的Runnable</p><p>这是第二个为什么占内存的原因，因为每一个使用了databinding的界面都会生成一个这个Runnable，同时数据的双向绑定也是在这里完成的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable mRebindRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            mPendingRebind = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        processReferenceQueue();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (VERSION.SDK_INT &gt;= VERSION_CODES.KITKAT) &#123;</span><br><span class="line">            <span class="comment">// Nested so that we don&#x27;t get a lint warning in IntelliJ</span></span><br><span class="line">            <span class="keyword">if</span> (!mRoot.isAttachedToWindow()) &#123;</span><br><span class="line">                <span class="comment">// Don&#x27;t execute the pending bindings until the View</span></span><br><span class="line">                <span class="comment">// is attached again.</span></span><br><span class="line">                mRoot.removeOnAttachStateChangeListener(ROOT_REATTACHED_LISTENER);</span><br><span class="line">                mRoot.addOnAttachStateChangeListener(ROOT_REATTACHED_LISTENER);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        executePendingBindings();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>看下executePendingBindings最后会执行到protected abstract void executeBindings() 这是一个抽象类，我们看它在ActivityHomeBindingImpl的实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeBindings</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line">    <span class="comment">// batch finished</span></span><br><span class="line">    <span class="keyword">if</span> ((dirtyFlags &amp; <span class="number">0x7L</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// api target 1</span></span><br><span class="line"></span><br><span class="line">        androidx.databinding.adapters.TextViewBindingAdapter.setText(<span class="keyword">this</span>.editAddress, viewModelUserFieldAddress);</span><br><span class="line">        androidx.databinding.adapters.TextViewBindingAdapter.setText(<span class="keyword">this</span>.nickName, viewModelUserFieldNickName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((dirtyFlags &amp; <span class="number">0x4L</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// api target 1</span></span><br><span class="line"></span><br><span class="line">        androidx.databinding.adapters.TextViewBindingAdapter.setTextWatcher(<span class="keyword">this</span>.editAddress, (androidx.databinding.adapters.TextViewBindingAdapter.BeforeTextChanged)<span class="keyword">null</span>, (androidx.databinding.adapters.TextViewBindingAdapter.OnTextChanged)<span class="keyword">null</span>, (androidx.databinding.adapters.TextViewBindingAdapter.AfterTextChanged)<span class="keyword">null</span>, editAddressandroidTextAttrChanged);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>看到这里应该就明白了，UI和data是怎么双向绑定的</li></ul><p>那么还有一个内存过大的原因，我们看ActivityHomeBindingImpl的构造中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ActivityHomeBindingImpl</span><span class="params">(androidx.databinding.DataBindingComponent bindingComponent, View root, Object[] bindings)</span> </span>&#123;</span><br><span class="line">		...</span><br><span class="line">    <span class="comment">// listeners</span></span><br><span class="line">    invalidateAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这个invalidateAll会执行requestRebind函数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">requestRebind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mContainingBinding != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mContainingBinding.requestRebind();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> LifecycleOwner owner = <span class="keyword">this</span>.mLifecycleOwner;</span><br><span class="line">        <span class="keyword">if</span> (owner != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Lifecycle.State state = owner.getLifecycle().getCurrentState();</span><br><span class="line">            <span class="keyword">if</span> (!state.isAtLeast(Lifecycle.State.STARTED)) &#123;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// wait until lifecycle owner is started</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mPendingRebind) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingRebind = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (USE_CHOREOGRAPHER) &#123;</span><br><span class="line">            mChoreographer.postFrameCallback(mFrameCallback);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mUIThreadHandler.post(mRebindRunnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后这里给主线程发送消息,这也是内存开销之一</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/05/16/%E7%AB%9F%E7%84%B6%E5%A6%82%E6%AD%A4%E7%AE%80%E5%8D%95%EF%BC%8CDataBinding-%E5%92%8C-ViewBinding-%E8%BD%AC/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/05/16/%E7%AB%9F%E7%84%B6%E5%A6%82%E6%AD%A4%E7%AE%80%E5%8D%95%EF%BC%8CDataBinding-%E5%92%8C-ViewBinding-%E8%BD%AC/" class="post-title-link" itemprop="url">竟然如此简单，DataBinding 和 ViewBinding[转]</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-05-16 04:27:52" itemprop="dateCreated datePublished" datetime="2022-05-16T04:27:52+08:00">2022-05-16</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-05-17 11:51:37" itemprop="dateModified" datetime="2022-05-17T11:51:37+08:00">2022-05-17</time></span></div></header><div class="post-body" itemprop="articleBody"><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6913723416671420430">原文链接：竟然如此简单，DataBinding 和 ViewBinding</a></p><p>在之前的文章 <a target="_blank" rel="noopener" href="https://juejin.cn/post/6905942568467759111">Kotlin 插件的落幕，ViewBinding 的崛起</a> 中介绍了 Google 为什么不建议在项目中使用 Kotlin 合成方法（Synthetic 视图）， Google 建议使用 ViewBinding 替换 Kotlin 合成方法，那么 ViewBinding 和 DataBinding 都有什么区别。</p><p><strong>ViewBinding：</strong></p><ul><li>仅仅支持绑定 View</li><li>不需要在布局文件中添加 layout 标签</li><li>需要在模块级 <code>build.gradle</code> 文件中添加 <code>viewBinding = true</code> 即可使用</li><li>效率高于 DataBinding，因为避免了与数据绑定相关的开销和性能问题</li><li>相比于 <code>kotlin-android-extensions</code> 插件避免了空异常</li></ul><p><strong>DataBinding：</strong></p><ul><li>包含了 ViewBinding 所有的功能</li><li>需要在模块级 <code>build.gradle</code> 文件内添加 <code>dataBinding = true</code> 并且需要在布局文件中添加 layout 标签才可以使用</li><li>支持 data 和 view 双向绑定</li><li>效率低于 ViewBinding，因为注释处理器会影响数据绑定的构建时间。</li></ul><p>ViewBinding 可以实现的， DataBinding 都可以实现，但是 DataBinding 的性能低于 ViewBinding，DataBinding 和 ViewBinding 会为每个 XML 文件生成绑定类。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">R</span>.</span></span>layout.activity_main -&gt; ActivityMainBinding</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">R</span>.</span></span>layout.fragment_main -&gt; FragmentMainBinding</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">R</span>.</span></span>layout.dialog_app -&gt; DialogAppBinding</span><br></pre></td></tr></table></figure><p>在 <a target="_blank" rel="noopener" href="https://juejin.cn/post/6905942568467759111">Kotlin 插件的落幕，ViewBinding 的崛起</a> 文章中同时也分析了 Kotlin 合成方法所带来的问题。即使 Kotlin 合成方法有很多问题，但是还有小伙伴愿意使用。</p><p>ViewBinding 和 DataBinding 为我们解决了这么多问题，但是为什么很多小伙伴们不愿意使用 ViewBinding 和 DataBinding，今天我们从使用的角度来分析。</p><h2 id="ViewBinding-和-DataBinding"><a href="#ViewBinding-和-DataBinding" class="headerlink" title="ViewBinding 和 DataBinding"></a>ViewBinding 和 DataBinding</h2><p>我大概汇总了 ViewBinding 和 DataBinding 在不同场景的所有用法，我们来看一下在项目中如何使用。</p><p><strong>基本配置</strong></p><p>从 <code>Android Studio 3.6</code> 版本开始，就内置在 Gradle 插件中了，不需要添加任何额外的库来使用它们，但是在 <code>Android Studio 3.6</code> 和 <code>Android Studio 4.0</code> 中使用方式不一样。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Android Studio 3.6</span></span><br><span class="line">android &#123;</span><br><span class="line">    viewBinding &#123;</span><br><span class="line">        enabled = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    dataBinding&#123;</span><br><span class="line">        enabled = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Android Studio 4.0</span></span><br><span class="line">android &#123;</span><br><span class="line">    buildFeatures &#123;</span><br><span class="line">        dataBinding = <span class="literal">true</span></span><br><span class="line">        viewBinding = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ViewBinding-的使用"><a href="#ViewBinding-的使用" class="headerlink" title="ViewBinding 的使用"></a>ViewBinding 的使用</h3><p>因为涉及到的场景比较多，为了减少篇幅，我只列出来核心部分，如果之前从来没有用过，这里只需要知道 ViewBinding 的门槛比 Kotlin 合成方法要高即可。</p><p><strong>不想为某个布局生成 binding 类，将下面属性添加到布局文件的根视图中</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">tools:viewBindingIgnore</span>=<span class="string">&quot;true&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>在 Activity 中使用</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    <span class="keyword">val</span> binding: ActivityMainBinding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">    setContentView(binding.root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>在 Fragment 中使用</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?, savedInstanceState: <span class="type">Bundle</span>?)</span></span>: View &#123;</span><br><span class="line">    <span class="keyword">val</span> binding = FragmentViewBindBinding.inflate(inflater,container,<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">return</span> binding.root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在 Adapter 中的使用</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: RecyclerView.ViewHolder &#123;</span><br><span class="line">    RecycleItemProductBinding.inflate(LayoutInflater.from(parent.context), parent, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在 Dialog 中使用</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    binding = DialogAppBinding.inflate(layoutInflater)</span><br><span class="line">    setContentView(binding.root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>include 标签的使用</strong></p><p><code>include</code> 标签不带 <code>merge</code> 标签，需要给 <code>include</code> 标签添加 id, 直接使用 id 即可，用法如下所示。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">include</span></span><br><span class="line">    android:id=<span class="string">&quot;@+id/include&quot;</span></span><br><span class="line">    layout=<span class="string">&quot;@layout/layout_include_item&quot;</span> /&gt;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">val</span> binding: ActivityMainBinding = <span class="module-access"><span class="module"><span class="identifier">ActivityMainBinding</span>.</span></span>inflate(layoutInflater)</span><br><span class="line">binding.<span class="keyword">include</span>.includeTvTitle.set<span class="constructor">Text(<span class="string">&quot;使用 include 布局中的控件, 不包含 merge&quot;</span>)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>作者：DHL<br>链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6913723416671420430">https://juejin.cn/post/6913723416671420430</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>作者：DHL<br>链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6913723416671420430">https://juejin.cn/post/6913723416671420430</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>作者：DHL<br>链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6913723416671420430">https://juejin.cn/post/6913723416671420430</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/05/14/Jetpack%E7%B3%BB%E5%88%97%E2%80%94Lifecycle%E6%9E%84%E6%9E%B6%E7%BB%84%E4%BB%B6%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/05/14/Jetpack%E7%B3%BB%E5%88%97%E2%80%94Lifecycle%E6%9E%84%E6%9E%B6%E7%BB%84%E4%BB%B6%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">Jetpack系列—Lifecycle构架组件原理解析(更新中)</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-05-14 11:14:51" itemprop="dateCreated datePublished" datetime="2022-05-14T11:14:51+08:00">2022-05-14</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-05-17 11:51:37" itemprop="dateModified" datetime="2022-05-17T11:51:37+08:00">2022-05-17</time></span></div></header><div class="post-body" itemprop="articleBody"><ul><li>什么是Lifecycle</li><li>如何使用Lifecycle观察宿主状态</li><li>Fragment是如何实现Lifecycle的</li><li>Activity是如何实现Lifecycle的</li><li>Lifecycle是如何分发宿主状态的</li></ul><h2 id="什么是Lifecycle"><a href="#什么是Lifecycle" class="headerlink" title="什么是Lifecycle"></a>什么是Lifecycle</h2><ul><li>具备宿主生命周期感知能力的组件。它能持有组件(如Activty或Fragment)生命周期状态的信息，并且允许其他观察者监听宿主的状态</li></ul><h2 id="Lifecycle怎么使用"><a href="#Lifecycle怎么使用" class="headerlink" title="Lifecycle怎么使用"></a>Lifecycle怎么使用</h2><h3 id="自定义LifecycleObserver观察者"><a href="#自定义LifecycleObserver观察者" class="headerlink" title="自定义LifecycleObserver观察者"></a>自定义LifecycleObserver观察者</h3><ul><li>这种写法是为了避免在Activity或者Fragment中去覆写大量的生命周期函数回调，如onCreate onStart等，可以在自己的生命周期回调里去写逻辑，避免宿主太乱</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.自定义的LifecycleObserver观察者，用注解声明每个方法观察的宿主的状态，想感知哪个，就在哪个上加注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocationObserver</span> <span class="keyword">implements</span> <span class="title">LifecycleObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_START)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//开启定位</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_STOP)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//停止定位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.注册观察者，观察宿主生命周期状态变化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> <span class="meta">@org</span>.jetbrains.annotations.Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.注册观察者，观察宿主生命周期状态变化</span></span><br><span class="line">        getLifecycle().addObserver(<span class="keyword">new</span> LocationObserver());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Fragment和Activity是如何进行消息派发的？"><a href="#Fragment和Activity是如何进行消息派发的？" class="headerlink" title="Fragment和Activity是如何进行消息派发的？"></a>Fragment和Activity是如何进行消息派发的？</h2><h3 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h3><ol><li>实现LifecycleOwner接口，返回LifecycleRegistry</li><li>通过LifecycleRegistry在各生命周期进行派发</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fragment</span> <span class="keyword">implements</span> <span class="title">ComponentCallbacks</span>, <span class="title">OnCreateContextMenuListener</span>, <span class="title">LifecycleOwner</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ViewModelStoreOwner</span>, <span class="title">HasDefaultViewModelProviderFactory</span>, <span class="title">SavedStateRegistryOwner</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ActivityResultCaller</span> </span>&#123;</span><br><span class="line">          </span><br><span class="line">    LifecycleRegistry mLifecycleRegistry;</span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Lifecycle <span class="title">getLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mLifecycleRegistry;</span><br><span class="line">    &#125;</span><br><span class="line">          </span><br><span class="line">   	</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">performStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">        mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START);</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><ol><li>实现LifecycleOwner接口，实现getLifecycle方法，返回mLifecycleRegistry</li><li>并没有直接使用mLifecycleRegistry在各生命周期函数中进行派发，而是借助了一个透明的ReportFragment进行的</li><li>执行ReportFragment.injectIfNeededIn(this)，把自己挂载到Activity上</li><li>然后在对应的生命周期进行派出事件</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentActivity</span> <span class="keyword">extends</span> <span class="title">androidx</span>.<span class="title">core</span>.<span class="title">app</span>.<span class="title">ComponentActivity</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">        <span class="title">ContextAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">LifecycleOwner</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ViewModelStoreOwner</span>,</span></span><br><span class="line"><span class="class">        <span class="title">HasDefaultViewModelProviderFactory</span>,</span></span><br><span class="line"><span class="class">        <span class="title">SavedStateRegistryOwner</span>,</span></span><br><span class="line"><span class="class">        <span class="title">OnBackPressedDispatcherOwner</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ActivityResultRegistryOwner</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ActivityResultCaller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Lifecycle <span class="title">getLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mLifecycleRegistry;</span><br><span class="line">    &#125;</span><br><span class="line">          </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        ReportFragment.injectIfNeededIn(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (mContentLayoutId != <span class="number">0</span>) &#123;</span><br><span class="line">            setContentView(mContentLayoutId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReportFragment</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">app</span>.<span class="title">Fragment</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//把自己添加到Activity上</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectIfNeededIn</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">29</span>) &#123;</span><br><span class="line">            <span class="comment">// On API 29+, we can register for the correct Lifecycle callbacks directly</span></span><br><span class="line">            LifecycleCallbacks.registerIn(activity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Prior to API 29 and to maintain compatibility with older versions of</span></span><br><span class="line">        <span class="comment">// ProcessLifecycleOwner (which may not be updated when lifecycle-runtime is updated and</span></span><br><span class="line">        <span class="comment">// need to support activities that don&#x27;t extend from FragmentActivity from support lib),</span></span><br><span class="line">        <span class="comment">// use a framework fragment to get the correct timing of Lifecycle events</span></span><br><span class="line">        android.app.FragmentManager manager = activity.getFragmentManager();</span><br><span class="line">        <span class="keyword">if</span> (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            manager.beginTransaction().add(<span class="keyword">new</span> ReportFragment(), REPORT_FRAGMENT_TAG).commit();</span><br><span class="line">            <span class="comment">// Hopefully, we are the first to make a transaction.</span></span><br><span class="line">            manager.executePendingTransactions();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        dispatchStart(mProcessListener);</span><br><span class="line">        dispatch(Lifecycle.Event.ON_START);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(<span class="meta">@NonNull</span> Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="number">29</span>) &#123;</span><br><span class="line">            <span class="comment">// Only dispatch events from ReportFragment on API levels prior</span></span><br><span class="line">            <span class="comment">// to API 29. On API 29+, this is handled by the ActivityLifecycleCallbacks</span></span><br><span class="line">            <span class="comment">// added in ReportFragment.injectIfNeededIn</span></span><br><span class="line">            dispatch(getActivity(), event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//真正派发的地方法 获取所在activity的LifecycleRegistry 这就是为什么ComponentActivity要实现LifecycleOnwer接口</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(<span class="meta">@NonNull</span> Activity activity, <span class="meta">@NonNull</span> Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleRegistryOwner) &#123;</span><br><span class="line">            ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleOwner) &#123;</span><br><span class="line">            Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();</span><br><span class="line">            <span class="keyword">if</span> (lifecycle <span class="keyword">instanceof</span> LifecycleRegistry) &#123;</span><br><span class="line">                ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么要这么做？</p><p>这是一种切面的方式，为了兼容不是继承AppcompactActivity的Activity,而是直接继承Activity这个类的，在LifecycleDispatcher这个类里，通过注册Ativity的生命周期回调，实现DispatchActivityCallback，然后在回调的onActivityCreated方法内执行ReportFragment.injectIfNeededIn(this); 这样每个继承自Activity的也同样可以进行生命周期事件的派发了</p></blockquote><h3 id="LifecycleOwner、Lifecycle、LifecycleRegistry的关系"><a href="#LifecycleOwner、Lifecycle、LifecycleRegistry的关系" class="headerlink" title="LifecycleOwner、Lifecycle、LifecycleRegistry的关系"></a>LifecycleOwner、Lifecycle、LifecycleRegistry的关系</h3><p><img src="/../images/image-20220514122303160.png" alt="image-20220514122303160"></p><h2 id="LifecycleRestry事件分发的源码"><a href="#LifecycleRestry事件分发的源码" class="headerlink" title="LifecycleRestry事件分发的源码"></a>LifecycleRestry事件分发的源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleRegistry</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(<span class="meta">@NonNull</span> LifecycleObserver observer)</span> </span>&#123;</span><br><span class="line">        enforceMainThreadIfNeeded(<span class="string">&quot;addObserver&quot;</span>);</span><br><span class="line">      	<span class="comment">//宿主的状态，和宿主的生命周期不是一个概念</span></span><br><span class="line">      	<span class="comment">//切换到后台后，会执行onPause()但是状态是started状态，因为State这个枚举中并没有Paused的状态，只到started状态后面是Resumed状态</span></span><br><span class="line">        State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;</span><br><span class="line">        ObserverWithState statefulObserver = <span class="keyword">new</span> ObserverWithState(observer, initialState);</span><br><span class="line">        ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);</span><br><span class="line"></span><br><span class="line">      	...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行addObserver方法的可能在onCreate在onStart在onResume都可以，只要不是在onDestroy，都把宿主状态初始为INTIALIZED状态</p><p>把initialState包装成ObserverWithState即为带有状态的观察者</p><p><strong>宿主的生命周期和宿主状态模型图</strong></p><ul><li><p>前进状态：执行onCreate方法变为CREATED状态，执行onStart方法后，变为STARTED状态，执行onResume方法后，变为RESUMED状态，这是前进状态</p></li><li><p>倒退状态：执行onPause方法后，由RESUMED状态倒退到STARTED状态，执行onSop方法后，由STARTED状态倒退到CREATED状态，这是倒退的状态</p></li></ul><p><img src="/../images/image-20220515112325695.png" alt="image-20220515112325695"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(<span class="meta">@NonNull</span> LifecycleObserver observer)</span> </span>&#123;</span><br><span class="line">    enforceMainThreadIfNeeded(<span class="string">&quot;addObserver&quot;</span>);</span><br><span class="line">...</span><br><span class="line">    State targetState = calculateTargetState(observer);</span><br><span class="line">    mAddingObserverCounter++;</span><br><span class="line">    <span class="keyword">while</span> ((statefulObserver.mState.compareTo(targetState) &lt; <span class="number">0</span></span><br><span class="line">            &amp;&amp; mObserverMap.contains(observer))) &#123;</span><br><span class="line">        pushParentState(statefulObserver.mState);</span><br><span class="line">        <span class="keyword">final</span> Event event = Event.upFrom(statefulObserver.mState);</span><br><span class="line">        <span class="keyword">if</span> (event == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;no event up from &quot;</span> + statefulObserver.mState);</span><br><span class="line">        &#125;</span><br><span class="line">        statefulObserver.dispatchEvent(lifecycleOwner, event);</span><br><span class="line">        popParentState();</span><br><span class="line">        <span class="comment">// mState / subling may have been changed recalculate</span></span><br><span class="line">        targetState = calculateTargetState(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isReentrance) &#123;</span><br><span class="line">        <span class="comment">// we do sync only on the top level.</span></span><br><span class="line">        sync();</span><br><span class="line">    &#125;</span><br><span class="line">    mAddingObserverCounter--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Event <span class="title">upFrom</span><span class="params">(<span class="meta">@NonNull</span> State state)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">    <span class="keyword">case</span> INITIALIZED:</span><br><span class="line">      <span class="keyword">return</span> ON_CREATE;</span><br><span class="line">    <span class="keyword">case</span> CREATED:</span><br><span class="line">      <span class="keyword">return</span> ON_START;</span><br><span class="line">    <span class="keyword">case</span> STARTED:</span><br><span class="line">      <span class="keyword">return</span> ON_RESUME;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchEvent</span><span class="params">(LifecycleOwner owner, Event event)</span> </span>&#123;</span><br><span class="line">  State newState = event.getTargetState();</span><br><span class="line">  mState = min(mState, newState);</span><br><span class="line">  mLifecycleObserver.onStateChanged(owner, event);</span><br><span class="line">  mState = newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> State <span class="title">getTargetState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> ON_CREATE:</span><br><span class="line">    <span class="keyword">case</span> ON_STOP:</span><br><span class="line">      <span class="keyword">return</span> State.CREATED;</span><br><span class="line">    <span class="keyword">case</span> ON_START:</span><br><span class="line">    <span class="keyword">case</span> ON_PAUSE:</span><br><span class="line">      <span class="keyword">return</span> State.STARTED;</span><br><span class="line">    <span class="keyword">case</span> ON_RESUME:</span><br><span class="line">      <span class="keyword">return</span> State.RESUMED;</span><br><span class="line">    <span class="keyword">case</span> ON_DESTROY:</span><br><span class="line">      <span class="keyword">return</span> State.DESTROYED;</span><br><span class="line">    <span class="keyword">case</span> ON_ANY:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="keyword">this</span> + <span class="string">&quot; has no target state&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个while循环很重要，这个循环会把宿主由初始状态INITIALIZED 前进到当前宿主应有的生命周期状态可能是STARTED也可能是RESUMED的</p><ol><li>先通过calculateTargetState(observer)拿到宿主的当前状态，比如宿主在onResume中注册的addObserver方法，那它当前<strong>应该</strong>的状态是RESUMED</li><li>通过比较当前状态和当前应该处于的状态statefulObserver.mState.compareTo(targetState)小于0代表状态还没有前进到，比如第一次状态肯定是INITIALIZED而宿主应该处于是RESUMED，所以执行while循环</li><li>final Event event &#x3D; Event.upFrom(statefulObserver.mState)由当前状态获取应该执行的生周期事件，得知要执行的事件是ON_CREATE</li><li>执行 statefulObserver.dispatchEvent(lifecycleOwner, event)</li><li>先由event.getTargetState() 事件获取newState，比如当前是ON_CREATE 得到CREATED</li><li>mState &#x3D; newState赋值当前状态为新的状态，这样再去while中比较</li></ol><p>这样就会把当前RESUMED之前的事件都派发给宿主，而不是在于它在哪里进行了注册，宿主会收到一个完整的生命周期事件，进行注册等操作</p><p><img src="/../images/image-20220515114041728.png" alt="image-20220515114041728"></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/05/13/%E8%81%8A%E8%81%8AWebSocket%E5%8F%8AOkHttp%E5%AE%9E%E7%8E%B0WebSocket/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/05/13/%E8%81%8A%E8%81%8AWebSocket%E5%8F%8AOkHttp%E5%AE%9E%E7%8E%B0WebSocket/" class="post-title-link" itemprop="url">聊聊WebSocket及OkHttp实现WebSocket</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-05-13 18:43:51" itemprop="dateCreated datePublished" datetime="2022-05-13T18:43:51+08:00">2022-05-13</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-05-17 11:51:37" itemprop="dateModified" datetime="2022-05-17T11:51:37+08:00">2022-05-17</time></span></div></header><div class="post-body" itemprop="articleBody"><p>OkHttp应该算是Android中使用最广泛的网络库了，我们通常会利用它来实现HTTP请求，但是实际上它还可以支持WebSocket，并且使用起来还非常的便捷。那本文就来聊聊，利用OkHttp实现WebSocket的一些细节，包括对WebSocket的介绍，以及在传输如何做鉴权、长连接保活及其原理。</p><h2 id="1-WebSocket"><a href="#1-WebSocket" class="headerlink" title="1.WebSocket"></a>1.WebSocket</h2><h3 id="1-1-为什么使用WebSocket"><a href="#1-1-为什么使用WebSocket" class="headerlink" title="1.1 为什么使用WebSocket?"></a>1.1 为什么使用WebSocket?</h3><p>我们做客户端开发时，接触最多的应用层网络协议，就是HTTP协议，而今天介绍的<code>WebSocket</code>，下层和<code>HTTP</code>一样也是基于<code>TCP</code>协议，这是一种轻量级网络通信协议，也属于应用层协议。</p><p><code>WebSocket</code>与<code>HTTP2</code> 一样，其实都是为了解决<code>HTTP1.1</code>的一些缺陷而诞生的，而<code>WebSocket</code>针对的就是<code>「请求-应答」</code>这种<code>「半双工」</code>的模式的通信缺陷。</p><p><code>「请求-应答」</code>是半双工的通信模式，数据的传输必须经过一次请求应答，这个完整的通信过程，通信的同一时刻数据只能在一个方向上传递。它最大的问题在于，HTTP是一种被动的模式，服务端必须等待客户端请求才可以返回数据，无法主动向客户端发送数据。</p><p>这也导致在<code>WebSocket</code>出现之前，一些对实时性有要求的服务，通常是基于轮询这种简单的模式来实现。轮询就是由客户端定时发起请求，如果服输端有需要传递的数据，可以借助这个请求去响应数据。</p><p>轮询的缺点也非常明显，大量空闲的时间，其实是在反复发送无效的请求，这显然是一种资源的损耗。</p><p>虽然在之后的<code>HTTP2</code> <code>HTTP3</code>中针对这种半双工的缺陷新增了<code>Stream</code> <code>Server</code> <code>Push</code>等特性，但是’请求-应答’依然是<code>HTTP</code>协议请要的通信方式。</p><p><code>WebSocket</code>协议是由<code>HTML5</code>规范定义的，原本是为了浏览器而设计的，可以避免同源的限制，浏览器可以与任意服务端通信，现代浏览器基本上都已经支持<code>WebSocket</code>。</p><p>虽然WebSocket原本是被定义在<code>HTML5</code>中，但它也适用于移动端，尽管移动端也可以直接通过<code>Socket</code>与服务端通信，但借助<code>WebSocket</code>，可以利用<code>80（HTTP）</code>或<code>443（HTTPS）</code>端口通信，有效的避免一些防火墙的拦截。</p><p><code>WebSocket</code>是真正意义上的<code>全双工模式</code>，也就我们俗称的<code>‘长连接’</code>。当完成握手连接后，客户端和服务端均可以主动的发起请求，回复响应，并且两边的传输都是相互独立的。</p><h3 id="1-2-WebSocket的特点"><a href="#1-2-WebSocket的特点" class="headerlink" title="1.2 WebSocket的特点"></a>1.2 WebSocket的特点</h3><p><code>WebSocket</code>的数据传输，是基于<code>TCP</code>协议，但是在传输之前，还有一个握手的过程，双方确认过眼神，才能够正式的传输数据。</p><p><code>WebSocket</code>的握手过程，符合其<code>‘Web’</code>的特性，是利用<code>HTTP</code>本身的<code>‘协议升级’</code>来实现。</p><p>在建立连接前，客户端还需要知道服务端的地址，WebSocket并没有另辟路径，而是沿用了HTTP的URL格式，但协议标识变成了<code>‘ws’</code>或者<code>‘wss’</code>，分别表示明文加密的<code>WebSocket</code>协议，这一点和<code>HTTP</code>和<code>HTTPS</code>的关系类似。</p><p>以下是一些WebSocket的URL例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws://cxmydev.com/some/path</span><br><span class="line">ws://cxmydev.com:8080/some/path</span><br><span class="line">wss://cxmydev.com:443?uid=xxx</span><br></pre></td></tr></table></figure><p>而在连接建立后，<code>WebSocket</code>采用二进制帧的形式传输数据，其中常用的包括用于数据传输的数据帧<code>MESSAGE</code>以及3个<code>控制帧</code>：</p><ul><li><code>PING</code>:主动保活的PING帧</li><li><code>PONG</code>：收到PING帧后回复</li><li><code>CLOSE</code>：主动关闭WebSocket连接</li></ul><p>小结下<code>WebSocket</code>特性：</p><ol><li><code>WebSocket</code>建立在TCP协议之上，对服务端友好。</li><li>默认端口采用80或443，握手阶段采用HTTP协议，不容易被防火墙屏蔽，能够通过各种HTTP代理服务器。</li><li>传输数据相比HTTP更轻量，少了HTTP HEADER，性能开销更小，通信更高效。</li><li>通过MESSAGE帧发送数据，可以发送文本或者二进制数据，如果数据过大，会被分为多个MESSAGE帧发送。</li><li>WebSocket沿用HTTP的URL，协议标识符’ws’或‘wss’</li></ol><h3 id="1-3-WebSocket原理"><a href="#1-3-WebSocket原理" class="headerlink" title="1.3 WebSocket原理"></a>1.3 WebSocket原理</h3><p><code>WebSocket</code>在<code>TCP</code>连接建立后，还要通过<code>Http</code>进行一次握手，也就是通过<code>Http</code>发送一条<code>GET请求</code>消息给服务器，告诉服务器我要建立<code>WebSocket连接</code>了，你准备好哦，具体做法就是在头部信息中添加相关参数。然后服务器响应我知道了，并且将连接协议改成<code>WebSocket</code>，开始建立长连接。</p><p>这里贴上请求头和响应头信息，从网上找了一张图：</p><p><img src="/../images/image-20220514062147256.png" alt="image-20220514062147256"></p><p>简单说明下参数：</p><ul><li>URL一般是以<code>ws</code>或者<code>wss</code>开头，<code>ws</code>对应<code>Websocket</code>协议，<code>wss</code>对应在<code>TLS</code>之上的<code>WebSocket</code>。类似于<code>Http</code>和<code>Https</code>的关系。</li><li>请求方法为GET方法。</li><li><code>Connection:Upgrade</code>，表示客户端要连接升级，不用Http协议。</li><li><code>Upgrade:websocket</code>， 表示客户端要升级建立<code>Websocket</code>连接。</li><li><code>Sec-Websocket-Key:key</code>， 这个key是随机生成的，服务器会通过这个参数验证该请求是否有效。</li><li><code>Sec-WebSocket-Version:13</code>， websocket使用的版本，一般就是13。</li><li><code>Sec-webSocket-Extension:permessage-deflate</code>，客户端指定的一些扩展协议，比如这里<code>permessage-deflate</code>就是<code>WebSocket</code>的一种压缩协议。</li><li><code>响应码101,</code>表示响应协议升级，后续的数据交互都按照Upgradet指定的<code>WebSocket</code>协议来。</li></ul><h2 id="2-结合OkHttp使用WebSocket进行通信"><a href="#2-结合OkHttp使用WebSocket进行通信" class="headerlink" title="2.结合OkHttp使用WebSocket进行通信"></a>2.结合OkHttp使用WebSocket进行通信</h2><h3 id="2-1-添加OkHttp依赖"><a href="#2-1-添加OkHttp依赖" class="headerlink" title="2.1 添加OkHttp依赖"></a>2.1 添加OkHttp依赖</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation(<span class="string">&quot;com.squareup.okhttp3:okhttp:4.7.2&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-2-实现代码"><a href="#2-2-实现代码" class="headerlink" title="2.2 实现代码"></a>2.2 实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化WebSocket</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mWbSocketUrl = <span class="string">&quot;ws://echo.websocket.org&quot;</span>;</span><br><span class="line">    mClient = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">            .pingInterval(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">            .build();</span><br><span class="line">    Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">            .url(mWbSocketUrl)</span><br><span class="line">            .build();</span><br><span class="line">    mWebSocket = mClient.newWebSocket(request, <span class="keyword">new</span> WsListener());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要是配置了<code>OkHttp</code>的一些参数，以及<code>WebSocket</code>的连接地址。其中<code>newWebSocket</code>方法就是进行<code>WebSocket</code>的初始化和连接。</p><p>这里要注意的点是<code>pingInterval</code>方法的配置，这个方法主要是用来设置<code>WebSocket</code>连接的保活。 相信做过长连接的同学都知道，一个长连接一般要隔几秒发送一条消息告诉服务器我在线，而服务器也会回复一个消息表示收到了，这样就确认了连接正常，客户端和服务器端都在线。</p><p>如果服务器没有<code>按时收到</code>这个消息那么服务器可能就会<code>主动关闭</code>这个连接，节约资源。 客户端没有<code>正常收到</code>这个返回的消息，也会做一些类似<code>重连的操作</code>，所以这个保活消息非常重要。</p><p>我们称这个消息叫作<code>心跳包</code>，一般用<code>PING，PONG</code>表示，像乒乓球一样，一来一回。 所以这里的<code>pingInterval</code>就是设置心跳包发送的间隔时间，设置了这个方法之后，<code>OkHttp</code>就会自动帮我们发送心跳包事件，也就是<code>ping</code>包。当间隔时间到了，没有收到<code>pong</code>包的话，监听事件中的<code>onFailure</code>方法就会被调用，此时我们就可以进行断线重连。</p><p>但是由于实际业务需求不一样，以及<code>okhttp</code>中心跳包事件给予我们权限较少，所以我们也可以自己完成心跳包事件，即在<code>WebSocket</code>连接成功之后，开始定时发送<code>ping</code>包，在下一次发送<code>ping</code>包之前检查上一个<code>pong</code>包是否收到，如果没收到，就视为异常，开始断线重连。感兴趣的同学可以看看文末的相关源码。</p><p>建立连接后，我们就可以正常发送和读取消息了，也就是在上文<code>WsListener</code>监听事件中表现：</p><blockquote><p>在<code>Android</code>程序中，如果应用被系统<code>kill</code>了进程，这种我们是没办法告诉<code>Sever</code>端，结束连接的，所以心跳包是有必要的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//监听事件，用于收消息，监听连接的状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WsListener</span> <span class="keyword">extends</span> <span class="title">WebSocketListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClosed</span><span class="params">(<span class="meta">@NotNull</span> WebSocket webSocket, <span class="keyword">int</span> code, <span class="meta">@NotNull</span> String reason)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onClosed(webSocket, code, reason);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClosing</span><span class="params">(<span class="meta">@NotNull</span> WebSocket webSocket, <span class="keyword">int</span> code, <span class="meta">@NotNull</span> String reason)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onClosing(webSocket, code, reason);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(<span class="meta">@NotNull</span> WebSocket webSocket, <span class="meta">@NotNull</span> Throwable t, <span class="meta">@Nullable</span> Response response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onFailure(webSocket, t, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="meta">@NotNull</span> WebSocket webSocket, <span class="meta">@NotNull</span> String text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onMessage(webSocket, text);</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;客户端收到消息:&quot;</span> + text);</span><br><span class="line">        onWSDataChanged(DATE_NORMAL, text);</span><br><span class="line">       <span class="comment">//测试发消息</span></span><br><span class="line">        webSocket.send(<span class="string">&quot;我是客户端，你好啊&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="meta">@NotNull</span> WebSocket webSocket, <span class="meta">@NotNull</span> ByteString bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onMessage(webSocket, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(<span class="meta">@NotNull</span> WebSocket webSocket, <span class="meta">@NotNull</span> Response response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onOpen(webSocket, response);</span><br><span class="line">        Log.e(TAG,<span class="string">&quot;连接成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//发送String消息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">final</span> String message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mWebSocket != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mWebSocket.send(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送byte消息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">final</span> ByteString message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mWebSocket != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mWebSocket.send(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">//主动断开连接</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnect</span><span class="params">(<span class="keyword">int</span> code, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mWebSocket != <span class="keyword">null</span>)</span><br><span class="line">        mWebSocket.close(code, reason);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>这里要注意，回调的方法都是在子线程回调的，如果需要<code>更新UI</code>，需要切换到主线程。</p></blockquote><p>基本操作就这么多，还是很简单的吧，初始化<code>Websocket</code>——连接——连接成功——收发消息。</p><p>其中<code>WebSocket</code>类是一个操作接口，主要提供了以下<strong>几个方法</strong></p><ul><li><code>send(text: String)</code>发送一个String类型的消息</li><li><code>send(bytes: ByteString)</code> 发送一个二进制类型的消息</li><li><code>close(code: Int, reason: String?)</code>关闭WebSocket连接</li></ul><p>如果有同学想测试下<code>WebSocket</code>的功能但是又没有<strong>实际的服务器</strong>，怎么办呢？ 其实<code>OkHttp</code>官方有一个<code>MockWebSocket</code>服务，可以用来模拟服务端，下面我们一起试一下：</p><h3 id="2-3-模拟服务器"><a href="#2-3-模拟服务器" class="headerlink" title="2.3 模拟服务器"></a>2.3 模拟服务器</h3><p>首先集成<code>MockWebSocket</code>服务库：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;com.squareup.okhttp3:mockwebserver:4.7.2&#x27;</span></span><br></pre></td></tr></table></figure><p>然后就可以新建<code>MockWebServer</code>，并加入<code>MockResponse</code>作为接收消息的响应。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">MockWebServer mMockWebServer = <span class="keyword">new</span> MockWebServer();</span><br><span class="line">MockResponse response = <span class="keyword">new</span> MockResponse()</span><br><span class="line">        .withWebSocketUpgrade(<span class="keyword">new</span> WebSocketListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(<span class="meta">@NotNull</span> WebSocket webSocket, <span class="meta">@NotNull</span> Response response)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.onOpen(webSocket, response);</span><br><span class="line">                <span class="comment">//有客户端连接时回调</span></span><br><span class="line">                Log.e(TAG, <span class="string">&quot;服务器收到客户端连接成功回调：&quot;</span>);</span><br><span class="line">                mWebSocket = webSocket;</span><br><span class="line">                mWebSocket.send(<span class="string">&quot;我是服务器，你好呀&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="meta">@NotNull</span> WebSocket webSocket, <span class="meta">@NotNull</span> String text)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.onMessage(webSocket, text);</span><br><span class="line"></span><br><span class="line">                Log.e(TAG, <span class="string">&quot;服务器收到消息：&quot;</span> + text);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClosed</span><span class="params">(<span class="meta">@NotNull</span> WebSocket webSocket, <span class="keyword">int</span> code, <span class="meta">@NotNull</span> String reason)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.onClosed(webSocket, code, reason);</span><br><span class="line">                Log.e(TAG, <span class="string">&quot;onClosed：&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">mMockWebServer.enqueue(response);</span><br></pre></td></tr></table></figure><p>这里服务器端在收到客户端连接成功消息后，给客户端发送了一条消息。 要注意的是这段代码要在子线程执行，因为主线程不能进行网络操作。</p><p>然后就可以去初始化<code>Websocket</code>客户端了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取连接url，初始化websocket客户端</span></span><br><span class="line">String websocketUrl = <span class="string">&quot;ws://&quot;</span> + mMockWebServer.getHostName() + <span class="string">&quot;:&quot;</span> + mMockWebServer.getPort() + <span class="string">&quot;/&quot;</span>;</span><br><span class="line">WSManager.getInstance().init(websocketUrl);</span><br></pre></td></tr></table></figure><p>ok，运行项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//运行结果</span><br><span class="line">E/jimu: mWbSocketUrl=ws://localhost:38355/</span><br><span class="line">E/jimu: 服务器收到客户端连接成功回调：</span><br><span class="line">E/jimu: 连接成功！</span><br><span class="line">E/jimu: 客户端收到消息:我是服务器，你好呀</span><br><span class="line">E/jimu: 服务器收到消息：我是客户端，你好啊</span><br></pre></td></tr></table></figure><h3 id="2-4-WebSocket如何进行鉴权"><a href="#2-4-WebSocket如何进行鉴权" class="headerlink" title="2.4 WebSocket如何进行鉴权"></a>2.4 WebSocket如何进行鉴权</h3><p>接下来我们聊聊 <code>WebSocket</code> 连接的鉴权问题。</p><p>所谓鉴权，其实就是为了安全考虑，避免服务端启动 <code>WebSocket</code> 的连接服务后，任谁都可以连接，这肯定会引发一些安全问题。其次，服务端还需要将 <code>WebSocket</code> 的连接实体与一个真是的用户对应起来，否者业务无法保证了。</p><p>那么问题就回到了，<code>WebSocket</code> 通信的完整过程中，如何以及何时将一些业务数据传递给服务端？当然在 <code>WebSocket</code> 连接建立之后，立即给服务端发送一些鉴权的数据，必然是可以做到业务实现的，但是这样明显是不够优雅的。</p><p>前文提到，<code>WebSocket</code> 在握手阶段，使用的是 <code>HTTP</code> 的 “协议升级”，它本质上还是 <code>HTTP</code> 的报文头发送一些特殊的头数据，来完成协议升级。</p><p>例如在 <code>RealWebSocket</code> 中，就有构造 <code>Header</code> 的过程，如 <code>Upgrade</code>、<code>Connection</code> 等等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(OkHttpClient client)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">final</span> Request request = originalRequest.newBuilder()</span><br><span class="line">    .header(<span class="string">&quot;Upgrade&quot;</span>, <span class="string">&quot;websocket&quot;</span>)</span><br><span class="line">    .header(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;Upgrade&quot;</span>)</span><br><span class="line">    .header(<span class="string">&quot;Sec-WebSocket-Key&quot;</span>, key)</span><br><span class="line">    .header(<span class="string">&quot;Sec-WebSocket-Version&quot;</span>, <span class="string">&quot;13&quot;</span>)</span><br><span class="line">    .build();</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么实际我们在 <code>WebSocket</code> 阶段，也可以通过 <code>Header</code> 传输一些鉴权的数据，例如 <code>uid</code>、<code>token</code> 之类，具体方法就是在构造 <code>Request</code> 的时候，为其增加 <code>Header</code>，这里就不举例说明了。</p><p>另外 <code>WebSocket</code> 的 <code>URL</code> 也是可以携带参数的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wss://cxmydev.com:443?uid=xxx&amp;token=xxx</span><br></pre></td></tr></table></figure><h2 id="3-OkHttp-源码解读WebSocket连接过程及协议"><a href="#3-OkHttp-源码解读WebSocket连接过程及协议" class="headerlink" title="3.OkHttp 源码解读WebSocket连接过程及协议"></a>3.OkHttp 源码解读WebSocket连接过程及协议</h2><p><code>WebSocket</code>整个流程无非三个功能：连接，接收消息，发送消息。下面我们就从这<code>三个方面</code>分析下具体是怎么实现的。</p><h3 id="3-1-连接"><a href="#3-1-连接" class="headerlink" title="3.1 连接"></a>3.1 连接</h3><p>通过上面的代码我们得知，<code>WebSocket</code>连接是通过<code>newWebSocket</code>方法。直接点进去看这个方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newWebSocket</span><span class="params">(request: <span class="type">Request</span>, listener: <span class="type">WebSocketListener</span>)</span></span>: WebSocket &#123;</span><br><span class="line">  <span class="keyword">val</span> webSocket = RealWebSocket(</span><br><span class="line">      taskRunner = TaskRunner.INSTANCE,</span><br><span class="line">      originalRequest = request,</span><br><span class="line">      listener = listener,</span><br><span class="line">      random = Random(),</span><br><span class="line">      pingIntervalMillis = pingIntervalMillis.toLong(),</span><br><span class="line">      extensions = <span class="literal">null</span>, <span class="comment">// Always null for clients.</span></span><br><span class="line">      minimumDeflateSize = minWebSocketMessageToCompress</span><br><span class="line">  )</span><br><span class="line">  webSocket.connect(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">return</span> webSocket</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里做了两件事：</p><ul><li>初始化<code>RealWebSocket</code>，主要是设置了一些参数（比如<code>pingIntervalMillis</code>心跳包时间间隔，还有监听事件之类的）</li><li><code>connect</code>方法进行<code>WebSocket</code>连接</li></ul><p>继续查看connect方法：</p><h4 id="3-1-1-connect-WebSocket连接握手"><a href="#3-1-1-connect-WebSocket连接握手" class="headerlink" title="3.1.1 connect(WebSocket连接握手)"></a>3.1.1 connect(WebSocket连接握手)</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">connect</span><span class="params">(client: <span class="type">OkHttpClient</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">//***</span></span><br><span class="line">  <span class="keyword">val</span> webSocketClient = client.newBuilder()</span><br><span class="line">      .eventListener(EventListener.NONE)</span><br><span class="line">      .protocols(ONLY_HTTP1)</span><br><span class="line">      .build()</span><br><span class="line">  <span class="keyword">val</span> request = originalRequest.newBuilder()</span><br><span class="line">      .header(<span class="string">&quot;Upgrade&quot;</span>, <span class="string">&quot;websocket&quot;</span>)</span><br><span class="line">      .header(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;Upgrade&quot;</span>)</span><br><span class="line">      .header(<span class="string">&quot;Sec-WebSocket-Key&quot;</span>, key)</span><br><span class="line">      .header(<span class="string">&quot;Sec-WebSocket-Version&quot;</span>, <span class="string">&quot;13&quot;</span>)</span><br><span class="line">      .header(<span class="string">&quot;Sec-WebSocket-Extensions&quot;</span>, <span class="string">&quot;permessage-deflate&quot;</span>)</span><br><span class="line">      .build()</span><br><span class="line">  call = RealCall(webSocketClient, request, forWebSocket = <span class="literal">true</span>)</span><br><span class="line">  call!!.enqueue(<span class="keyword">object</span> : Callback &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>, response: <span class="type">Response</span>)</span></span> &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//得到数据流</span></span><br><span class="line">      <span class="keyword">val</span> streams: Streams</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        checkUpgradeSuccess(response, exchange)</span><br><span class="line">        streams = exchange!!.newWebSocketStreams()</span><br><span class="line">      &#125; </span><br><span class="line">      </span><br><span class="line">      <span class="comment">//***</span></span><br><span class="line">      <span class="comment">// Process all web socket messages.</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> name = <span class="string">&quot;<span class="variable">$okHttpName</span> WebSocket <span class="subst">$&#123;request.url.redact()&#125;</span>&quot;</span></span><br><span class="line">        initReaderAndWriter(name, streams)</span><br><span class="line">        listener.onOpen(<span class="keyword">this</span><span class="symbol">@RealWebSocket</span>, response)</span><br><span class="line">        loopReader()</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        failWebSocket(e, <span class="literal">null</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Websocket</code>连接需要一次<code>Http</code>协议的握手，然后才能把协议升级成<code>WebSocket</code>。所以这段代码就体现出这个功能了。</p><p>首先就<code>new</code>了一个用来进行<code>Http</code>连接的<code>request</code>，其中<code>Header</code>的参数就表示我要进行<code>WebSocket</code>连接了，参数解析如下：</p><ul><li><code>Connection:Upgrade</code>，表示客户端要连接升级</li><li><code>Upgrade:websocket</code>， 表示客户端要升级建立Websocket连接</li><li><code>Sec-Websocket-Key:key</code>， 这个key是随机生成的，服务器会通过这个参数验证该请求是否有效</li><li><code>Sec-WebSocket-Version:13</code>， websocket使用的版本，一般就是13</li><li><code>Sec-webSocket-Extension:permessage-deflate</code>，客户端指定的一些扩展协议，比如这里<code>permessage-deflate</code>就是<code>WebSocket</code>的一种压缩协议。</li></ul><p><code>Header</code>设置好之后，就调用了<code>call</code>的<code>enqueue</code>方法，这个方法大家应该都很熟悉吧，<code>OkHttp</code>里面对于<code>Http</code>请求的异步请求就是这个方法。 至此，握手结束，服务器返回<code>响应码101</code>，表示协议升级。</p><p>然后我们继续看看获取服务器响应之后又做了什么？ 在发送<code>Http</code>请求成功之后，<code>onResponse</code>响应方法里面主要表现为四个处理逻辑：</p><ul><li>将<code>Http</code>流转换成<code>WebSocket</code>流，得到<code>Streams</code>对象，这个流后面会转化成输入流和输出流，也就是进行发送和读取的操作流</li><li><code>listener.onOpen(this@RealWebSocket, response)</code>，回调了接口<code>WebSocketListener</code>的<code>onOpen</code>方法，告诉用户<code>WebSocket</code>已经连接</li><li><code>initReaderAndWriter(name, streams)</code></li><li><code>loopReader()</code></li></ul><p>前两个逻辑还是比较好理解，主要是后两个方法，我们分别解析下。 首先看<code>initReaderAndWriter</code>方法。</p><h4 id="3-1-2-initReaderAndWriter（初始化输入流输出流）"><a href="#3-1-2-initReaderAndWriter（初始化输入流输出流）" class="headerlink" title="3.1.2 initReaderAndWriter（初始化输入流输出流）"></a>3.1.2 initReaderAndWriter（初始化输入流输出流）</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RealWebSocket.kt</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">initReaderAndWriter</span><span class="params">(name: <span class="type">String</span>, streams: <span class="type">Streams</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> extensions = <span class="keyword">this</span>.extensions!!</span><br><span class="line">  synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">//***</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写数据，发送数据的工具类</span></span><br><span class="line">    <span class="keyword">this</span>.writer = WebSocketWriter()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置心跳包事件</span></span><br><span class="line">    <span class="keyword">if</span> (pingIntervalMillis != <span class="number">0L</span>) &#123;</span><br><span class="line">      <span class="keyword">val</span> pingIntervalNanos = MILLISECONDS.toNanos(pingIntervalMillis)</span><br><span class="line">      taskQueue.schedule(<span class="string">&quot;<span class="variable">$name</span> ping&quot;</span>, pingIntervalNanos) &#123;</span><br><span class="line">        writePingFrame()</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@schedule</span> pingIntervalNanos</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//***</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//***</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取数据的工具类</span></span><br><span class="line">  reader = WebSocketReader(     </span><br><span class="line">    ***</span><br><span class="line">    frameCallback = <span class="keyword">this</span>,</span><br><span class="line">    ***</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">writePingFrame</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="comment">//***</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    writer.writePing(ByteString.EMPTY)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">    failWebSocket(e, <span class="literal">null</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个方法主要干了两件事：</p><ul><li>实例化输出流输入流工具类，也就是<code>WebSocketWriter</code>和<code>WebSocketReader</code>，用来处理数据的收发。</li><li>设置心跳包事件。如果<code>pingIntervalMillis</code>参数不为0，就通过计时器，每隔<code>pingIntervalNanos</code>发送一个<code>ping</code>消息。其中<code>writePingFrame</code>方法就是发送了<code>ping</code>帧数据。</li></ul><h3 id="3-2-接收消息处理消息"><a href="#3-2-接收消息处理消息" class="headerlink" title="3.2 接收消息处理消息"></a>3.2 接收消息处理消息</h3><h4 id="3-2-1-loopReader"><a href="#3-2-1-loopReader" class="headerlink" title="3.2.1 loopReader"></a>3.2.1 loopReader</h4><p>接着看看这个<code>loopReader</code>方法是干什么的，看这个名字我们大胆猜测下，难道这个方法就是用来循环读取数据的？去代码里找找答案：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">loopReader</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (receivedCloseCode == -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// This method call results in one or more onRead* methods being called on this thread.</span></span><br><span class="line">    reader!!.processNextFrame()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码很简单，一个<code>while</code>循环，循环条件是<code>receivedCloseCode == -1</code>的时候，做的事情是<code>reader!!.processNextFrame()</code>方法。继续：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//WebSocketWriter.kt</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">processNextFrame</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">//读取头部信息</span></span><br><span class="line">  readHeader()</span><br><span class="line">  <span class="keyword">if</span> (isControlFrame) &#123;</span><br><span class="line">    <span class="comment">//如果是控制帧，读取控制帧内容</span></span><br><span class="line">    readControlFrame()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//读取普通消息内容</span></span><br><span class="line">    readMessageFrame()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取头部信息</span></span><br><span class="line"><span class="meta">@Throws(IOException::class, ProtocolException::class)</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">readHeader</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (closed) <span class="keyword">throw</span> IOException(<span class="string">&quot;closed&quot;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">//读取数据，获取数据帧的前8位</span></span><br><span class="line">    b0 = source.readByte() and <span class="number">0xff</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    source.timeout().timeout(timeoutBefore, TimeUnit.NANOSECONDS)</span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="comment">//***</span></span><br><span class="line">  <span class="comment">//获取数据帧的opcode（数据格式）</span></span><br><span class="line">  opcode = b0 and B0_MASK_OPCODE</span><br><span class="line">  <span class="comment">//是否为最终帧</span></span><br><span class="line">  isFinalFrame = b0 and B0_FLAG_FIN != <span class="number">0</span></span><br><span class="line">  <span class="comment">//是否为控制帧（指令）</span></span><br><span class="line">  isControlFrame = b0 and OPCODE_FLAG_CONTROL != <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//判断最终帧，获取帧长度等等</span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取控制帧（指令）</span></span><br><span class="line">  <span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">readControlFrame</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (frameLength &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">    source.readFully(controlFrameBuffer, frameLength)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">when</span> (opcode) &#123;</span><br><span class="line">    OPCODE_CONTROL_PING -&gt; &#123;</span><br><span class="line">    <span class="comment">//ping 帧</span></span><br><span class="line">      frameCallback.onReadPing(controlFrameBuffer.readByteString())</span><br><span class="line">    &#125;</span><br><span class="line">    OPCODE_CONTROL_PONG -&gt; &#123;</span><br><span class="line">      <span class="comment">//pong 帧</span></span><br><span class="line">      frameCallback.onReadPong(controlFrameBuffer.readByteString())</span><br><span class="line">    &#125;</span><br><span class="line">    OPCODE_CONTROL_CLOSE -&gt; &#123;</span><br><span class="line">      <span class="comment">//关闭 帧</span></span><br><span class="line">      <span class="keyword">var</span> code = CLOSE_NO_STATUS_CODE</span><br><span class="line">      <span class="keyword">var</span> reason = <span class="string">&quot;&quot;</span></span><br><span class="line">      <span class="keyword">val</span> bufferSize = controlFrameBuffer.size</span><br><span class="line">      <span class="keyword">if</span> (bufferSize == <span class="number">1L</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ProtocolException(<span class="string">&quot;Malformed close payload length of 1.&quot;</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bufferSize != <span class="number">0L</span>) &#123;</span><br><span class="line">        code = controlFrameBuffer.readShort().toInt()</span><br><span class="line">        reason = controlFrameBuffer.readUtf8()</span><br><span class="line">        <span class="keyword">val</span> codeExceptionMessage = WebSocketProtocol.closeCodeExceptionMessage(code)</span><br><span class="line">        <span class="keyword">if</span> (codeExceptionMessage != <span class="literal">null</span>) <span class="keyword">throw</span> ProtocolException(codeExceptionMessage)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//回调onReadClose方法</span></span><br><span class="line">      frameCallback.onReadClose(code, reason)</span><br><span class="line">      closed = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取普通消息</span></span><br><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">readMessageFrame</span><span class="params">()</span></span> &#123;</span><br><span class="line">  </span><br><span class="line">  readMessage()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (readingCompressedMessage) &#123;</span><br><span class="line">    <span class="keyword">val</span> messageInflater = <span class="keyword">this</span>.messageInflater</span><br><span class="line">        ?: MessageInflater(noContextTakeover).also &#123; <span class="keyword">this</span>.messageInflater = it &#125;</span><br><span class="line">    messageInflater.inflate(messageFrameBuffer)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (opcode == OPCODE_TEXT) &#123;</span><br><span class="line">    frameCallback.onReadMessage(messageFrameBuffer.readUtf8())</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    frameCallback.onReadMessage(messageFrameBuffer.readByteString())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码还是比较直观，这个<code>processNextFrame</code>其实就是读取数据用的，首先读取头部信息，获取数据帧的类型，判断是否为控制帧，再分别去读取控制帧数据或者普通消息帧数据。</p><h4 id="3-2-2-数据帧格式"><a href="#3-2-2-数据帧格式" class="headerlink" title="3.2.2 数据帧格式"></a>3.2.2 数据帧格式</h4><p>问题来了，什么是<strong>数据头部信息</strong>，什么是<strong>控制帧</strong>？ 这里就要说下<code>WebSocket</code>的数据帧了，先附上一个数据帧格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> 0 1 2 3 4 5 6 7    0 1 2 3 4 5 6 7  0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7</span><br><span class="line">+-+-+-+-+-------+  +-+-------------+ +-----------------------------+</span><br><span class="line">|F|R|R|R| OP    |  |M| LENGTH      |   Extended payload length</span><br><span class="line">|I|S|S|S| CODE  |  |A|             |  （if LENGTH=126）</span><br><span class="line">|N|V|V|V|       |  |S|             |</span><br><span class="line">| |1|2|3|       |  |K|             |</span><br><span class="line">+-+-+-+-+-------+  +-+-------------+</span><br><span class="line">|                      Extended payload length（if LENGTH=127）</span><br><span class="line">+                                  +-------------------------------</span><br><span class="line">|      Extended payload length     | Masking-key，if Mask set to 1</span><br><span class="line">+----------------------------------+-------------------------------</span><br><span class="line">|   Masking-key                    |       Data</span><br><span class="line">+----------------------------------+-------------------------------</span><br><span class="line">|                                Data</span><br><span class="line">+----------------------------------+-------------------------------</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我承认，我懵逼了。 冷静冷静，一步一步分析下吧。</p><p>首先每一行代表4个字节，一共也就是32位数，哦，那也就是几个字节而已嘛，每个字节有他自己的代表意义呗，这样想是不是就很简单了，下面来具体看看每个字节。</p><p><strong>第1个字节：</strong></p><ul><li>第一位是<code>FIN码</code>，其实就是一个标示位，因为数据可能多帧操作嘛，所以多帧情况下，只有最后一帧的<code>FIN</code>设置成1，标示结束帧，前面所有帧设置为0。</li><li>第二位到第四位是<code>RSV码</code>，一般通信两端没有设置自定义协议，就默认为0。</li><li>后四位是<code>opcode</code>，我们叫它操作码。这个就是判断这个数据帧的类型了，一般有以下几个被定义好的类型：</li></ul><p>1） <code>0x0</code> 表示附加数据帧<br>2） <code>0x1</code> 表示文本数据帧<br>3） <code>0x2</code> 表示二进制数据帧<br>4） <code>0x3-7</code> 保留用于未来的非控制帧<br>5） <code>0x8</code> 表示连接关闭<br>6） <code>0x9</code> 表示ping<br>7） <code>0xA</code> 表示pong<br>8） <code>0xB-F</code> 保留用于未来的非控制帧</p><p>是不是发现了些什么，这不就对应了我们应用中的几种格式吗？<code>2和3</code>对应的是普通消息帧，包括了文本和二进制数据。<code>567</code>对应的就是控制帧格式，包括了<code>close，ping，pong</code>。</p><p><strong>第2个字节：</strong></p><ul><li>第一位是<code>Mask</code>掩码，其实就是标识数据是否加密混淆，1代表数据经过掩码的，0是没有经过掩码的，如果是1的话，后续就会有4个字节代表<code>掩码key</code>，也就是数据帧中<code>Masking-key</code>所处的位置。</li><li>后7位是<code>LENGTH</code>，用来标示数据长度。因为只有7位，所以最大只能储存1111111对应的十进制数<code>127长度</code>的数据，如果需要更大的数据，这个储存长度肯定就不够了。 <strong>所以规定来了</strong>，1) <code>小于126长度</code>则数据用这七位表示实际长度。2) 如果长度<code>设置为126</code>，也就是二进制1111110，就代表取<code>额外2个字节</code>表示数据长度，共是16位表示数据长度。3) 如果长度<code>设置为127</code>，也就是二进制1111111，就代表取<code>额外8个字节</code>，共是64位表示数据长度。</li></ul><blockquote><p>需要注意的是LENGHT的三种情况在一个数据帧里面只会出现一种情况，不共存，所以在图中是用<strong>if</strong>表示。同样的，Masking-key也是当Mask为1的时候才存在。</p></blockquote><p>所以也就有了数据帧里面的<code>Extended payload length（LENGTH=126）</code>所处的2个字节，以及<code>Extended payload length（LENGTH=127）</code>所处的8个字节。</p><p>最后的字节部分自然就是<code>掩码key</code>（Mask为1的时候才存在）和具体的<code>传输数据</code>了。<br>还是有点晕吧😷，来张图总结下： <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/13/173476f65b9b0001~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.image" alt="数据帧格式.jpeg"></p><p>好了，了解了<strong>数据帧格式</strong>后，我们再来读源码就清晰多了。 先看看怎么读的<code>头部信息</code>并解析的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取数据帧前8位数据</span></span><br><span class="line">b0 = source.readByte() and <span class="number">0xff</span></span><br><span class="line"><span class="comment">//获取数据帧的opcode（数据格式）</span></span><br><span class="line">opcode = b0 and B0_MASK_OPCODE（<span class="number">15</span>）</span><br><span class="line"><span class="comment">//是否为最终帧</span></span><br><span class="line">isFinalFrame = b0 and B0_FLAG_FIN（<span class="number">128</span>） != <span class="number">0</span></span><br><span class="line"><span class="comment">//是否为控制帧（指令）</span></span><br><span class="line">isControlFrame = b0 and OPCODE_FLAG_CONTROL（<span class="number">8</span>） != <span class="number">0</span>  </span><br></pre></td></tr></table></figure><ul><li>第一句获取头信息，<code>and</code>是按位与计算，<code>and 0xff</code>意思就是按位与11111111，所以头部信息其实就是取了数据帧的<code>前8位数据</code>，一个字节。</li><li>第二句获取<code>opcode</code>，<code>and 15</code>也就是按位与00001111，其实也就是取了后四位数据，刚好对应上<code>opcode</code>的位置，第一个字节的后四位。</li><li>第三句获取是否为<code>最终帧</code>，刚才数据帧格式中说过，第一位<code>FIN</code>标识了是否为最后一帧数据，1代表结束帧，所以这里<code>and 128</code>也就是按位与10000000，也就是取的第一位数。</li><li>第四句获取是否为控制帧，<code>and 8</code>也就是按位与00001000，取得是第五位，也就是<code>opcode</code>的第一位，这是什么意思呢？我们看看刚才的数据帧格式，发现从<code>0x8</code>开始就是所谓的控制帧了。<code>0x8</code>对应的二进制是1000，<code>0x7</code>对应的二进制是0111。发现了吧，如果为控制帧的时候，<code>opcode</code>第一位肯定是为1的，所以这里就判断的第五位。</li></ul><p>后面还有读取第二个字节的代码，大家可以自己沿着这个思路自己看看，包括了读取<code>MASK</code>，读取数据长度的三种长度等。</p><p>所以这个<code>processNextFrame</code>方法主要做了三件事：</p><ul><li><code>readHeader</code>方法中，判断了是否为控制帧，是否为<code>结束帧</code>，然后获取了<code>Mask</code>标识，帧长度等参数</li><li><code>readControlFrame</code>方法中，主要处理了该帧数据为<code>ping，pong，close</code>三种情况，并且在收到<code>close关闭帧</code>的情况下，回调了<code>onReadClose</code>方法，这个待会要细看下。</li><li><code>readMessageFrame</code>方法中，主要是读取了消息后，回调了onReadMessage方法。</li></ul><p>至此可以发现，其实<code>WebSocket</code>传输数据并不是一个简单的事，只是<code>OkHttp</code>都帮我们封装好了，我们只需要直接传输数据即可，感谢这些三方库为我们开发作出的贡献，不知道什么时候我也能做出点贡献呢🤔。</p><p>对了，刚才说回调也很重要，接着看看。<code>onReadClose</code>和<code>onReadMessage</code>回调到哪了呢？还记得上文初始化<code>WebSocketWriter</code>的时候设置了回调接口吗。所以就是回调给<code>RealWebSocket</code>了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RealWebSocket.kt</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onReadClose</span><span class="params">(code: <span class="type">Int</span>, reason: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">  require(code != -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> toClose: Streams? = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">var</span> readerToClose: WebSocketReader? = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">var</span> writerToClose: WebSocketWriter? = <span class="literal">null</span></span><br><span class="line">  synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">    check(receivedCloseCode == -<span class="number">1</span>) &#123; <span class="string">&quot;already closed&quot;</span> &#125;</span><br><span class="line">    receivedCloseCode = code</span><br><span class="line">    receivedCloseReason = reason </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    listener.onClosing(<span class="keyword">this</span>, code, reason)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (toClose != <span class="literal">null</span>) &#123;</span><br><span class="line">      listener.onClosed(<span class="keyword">this</span>, code, reason)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    toClose?.closeQuietly()</span><br><span class="line">    readerToClose?.closeQuietly()</span><br><span class="line">    writerToClose?.closeQuietly()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onReadMessage</span><span class="params">(text: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">  listener.onMessage(<span class="keyword">this</span>, text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onReadMessage</span><span class="params">(bytes: <span class="type">ByteString</span>)</span></span> &#123;</span><br><span class="line">  listener.onMessage(<span class="keyword">this</span>, bytes)</span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>onReadClose</code>回调方法里面有个关键的参数，<code>receivedCloseCode</code>。还记得这个参数吗？上文中解析消息的循环条件就是<code>receivedCloseCode == -1</code>，所以当收到关闭帧的时候，<code>receivedCloseCode</code>就不再等于-1（规定大于1000），也就不再去读取解析消息了。这样整个流程就结束了。</p><p>其中还有一些<code>WebSocketListener</code>的回调，比如<code>onClosing，onClosed，onMessage</code>等，就直接回调给用户使用了。至此，接收消息处理消息说完了。</p><h3 id="3-3-发消息"><a href="#3-3-发消息" class="headerlink" title="3.3 发消息"></a>3.3 发消息</h3><p>好了。接着说发送，看看<code>send</code>方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Synchronized</span> <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">send</span><span class="params">(<span class="keyword">data</span>: <span class="type">ByteString</span>, formatOpcode: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">  <span class="comment">// ***</span></span><br><span class="line">  <span class="comment">// Enqueue the message frame.</span></span><br><span class="line">  queueSize += <span class="keyword">data</span>.size.toLong()</span><br><span class="line">  messageAndCloseQueue.add(Message(formatOpcode, <span class="keyword">data</span>))</span><br><span class="line">  runWriter()</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先，把要发送的<code>data</code>封装成<code>Message</code>对象，然后入队列<code>messageAndCloseQueue</code>。最后执行<code>runWriter</code>方法。这都不用猜了，<code>runWriter</code>肯定就要开始发送消息了，继续看：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RealWebSocket.kt</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">runWriter</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.assertThreadHoldsLock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> writerTask = writerTask</span><br><span class="line">  <span class="keyword">if</span> (writerTask != <span class="literal">null</span>) &#123;</span><br><span class="line">    taskQueue.schedule(writerTask)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">WriterTask</span> : <span class="type">Task</span></span>(<span class="string">&quot;<span class="variable">$name</span> writer&quot;</span>) &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">runOnce</span><span class="params">()</span></span>: <span class="built_in">Long</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (writeOneFrame()) <span class="keyword">return</span> <span class="number">0L</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">      failWebSocket(e, <span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1L</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是schedule方法转到WriterTask的runOnce方法过程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//TaskQueue.kt</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">schedule</span><span class="params">(task: <span class="type">Task</span>, delayNanos: <span class="type">Long</span> = <span class="number">0</span>L)</span></span> &#123;</span><br><span class="line">  synchronized(taskRunner) &#123;</span><br><span class="line">    <span class="keyword">if</span> (scheduleAndDecide(task, delayNanos, recurrence = <span class="literal">false</span>)) &#123;</span><br><span class="line">      taskRunner.kickCoordinator(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">scheduleAndDecide</span><span class="params">(task: <span class="type">Task</span>, delayNanos: <span class="type">Long</span>, recurrence: <span class="type">Boolean</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">  <span class="comment">//***</span></span><br><span class="line">  <span class="keyword">if</span> (insertAt == -<span class="number">1</span>) insertAt = futureTasks.size</span><br><span class="line">  futureTasks.add(insertAt, task)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Impact the coordinator if we inserted at the front.</span></span><br><span class="line">  <span class="keyword">return</span> insertAt == <span class="number">0</span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//TaskRunner.kt</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">kickCoordinator</span><span class="params">(taskQueue: <span class="type">TaskQueue</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.assertThreadHoldsLock()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (taskQueue.activeTask == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (taskQueue.futureTasks.isNotEmpty()) &#123;</span><br><span class="line">      readyQueues.addIfAbsent(taskQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      readyQueues.remove(taskQueue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;    </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (coordinatorWaiting) &#123;</span><br><span class="line">    backend.coordinatorNotify(<span class="keyword">this</span><span class="symbol">@TaskRunner</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    backend.execute(runnable)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> runnable: Runnable = <span class="keyword">object</span> : Runnable &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">val</span> task = synchronized(<span class="keyword">this</span><span class="symbol">@TaskRunner</span>) &#123;</span><br><span class="line">        awaitTaskToRun()</span><br><span class="line">      &#125; ?: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">      logElapsed(task, task.queue!!) &#123;</span><br><span class="line">        <span class="keyword">var</span> completedNormally = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          runTask(task)</span><br><span class="line">          completedNormally = <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">// If the task is crashing start another thread to service the queues.</span></span><br><span class="line">          <span class="keyword">if</span> (!completedNormally) &#123;</span><br><span class="line">            backend.execute(<span class="keyword">this</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">runTask</span><span class="params">(task: <span class="type">Task</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    delayNanos = task.runOnce()</span><br><span class="line">  &#125; </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码有点长，这里是从<code>runWriter</code>开始跟的几个方法，拿到<code>writerTask</code>实例后，存到<code>TaskQueue</code>的<code>futureTasks列表</code>里，然后到<code>runnable</code>这里可以看到是一个<code>while</code>死循环，不断的从<code>futureTasks</code>中取出<code>Task</code>并执行<code>runTask</code>方法，直到<code>Task</code>为空，循环停止。</p><p>其中涉及到两个新的类：</p><ul><li><code>TaskQueue类</code>主要就是管理消息任务列表，保证按顺序执行</li><li><code>TaskRunner类</code>主要就是做一些任务的具体操作，比如线程池里执行任务，记录消息任务的状态（准备发送的任务队列<code>readyQueues</code>，正在执行的任务队列<code>busyQueues</code>等等）</li></ul><p>而每一个Task最后都是执行到了<code>WriterTask</code>的<code>runOnce</code>方法，也就是<code>writeOneFrame</code>方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">writeOneFrame</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">  synchronized(<span class="keyword">this</span><span class="symbol">@RealWebSocket</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (failed) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// Failed web socket.</span></span><br><span class="line">    &#125;</span><br><span class="line">    writer = <span class="keyword">this</span>.writer</span><br><span class="line">    pong = pongQueue.poll()</span><br><span class="line">    <span class="keyword">if</span> (pong == <span class="literal">null</span>) &#123;</span><br><span class="line">      messageOrClose = messageAndCloseQueue.poll()</span><br><span class="line">      <span class="keyword">if</span> (messageOrClose <span class="keyword">is</span> Close) &#123;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (messageOrClose == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// The queue is exhausted.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//发送消息逻辑，包括`pong`消息，普通消息，关闭消息</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pong != <span class="literal">null</span>) &#123;</span><br><span class="line">      writer!!.writePong(pong)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (messageOrClose <span class="keyword">is</span> Message) &#123;</span><br><span class="line">      <span class="keyword">val</span> message = messageOrClose <span class="keyword">as</span> Message</span><br><span class="line">      writer!!.writeMessageFrame(message.formatOpcode, message.<span class="keyword">data</span>)</span><br><span class="line">      synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">        queueSize -= message.<span class="keyword">data</span>.size.toLong()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (messageOrClose <span class="keyword">is</span> Close) &#123;</span><br><span class="line">      <span class="keyword">val</span> close = messageOrClose <span class="keyword">as</span> Close</span><br><span class="line">      writer!!.writeClose(close.code, close.reason)</span><br><span class="line">      <span class="comment">// We closed the writer: now both reader and writer are closed.</span></span><br><span class="line">      <span class="keyword">if</span> (streamsToClose != <span class="literal">null</span>) &#123;</span><br><span class="line">        listener.onClosed(<span class="keyword">this</span>, receivedCloseCode, receivedCloseReason!!)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    streamsToClose?.closeQuietly()</span><br><span class="line">    readerToClose?.closeQuietly()</span><br><span class="line">    writerToClose?.closeQuietly()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里就会执行发送消息的逻辑了，主要有三种消息情况处理：</p><ul><li><code>pong消息</code>，这个主要是为服务器端准备的，发送给客户端回应心跳包。</li><li><code>普通消息</code>，就会把数据类型<code>Opcode</code>和具体数据发送过去</li><li><code>关闭消息</code>，其实当用户执行<code>close</code>方法关闭<code>WebSocket</code>的时候，也是发送了一条<code>Close控制帧</code>消息给服务器告知这个关闭需求，并带上<code>code状态码</code>和<code>reason关闭原因</code>，然后服务器端就会关闭当前连接。</li></ul><p>好了。最后一步了，就是把这些数据组装成<code>WebSocket</code>数据帧并写入流，分成<code>控制帧</code>数据和<code>普通消息数据帧</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写入（发送）控制帧</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">writeControlFrame</span><span class="params">(opcode: <span class="type">Int</span>, payload: <span class="type">ByteString</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (writerClosed) <span class="keyword">throw</span> IOException(<span class="string">&quot;closed&quot;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">val</span> length = payload.size</span><br><span class="line">  require(length &lt;= PAYLOAD_BYTE_MAX) &#123;</span><br><span class="line">    <span class="string">&quot;Payload size must be less than or equal to <span class="variable">$PAYLOAD_BYTE_MAX</span>&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">val</span> b0 = B0_FLAG_FIN or opcode</span><br><span class="line">  sinkBuffer.writeByte(b0)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> b1 = length</span><br><span class="line">  <span class="keyword">if</span> (isClient) &#123;</span><br><span class="line">    b1 = b1 or B1_FLAG_MASK</span><br><span class="line">    sinkBuffer.writeByte(b1)</span><br><span class="line">    random.nextBytes(maskKey!!)</span><br><span class="line">    sinkBuffer.write(maskKey)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">val</span> payloadStart = sinkBuffer.size</span><br><span class="line">      sinkBuffer.write(payload)</span><br><span class="line">      sinkBuffer.readAndWriteUnsafe(maskCursor!!)</span><br><span class="line">      maskCursor.seek(payloadStart)</span><br><span class="line">      toggleMask(maskCursor, maskKey)</span><br><span class="line">      maskCursor.close()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sinkBuffer.writeByte(b1)</span><br><span class="line">    sinkBuffer.write(payload)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sink.flush()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//写入（发送）普通消息数据帧</span></span><br><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">writeMessageFrame</span><span class="params">(formatOpcode: <span class="type">Int</span>, <span class="keyword">data</span>: <span class="type">ByteString</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (writerClosed) <span class="keyword">throw</span> IOException(<span class="string">&quot;closed&quot;</span>)</span><br><span class="line"></span><br><span class="line">  messageBuffer.write(<span class="keyword">data</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> b0 = formatOpcode or B0_FLAG_FIN</span><br><span class="line">  <span class="keyword">val</span> dataSize = messageBuffer.size</span><br><span class="line">  sinkBuffer.writeByte(b0)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> b1 = <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> (isClient) &#123;</span><br><span class="line">    b1 = b1 or B1_FLAG_MASK</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">when</span> &#123;</span><br><span class="line">    dataSize &lt;= PAYLOAD_BYTE_MAX -&gt; &#123;</span><br><span class="line">      b1 = b1 or dataSize.toInt()</span><br><span class="line">      sinkBuffer.writeByte(b1)</span><br><span class="line">    &#125;</span><br><span class="line">    dataSize &lt;= PAYLOAD_SHORT_MAX -&gt; &#123;</span><br><span class="line">      b1 = b1 or PAYLOAD_SHORT</span><br><span class="line">      sinkBuffer.writeByte(b1)</span><br><span class="line">      sinkBuffer.writeShort(dataSize.toInt())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">      b1 = b1 or PAYLOAD_LONG</span><br><span class="line">      sinkBuffer.writeByte(b1)</span><br><span class="line">      sinkBuffer.writeLong(dataSize)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isClient) &#123;</span><br><span class="line">    random.nextBytes(maskKey!!)</span><br><span class="line">    sinkBuffer.write(maskKey)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dataSize &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">      messageBuffer.readAndWriteUnsafe(maskCursor!!)</span><br><span class="line">      maskCursor.seek(<span class="number">0L</span>)</span><br><span class="line">      toggleMask(maskCursor, maskKey)</span><br><span class="line">      maskCursor.close()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sinkBuffer.write(messageBuffer, dataSize)</span><br><span class="line">  sink.emit()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>大家应该都能看懂了吧，其实就是组装数据帧，包括<code>Opcode，mask，数据长度</code>等等。两个方法的不同就在于普通数据需要判断数据长度的三种情况，再组装数据帧。最后都会通过<code>sinkBuffer</code>写入到输出数据流。</p><p>终于，基本的流程说的差不多了。其中还有很多细节，同学们可以自己花时间看看琢磨琢磨，比如<code>Okio</code>部分。还是那句话，希望大家有空自己也读一读相关源码，这样理解才能深刻，而且你肯定会发现很多我没说到的细节，欢迎大家讨论。我也会继续努力，最后大家给我加个油点个赞吧，感谢感谢。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/13/173476f65e6e3ed4~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.image" alt="OkHttp-WebSocket源码.jpg"></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/05/13/HTTPS-%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/05/13/HTTPS-%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">HTTPS 学习整理</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-05-13 08:23:15" itemprop="dateCreated datePublished" datetime="2022-05-13T08:23:15+08:00">2022-05-13</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-05-17 11:51:37" itemprop="dateModified" datetime="2022-05-17T11:51:37+08:00">2022-05-17</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="HTTPS-学习整理"><a href="#HTTPS-学习整理" class="headerlink" title="HTTPS 学习整理"></a>HTTPS 学习整理</h2><h3 id="1-HTTPS-连接及握手过程"><a href="#1-HTTPS-连接及握手过程" class="headerlink" title="1.HTTPS 连接及握手过程"></a>1.HTTPS 连接及握手过程</h3><p><strong>第一步</strong>，客户端发送给服务器Client Hello，叫做Client Hello 其实是一个一字节的数据</p><p><img src="/../images/image-20220513082622256.png" alt="image-20220513082622256"></p><p>发送Client Hello 还会附加一些信息</p><ol><li>可选的TLS版本</li><li>可选的加密套件<ul><li>可选的对称加密算法</li><li>可选的非对称加密算法</li><li>可选的hash算法</li></ul></li><li>客户端随机数（这个随机数随后会用到，等于是第一个随机数客户端和服务器都会使用到）</li></ol><p><img src="/../images/image-20220513082816474.png" alt="image-20220513082816474"></p><p><strong>第二步</strong>，服务端返回Server Hello 也是一个单字节数据，并把Client Hello 附加信息的确认值返回给客户端，同时生成服务端的随机数，返回给客户端</p><p><img src="/../images/image-20220513083321789.png" alt="image-20220513083321789"></p><p><strong>第三步</strong>，服务端下发证书，然后客户端这里会做证书的较验，这里的过程比较麻烦和复杂</p><p><img src="/../images/image-20220513083443606.png" alt="image-20220513083443606"></p><p>如图所示，证书中包含</p><ul><li>服务器公钥</li><li>服务器主机名</li><li>服务器公钥的签名</li><li>证书签发机构的公钥</li><li>证书签发机构的公角的签名</li><li>….</li></ul><p>较验的顺序也是如此，链式去使用签名去较验公钥是否准确，防止公钥被修改，一层层直到找到根证书，根证书一般都安装在pc或者手机里，然后逐层去较验公钥的正确性，最后证明服务器的公钥确实是真的，而不是假的</p><p><img src="/../images/image-20220513134035609.png" alt="image-20220513134035609"></p><p>如图所示，访问hencoder.com 然后证书链中的三级证书，客户端验证服务器证书的真实性，还通过主机名确认对方的身份，确实是我要访问的服务器，而不是其他在ca公签的服务器</p><p><img src="/../images/image-20220513134238446.png" alt="image-20220513134238446"></p><p><strong>第四步</strong>，客户端拿到服务器公钥后，和服务器一起通过公钥生成加密的Pre-master secret ，双方就公同持有了三个东西</p><ul><li>客户端随机数</li><li>服务器随机数</li><li>Pre-master secret</li></ul><p>通过这三个东西会各自独立的生成master secret 所以注意啦，<strong>最终的对称密钥并不是客户端生成后发给服务器的，而是由前面交互的随机数，及加密后的公钥独立生成的</strong></p><p><img src="/../images/image-20220513134634905.png" alt="image-20220513134634905"></p><p><strong>而且，生成的对称加密的密钥并不是简单的一个密码</strong></p><p><img src="/../images/image-20220513134726832.png" alt="image-20220513134726832"></p><p>那么有人可能会有疑问，为什么要很麻烦的生成客户端的加密密钥，服务端的加密密钥？用一个不行么？</p><p><img src="/../images/image-20220513134838968.png" alt="image-20220513134838968"></p><p><strong>第五步，客户端告诉服务器，我将使用加密通信，还有把前面几步合一起加密发给服务器，生送Finished 同样服务器也返回客户端：将使用加密通信，同时Finished握手</strong></p><p><img src="/../images/image-20220513135059793.png" alt="image-20220513135059793"></p><p>服务端返回</p><p><img src="/../images/image-20220513135117684.png" alt="image-20220513135117684"></p><p><img src="/../images/image-20220513135132604.png" alt="image-20220513135132604"></p><h3 id="2-在Android中合理使用HTTPS"><a href="#2-在Android中合理使用HTTPS" class="headerlink" title="2.在Android中合理使用HTTPS"></a>2.在Android中合理使用HTTPS</h3><p>CA公签的就不讨论了，使用很方便，根据所使用的网络框架，可以自行百度，非常简单方便。这里说下如何较验主机名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create an HostnameVerifier that hardwires the expected hostname.</span></span><br><span class="line"><span class="comment">// Note that is different than the URL&#x27;s hostname:</span></span><br><span class="line"><span class="comment">// example.com versus example.org</span></span><br><span class="line">HostnameVerifier hostnameVerifier = <span class="keyword">new</span> HostnameVerifier() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String hostname, SSLSession session)</span> </span>&#123;</span><br><span class="line">        HostnameVerifier hv =</span><br><span class="line">            HttpsURLConnection.getDefaultHostnameVerifier();</span><br><span class="line">        <span class="keyword">return</span> hv.verify(<span class="string">&quot;example.com&quot;</span>, session);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell the URLConnection to use our HostnameVerifier</span></span><br><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">&quot;https://example.org/&quot;</span>);</span><br><span class="line">HttpsURLConnection urlConnection =</span><br><span class="line">    (HttpsURLConnection)url.openConnection();</span><br><span class="line">urlConnection.setHostnameVerifier(hostnameVerifier);</span><br><span class="line">InputStream in = urlConnection.getInputStream();</span><br><span class="line">copyInputStreamToOutputStream(in, System.out);</span><br></pre></td></tr></table></figure><p>还有一种情况，有一些公司使用自签名证书，或者非知名机构颁发的证书，如果不做处理，会报https的网络异常，那么这时候上网上查的话，很多都是告诉不做较验，放开所有的证书，当然这样可以走的通，但是同时也失去了使用HTTPS的作用，是不认真负责的。</p><p>我们看官网上对这一过程的描述，之所以之前我们记不住，也是因为我们对HTTPS的握手和证书较验过程不够理解，现在看这段话</p><blockquote><p>在这种情况下，由于您的 CA 不受系统信任，将发生 SSLHandshakeException。原因可能是您有一个由 Android 尚不信任的新 CA 颁发的证书，或您的应用在没有 CA 的较旧版本上运行。CA 未知的原因通常是因为它不是公共 CA，而是由政府、公司或教育机构等组织颁发的仅供其自己使用的私有 CA。</p><p>幸运的是，您可以指示 HttpsURLConnection 信任特定的 CA 集。这个过程可能有点复杂，下面的示例展示了这个过程：从 InputStream 获取一个特定的 CA，用该 CA 创建 KeyStore，然后用后者创建和初始化 TrustManager。TrustManager 是系统用于验证来自服务器的证书的工具，可以通过包含一个或多个 CA 的 KeyStore 创建，而创建的 TrustManager 将仅信任这些 CA。</p><p>由于 TrustManager 是新建的，此示例将启动一个新的 SSLContext，它会提供一个 SSLSocketFactory，可用于替换来自 HttpsURLConnection 的默认 SSLSocketFactory。这样一来，连接将使用您的 CA 来验证证书。</p></blockquote><p>这下你知道，为啥Android客户会有一个证书文件了吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">// Load CAs from an InputStream</span></span><br><span class="line"><span class="comment">// (could be from a resource or ByteArrayInputStream or ...)</span></span><br><span class="line">CertificateFactory cf = CertificateFactory.getInstance(<span class="string">&quot;X.509&quot;</span>);</span><br><span class="line"><span class="comment">// From https://www.washington.edu/itconnect/security/ca/load-der.crt</span></span><br><span class="line">InputStream caInput = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;load-der.crt&quot;</span>));</span><br><span class="line">Certificate ca;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ca = cf.generateCertificate(caInput);</span><br><span class="line">    System.out.println(<span class="string">&quot;ca=&quot;</span> + ((X509Certificate) ca).getSubjectDN());</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    caInput.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a KeyStore containing our trusted CAs</span></span><br><span class="line">String keyStoreType = KeyStore.getDefaultType();</span><br><span class="line">KeyStore keyStore = KeyStore.getInstance(keyStoreType);</span><br><span class="line">keyStore.load(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">keyStore.setCertificateEntry(<span class="string">&quot;ca&quot;</span>, ca);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a TrustManager that trusts the CAs in our KeyStore</span></span><br><span class="line">String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();</span><br><span class="line">TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);</span><br><span class="line">tmf.init(keyStore);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create an SSLContext that uses our TrustManager</span></span><br><span class="line">SSLContext context = SSLContext.getInstance(<span class="string">&quot;TLS&quot;</span>);</span><br><span class="line">context.init(<span class="keyword">null</span>, tmf.getTrustManagers(), <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell the URLConnection to use a SocketFactory from our SSLContext</span></span><br><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">&quot;https://certs.cac.washington.edu/CAtest/&quot;</span>);</span><br><span class="line">HttpsURLConnection urlConnection =</span><br><span class="line">    (HttpsURLConnection)url.openConnection();</span><br><span class="line">urlConnection.setSSLSocketFactory(context.getSocketFactory());</span><br><span class="line">InputStream in = urlConnection.getInputStream();</span><br><span class="line">copyInputStreamToOutputStream(in, System.out);</span><br></pre></td></tr></table></figure><p>这个SSLContext很关键，由得到的SSLContextFactory是我们很多网络框架可以进行替换和设置，这样就可以通过自签名的ca集来检验较验证书的合法性了。</p><p>之所以说SSLContext很关键，因为不光HTTP可以使用SSL较验，很多上层加密都使用了SSL层的加密特性，比如我们可能会遇到的WSS Websocket的加密协议，怎么处理，一样的道理。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/03/20/Jetpack%E7%B3%BB%E5%88%97%E2%80%94LiveData/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="张龙"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SteveZhang博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2022/03/20/Jetpack%E7%B3%BB%E5%88%97%E2%80%94LiveData/" class="post-title-link" itemprop="url">Jetpack系列—LiveData原理解析</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-03-20 18:43:51" itemprop="dateCreated datePublished" datetime="2022-03-20T18:43:51+08:00">2022-03-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-05-17 11:51:37" itemprop="dateModified" datetime="2022-05-17T11:51:37+08:00">2022-05-17</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Jetpack%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Jetpack系列</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><ul><li>什么是<code>LiveData</code></li><li><code>LiveData</code>几种衍生类</li><li><code>LiveData</code>核心方法</li><li><code>LiveData</code>实现原理</li></ul><h2 id="1-什么是LiveData"><a href="#1-什么是LiveData" class="headerlink" title="1.什么是LiveData"></a>1.什么是LiveData</h2><ul><li><code>LiveData</code>组件是<code>Jetpack</code>新推出的基于观察者的消息订阅&#x2F;分发组件，具有宿主(<code>Activity</code>&#x2F;<code>Fragment</code>)生命周期感知能力，这种感知能力可确保<code>LiveData</code>仅分发消息给处于<code>活跃状态</code>的观察者，即只有处于<code>活跃状态</code>的观察者才能收到消息</li><li><code>LiveData</code>的消息分发机制，是以往的<code>Handler</code>，<code>EventBus</code>，<code>RxJavaBus</code>无法比拟的，它们不会顾及当前页面是否可见，一股脑的有消息就转发。导致即便应用在后台，页面不可见，还在做一些无用的绘制，计算(细心的同学可以发现微信消息列表是在可见状态时才会更新列表最新信息的)</li></ul><blockquote><p>活跃状态：<code>Observer</code>所在宿主处于<code>started</code>,<code>resumed</code>状态</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppcompactActivity</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle bundle)</span></span>&#123;</span><br><span class="line">    <span class="meta">@Ovderride</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span></span>&#123;</span><br><span class="line">      <span class="comment">//无论页面可见不可见，都会去执行页面刷新,IO。更有甚者弹出对话框</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//1.无论当前页面是否可见，这条消息都会被分发。——消耗资源</span></span><br><span class="line">  <span class="comment">//2.无论前宿主是否还存活，这条消息都会被分发。——内存泄漏</span></span><br><span class="line">  handler.sendMessage(msg);</span><br><span class="line"></span><br><span class="line">  liveData.observer(<span class="keyword">this</span>,<span class="keyword">new</span> Observer&lt;User&gt;)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onChanged</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//1.减少资源占用 —— 页面不可见时不会派发消息</span></span><br><span class="line">  <span class="comment">//2.确保页面始终保持最新状态——页面可见时，会立刻派发新新的一条消息给所有观察者——保证页面最新状态</span></span><br><span class="line">  <span class="comment">//3.不再需要手动处理生命周期——避免NPE</span></span><br><span class="line">  <span class="comment">//4.livedata默认是不能跨页面使用的，但是我们有办法，可以打造一款不用反注册，不会内存泄漏的消息总线——取代eventbus</span></span><br><span class="line">	liveData.postValue(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-LiveData的几种用法"><a href="#2-LiveData的几种用法" class="headerlink" title="2.LiveData的几种用法"></a>2.LiveData的几种用法</h2><h3 id="2-1-MutableLiveData"><a href="#2-1-MutableLiveData" class="headerlink" title="2.1 MutableLiveData"></a>2.1 MutableLiveData</h3><p>我们在使用LiveData在做消息分发的时候，需要使用这个子类。之所以这么设计，是考虑到单一开闭原则，只有拿到MutableLiveData对象才可以发送消息，LiveData对象只能接收消息，避免拿到LiveData对象时既能发消息也能收到消息的混乱使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutableLiveData</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">LiveData</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postValue</span><span class="params">(T value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.postValue(value);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setValue(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-MediatorLiveData"><a href="#2-2-MediatorLiveData" class="headerlink" title="2.2 MediatorLiveData"></a>2.2 MediatorLiveData</h3><ul><li>可以统一观察多个LiveData的发射的数据进行统一的处理</li><li>同时也可以做为一个LiveData，被其他Observer观察。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建两个长的差不多的LiveData对象</span></span><br><span class="line">LiveData&lt;Integer&gt; liveData1 = <span class="keyword">new</span> MutableLiveData();</span><br><span class="line">LiveData&lt;Integer&gt; liveData2 = <span class="keyword">new</span> MutableLiveData();</span><br><span class="line"></span><br><span class="line"><span class="comment">//再创建一个聚合类MediatorLiveData</span></span><br><span class="line">MediatorLiveData&lt;Integer&gt; liveDataMerger = <span class="keyword">new</span> MediatorLiveData();</span><br><span class="line"><span class="comment">//分别把上面创建的LiveData添加进来</span></span><br><span class="line">liveDataMerger.addSource(liveData1,observer);</span><br><span class="line">liveDataMerger.addSource(liveData2,observer);</span><br><span class="line"></span><br><span class="line">Observer observer = <span class="keyword">new</span> Observer&lt;Integer&gt;&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChanged</span><span class="params">(<span class="meta">@Nullable</span> Integer s)</span></span>&#123;</span><br><span class="line">    titleTextView.setText(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一旦liveData1或者liveData2发送了新的数据，observer便能观察到，以便统一处理更新UI</span></span><br></pre></td></tr></table></figure><h3 id="2-3-Transformations-map-操作符"><a href="#2-3-Transformations-map-操作符" class="headerlink" title="2.3 Transformations.map 操作符"></a>2.3 Transformations.map 操作符</h3><p>可以对liveData进行变化，并且返回一个新的livedata对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MutableLiveData&lt;Integer&gt; data = <span class="keyword">new</span> MutableLiveData&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据转换</span></span><br><span class="line">LiveData&lt;String&gt; transformData = Transformations.map(data,input -&gt; String.valueOf(input));</span><br><span class="line"><span class="comment">//使用转换后生成的transformData去观察数据</span></span><br><span class="line">transformData.observe(<span class="keyword">this</span>,output -&gt; &#123;</span><br><span class="line">  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用原始的livedata发送数据</span></span><br><span class="line">data.setValue(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h2 id="3-LiveData核心方法"><a href="#3-LiveData核心方法" class="headerlink" title="3.LiveData核心方法"></a>3.LiveData核心方法</h2><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>observe(LifecycleOwner owner,Observer observer)</td><td>注册和宿主生命周期关联的观察者</td></tr><tr><td>observeForever(Observer observer)</td><td>注册观察者，不会反注册，需要自行维护</td></tr><tr><td>setValue(T data)</td><td>发送数据，没有活跃的观察者时不会分发。只能在主线程。</td></tr><tr><td>postValue(T data)</td><td>和setValue一样。不受线程环境限制。</td></tr><tr><td>onActive</td><td>当且仅当有一个活跃的观察者时会触发</td></tr><tr><td>inActive</td><td>不存在活跃的观察者时会触发</td></tr></tbody></table><h2 id="4-LiveData实现原理"><a href="#4-LiveData实现原理" class="headerlink" title="4.LiveData实现原理"></a>4.LiveData实现原理</h2><p><img src="/../images/image-20220514110449881.png" alt="image-20220514110449881"></p><p><img src="/../images/image-20220514111210613.png" alt="image-20220514111210613"></p><p><code>LiveData</code>使用的有很多好处</p><ul><li>确保<code>UI</code>符合数据状态</li><li>不需要手动处理生命周期</li><li>始终保持最新的数据</li><li>事件总线<code>LiveDataBus</code></li></ul><p><strong>确保UI符合数据状态</strong></p><p>因为<code>livedata</code>实现了观察者模式 它里面的数据发生变化的时候，会向注册的<code>Observer</code>观察者发送通知，这时可以在观察者的<code>onChanged</code>里面更改UI 以保持数据的最新化</p><p><strong>不需要手动处理生命周期</strong></p><p>在注册<code>observe</code>的时候，会将当前宿主的生命周期进行绑定，当宿主被销毁时，就自动的进行销毁</p><p><strong>始终保持最新的数据</strong></p><p>可以这么理解，当宿主的生命周期变为非活跃状态的时候，那么它将在再次变为活跃状态的时候，接收到最新的数据，比如<code>activity</code> 从前台返回到后台，再从后台返回前台。再比如<code>actvity</code>和<code>fragment</code>由于配置的更改，而重新创建，也是能够接收到最新可用的数据，来保持最新的数据和UI</p><p>事件总线<code>LiveDataBus</code></p><p>使用<code>livedata</code>来实现消息总线，替代使用<code>eventbus</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有参数构造 mVersion = 0  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LiveData</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    mData = value;</span><br><span class="line">    mVersion = START_VERSION + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无参数构造，mVersion = -1  mData = NOT_SET</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LiveData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mData = NOT_SET;</span><br><span class="line">    mVersion = START_VERSION;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么为什么<code>livedata</code>需要一个<code>version</code>呢？</p><p>因为<code>livedata</code>通过<code>version</code>来控制数据分发，通过<code>mVersion</code>来进行数据的比对，本次是否需要进行数据的分发，因为不能<code>livedata</code>发送一次数据，而observable能接收到2，3次数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把宿主和observer进行绑定</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">observe</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner owner, <span class="meta">@NonNull</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    assertMainThread(<span class="string">&quot;observe&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//把lifecycle 和 observer包装成了一个LifecycleBoundObserver，也就是一个有边界的的observer</span></span><br><span class="line">    LifecycleBoundObserver wrapper = <span class="keyword">new</span> LifecycleBoundObserver(owner, observer);</span><br><span class="line">  <span class="comment">//包装完后，把wrapper放入一个hashmap里</span></span><br><span class="line">    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="keyword">null</span> &amp;&amp; !existing.isAttachedTo(owner)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Cannot add the same observer&quot;</span></span><br><span class="line">                + <span class="string">&quot; with different lifecycles&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//注意这里传入的是包装后的wrapper  lifecycleboundobserver</span></span><br><span class="line">    owner.getLifecycle().addObserver(wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过observe可以向livedata注册一个观察者对象</p><p>owner.getLifecycle().addObserver(wrapper) 进入 会进行到实现</p><p>LifecycleRegistry.addObserver(observer)方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(<span class="meta">@NonNull</span> LifecycleObserver observer)</span> </span>&#123;</span><br><span class="line">    enforceMainThreadIfNeeded(<span class="string">&quot;addObserver&quot;</span>);</span><br><span class="line">  <span class="comment">//判断当前宿主的生命周期状态</span></span><br><span class="line">    State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;</span><br><span class="line">  <span class="comment">//判断完后，会把当前宿主的生命周期和观察者进行包装</span></span><br><span class="line">    ObserverWithState statefulObserver = <span class="keyword">new</span> ObserverWithState(observer, initialState);</span><br><span class="line">  <span class="comment">//包装完成后也会存储到hashmap里</span></span><br><span class="line">    ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//为什么要再进行这么包装呢？主要是为了分发当前宿主的生命周期状态给每个observer</span></span><br><span class="line">    <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();</span><br><span class="line">    <span class="keyword">if</span> (lifecycleOwner == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// it is null we should be destroyed. Fallback quickly</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isReentrance = mAddingObserverCounter != <span class="number">0</span> || mHandlingEvent;</span><br><span class="line">    State targetState = calculateTargetState(observer);</span><br><span class="line">    mAddingObserverCounter++;</span><br><span class="line">    <span class="keyword">while</span> ((statefulObserver.mState.compareTo(targetState) &lt; <span class="number">0</span></span><br><span class="line">            &amp;&amp; mObserverMap.contains(observer))) &#123;</span><br><span class="line">        pushParentState(statefulObserver.mState);</span><br><span class="line">        <span class="keyword">final</span> Event event = Event.upFrom(statefulObserver.mState);</span><br><span class="line">        <span class="keyword">if</span> (event == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;no event up from &quot;</span> + statefulObserver.mState);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//分发宿主的生命周期状态 给observer</span></span><br><span class="line">        statefulObserver.dispatchEvent(lifecycleOwner, event);</span><br><span class="line">        popParentState();</span><br><span class="line">        <span class="comment">// mState / subling may have been changed recalculate</span></span><br><span class="line">        targetState = calculateTargetState(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isReentrance) &#123;</span><br><span class="line">        <span class="comment">// we do sync only on the top level.</span></span><br><span class="line">        sync();</span><br><span class="line">    &#125;</span><br><span class="line">    mAddingObserverCounter--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchEvent</span><span class="params">(LifecycleOwner owner, Event event)</span> </span>&#123;</span><br><span class="line">    State newState = event.getTargetState();</span><br><span class="line">    mState = min(mState, newState);</span><br><span class="line">  <span class="comment">//这个lifecycleobserver就是我们传递进来的lifecyclebounderobserver</span></span><br><span class="line">    mLifecycleObserver.onStateChanged(owner, event);</span><br><span class="line">    mState = newState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口是 LifecycleEventObserver的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LifecycleEventObserver</span> <span class="keyword">extends</span> <span class="title">LifecycleObserver</span> </span>&#123;</span><br><span class="line">		<span class="comment">//这个回调的是宿主生命周期的变化  有两个参数，一个是宿主 一个是Event</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner source, <span class="meta">@NonNull</span> Lifecycle.Event event)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constant for onCreate event of the &#123;<span class="doctag">@link</span> LifecycleOwner&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ON_CREATE,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constant for onStart event of the &#123;<span class="doctag">@link</span> LifecycleOwner&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ON_START,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constant for onResume event of the &#123;<span class="doctag">@link</span> LifecycleOwner&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ON_RESUME,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constant for onPause event of the &#123;<span class="doctag">@link</span> LifecycleOwner&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ON_PAUSE,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constant for onStop event of the &#123;<span class="doctag">@link</span> LifecycleOwner&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ON_STOP,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constant for onDestroy event of the &#123;<span class="doctag">@link</span> LifecycleOwner&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ON_DESTROY,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * An &#123;<span class="doctag">@link</span> Event Event&#125; constant that can be used to match all events.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ON_ANY;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>宿主的每个生命周期的改变都会回调到onStateChanged</p><p>我们看下它的实现 LifecycleBoundObserver 实现了LifecycleEventObserver</p><p>LifecycleBoundObserver.onStateChanged</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner source,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@NonNull</span> Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">    Lifecycle.State currentState = mOwner.getLifecycle().getCurrentState();</span><br><span class="line">  <span class="comment">//如果当前状态是destroyed</span></span><br><span class="line">    <span class="keyword">if</span> (currentState == DESTROYED) &#123;</span><br><span class="line">      <span class="comment">//自行移除，自行反注册这个observer</span></span><br><span class="line">        removeObserver(mObserver);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Lifecycle.State prevState = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (prevState != currentState) &#123;</span><br><span class="line">        prevState = currentState;</span><br><span class="line">      	<span class="comment">//否则就执行活跃状态的变更 看shouldBeActive方法</span></span><br><span class="line">        activeStateChanged(shouldBeActive());</span><br><span class="line">        currentState = mOwner.getLifecycle().getCurrentState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里判断了只有宿主的生命周期大于start的时候  才代表宿主是活跃的</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">shouldBeActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看activeStateChanged</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">activeStateChanged</span><span class="params">(<span class="keyword">boolean</span> newActive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (newActive == mActive) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    mActive = newActive;</span><br><span class="line">    changeActiveCounter(mActive ? <span class="number">1</span> : -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (mActive) &#123;</span><br><span class="line">        dispatchingValue(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeActiveCounter</span><span class="params">(<span class="keyword">int</span> change)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> previousActiveCount = mActiveCount;</span><br><span class="line">    mActiveCount += change;</span><br><span class="line">    <span class="keyword">if</span> (mChangingActiveState) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mChangingActiveState = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (previousActiveCount != mActiveCount) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> needToCallActive = previousActiveCount == <span class="number">0</span> &amp;&amp; mActiveCount &gt; <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">boolean</span> needToCallInactive = previousActiveCount &gt; <span class="number">0</span> &amp;&amp; mActiveCount == <span class="number">0</span>;</span><br><span class="line">            previousActiveCount = mActiveCount;</span><br><span class="line">            <span class="keyword">if</span> (needToCallActive) &#123;<span class="comment">//首次注册会执行onActive </span></span><br><span class="line">                onActive();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (needToCallInactive) &#123;<span class="comment">//当最后一个观察者被移除时，会执行onInactive</span></span><br><span class="line">                onInactive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mChangingActiveState = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onInactive</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//可以初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//可以反注册，释放资源，清理   paging就利用了这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着看 传入true 执行dispatchingValue 把当前的observer传入进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mActive) &#123;</span><br><span class="line">    dispatchingValue(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchingValue</span><span class="params">(<span class="meta">@Nullable</span> ObserverWrapper initiator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDispatchingValue) &#123;</span><br><span class="line">        mDispatchInvalidated = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mDispatchingValue = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        mDispatchInvalidated = <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">//不为空，走到considerNotify 里，见considerNotify</span></span><br><span class="line">        <span class="keyword">if</span> (initiator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            considerNotify(initiator);</span><br><span class="line">            initiator = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;? <span class="keyword">super</span> T&gt;, ObserverWrapper&gt;&gt; iterator =</span><br><span class="line">                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class="line">                considerNotify(iterator.next().getValue());</span><br><span class="line">                <span class="keyword">if</span> (mDispatchInvalidated) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (mDispatchInvalidated);</span><br><span class="line">    mDispatchingValue = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">considerNotify</span><span class="params">(ObserverWrapper observer)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果 observer是不活跃的，也是不进行分发的</span></span><br><span class="line">    <span class="keyword">if</span> (!observer.mActive) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//再判断宿主的生命周期是否大于start状态</span></span><br><span class="line">    <span class="keyword">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class="line">      <span class="comment">//如果不活跃，就把actvityStateChanged状态转为false</span></span><br><span class="line">        observer.activeStateChanged(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//mVersion是在livedata的构造里创建的 只有当observer.mLastVersion 小于mVersion的时候才会进行分发</span></span><br><span class="line">    <span class="keyword">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//这里是分发后，要把mLastVersion 和mVersion进行同步赋值</span></span><br><span class="line">    observer.mLastVersion = mVersion;</span><br><span class="line">  <span class="comment">//这里才是真正的分发回调onChaned 把livedata里的泛型数据传入进去</span></span><br><span class="line">    observer.mObserver.onChanged((T) mData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>livedata中还有一个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">observeForever</span><span class="params">(<span class="meta">@NonNull</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    assertMainThread(<span class="string">&quot;observeForever&quot;</span>);</span><br><span class="line">    AlwaysActiveObserver wrapper = <span class="keyword">new</span> AlwaysActiveObserver(observer);</span><br><span class="line">    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">    <span class="keyword">if</span> (existing <span class="keyword">instanceof</span> LiveData.LifecycleBoundObserver) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Cannot add the same observer&quot;</span></span><br><span class="line">                + <span class="string">&quot; with different lifecycles&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    wrapper.activeStateChanged(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果注册了这个方法，在宿主被销毁时，livedata是不会帮我们反注册的，需要我们自行去调用removeObserver</p><p>接着来看postValue</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> postTask;</span><br><span class="line">    <span class="keyword">synchronized</span> (mDataLock) &#123;</span><br><span class="line">        postTask = mPendingData == NOT_SET;</span><br><span class="line">        mPendingData = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!postTask) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前在子线程中，则必须调用postvalue 不能调用 setvalue</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    assertMainThread(<span class="string">&quot;setValue&quot;</span>);</span><br><span class="line">  <span class="comment">//新的数据需要进行分发，这里mLastVersion就小于mVersion了，可以进行分发，如果调用了onChanged的，消费了这个事件和数据，mLastVersion就同步了</span></span><br><span class="line">    mVersion++;</span><br><span class="line">    mData = value;</span><br><span class="line">    dispatchingValue(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dispatchingValue 传了null值 这个要区别于上面activeStateChanged中的dispatchingValue</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchingValue</span><span class="params">(<span class="meta">@Nullable</span> ObserverWrapper initiator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDispatchingValue) &#123;</span><br><span class="line">        mDispatchInvalidated = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mDispatchingValue = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        mDispatchInvalidated = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (initiator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            considerNotify(initiator);</span><br><span class="line">            initiator = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//这里传了null 所以，走下面的这个逻辑  遍历这个observers </span></span><br><span class="line">          <span class="comment">//这个observers就是我们之前addObserver添加进去的</span></span><br><span class="line">            <span class="keyword">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;? <span class="keyword">super</span> T&gt;, ObserverWrapper&gt;&gt; iterator =</span><br><span class="line">                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class="line">              <span class="comment">//遍历之后，就会调用considerNoity进行数据的分发，调用onChanged</span></span><br><span class="line">                considerNotify(iterator.next().getValue());</span><br><span class="line">                <span class="keyword">if</span> (mDispatchInvalidated) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (mDispatchInvalidated);</span><br><span class="line">    mDispatchingValue = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>livedata 这个方法，判断是否有活跃的观察者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasActiveObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mActiveCount &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下livedata的子类，实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutableLiveData</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">LiveData</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MutableLiveData</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MutableLiveData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.postValue(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setValue(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类好像什么都没做，只是复写了postvalue和setvalue并把方法改成了public而已，那么原因是什么？</p><blockquote><p>因为livedata作为数据发送组件，必定是一方发送一方接收，不能既发送又接收，所以MutableLiveData 是为了规避这个问题才存在的，只有拿到的对象是MutableLiveData它才能进行一个数据的发送</p></blockquote></div><footer class="post-footer"><div class="post-eof"></div></footer></article><nav class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a></nav></div><script>window.addEventListener("tabs:register",()=>{let e=CONFIG.comments["activeClass"];if(CONFIG.comments.storage&&(e=localStorage.getItem("comments_active")||e),e){let t=document.querySelector(`a[href="#comment-${e}"]`);t&&t.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">张龙</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">18</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">3</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">4</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">张龙</span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script></body></html>