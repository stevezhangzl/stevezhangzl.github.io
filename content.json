{"meta":{"title":"SteveZhang博客","subtitle":"","description":"","author":"张龙","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Kotlin 委托属性","slug":"Kotlin-委托属性","date":"2022-02-06T22:06:04.000Z","updated":"2022-02-06T22:06:27.000Z","comments":true,"path":"2022/02/07/Kotlin-委托属性/","link":"","permalink":"http://example.com/2022/02/07/Kotlin-%E5%A7%94%E6%89%98%E5%B1%9E%E6%80%A7/","excerpt":"","text":"Kotlin委托属性Kotlin常见的委托属性包括两种：延迟属性(lazy properties) 与可观察属性(observable properties)。 委托属性的语法1var/val &lt;属性名&gt;:&lt;类型&gt; by &lt;表达式&gt; 用例123val INSTANCE:Singleton by lazy(mode = LazyThreadSafetyMode.SYNCHRONIZED)&#123; Singleton()&#125; 这里所说的委托就是在by 后面的表达式； 属性对应的get()（与set()）会被委托给它的getValue()与setValue()函数； 属性的委托需要提供一个getValue函数； 接下来我们重点介绍下上文中我们用到的延迟属性lazy: 在Lazy.kt 文件中，声明了Lazy接口的getValue扩展函数，所以最终赋值的时候会调用该函数： 12@kotlin .interal.InlineOnlypublic inline operator fun &lt;T&gt; Lazy&lt;T&gt;.getValue(thieRef:Any?,property:KProperty&lt;*&gt;):T = value","categories":[],"tags":[]},{"title":"Vue - 动画","slug":"Vue-动画","date":"2022-02-02T10:39:12.000Z","updated":"2022-02-06T03:58:29.000Z","comments":true,"path":"2022/02/02/Vue-动画/","link":"","permalink":"http://example.com/2022/02/02/Vue-%E5%8A%A8%E7%94%BB/","excerpt":"","text":"在CSS过渡和动画中自动应用class 可以配合使用第三方CSS动画库，如Animate.css 在过渡钩子函数中使用JavaScript直接操作DOM 可以配合全名用第三方JavaScript动画库，如Velocity.js","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-02-02T08:29:10.000Z","updated":"2022-02-02T08:29:10.000Z","comments":true,"path":"2022/02/02/hello-world/","link":"","permalink":"http://example.com/2022/02/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Kotlin 单例object & Kotlin和 Java 单例模式","slug":"kotlin 单例","date":"2022-02-02T08:29:10.000Z","updated":"2022-02-06T21:15:59.000Z","comments":true,"path":"2022/02/02/kotlin 单例/","link":"","permalink":"http://example.com/2022/02/02/kotlin%20%E5%8D%95%E4%BE%8B/","excerpt":"单例objectobject的定义Java123public class Singleton&#123; public static final Singleton INSTANCE = new Singleton();&#125; Kotlin1object Singleton&#123;&#125;//定义单例，类加载时实例化对象Singleton既是类名也是对象名 饿汉式——类一旦加载就马上初始化","text":"单例objectobject的定义Java123public class Singleton&#123; public static final Singleton INSTANCE = new Singleton();&#125; Kotlin1object Singleton&#123;&#125;//定义单例，类加载时实例化对象Singleton既是类名也是对象名 饿汉式——类一旦加载就马上初始化 访问object的成员Kotlin1234object Singleton&#123; var x:Int = 2 fun y()&#123;...&#125;&#125; 12Singleton.xSingleton.y Java123Singleton.INSTANCE.getX();Singleton.INSTANCE.setX(2);Singleton.INSTANCE.y(); 静态成员 @JvmStatic kotlin中没有静态成员，想要模拟需要@JvmStatic 注解 Kotlin1234object Singleton&#123; @JvmStatic var x:Int = 2 @JvmStatic fun y()&#123;...&#125;&#125; 12Singleton.xSingleton.y() Java123Singleton.getX();Singleton.setX(2);Singleton.y(); object的成员直接按照Java静态成员生成字节码，对Kotlin内部使用无任何影响，Java调用object成员可直接视同调用静态成员一般。 不生成getter&#x2F;setter @JvmFieldKotlin1234object Singleton&#123; @JvmField var x:Int = 2 @JvmField fun y()&#123;...&#125;&#125; 12Singleton.xSingleton.y() 这里object 会生成静态的，如果不是object 其实不会生成静态的 Java12Singleton.x; //属性x不生成getter/setter 访问方式等同于java fieldSingleton.y(); 普通类的静态成员123class Foo&#123; @JvmStatic fun y()&#123;&#125; //Only members in named ojbects and companion objects can be annotated with &#x27;@JvmStatic&#x27;&#125; Kotlin12345class Foo&#123; companion object&#123; @JvmStatic fun y()&#123;&#125; &#125;&#125; Java123public class Foo&#123; public static void y()&#123;&#125;&#125; 123class Foo&#123; @JvmField var x:Int = 2 // 生成非静态的Field 不带getter/setter的写法&#125; Kotlin和 Java 单例模式饿汉式 空间换时间 Java 1234567public class Singleton1Java &#123; public static Singleton1Java INSTANCE = new Singleton1Java(); public static Singleton1Java getInstance()&#123; return INSTANCE; &#125;&#125; Kotlin 1object Singleton1Kotlin &#123;&#125; Kotlin to Java 1234567public final class Singleton1Kotlin &#123; @NotNull public static final Singleton1Kotlin INSTANCE = new Singleton1Kotlin(); private Singleton1Kotlin() &#123; &#125;&#125; 懒汉式 时间换空间","categories":[],"tags":[]},{"title":"借助v2ray,记一次VPN内网穿透实践","slug":"记一次vpn内网穿透实践","date":"2022-02-02T08:29:10.000Z","updated":"2022-02-07T22:07:54.000Z","comments":true,"path":"2022/02/02/记一次vpn内网穿透实践/","link":"","permalink":"http://example.com/2022/02/02/%E8%AE%B0%E4%B8%80%E6%AC%A1vpn%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%AE%9E%E8%B7%B5/","excerpt":"花了一天搞了下公司的内网穿透，先给出参考的链接原文及原理，再给出自己的实践记录，可以直接拷贝，换下端口和你们阿里云(或者自己使用的云，这里都以阿里云做例子)的外网IP就OK了","text":"花了一天搞了下公司的内网穿透，先给出参考的链接原文及原理，再给出自己的实践记录，可以直接拷贝，换下端口和你们阿里云(或者自己使用的云，这里都以阿里云做例子)的外网IP就OK了 反向代理&#x2F;内网穿透 原理简单点说，就是，最终实现了，你在家里，通过阿里云服务器，通过公司的局域网服务器来访问公司的局域网资源，这个特别适用于，你个人没法使用公司外网IP做内网映射，局域网服务器(或者在公司的某一台电脑)可以访问外网的情况。当然更习惯于用远程的当我没说。原理就是，两个服务器都部署v2ray，然后公司的局域网连接阿里云服务器，再反向代理回来，最终客户机通过客户端连接阿里云服务器，最终通过公司的服务器访问内网。 配置1.阿里云服务器先配置中间的阿里云服务器，别忘了阿里云服务器要保证你的vpn服务的端口要设置为开放状态，因为本来是要客户机和内网的服务器走两个inbounds的，但还需要让领导再开一个端口就没好意思提，这里用同一个vemess inbound 来接收来自两端的请求，做简化处理也是可行的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&#123; &quot;reverse&quot;:&#123;//反向代理设置，正常搭vpn不需要 &quot;portals&quot;:[ &#123; &quot;tag&quot;:&quot;portal&quot;, &quot;domain&quot;:&quot;private.cloud.com&quot; //这个域名可以随便取，但要和下面保持一致 &#125; ] &#125;, &quot;log&quot;: &#123; &quot;access&quot;: &quot;&quot;, &quot;error&quot;: &quot;&quot;, &quot;loglevel&quot;: &quot;warning&quot; &#125;, &quot;inbounds&quot;: [ &#123; &quot;tag&quot;:&quot;interconn&quot;, &quot;port&quot;: 10086, //开放的端口 &quot;protocol&quot;: &quot;vmess&quot;, &quot;settings&quot;: &#123; &quot;clients&quot;: [//设置访问账户的id 可随机生成 但要注意对应 &#123; &quot;id&quot;: &quot;0c15dd83-3552-4b53-b835-907e6c262d9b&quot;, &quot;alterId&quot;: 64 &#125; ] &#125; &#125; ], &quot;routing&quot;:&#123; &quot;rules&quot;:[ &#123; &quot;type&quot;:&quot;field&quot;, &quot;inboundTag&quot;:[ &quot;external&quot; ], &quot;outboundTag&quot;:&quot;portal&quot; &#125;, &#123; &quot;type&quot;:&quot;field&quot;, &quot;inboundTag&quot;:[ &quot;tunnel&quot; ], &quot;domain&quot;:[ &quot;full:private.cloud.com&quot; ], &quot;outboundTag&quot;:&quot;portal&quot; &#125; ] &#125;&#125; 因为公司阿里云服务器是windows服务器，所以也学习了下windows版本的v2ray服务器的部署，其实非常简单。 网上下载v2ray-windows-64 v2ray.exe执行就是把控制台显示出来并启动v2ray，它会自动使用当前目录下的config配置，可以看到访问的ip wv2ray.exe也是启动v2ray，但是它是后台启动，能在任务进程中看到及关闭该进程服务 2.内网服务器因为一直拉取github的内容拉不下来，自动安装一直不成功，所以内网的linux服务器是手动部署的，其实效果是一样的，就是稍微麻烦些 v2ray完全使用教程 2-2手动安装 我这里是通过自己的电脑下载下来v2ray-linux-64.zip 然后scp到服务器上解压，然后进行手动部署的 然后把各个文件mv到相应的目录中 123456sudo mkdir /etc/v2ray /usr/bin/v2ray /var/log/v2ray # 创建目录sudo chmod +x v2ray v2ctl # 赋予可执行权限sudo mv v2ray v2ctl geoip.dat geosite.dat -t /usr/bin/v2ray # 移动文件touch /etc/v2ray/config.json # 仅创建配置文件的空文件sudo mv systemd/v2ray.service /etc/systemd/system/sudo systemctl enable v2ray # 用于程序开机启动并且崩溃时自动重启程序 但要注意对应的目录，而且要看下v2ray.service中的配置，执行的命令的v2ray相应的文件是否存在，在这里卡了好久，一直启不起来服务，结果发现是v2ray和config.json相应的目录不对 12345678#启用和禁用sudo systemctl enable v2raysudo systemctl disable v2ray#启动、停止、重启v2raysudo systemctl start v2raysudo systemctl stop v2raysudo systemctl restart v2ray 下面给出内网服务器的配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&#123; &quot;reverse&quot;:&#123; &quot;bridges&quot;:[ &#123; &quot;tag&quot;:&quot;bridge&quot;, &quot;domain&quot;:&quot;private.cloud.com&quot; // A 和 B 反向代理通信的域名，可以自己取一个，可以不是自己购买的域名，但必须跟上面 阿里云 中的 reverse 配置的域名一致 &#125; ] &#125;, &quot;outbounds&quot;:[ &#123; //内网连接阿里云的outbound &quot;tag&quot;:&quot;tunnel&quot;, &quot;protocol&quot;:&quot;vmess&quot;, &quot;settings&quot;:&#123; &quot;vnext&quot;:[ &#123; &quot;address&quot;:&quot;serveraddr.com&quot;, // 阿里云外网 地址，IP 或 实际的域名 &quot;port&quot;:10086, &quot;users&quot;:[ &#123; &quot;id&quot;:&quot;0c15dd83-3552-4b53-b835-907e6c262d9b&quot;, &quot;alterId&quot;:64 &#125; ] &#125; ] &#125; &#125;, // 另一个 outbound，最终连接私有网盘 &#123; &quot;protocol&quot;:&quot;freedom&quot;, &quot;settings&quot;:&#123; &#125;, &quot;tag&quot;:&quot;out&quot; &#125; ], &quot;routing&quot;:&#123; &quot;rules&quot;:[ &#123; // 配置 A 主动连接 B 的路由规则 &quot;type&quot;:&quot;field&quot;, &quot;inboundTag&quot;:[ &quot;bridge&quot; ], &quot;domain&quot;:[ &quot;full:private.cloud.com&quot; ], &quot;outboundTag&quot;:&quot;tunnel&quot; &#125;, &#123; // 反向连接访问私有网盘的规则 &quot;type&quot;:&quot;field&quot;, &quot;inboundTag&quot;:[ &quot;bridge&quot; ], &quot;outboundTag&quot;:&quot;out&quot; &#125; ] &#125;&#125; 3.客户端配置看你使用的系统，我的是客户端设置完后自动生成json的，没啥特殊要说的，可以自己生成，也可以直接使用这个配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&#123; &quot;routing&quot; : &#123; &quot;name&quot; : &quot;all_to_main&quot;, &quot;domainStrategy&quot; : &quot;AsIs&quot;, &quot;rules&quot; : [ &#123; &quot;type&quot; : &quot;field&quot;, &quot;outboundTag&quot; : &quot;ip_60&quot;, &quot;port&quot; : &quot;0-65535&quot; &#125; ] &#125;, &quot;inbounds&quot; : [ &#123; &quot;listen&quot; : &quot;127.0.0.1&quot;, &quot;protocol&quot; : &quot;socks&quot;, &quot;settings&quot; : &#123; &quot;ip&quot; : &quot;127.0.0.1&quot;, &quot;auth&quot; : &quot;noauth&quot;, &quot;udp&quot; : false &#125;, &quot;tag&quot; : &quot;socksinbound&quot;, &quot;port&quot; : 1081 &#125;, &#123; &quot;listen&quot; : &quot;127.0.0.1&quot;, &quot;protocol&quot; : &quot;http&quot;, &quot;settings&quot; : &#123; &quot;timeout&quot; : 0 &#125;, &quot;tag&quot; : &quot;httpinbound&quot;, &quot;port&quot; : 8001 &#125; ], &quot;dns&quot; : &#123; &quot;servers&quot; : [ &quot;localhost&quot; ] &#125;, &quot;log&quot; : &#123; &quot;loglevel&quot; : &quot;info&quot; &#125;, &quot;outbounds&quot; : [ &#123; &quot;sendThrough&quot; : &quot;0.0.0.0&quot;, &quot;mux&quot; : &#123; &quot;enabled&quot; : false, &quot;concurrency&quot; : 8 &#125;, &quot;protocol&quot; : &quot;vmess&quot;, &quot;settings&quot; : &#123; &quot;vnext&quot; : [ &#123; &quot;address&quot; : &quot;serveraddr.com&quot;, &quot;users&quot; : [ &#123; &quot;id&quot; : &quot;0c15dd83-3552-4b53-b835-907e6c262d9b&quot;, &quot;alterId&quot; : 64, &quot;security&quot; : &quot;auto&quot;, &quot;level&quot; : 0 &#125; ], &quot;port&quot; : 10086 &#125; ] &#125;, &quot;tag&quot; : &quot;ip_60&quot;, &quot;streamSettings&quot; : &#123; &quot;wsSettings&quot; : &#123; &quot;path&quot; : &quot;&quot;, &quot;headers&quot; : &#123; &#125; &#125;, &quot;quicSettings&quot; : &#123; &quot;key&quot; : &quot;&quot;, &quot;header&quot; : &#123; &quot;type&quot; : &quot;none&quot; &#125;, &quot;security&quot; : &quot;none&quot; &#125;, &quot;tlsSettings&quot; : &#123; &quot;allowInsecure&quot; : false, &quot;alpn&quot; : [ &quot;http\\/1.1&quot; ], &quot;serverName&quot; : &quot;server.cc&quot;, &quot;allowInsecureCiphers&quot; : false &#125;, &quot;httpSettings&quot; : &#123; &quot;path&quot; : &quot;&quot; &#125;, &quot;kcpSettings&quot; : &#123; &quot;header&quot; : &#123; &quot;type&quot; : &quot;none&quot; &#125;, &quot;mtu&quot; : 1350, &quot;congestion&quot; : false, &quot;tti&quot; : 20, &quot;uplinkCapacity&quot; : 5, &quot;writeBufferSize&quot; : 1, &quot;readBufferSize&quot; : 1, &quot;downlinkCapacity&quot; : 20 &#125;, &quot;tcpSettings&quot; : &#123; &quot;header&quot; : &#123; &quot;type&quot; : &quot;none&quot; &#125; &#125;, &quot;security&quot; : &quot;none&quot;, &quot;network&quot; : &quot;tcp&quot; &#125; &#125; ]&#125;","categories":[],"tags":[]}],"categories":[],"tags":[]}