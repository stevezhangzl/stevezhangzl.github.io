{"meta":{"title":"SteveZhang博客","subtitle":"","description":"","author":"张龙","url":"http://example.com","root":"/"},"pages":[{"title":"标签","date":"2022-02-17T19:42:42.000Z","updated":"2022-02-17T19:43:25.000Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-02-17T19:39:33.000Z","updated":"2022-02-17T19:44:01.000Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Gradle基础","slug":"Gradle基础","date":"2022-05-14T04:38:51.000Z","updated":"2022-05-14T04:38:51.000Z","comments":true,"path":"2022/05/14/Gradle基础/","link":"","permalink":"http://example.com/2022/05/14/Gradle%E5%9F%BA%E7%A1%80/","excerpt":"讲解Gradle基础知识，语法及生命周期","text":"讲解Gradle基础知识，语法及生命周期 Gradle 基础使用 .&#x2F;gradlew clean -q 来过滤只显示我们的自己的输出日志 一 语法1.1 基础语法123456789101112131415161718192021222324252627int a = 10def b = 10String str = &quot;Hello,&quot; + &quot;World&quot;String str2 = str.toUpperCase()//列表def array = [1,2,3,4]array.add(5)array.each&#123;//闭包特性，只有一个参数默认为it 可以省略 it -&gt; 不写 println(&quot;each item is $it&quot;)&#125;//映射表def map = [&quot;name&quot;:&quot;mooc&quot;,&quot;age&quot;:&quot;100&quot;]println(&quot;age is $&#123;map[&quot;age&quot;]&#125;&quot;)//循环for(int i = 0;i&lt;10;i++)&#123; println(&quot;i is $i&quot;)&#125;//函数def hello(String name)&#123; println(&quot;Hello, $name&quot;)&#125; 1.2 DSL Domain Specific Language 领域专用语言 只能用于构建，不能干别的，所以说是领域专用语言 这个是android build.gradle 的DSL 12345678910111213141516171819202122232425262728android &#123; compileSdkVersion 30 buildToolsVersion &quot;30.0.3&quot; defaultConfig &#123; applicationId &quot;com.steve.gradle_study&quot; minSdkVersion 21 targetSdkVersion 30 versionCode 1 versionName &quot;1.0&quot; testInstrumentationRunner &quot;androidx.test.runner.AndroidJUnitRunner&quot; &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile(&#x27;proguard-android-optimize.txt&#x27;), &#x27;proguard-rules.pro&#x27; &#125; &#125; compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 &#125; kotlinOptions &#123; jvmTarget = &#x27;1.8&#x27; &#125;&#125; 1.3 闭包DSL的实现是基于groovy中的闭包实现的 开放匿名的代码块，可以接受参数，具有返回值，也可以被分配给变量 定义规则:{ [params -&gt; ] statements } 123456789101112131415161718def c = &#123; println(&quot;hello closure&quot;)&#125;c()def c2 = &#123; it -&gt; println (&quot;it is $it&quot;)&#125;c2(&quot;yt&quot;)def c3 = &#123; println (&quot;it is $it&quot;)&#125;c3(&quot;yt&quot;)def c4 = &#123; name,age -&gt; println (&quot;name is $name&quot;) println (&quot;age is $age&quot;)&#125;c4(&quot;wwww&quot;,33) 1.4 实现自己的DSL123456&#123; compileSdkVersion 25 defaultConfig&#123; versionName &quot;1.0&quot; &#125;&#125; 用户配置成这样，我们怎么能取到对应的配置的值，使用对象关联起来 里面的defaultconfig 闭包对应的对象 123456class DefalutConfig&#123; private String versionName def versionName(String versionName)&#123; this.versionName = versionName &#125;&#125; 外面的android 闭包对应的对象 1234567891011121314151617181920class Android&#123; private int compileSdkVersion private DefalutConfig defalutConfig Android()&#123; this.defalutConfig = new DefalutConfig() &#125; def compileSdkVersion(int compileSdkVersion)&#123; this.compileSdkVersion =compileSdkVersion &#125; //传入一个闭包，接收到闭包后跟我们的DefaultConfig成员变量关联起来 def defaultConfig(Closure closure)&#123; //关联之后，对象就获到到闭包中对应同名的值了 closure.setDelegate(defalutConfig) closure.call() &#125;&#125; 使用 123456789101112def myAndroid = &#123; compileSdkVersion 25 defaultConfig&#123; versionName &quot;1.0&quot; &#125;&#125;Android a = new Android()//将闭包与具体对象关联起来，这样在闭包中设置的值就到了对象a中了，我们可以打印a 获取a中的值myAndroid.delegate = amyAndroid.call() 运行 1./graldew clean -q 二 Gradle构建脚本基础几个关键的文件 settings.gradle—定义全局参与构建的模块 build.gradle—有两类build.gradle文件，一个是全局的定义共用参数，各个单独的定义自己的配置 gradle.properties—定义开关型参数的文件 三 Gradle构建的生命周期 初始化阶段—收集所有要参与构建的子工程，创建一个项目层次结构，并且为每一个项目创建一个project实例，和这个阶段关系最大的就是我们的settings.gradle文件 配置阶段—执行各个子工程自己的build.gradle，对project进行配置，并且根据配置形成一个任务依赖链，以便在下一个阶段执行阶段，方便执行任务 执行阶段—执行上一阶段的tasks 我们在settings.gradle中添加生命周期的监听函数 1234567891011121314151617181920//添加构建的生命周期gradle.addBuildListener(new BuildAdapter()&#123; @Override void settingsEvaluated(Settings settings) &#123; super.settingsEvaluated(settings) println (&quot;[life-cycle] 初始化阶段完成&quot;) &#125; @Override void projectsEvaluated(Gradle gradle) &#123; super.projectsEvaluated(gradle) println (&quot;[life-cycle] 配置阶段完成&quot;) &#125; @Override void buildFinished(BuildResult result) &#123; super.buildFinished(result) println (&quot;[life-cycle] 构建结束&quot;) &#125;&#125;) 打印结果 几个主要角色 初始化阶段-root project 配置阶段-project 执行阶段-task","categories":[],"tags":[]},{"title":"okhttp网络框架原理","slug":"okhttp网络框架源码(kotlin)","date":"2022-05-14T04:38:51.000Z","updated":"2022-05-14T04:38:51.000Z","comments":true,"path":"2022/05/14/okhttp网络框架源码(kotlin)/","link":"","permalink":"http://example.com/2022/05/14/okhttp%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81(kotlin)/","excerpt":"okhttp网络框架原理","text":"okhttp网络框架原理 okhttp 网络框架原理12345678910111213141516171819202122232425262728293031323334353637383940414243//构造函数class Builder constructor() &#123;//空参数构造函数 //成员变量的默认初始化 //分发器——重点 主要处理异步请求网络 缓存等分发流程 internal var dispatcher: Dispatcher = Dispatcher() //连接池，每一个连接进入连接池，1.同样url会连接复用 2.哪些连接打开 哪些复用 的策略 internal var connectionPool: ConnectionPool = ConnectionPool() internal val interceptors: MutableList&lt;Interceptor&gt; = mutableListOf() internal val networkInterceptors: MutableList&lt;Interceptor&gt; = mutableListOf() internal var eventListenerFactory: EventListener.Factory = EventListener.NONE.asFactory() internal var retryOnConnectionFailure = true internal var authenticator: Authenticator = Authenticator.NONE internal var followRedirects = true internal var followSslRedirects = true internal var cookieJar: CookieJar = CookieJar.NO_COOKIES internal var cache: Cache? = null internal var dns: Dns = Dns.SYSTEM internal var proxy: Proxy? = null internal var proxySelector: ProxySelector? = null internal var proxyAuthenticator: Authenticator = Authenticator.NONE internal var socketFactory: SocketFactory = SocketFactory.getDefault() internal var sslSocketFactoryOrNull: SSLSocketFactory? = null internal var x509TrustManagerOrNull: X509TrustManager? = null internal var connectionSpecs: List&lt;ConnectionSpec&gt; = DEFAULT_CONNECTION_SPECS internal var protocols: List&lt;Protocol&gt; = DEFAULT_PROTOCOLS internal var hostnameVerifier: HostnameVerifier = OkHostnameVerifier internal var certificatePinner: CertificatePinner = CertificatePinner.DEFAULT internal var certificateChainCleaner: CertificateChainCleaner? = null internal var callTimeout = 0 internal var connectTimeout = 10_000 internal var readTimeout = 10_000 internal var writeTimeout = 10_000 internal var pingInterval = 0 //设置方法，直接使用apply 作用域函数 apply fun readTimeout(duration: Duration) = apply &#123; readTimeout = checkDuration(&quot;timeout&quot;, duration.toMillis(), TimeUnit.MILLISECONDS) &#125; ... &#125; kotlin 知识点补充 internal —— 能见到类声明的 本模块内 的任何客户端都可见其interanl成员 作用域函数——是在对象的上下文中执行代码块。当对一个对象调用这样的函数并提供一个 lambda 表达式时，它会形成一个临时作用域。在此作用域中，可以访问该对象而无需其名称。共有以下五种：let、run、with、apply 以及 also。 每个作用域函数之间有两个主要区别： 引用上下文对象的方式 this 和 it 返回值 apply 这里 使用this 但可以省略 另外使用it的是let和also apply 和also 返回上下文对象本身。因此，它们可以作为辅助步骤包含在调用链中：你可以继续在同一个对象上进行链式函数调用。有返回值，返回的就是对象本身。 let、run和with返回lambda表达式的结果。所以可以给一个变量赋值。 val numbers &#x3D; mutableListOf(“one”, “two”, “three”)val countEndsWithE &#x3D; numbers.run { add(“four”) add(“five”) count { it.endsWith(“e”) }&#x2F;&#x2F;返回的的此表达式的结果，所以是count是Int}println(“There are $countEndsWithE elements that end with e.”) 此外，还可以忽略返回值，仅使用作用域函数为变量创建一个临时作用域。 val numbers &#x3D; mutableListOf(“one”, “two”, “three”)with(numbers) { val firstItem &#x3D; first() val lastItem &#x3D; last() println(“First item: $firstItem, last item: $lastItem”)} 不返回东西，而是限制在with作用域内操作的是numbers对象，省略了this okhttp的调用流程图 核心是getResponseWithInterceptorChain方法，拦截器链的实现，主要请求也是在这里完成的 同步是excute 异步 equeue BuIld设计模式 要构造的对象参数很多，可以参考okttp的build模式，可以大大简化，构建的步骤和传参，方便使用链式操作来设置单独的属性。","categories":[],"tags":[]},{"title":"借助v2ray,记一次VPN内网穿透实践","slug":"记一次vpn内网穿透实践","date":"2022-05-14T04:38:51.000Z","updated":"2022-05-14T04:38:52.000Z","comments":true,"path":"2022/05/14/记一次vpn内网穿透实践/","link":"","permalink":"http://example.com/2022/05/14/%E8%AE%B0%E4%B8%80%E6%AC%A1vpn%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%AE%9E%E8%B7%B5/","excerpt":"花了一天搞了下公司的内网穿透，先给出参考的链接原文及原理，再给出自己的实践记录，可以直接拷贝，换下端口和你们阿里云(或者自己使用的云，这里都以阿里云做例子)的外网IP就OK了","text":"花了一天搞了下公司的内网穿透，先给出参考的链接原文及原理，再给出自己的实践记录，可以直接拷贝，换下端口和你们阿里云(或者自己使用的云，这里都以阿里云做例子)的外网IP就OK了 反向代理&#x2F;内网穿透 原理简单点说，就是，最终实现了，你在家里，通过阿里云服务器，通过公司的局域网服务器来访问公司的局域网资源，这个特别适用于，你个人没法使用公司外网IP做内网映射，局域网服务器(或者在公司的某一台电脑)可以访问外网的情况。当然更习惯于用远程的当我没说。原理就是，两个服务器都部署v2ray，然后公司的局域网连接阿里云服务器，再反向代理回来，最终客户机通过客户端连接阿里云服务器，最终通过公司的服务器访问内网。 配置1.阿里云服务器先配置中间的阿里云服务器，别忘了阿里云服务器要保证你的vpn服务的端口要设置为开放状态，因为本来是要客户机和内网的服务器走两个inbounds的，但还需要让领导再开一个端口就没好意思提，这里用同一个vemess inbound 来接收来自两端的请求，做简化处理也是可行的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&#123; &quot;reverse&quot;:&#123;//反向代理设置，正常搭vpn不需要 &quot;portals&quot;:[ &#123; &quot;tag&quot;:&quot;portal&quot;, &quot;domain&quot;:&quot;private.cloud.com&quot; //这个域名可以随便取，但要和下面保持一致 &#125; ] &#125;, &quot;log&quot;: &#123; &quot;access&quot;: &quot;&quot;, &quot;error&quot;: &quot;&quot;, &quot;loglevel&quot;: &quot;warning&quot; &#125;, &quot;inbounds&quot;: [ &#123; &quot;tag&quot;:&quot;interconn&quot;, &quot;port&quot;: 10086, //开放的端口 &quot;protocol&quot;: &quot;vmess&quot;, &quot;settings&quot;: &#123; &quot;clients&quot;: [//设置访问账户的id 可随机生成 但要注意对应 &#123; &quot;id&quot;: &quot;0c15dd83-3552-4b53-b835-907e6c262d9b&quot;, &quot;alterId&quot;: 64 &#125; ] &#125; &#125; ], &quot;routing&quot;:&#123; &quot;rules&quot;:[ &#123; &quot;type&quot;:&quot;field&quot;, &quot;inboundTag&quot;:[ &quot;external&quot; ], &quot;outboundTag&quot;:&quot;portal&quot; &#125;, &#123; &quot;type&quot;:&quot;field&quot;, &quot;inboundTag&quot;:[ &quot;tunnel&quot; ], &quot;domain&quot;:[ &quot;full:private.cloud.com&quot; ], &quot;outboundTag&quot;:&quot;portal&quot; &#125; ] &#125;&#125; 因为公司阿里云服务器是windows服务器，所以也学习了下windows版本的v2ray服务器的部署，其实非常简单。 网上下载v2ray-windows-64 v2ray.exe执行就是把控制台显示出来并启动v2ray，它会自动使用当前目录下的config配置，可以看到访问的ip wv2ray.exe也是启动v2ray，但是它是后台启动，能在任务进程中看到及关闭该进程服务 2.内网服务器因为一直拉取github的内容拉不下来，自动安装一直不成功，所以内网的linux服务器是手动部署的，其实效果是一样的，就是稍微麻烦些 v2ray完全使用教程 2-2手动安装 我这里是通过自己的电脑下载下来v2ray-linux-64.zip 然后scp到服务器上解压，然后进行手动部署的 然后把各个文件mv到相应的目录中 123456sudo mkdir /etc/v2ray /usr/bin/v2ray /var/log/v2ray # 创建目录sudo chmod +x v2ray v2ctl # 赋予可执行权限sudo mv v2ray v2ctl geoip.dat geosite.dat -t /usr/bin/v2ray # 移动文件touch /etc/v2ray/config.json # 仅创建配置文件的空文件sudo mv systemd/v2ray.service /etc/systemd/system/sudo systemctl enable v2ray # 用于程序开机启动并且崩溃时自动重启程序 但要注意对应的目录，而且要看下v2ray.service中的配置，执行的命令的v2ray相应的文件是否存在，在这里卡了好久，一直启不起来服务，结果发现是v2ray和config.json相应的目录不对 12345678#启用和禁用sudo systemctl enable v2raysudo systemctl disable v2ray#启动、停止、重启v2raysudo systemctl start v2raysudo systemctl stop v2raysudo systemctl restart v2ray 下面给出内网服务器的配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&#123; &quot;reverse&quot;:&#123; &quot;bridges&quot;:[ &#123; &quot;tag&quot;:&quot;bridge&quot;, &quot;domain&quot;:&quot;private.cloud.com&quot; // A 和 B 反向代理通信的域名，可以自己取一个，可以不是自己购买的域名，但必须跟上面 阿里云 中的 reverse 配置的域名一致 &#125; ] &#125;, &quot;outbounds&quot;:[ &#123; //内网连接阿里云的outbound &quot;tag&quot;:&quot;tunnel&quot;, &quot;protocol&quot;:&quot;vmess&quot;, &quot;settings&quot;:&#123; &quot;vnext&quot;:[ &#123; &quot;address&quot;:&quot;serveraddr.com&quot;, // 阿里云外网 地址，IP 或 实际的域名 &quot;port&quot;:10086, &quot;users&quot;:[ &#123; &quot;id&quot;:&quot;0c15dd83-3552-4b53-b835-907e6c262d9b&quot;, &quot;alterId&quot;:64 &#125; ] &#125; ] &#125; &#125;, // 另一个 outbound，最终连接私有网盘 &#123; &quot;protocol&quot;:&quot;freedom&quot;, &quot;settings&quot;:&#123; &#125;, &quot;tag&quot;:&quot;out&quot; &#125; ], &quot;routing&quot;:&#123; &quot;rules&quot;:[ &#123; // 配置 A 主动连接 B 的路由规则 &quot;type&quot;:&quot;field&quot;, &quot;inboundTag&quot;:[ &quot;bridge&quot; ], &quot;domain&quot;:[ &quot;full:private.cloud.com&quot; ], &quot;outboundTag&quot;:&quot;tunnel&quot; &#125;, &#123; // 反向连接访问私有网盘的规则 &quot;type&quot;:&quot;field&quot;, &quot;inboundTag&quot;:[ &quot;bridge&quot; ], &quot;outboundTag&quot;:&quot;out&quot; &#125; ] &#125;&#125; 3.客户端配置看你使用的系统，我的是客户端设置完后自动生成json的，没啥特殊要说的，可以自己生成，也可以直接使用这个配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&#123; &quot;routing&quot; : &#123; &quot;name&quot; : &quot;all_to_main&quot;, &quot;domainStrategy&quot; : &quot;AsIs&quot;, &quot;rules&quot; : [ &#123; &quot;type&quot; : &quot;field&quot;, &quot;outboundTag&quot; : &quot;ip_60&quot;, &quot;port&quot; : &quot;0-65535&quot; &#125; ] &#125;, &quot;inbounds&quot; : [ &#123; &quot;listen&quot; : &quot;127.0.0.1&quot;, &quot;protocol&quot; : &quot;socks&quot;, &quot;settings&quot; : &#123; &quot;ip&quot; : &quot;127.0.0.1&quot;, &quot;auth&quot; : &quot;noauth&quot;, &quot;udp&quot; : false &#125;, &quot;tag&quot; : &quot;socksinbound&quot;, &quot;port&quot; : 1081 &#125;, &#123; &quot;listen&quot; : &quot;127.0.0.1&quot;, &quot;protocol&quot; : &quot;http&quot;, &quot;settings&quot; : &#123; &quot;timeout&quot; : 0 &#125;, &quot;tag&quot; : &quot;httpinbound&quot;, &quot;port&quot; : 8001 &#125; ], &quot;dns&quot; : &#123; &quot;servers&quot; : [ &quot;localhost&quot; ] &#125;, &quot;log&quot; : &#123; &quot;loglevel&quot; : &quot;info&quot; &#125;, &quot;outbounds&quot; : [ &#123; &quot;sendThrough&quot; : &quot;0.0.0.0&quot;, &quot;mux&quot; : &#123; &quot;enabled&quot; : false, &quot;concurrency&quot; : 8 &#125;, &quot;protocol&quot; : &quot;vmess&quot;, &quot;settings&quot; : &#123; &quot;vnext&quot; : [ &#123; &quot;address&quot; : &quot;serveraddr.com&quot;, &quot;users&quot; : [ &#123; &quot;id&quot; : &quot;0c15dd83-3552-4b53-b835-907e6c262d9b&quot;, &quot;alterId&quot; : 64, &quot;security&quot; : &quot;auto&quot;, &quot;level&quot; : 0 &#125; ], &quot;port&quot; : 10086 &#125; ] &#125;, &quot;tag&quot; : &quot;ip_60&quot;, &quot;streamSettings&quot; : &#123; &quot;wsSettings&quot; : &#123; &quot;path&quot; : &quot;&quot;, &quot;headers&quot; : &#123; &#125; &#125;, &quot;quicSettings&quot; : &#123; &quot;key&quot; : &quot;&quot;, &quot;header&quot; : &#123; &quot;type&quot; : &quot;none&quot; &#125;, &quot;security&quot; : &quot;none&quot; &#125;, &quot;tlsSettings&quot; : &#123; &quot;allowInsecure&quot; : false, &quot;alpn&quot; : [ &quot;http\\/1.1&quot; ], &quot;serverName&quot; : &quot;server.cc&quot;, &quot;allowInsecureCiphers&quot; : false &#125;, &quot;httpSettings&quot; : &#123; &quot;path&quot; : &quot;&quot; &#125;, &quot;kcpSettings&quot; : &#123; &quot;header&quot; : &#123; &quot;type&quot; : &quot;none&quot; &#125;, &quot;mtu&quot; : 1350, &quot;congestion&quot; : false, &quot;tti&quot; : 20, &quot;uplinkCapacity&quot; : 5, &quot;writeBufferSize&quot; : 1, &quot;readBufferSize&quot; : 1, &quot;downlinkCapacity&quot; : 20 &#125;, &quot;tcpSettings&quot; : &#123; &quot;header&quot; : &#123; &quot;type&quot; : &quot;none&quot; &#125; &#125;, &quot;security&quot; : &quot;none&quot;, &quot;network&quot; : &quot;tcp&quot; &#125; &#125; ]&#125;","categories":[],"tags":[]},{"title":"Jetpack系列—底部导航路由BottomNavigationView原理","slug":"Jetpack系列—底部导航路由原理","date":"2022-05-14T04:38:51.000Z","updated":"2022-05-14T04:38:51.000Z","comments":true,"path":"2022/05/14/Jetpack系列—底部导航路由原理/","link":"","permalink":"http://example.com/2022/05/14/Jetpack%E7%B3%BB%E5%88%97%E2%80%94%E5%BA%95%E9%83%A8%E5%AF%BC%E8%88%AA%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86/","excerpt":"主要介绍BottomNavigationView及其实现原理","text":"主要介绍BottomNavigationView及其实现原理 bottom_nav_menu.xml 配置底部item的显示内容和个数 1234567891011&lt;fragment android:id=&quot;@+id/nav_host_fragment_activity_main&quot; android:name=&quot;androidx.navigation.fragment.NavHostFragment&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:defaultNavHost=&quot;true&quot; app:layout_constraintBottom_toTopOf=&quot;@id/nav_view&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:navGraph=&quot;@navigation/mobile_navigation&quot; /&gt; 1app:defaultNavHost=&quot;true&quot; 是否和系统的返回键相关联 如果相关联，如果回退栈中有fragment 那么就会拦截返回键 如果没有的话就执行返回键的默认行为 1app:navGraph=&quot;@navigation/mobile_navigation&quot; 底部路由结构 1234567891011121314151617181920212223242526&lt;navigation xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/mobile_navigation&quot; app:startDestination=&quot;@+id/navigation_home&quot;&gt; &lt;--节点所配置的fragment --&gt; &lt;fragment android:id=&quot;@+id/navigation_home&quot; android:name=&quot;com.steve.ppjoke_android.ui.home.HomeFragment&quot; android:label=&quot;@string/title_home&quot; tools:layout=&quot;@layout/fragment_home&quot; /&gt; &lt;fragment android:id=&quot;@+id/navigation_dashboard&quot; android:name=&quot;com.steve.ppjoke_android.ui.dashboard.DashboardFragment&quot; android:label=&quot;@string/title_dashboard&quot; tools:layout=&quot;@layout/fragment_dashboard&quot; /&gt; &lt;fragment android:id=&quot;@+id/navigation_notifications&quot; android:name=&quot;com.steve.ppjoke_android.ui.notifications.NotificationsFragment&quot; android:label=&quot;@string/title_notifications&quot; tools:layout=&quot;@layout/fragment_notifications&quot; /&gt;&lt;/navigation&gt; 1app:startDestination=&quot;@+id/navigation_home&quot; 默认要显示的页面是哪一个 通过可视化界面配置fragment 123456789101112131415161718&lt;fragment android:id=&quot;@+id/navigation_home&quot; android:name=&quot;com.steve.ppjoke_android.ui.home.HomeFragment&quot; android:label=&quot;@string/title_home&quot; tools:layout=&quot;@layout/fragment_home&quot;&gt; &lt;!-- 当前fragment跳转到下一页的动作，所以必须指定目标页--&gt; &lt;action android:id=&quot;@+id/id_action&quot; app:destination=&quot;@id/navigation_dashboard&quot; /&gt; &lt;!--指的是创建当前fragment时需要传递的参数 --&gt; &lt;argument android:name=&quot;arg1&quot; app:argType=&quot;integer&quot; /&gt; &lt;!--通过url拉起页面，隐式意图 就是页面路由 --&gt; &lt;deepLink android:id=&quot;@+id/deepLink&quot; app:uri=&quot;www.imooc.com&quot; /&gt;&lt;/fragment&gt; 先看承载的Fragment的实现逻辑 NavHostFragment.java 123456789101112131415161718192021222324252627282930313233343536373839404142public void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); final Context context = requireContext(); //切换fragment的能力委托给NavHostController mNavController = new NavHostController(context); ... //添加了两个导航器 onCreateNavController(mNavController); Bundle navState = null; if (savedInstanceState != null) &#123; navState = savedInstanceState.getBundle(KEY_NAV_CONTROLLER_STATE); if (savedInstanceState.getBoolean(KEY_DEFAULT_NAV_HOST, false)) &#123; mDefaultNavHost = true; getParentFragmentManager().beginTransaction() .setPrimaryNavigationFragment(this) .commit(); &#125; mGraphId = savedInstanceState.getInt(KEY_GRAPH_ID); &#125; if (navState != null) &#123; // Navigation controller state overrides arguments mNavController.restoreState(navState); &#125; if (mGraphId != 0) &#123; // Set from onInflate() mNavController.setGraph(mGraphId); &#125; else &#123; // See if it was set by NavHostFragment.create() final Bundle args = getArguments(); final int graphId = args != null ? args.getInt(KEY_GRAPH_ID) : 0; final Bundle startDestinationArgs = args != null ? args.getBundle(KEY_START_DESTINATION_ARGS) : null; if (graphId != 0) &#123; mNavController.setGraph(graphId, startDestinationArgs); &#125; &#125;&#125; onCreateNavController 1234567protected void onCreateNavController(@NonNull NavController navController) &#123; navController.getNavigatorProvider().addNavigator( //第一个，给dialogframgent提供跳转，切换的能力 new DialogFragmentNavigator(requireContext(), getChildFragmentManager())); //第二个，是给fragment提供跳转 navController.getNavigatorProvider().addNavigator(createFragmentNavigator());&#125; 除此之外，还在NavController的构造函数里添加了两个默认的navigator 1234567891011121314public NavController(@NonNull Context context) &#123; mContext = context; while (context instanceof ContextWrapper) &#123; if (context instanceof Activity) &#123; mActivity = (Activity) context; break; &#125; context = ((ContextWrapper) context).getBaseContext(); &#125; //这个导航器的作用是配置的默认启动的页面，启动后会跳转，唯一被用到的地方 mNavigatorProvider.addNavigator(new NavGraphNavigator(mNavigatorProvider)); //为activity跳转提供支持 mNavigatorProvider.addNavigator(new ActivityNavigator(mContext));&#125; 为什么把navigator添加到provider里呢？ privoder本质是一个hashmap，存储导航器的实例 这4个导航器有什么相同点有什么不同点？ 都继承自Navigator 12345678910111213141516171819202122232425262728//泛型必须继承NavDestination 而NavDestination就是dialog activity fragment 之所以这么设计泛型，是需要activity的navigator只能创建activity的navigator 而fragment只能创建fragment的导航器public abstract class Navigator&lt;D extends NavDestination&gt; &#123; //1.每一个navigator的子类都必须标注一个Name的注解，只有这样，才会把它添加到provider里，我们之前说provider是一个hashmap 它的key就是我们标注的name的名字，value是navigator的实例本身 //2.navigator在创建destination的时候,它会解析navigator上的name，以此来得到导航器的名称 public @interface Name &#123; String value(); &#125; ... //创建Destination 看下面Destination的构造 public abstract D createDestination(); //跳转逻辑 public abstract NavDestination navigate(@NonNull D destination, @Nullable Bundle args,@Nullable NavOptions navOptions, @Nullable Extras navigatorExtras); //是否拦截系统的返回键，实现回退栈的操作 public abstract boolean popBackStack(); //空接口，实现用来做额外的事情，比如过渡元素，转场动画 public interface Extras &#123; &#125;&#125; 123456789//传入一个navigatorpublic NavDestination(@NonNull Navigator&lt;? extends NavDestination&gt; navigator) &#123; this(NavigatorProvider.getNameForNavigator(navigator.getClass()));&#125;//传入一个navigatorName 这个name就是通过标注在navigator上面的name的注解得到的public NavDestination(@NonNull String navigatorName) &#123; mNavigatorName = navigatorName;&#125; 那么为什么要传入navigatorName呢？ NavDestination就是我们跳转的一个个页面，我们通过传入的navigatorName在provider这个hashmap中得到destination实例，就是这么得到我们的跳转的实例的 我们接着看Navigator中的navigate方法 12//跳转逻辑public abstract NavDestination navigate(@NonNull D destination, @Nullable Bundle args,@Nullable NavOptions navOptions, @Nullable Extras navigatorExtras); 由于activity fragment dialog的具体跳转方法都不一样，所以，不会交由父类来实现，所以这里是抽象的，使用了模板方法 Navigator父类了解后，我们来了了解其子类的实现 ActivityNavigator 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119//provider中的key的名字就是activity@Navigator.Name(&quot;activity&quot;)public class ActivityNavigator extends Navigator&lt;ActivityNavigator.Destination&gt; &#123; public final Destination setIntent(@Nullable Intent intent) &#123; mIntent = intent; return this &#125; ... public final Destination setTargetPackage(@Nullable String packageName) &#123; if (mIntent == null) &#123; mIntent = new Intent(); &#125; mIntent.setPackage(packageName); return this; &#125; public Destination setData()&#123; ... &#125; public Destination setComponentName()&#123; ... &#125; //上面这些类都是为了构造或传入Intent对象 ... //核心方法navigate public NavDestination navigate(@NonNull Destination destination, @Nullable Bundle args, @Nullable NavOptions navOptions, @Nullable Navigator.Extras navigatorExtras) &#123; //1.获取跳转Intent if (destination.getIntent() == null) &#123; throw new IllegalStateException(&quot;Destination &quot; + destination.getId() + &quot; does not have an Intent set.&quot;); &#125; Intent intent = new Intent(destination.getIntent()); if (args != null) &#123; intent.putExtras(args); String dataPattern = destination.getDataPattern(); if (!TextUtils.isEmpty(dataPattern)) &#123; // Fill in the data pattern with the args to build a valid URI StringBuffer data = new StringBuffer(); Pattern fillInPattern = Pattern.compile(&quot;\\\\&#123;(.+?)\\\\&#125;&quot;); Matcher matcher = fillInPattern.matcher(dataPattern); while (matcher.find()) &#123; String argName = matcher.group(1); if (args.containsKey(argName)) &#123; matcher.appendReplacement(data, &quot;&quot;); //noinspection ConstantConditions data.append(Uri.encode(args.get(argName).toString())); &#125; else &#123; throw new IllegalArgumentException(&quot;Could not find &quot; + argName + &quot; in &quot; + args + &quot; to fill data pattern &quot; + dataPattern); &#125; &#125; matcher.appendTail(data); intent.setData(Uri.parse(data.toString())); &#125; &#125; // extra 获取额外的flag if (navigatorExtras instanceof Extras) &#123; Extras extras = (Extras) navigatorExtras; intent.addFlags(extras.getFlags()); &#125; //设置intent的跳转的flag if (!(mContext instanceof Activity)) &#123; // If we&#x27;re not launching from an Activity context we have to launch in a new task. intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); &#125; if (navOptions != null &amp;&amp; navOptions.shouldLaunchSingleTop()) &#123; intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP); &#125; //设置跳转的当前页面的hostid 用来做页面溯源 if (mHostActivity != null) &#123; final Intent hostIntent = mHostActivity.getIntent(); if (hostIntent != null) &#123; final int hostCurrentId = hostIntent.getIntExtra(EXTRA_NAV_CURRENT, 0); if (hostCurrentId != 0) &#123; intent.putExtra(EXTRA_NAV_SOURCE, hostCurrentId); &#125; &#125; &#125; final int destId = destination.getId(); intent.putExtra(EXTRA_NAV_CURRENT, destId); //设置跳转的动画 if (navOptions != null) &#123; // For use in applyPopAnimationsToPendingTransition() intent.putExtra(EXTRA_POP_ENTER_ANIM, navOptions.getPopEnterAnim()); intent.putExtra(EXTRA_POP_EXIT_ANIM, navOptions.getPopExitAnim()); &#125; //使用context.startActivity来进行真正的跳转 if (navigatorExtras instanceof Extras) &#123; Extras extras = (Extras) navigatorExtras; ActivityOptionsCompat activityOptions = extras.getActivityOptions(); if (activityOptions != null) &#123; ActivityCompat.startActivity(mContext, intent, activityOptions.toBundle()); &#125; else &#123; mContext.startActivity(intent); &#125; &#125; else &#123; mContext.startActivity(intent); &#125; if (navOptions != null &amp;&amp; mHostActivity != null) &#123; int enterAnim = navOptions.getEnterAnim(); int exitAnim = navOptions.getExitAnim(); if (enterAnim != -1 || exitAnim != -1) &#123; enterAnim = enterAnim != -1 ? enterAnim : 0; exitAnim = exitAnim != -1 ? exitAnim : 0; mHostActivity.overridePendingTransition(enterAnim, exitAnim); &#125; &#125; return null; &#125; &#125; 接下来DialogFragment 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Navigator.Name(&quot;dialog&quot;)public final class DialogFragmentNavigator extends Navigator&lt;DialogFragmentNavigator.Destination&gt; &#123; //同样的创建，传入navigator通过navigator来取出它的名字 public Destination createDestination() &#123; return new Destination(this); &#125; //设置className public final Destination setClassName(@NonNull String className) &#123; mClassName = className; return this; &#125; //核心跳转navigate public NavDestination navigate(@NonNull final Destination destination, @Nullable Bundle args, @Nullable NavOptions navOptions, @Nullable Navigator.Extras navigatorExtras) &#123; if (mFragmentManager.isStateSaved()) &#123; Log.i(TAG, &quot;Ignoring navigate() call: FragmentManager has already&quot; + &quot; saved its state&quot;); return null; &#125; String className = destination.getClassName(); //1.获取classname 全类名 if (className.charAt(0) == &#x27;.&#x27;) &#123; className = mContext.getPackageName() + className; &#125; //2.通过classname 反射构造一个fragment的对象 instantiate这个方法 final Fragment frag = mFragmentManager.getFragmentFactory().instantiate( mContext.getClassLoader(), className); //3.如果不是dialogfragment的子类，就抛异常 if (!DialogFragment.class.isAssignableFrom(frag.getClass())) &#123; throw new IllegalArgumentException(&quot;Dialog destination &quot; + destination.getClassName() + &quot; is not an instance of DialogFragment&quot;); &#125; //4.强转成DialogFragment final DialogFragment dialogFragment = (DialogFragment) frag; dialogFragment.setArguments(args); dialogFragment.getLifecycle().addObserver(mObserver); //5.通过show方法就把dialogfragment展示出来 dialogFragment.show(mFragmentManager, DIALOG_TAG + mDialogCount++); return destination; &#125;&#125; 再来看FragmentNavigator 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697@Navigator.Name(&quot;fragment&quot;)public class FragmentNavigator extends Navigator&lt;FragmentNavigator.Destination&gt; &#123; public Destination createDestination() &#123; return new Destination(this); &#125; @NavDestination.ClassType(Fragment.class) public static class Destination extends NavDestination &#123; //同上，设置全类名 public final Destination setClassName(@NonNull String className) &#123; mClassName = className; return this; &#125; &#125; public NavDestination navigate(@NonNull Destination destination, @Nullable Bundle args, @Nullable NavOptions navOptions, @Nullable Navigator.Extras navigatorExtras) &#123; if (mFragmentManager.isStateSaved()) &#123; Log.i(TAG, &quot;Ignoring navigate() call: FragmentManager has already&quot; + &quot; saved its state&quot;); return null; &#125; //1.通过destination获取classname 全类名 String className = destination.getClassName(); if (className.charAt(0) == &#x27;.&#x27;) &#123; className = mContext.getPackageName() + className; &#125; //2.实例化一个fragment对象，并设置arguments final Fragment frag = instantiateFragment(mContext, mFragmentManager, className, args); frag.setArguments(args); //3.得到Transaction对象 final FragmentTransaction ft = mFragmentManager.beginTransaction(); //跳转动画 int enterAnim = navOptions != null ? navOptions.getEnterAnim() : -1; int exitAnim = navOptions != null ? navOptions.getExitAnim() : -1; int popEnterAnim = navOptions != null ? navOptions.getPopEnterAnim() : -1; int popExitAnim = navOptions != null ? navOptions.getPopExitAnim() : -1; if (enterAnim != -1 || exitAnim != -1 || popEnterAnim != -1 || popExitAnim != -1) &#123; enterAnim = enterAnim != -1 ? enterAnim : 0; exitAnim = exitAnim != -1 ? exitAnim : 0; popEnterAnim = popEnterAnim != -1 ? popEnterAnim : 0; popExitAnim = popExitAnim != -1 ? popExitAnim : 0; ft.setCustomAnimations(enterAnim, exitAnim, popEnterAnim, popExitAnim); &#125; //4.通过replace跳转，这种方式不好，会告诉页面生命周期重启，需要自己再构建一个使用hide和show的FragmentNavigator ft.replace(mContainerId, frag); ft.setPrimaryNavigationFragment(frag); final @IdRes int destId = destination.getId(); final boolean initialNavigation = mBackStack.isEmpty(); // TODO Build first class singleTop behavior for fragments final boolean isSingleTopReplacement = navOptions != null &amp;&amp; !initialNavigation &amp;&amp; navOptions.shouldLaunchSingleTop() &amp;&amp; mBackStack.peekLast() == destId; boolean isAdded; if (initialNavigation) &#123; isAdded = true; &#125; else if (isSingleTopReplacement) &#123; // Single Top means we only want one instance on the back stack if (mBackStack.size() &gt; 1) &#123; // If the Fragment to be replaced is on the FragmentManager&#x27;s // back stack, a simple replace() isn&#x27;t enough so we // remove it from the back stack and put our replacement // on the back stack in its place mFragmentManager.popBackStack( generateBackStackName(mBackStack.size(), mBackStack.peekLast()), FragmentManager.POP_BACK_STACK_INCLUSIVE); ft.addToBackStack(generateBackStackName(mBackStack.size(), destId)); &#125; isAdded = false; &#125; else &#123; ft.addToBackStack(generateBackStackName(mBackStack.size() + 1, destId)); isAdded = true; &#125; if (navigatorExtras instanceof Extras) &#123; Extras extras = (Extras) navigatorExtras; for (Map.Entry&lt;View, String&gt; sharedElement : extras.getSharedElements().entrySet()) &#123; ft.addSharedElement(sharedElement.getKey(), sharedElement.getValue()); &#125; &#125; ft.setReorderingAllowed(true); ft.commit(); // The commit succeeded, update our view of the world if (isAdded) &#123; mBackStack.add(destId); return destination; &#125; else &#123; return null; &#125; &#125;&#125; 最后来看NavGraphNavigator 1234567891011@Navigator.Name(&quot;navigation&quot;)public class NavGraphNavigator extends Navigator&lt;NavGraph&gt; &#123; //这里没有new Destination对象，而是new了一个NavGraph,传入Navigator public NavGraph createDestination() &#123; return new NavGraph(this); &#125; &#125; NavGraph.java 是NavDestination的子类，是特殊的子类 123456789public class NavGraph extends NavDestination implements Iterable&lt;NavDestination&gt; &#123; //node数组，这里就是存储了一个个跳转节点的的实例，也就是我们在 mobile_navigation.xml中声明的一个个fragment activity实例，都会被存储到mNodes中 final SparseArrayCompat&lt;NavDestination&gt; mNodes = new SparseArrayCompat&lt;&gt;(); //这个就是对应mobile_navigation.xml中指定的app:startDestination=&quot;@+id/navigation_dashboard&quot; 而一旦xml被解析，这里就获取到我们指定的页面id private int mStartDestId;&#125; 那么又是在哪里解析的，什么时候解析的呢？ 还记得我们上面的宿主fragment NavHostFragment 我们在oncreate中创建了NavHostController 我们看下Controller中的逻辑 123456789101112public class NavController &#123; public void setGraph(@NavigationRes int graphResId) &#123; setGraph(graphResId, null); &#125; public void setGraph(@NavigationRes int graphResId, @Nullable Bundle startDestinationArgs) &#123; //调用navinflater的inflate方法来解析xml文件 setGraph(getNavInflater().inflate(graphResId), startDestinationArgs); &#125;&#125; 这个inflate方法 12345678910111213141516171819202122232425262728293031323334public NavGraph inflate(@NavigationRes int graphResId) &#123; Resources res = mContext.getResources(); //1.获取xml parser来解析xml文件 XmlResourceParser parser = res.getXml(graphResId); //2.获取属性 final AttributeSet attrs = Xml.asAttributeSet(parser); try &#123; int type; while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; // Empty loop &#125; if (type != XmlPullParser.START_TAG) &#123; throw new XmlPullParserException(&quot;No start tag found&quot;); &#125; String rootElement = parser.getName(); //3.实际上是另一个inflate方法来解析构造出的具体的NavDestion对象 这里主要通过parser获取标签名，再通过name 在provider中拿到navigator 再通过navigator来创建各自的navigation NavDestination destination = inflate(res, parser, attrs, graphResId); if (!(destination instanceof NavGraph)) &#123; throw new IllegalArgumentException(&quot;Root element &lt;&quot; + rootElement + &quot;&gt;&quot; + &quot; did not inflate into a NavGraph&quot;); &#125; return (NavGraph) destination; &#125; catch (Exception e) &#123; //也就是说我们在编写mobile_navigation.xml中的根节点必须是navigation 否则解析后会抛出异常 throw new RuntimeException(&quot;Exception inflating &quot; + res.getResourceName(graphResId) + &quot; line &quot; + parser.getLineNumber(), e); &#125; finally &#123; parser.close(); &#125;&#125; 通过navigator来创建具体的跳转navigation实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051private NavDestination inflate(@NonNull Resources res, @NonNull XmlResourceParser parser, @NonNull AttributeSet attrs, int graphResId) throws XmlPullParserException, IOException &#123; //1.通过provider获取具体的navigator对象 parser.getName 得到的就是标签的名fragment dialog activity Navigator&lt;?&gt; navigator = mNavigatorProvider.getNavigator(parser.getName()); //2.得到navigator后，就通过调用 createDestination方法来得到创建NavDestination 最后也是返回的是这个dest final NavDestination dest = navigator.createDestination(); dest.onInflate(mContext, attrs); final int innerDepth = parser.getDepth() + 1; int type; int depth; while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; ((depth = parser.getDepth()) &gt;= innerDepth || type != XmlPullParser.END_TAG)) &#123; if (type != XmlPullParser.START_TAG) &#123; continue; &#125; if (depth &gt; innerDepth) &#123; continue; &#125; final String name = parser.getName(); //3.中间解析各个子标签 //如查是argument标签，就把argument数据inflate到destination中 if (TAG_ARGUMENT.equals(name)) &#123; inflateArgumentForDestination(res, dest, attrs, graphResId); &#125; else if (TAG_DEEP_LINK.equals(name)) &#123; //如果是deeplink 就把信息inflate到destination inflateDeepLink(res, dest, attrs); &#125; else if (TAG_ACTION.equals(name)) &#123; //如果是action就把信息infalte到destinatioin中的actioin中 inflateAction(res, dest, attrs, parser, graphResId); &#125; else if (TAG_INCLUDE.equals(name) &amp;&amp; dest instanceof NavGraph) &#123; final TypedArray a = res.obtainAttributes( attrs, androidx.navigation.R.styleable.NavInclude); final int id = a.getResourceId( androidx.navigation.R.styleable.NavInclude_graph, 0); ((NavGraph) dest).addDestination(inflate(id)); a.recycle(); //如查是NavGraph &#125; else if (dest instanceof NavGraph) &#123; //就递归去调用 inflate解析子标签，然后把子标签生成的destinatioin加入到NavGraph的mNodes中去 ((NavGraph) dest).addDestination(inflate(res, parser, attrs, graphResId)); &#125; &#125; return dest;&#125; 解析完Navgraph后，把graph和controller相关联 12345678910public void setGraph(@NonNull NavGraph graph, @Nullable Bundle startDestinationArgs) &#123; if (mGraph != null) &#123; // Pop everything from the old graph off the back stack popBackStackInternal(mGraph.getId(), true); &#125; //把graph 赋值给controller中的mGraph变量 mGraph = graph; //这里就会把默认显示的页面给打开 onGraphCreated(startDestinationArgs);&#125; 回头看看NavGraphNavigator.java 的navigate方法 1234567891011121314151617181920212223public NavDestination navigate(@NonNull NavGraph destination, @Nullable Bundle args, @Nullable NavOptions navOptions, @Nullable Extras navigatorExtras) &#123; //拿到默认展示页面的id int startId = destination.getStartDestination(); if (startId == 0) &#123; throw new IllegalStateException(&quot;no start destination defined via&quot; + &quot; app:startDestination for &quot; + destination.getDisplayName()); &#125; //有这个id后，就能拿到默认展示页面的destination对象 NavDestination startDestination = destination.findNode(startId, false); if (startDestination == null) &#123; final String dest = destination.getStartDestDisplayName(); throw new IllegalArgumentException(&quot;navigation destination &quot; + dest + &quot; is not a direct child of this NavGraph&quot;); &#125; //然后通过name在provider中拿到navigator 这个navigator可能是fragmentnavigator activitynavigator dialognavigator Navigator&lt;NavDestination&gt; navigator = mNavigatorProvider.getNavigator( startDestination.getNavigatorName()); //执行具体的navigator的naigate方法把默认页面启动起来 return navigator.navigate(startDestination, startDestination.addInDefaultArgs(args), navOptions, navigatorExtras);&#125; Navigation各类之间的关系","categories":[{"name":"Jetpack系列","slug":"Jetpack系列","permalink":"http://example.com/categories/Jetpack%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"},{"name":"Jetpack","slug":"Jetpack","permalink":"http://example.com/tags/Jetpack/"}]},{"title":"Jetpack系列—Lifecycle构架组件原理解析(更新中)","slug":"Jetpack系列—Lifecycle构架组件原理解析","date":"2022-05-14T03:14:51.000Z","updated":"2022-05-14T04:38:51.000Z","comments":true,"path":"2022/05/14/Jetpack系列—Lifecycle构架组件原理解析/","link":"","permalink":"http://example.com/2022/05/14/Jetpack%E7%B3%BB%E5%88%97%E2%80%94Lifecycle%E6%9E%84%E6%9E%B6%E7%BB%84%E4%BB%B6%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/","excerpt":"","text":"什么是Lifecycle 如何使用Lifecycle观察宿主状态 Fragment是如何实现Lifecycle的 Activity是如何实现Lifecycle的 Lifecycle是如何分发宿主状态的 1.什么是Lifecycle 具备宿主生命周期感知能力的组件。它能持有组件(如Activty或Fragment)生命周期状态的信息，并且允许其他观察者监听宿主的状态 2.Lifecycle怎么使用2.1 自定义LifecycleObserver观察者 这种写法是为了避免在Activity或者Fragment中去覆写大量的生命周期函数回调，如onCreate onStart等，可以在自己的生命周期回调里去写逻辑，避免宿主太乱 1234567891011121314151617181920212223242526//1.自定义的LifecycleObserver观察者，用注解声明每个方法观察的宿主的状态，想感知哪个，就在哪个上加注解public class LocationObserver implements LifecycleObserver &#123; @OnLifecycleEvent(Lifecycle.Event.ON_START) void onStart()&#123; //开启定位 &#125; @OnLifecycleEvent(Lifecycle.Event.ON_STOP) void onStop()&#123; //停止定位 &#125;&#125; //2.注册观察者，观察宿主生命周期状态变化public class MyFragment extends Fragment &#123; @Override public void onCreate(@Nullable @org.jetbrains.annotations.Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //2.注册观察者，观察宿主生命周期状态变化 getLifecycle().addObserver(new LocationObserver()); &#125;&#125; LifecycleOwner、Lifecycle、LifecycleRegistry的关系","categories":[],"tags":[]},{"title":"聊聊WebSocket及OkHttp实现WebSocket","slug":"聊聊WebSocket及OkHttp实现WebSocket","date":"2022-05-13T10:43:51.000Z","updated":"2022-05-14T04:38:51.000Z","comments":true,"path":"2022/05/13/聊聊WebSocket及OkHttp实现WebSocket/","link":"","permalink":"http://example.com/2022/05/13/%E8%81%8A%E8%81%8AWebSocket%E5%8F%8AOkHttp%E5%AE%9E%E7%8E%B0WebSocket/","excerpt":"","text":"OkHttp应该算是Android中使用最广泛的网络库了，我们通常会利用它来实现HTTP请求，但是实际上它还可以支持WebSocket，并且使用起来还非常的便捷。那本文就来聊聊，利用OkHttp实现WebSocket的一些细节，包括对WebSocket的介绍，以及在传输如何做鉴权、长连接保活及其原理。 1.WebSocket1.1 为什么使用WebSocket?我们做客户端开发时，接触最多的应用层网络协议，就是HTTP协议，而今天介绍的WebSocket，下层和HTTP一样也是基于TCP协议，这是一种轻量级网络通信协议，也属于应用层协议。 WebSocket与HTTP2 一样，其实都是为了解决HTTP1.1的一些缺陷而诞生的，而WebSocket针对的就是「请求-应答」这种「半双工」的模式的通信缺陷。 「请求-应答」是半双工的通信模式，数据的传输必须经过一次请求应答，这个完整的通信过程，通信的同一时刻数据只能在一个方向上传递。它最大的问题在于，HTTP是一种被动的模式，服务端必须等待客户端请求才可以返回数据，无法主动向客户端发送数据。 这也导致在WebSocket出现之前，一些对实时性有要求的服务，通常是基于轮询这种简单的模式来实现。轮询就是由客户端定时发起请求，如果服输端有需要传递的数据，可以借助这个请求去响应数据。 轮询的缺点也非常明显，大量空闲的时间，其实是在反复发送无效的请求，这显然是一种资源的损耗。 虽然在之后的HTTP2 HTTP3中针对这种半双工的缺陷新增了Stream Server Push等特性，但是’请求-应答’依然是HTTP协议请要的通信方式。 WebSocket协议是由HTML5规范定义的，原本是为了浏览器而设计的，可以避免同源的限制，浏览器可以与任意服务端通信，现代浏览器基本上都已经支持WebSocket。 虽然WebSocket原本是被定义在HTML5中，但它也适用于移动端，尽管移动端也可以直接通过Socket与服务端通信，但借助WebSocket，可以利用80（HTTP）或443（HTTPS）端口通信，有效的避免一些防火墙的拦截。 WebSocket是真正意义上的全双工模式，也就我们俗称的‘长连接’。当完成握手连接后，客户端和服务端均可以主动的发起请求，回复响应，并且两边的传输都是相互独立的。 1.2 WebSocket的特点WebSocket的数据传输，是基于TCP协议，但是在传输之前，还有一个握手的过程，双方确认过眼神，才能够正式的传输数据。 WebSocket的握手过程，符合其‘Web’的特性，是利用HTTP本身的‘协议升级’来实现。 在建立连接前，客户端还需要知道服务端的地址，WebSocket并没有另辟路径，而是沿用了HTTP的URL格式，但协议标识变成了‘ws’或者‘wss’，分别表示明文加密的WebSocket协议，这一点和HTTP和HTTPS的关系类似。 以下是一些WebSocket的URL例子： 123ws://cxmydev.com/some/pathws://cxmydev.com:8080/some/pathwss://cxmydev.com:443?uid=xxx 而在连接建立后，WebSocket采用二进制帧的形式传输数据，其中常用的包括用于数据传输的数据帧MESSAGE以及3个控制帧： PING:主动保活的PING帧 PONG：收到PING帧后回复 CLOSE：主动关闭WebSocket连接 小结下WebSocket特性： WebSocket建立在TCP协议之上，对服务端友好。 默认端口采用80或443，握手阶段采用HTTP协议，不容易被防火墙屏蔽，能够通过各种HTTP代理服务器。 传输数据相比HTTP更轻量，少了HTTP HEADER，性能开销更小，通信更高效。 通过MESSAGE帧发送数据，可以发送文本或者二进制数据，如果数据过大，会被分为多个MESSAGE帧发送。 WebSocket沿用HTTP的URL，协议标识符’ws’或‘wss’ 1.3 WebSocket原理WebSocket在TCP连接建立后，还要通过Http进行一次握手，也就是通过Http发送一条GET请求消息给服务器，告诉服务器我要建立WebSocket连接了，你准备好哦，具体做法就是在头部信息中添加相关参数。然后服务器响应我知道了，并且将连接协议改成WebSocket，开始建立长连接。 这里贴上请求头和响应头信息，从网上找了一张图： 简单说明下参数： URL一般是以ws或者wss开头，ws对应Websocket协议，wss对应在TLS之上的WebSocket。类似于Http和Https的关系。 请求方法为GET方法。 Connection:Upgrade，表示客户端要连接升级，不用Http协议。 Upgrade:websocket， 表示客户端要升级建立Websocket连接。 Sec-Websocket-Key:key， 这个key是随机生成的，服务器会通过这个参数验证该请求是否有效。 Sec-WebSocket-Version:13， websocket使用的版本，一般就是13。 Sec-webSocket-Extension:permessage-deflate，客户端指定的一些扩展协议，比如这里permessage-deflate就是WebSocket的一种压缩协议。 响应码101,表示响应协议升级，后续的数据交互都按照Upgradet指定的WebSocket协议来。 2.结合OkHttp使用WebSocket进行通信2.1 添加OkHttp依赖1implementation(&quot;com.squareup.okhttp3:okhttp:4.7.2&quot;) 2.2 实现代码1234567891011//初始化WebSocketpublic void init() &#123; mWbSocketUrl = &quot;ws://echo.websocket.org&quot;; mClient = new OkHttpClient.Builder() .pingInterval(10, TimeUnit.SECONDS) .build(); Request request = new Request.Builder() .url(mWbSocketUrl) .build(); mWebSocket = mClient.newWebSocket(request, new WsListener());&#125; 这里主要是配置了OkHttp的一些参数，以及WebSocket的连接地址。其中newWebSocket方法就是进行WebSocket的初始化和连接。 这里要注意的点是pingInterval方法的配置，这个方法主要是用来设置WebSocket连接的保活。 相信做过长连接的同学都知道，一个长连接一般要隔几秒发送一条消息告诉服务器我在线，而服务器也会回复一个消息表示收到了，这样就确认了连接正常，客户端和服务器端都在线。 如果服务器没有按时收到这个消息那么服务器可能就会主动关闭这个连接，节约资源。 客户端没有正常收到这个返回的消息，也会做一些类似重连的操作，所以这个保活消息非常重要。 我们称这个消息叫作心跳包，一般用PING，PONG表示，像乒乓球一样，一来一回。 所以这里的pingInterval就是设置心跳包发送的间隔时间，设置了这个方法之后，OkHttp就会自动帮我们发送心跳包事件，也就是ping包。当间隔时间到了，没有收到pong包的话，监听事件中的onFailure方法就会被调用，此时我们就可以进行断线重连。 但是由于实际业务需求不一样，以及okhttp中心跳包事件给予我们权限较少，所以我们也可以自己完成心跳包事件，即在WebSocket连接成功之后，开始定时发送ping包，在下一次发送ping包之前检查上一个pong包是否收到，如果没收到，就视为异常，开始断线重连。感兴趣的同学可以看看文末的相关源码。 建立连接后，我们就可以正常发送和读取消息了，也就是在上文WsListener监听事件中表现： 在Android程序中，如果应用被系统kill了进程，这种我们是没办法告诉Sever端，结束连接的，所以心跳包是有必要的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//监听事件，用于收消息，监听连接的状态class WsListener extends WebSocketListener &#123; @Override public void onClosed(@NotNull WebSocket webSocket, int code, @NotNull String reason) &#123; super.onClosed(webSocket, code, reason); &#125; @Override public void onClosing(@NotNull WebSocket webSocket, int code, @NotNull String reason) &#123; super.onClosing(webSocket, code, reason); &#125; @Override public void onFailure(@NotNull WebSocket webSocket, @NotNull Throwable t, @Nullable Response response) &#123; super.onFailure(webSocket, t, response); &#125; @Override public void onMessage(@NotNull WebSocket webSocket, @NotNull String text) &#123; super.onMessage(webSocket, text); Log.e(TAG, &quot;客户端收到消息:&quot; + text); onWSDataChanged(DATE_NORMAL, text); //测试发消息 webSocket.send(&quot;我是客户端，你好啊&quot;); &#125; @Override public void onMessage(@NotNull WebSocket webSocket, @NotNull ByteString bytes) &#123; super.onMessage(webSocket, bytes); &#125; @Override public void onOpen(@NotNull WebSocket webSocket, @NotNull Response response) &#123; super.onOpen(webSocket, response); Log.e(TAG,&quot;连接成功！&quot;); &#125;&#125;//发送String消息public void send(final String message) &#123; if (mWebSocket != null) &#123; mWebSocket.send(message); &#125;&#125;//发送byte消息public void send(final ByteString message) &#123; if (mWebSocket != null) &#123; mWebSocket.send(message); &#125;&#125; //主动断开连接public void disconnect(int code, String reason) &#123; if (mWebSocket != null) mWebSocket.close(code, reason);&#125; 这里要注意，回调的方法都是在子线程回调的，如果需要更新UI，需要切换到主线程。 基本操作就这么多，还是很简单的吧，初始化Websocket——连接——连接成功——收发消息。 其中WebSocket类是一个操作接口，主要提供了以下几个方法 send(text: String)发送一个String类型的消息 send(bytes: ByteString) 发送一个二进制类型的消息 close(code: Int, reason: String?)关闭WebSocket连接 如果有同学想测试下WebSocket的功能但是又没有实际的服务器，怎么办呢？ 其实OkHttp官方有一个MockWebSocket服务，可以用来模拟服务端，下面我们一起试一下： 2.3 模拟服务器首先集成MockWebSocket服务库： 1implementation &#x27;com.squareup.okhttp3:mockwebserver:4.7.2&#x27; 然后就可以新建MockWebServer，并加入MockResponse作为接收消息的响应。 123456789101112131415161718192021222324252627MockWebServer mMockWebServer = new MockWebServer();MockResponse response = new MockResponse() .withWebSocketUpgrade(new WebSocketListener() &#123; @Override public void onOpen(@NotNull WebSocket webSocket, @NotNull Response response) &#123; super.onOpen(webSocket, response); //有客户端连接时回调 Log.e(TAG, &quot;服务器收到客户端连接成功回调：&quot;); mWebSocket = webSocket; mWebSocket.send(&quot;我是服务器，你好呀&quot;); &#125; @Override public void onMessage(@NotNull WebSocket webSocket, @NotNull String text) &#123; super.onMessage(webSocket, text); Log.e(TAG, &quot;服务器收到消息：&quot; + text); &#125; @Override public void onClosed(@NotNull WebSocket webSocket, int code, @NotNull String reason) &#123; super.onClosed(webSocket, code, reason); Log.e(TAG, &quot;onClosed：&quot;); &#125; &#125;);mMockWebServer.enqueue(response); 这里服务器端在收到客户端连接成功消息后，给客户端发送了一条消息。 要注意的是这段代码要在子线程执行，因为主线程不能进行网络操作。 然后就可以去初始化Websocket客户端了： 123//获取连接url，初始化websocket客户端String websocketUrl = &quot;ws://&quot; + mMockWebServer.getHostName() + &quot;:&quot; + mMockWebServer.getPort() + &quot;/&quot;;WSManager.getInstance().init(websocketUrl); ok，运行项目 123456//运行结果E/jimu: mWbSocketUrl=ws://localhost:38355/E/jimu: 服务器收到客户端连接成功回调：E/jimu: 连接成功！E/jimu: 客户端收到消息:我是服务器，你好呀E/jimu: 服务器收到消息：我是客户端，你好啊 2.4 WebSocket如何进行鉴权接下来我们聊聊 WebSocket 连接的鉴权问题。 所谓鉴权，其实就是为了安全考虑，避免服务端启动 WebSocket 的连接服务后，任谁都可以连接，这肯定会引发一些安全问题。其次，服务端还需要将 WebSocket 的连接实体与一个真是的用户对应起来，否者业务无法保证了。 那么问题就回到了，WebSocket 通信的完整过程中，如何以及何时将一些业务数据传递给服务端？当然在 WebSocket 连接建立之后，立即给服务端发送一些鉴权的数据，必然是可以做到业务实现的，但是这样明显是不够优雅的。 前文提到，WebSocket 在握手阶段，使用的是 HTTP 的 “协议升级”，它本质上还是 HTTP 的报文头发送一些特殊的头数据，来完成协议升级。 例如在 RealWebSocket 中，就有构造 Header 的过程，如 Upgrade、Connection 等等。 12345678910public void connect(OkHttpClient client) &#123; // ... final Request request = originalRequest.newBuilder() .header(&quot;Upgrade&quot;, &quot;websocket&quot;) .header(&quot;Connection&quot;, &quot;Upgrade&quot;) .header(&quot;Sec-WebSocket-Key&quot;, key) .header(&quot;Sec-WebSocket-Version&quot;, &quot;13&quot;) .build(); //....&#125; 那么实际我们在 WebSocket 阶段，也可以通过 Header 传输一些鉴权的数据，例如 uid、token 之类，具体方法就是在构造 Request 的时候，为其增加 Header，这里就不举例说明了。 另外 WebSocket 的 URL 也是可以携带参数的。 1wss://cxmydev.com:443?uid=xxx&amp;token=xxx 3.OkHttp 源码解读WebSocket连接过程及协议WebSocket整个流程无非三个功能：连接，接收消息，发送消息。下面我们就从这三个方面分析下具体是怎么实现的。 3.1 连接通过上面的代码我们得知，WebSocket连接是通过newWebSocket方法。直接点进去看这个方法： 12345678910111213override fun newWebSocket(request: Request, listener: WebSocketListener): WebSocket &#123; val webSocket = RealWebSocket( taskRunner = TaskRunner.INSTANCE, originalRequest = request, listener = listener, random = Random(), pingIntervalMillis = pingIntervalMillis.toLong(), extensions = null, // Always null for clients. minimumDeflateSize = minWebSocketMessageToCompress ) webSocket.connect(this) return webSocket&#125; 这里做了两件事： 初始化RealWebSocket，主要是设置了一些参数（比如pingIntervalMillis心跳包时间间隔，还有监听事件之类的） connect方法进行WebSocket连接 继续查看connect方法： 3.1.1 connect(WebSocket连接握手)12345678910111213141516171819202122232425262728293031323334353637fun connect(client: OkHttpClient) &#123; //*** val webSocketClient = client.newBuilder() .eventListener(EventListener.NONE) .protocols(ONLY_HTTP1) .build() val request = originalRequest.newBuilder() .header(&quot;Upgrade&quot;, &quot;websocket&quot;) .header(&quot;Connection&quot;, &quot;Upgrade&quot;) .header(&quot;Sec-WebSocket-Key&quot;, key) .header(&quot;Sec-WebSocket-Version&quot;, &quot;13&quot;) .header(&quot;Sec-WebSocket-Extensions&quot;, &quot;permessage-deflate&quot;) .build() call = RealCall(webSocketClient, request, forWebSocket = true) call!!.enqueue(object : Callback &#123; override fun onResponse(call: Call, response: Response) &#123; //得到数据流 val streams: Streams try &#123; checkUpgradeSuccess(response, exchange) streams = exchange!!.newWebSocketStreams() &#125; //*** // Process all web socket messages. try &#123; val name = &quot;$okHttpName WebSocket $&#123;request.url.redact()&#125;&quot; initReaderAndWriter(name, streams) listener.onOpen(this@RealWebSocket, response) loopReader() &#125; catch (e: Exception) &#123; failWebSocket(e, null) &#125; &#125; &#125;)&#125; Websocket连接需要一次Http协议的握手，然后才能把协议升级成WebSocket。所以这段代码就体现出这个功能了。 首先就new了一个用来进行Http连接的request，其中Header的参数就表示我要进行WebSocket连接了，参数解析如下： Connection:Upgrade，表示客户端要连接升级 Upgrade:websocket， 表示客户端要升级建立Websocket连接 Sec-Websocket-Key:key， 这个key是随机生成的，服务器会通过这个参数验证该请求是否有效 Sec-WebSocket-Version:13， websocket使用的版本，一般就是13 Sec-webSocket-Extension:permessage-deflate，客户端指定的一些扩展协议，比如这里permessage-deflate就是WebSocket的一种压缩协议。 Header设置好之后，就调用了call的enqueue方法，这个方法大家应该都很熟悉吧，OkHttp里面对于Http请求的异步请求就是这个方法。 至此，握手结束，服务器返回响应码101，表示协议升级。 然后我们继续看看获取服务器响应之后又做了什么？ 在发送Http请求成功之后，onResponse响应方法里面主要表现为四个处理逻辑： 将Http流转换成WebSocket流，得到Streams对象，这个流后面会转化成输入流和输出流，也就是进行发送和读取的操作流 listener.onOpen(this@RealWebSocket, response)，回调了接口WebSocketListener的onOpen方法，告诉用户WebSocket已经连接 initReaderAndWriter(name, streams) loopReader() 前两个逻辑还是比较好理解，主要是后两个方法，我们分别解析下。 首先看initReaderAndWriter方法。 3.1.2 initReaderAndWriter（初始化输入流输出流）123456789101112131415161718192021222324252627282930313233343536373839404142//RealWebSocket.kt@Throws(IOException::class)fun initReaderAndWriter(name: String, streams: Streams) &#123; val extensions = this.extensions!! synchronized(this) &#123; //*** //写数据，发送数据的工具类 this.writer = WebSocketWriter() //设置心跳包事件 if (pingIntervalMillis != 0L) &#123; val pingIntervalNanos = MILLISECONDS.toNanos(pingIntervalMillis) taskQueue.schedule(&quot;$name ping&quot;, pingIntervalNanos) &#123; writePingFrame() return@schedule pingIntervalNanos &#125; &#125; //*** &#125;//***//读取数据的工具类 reader = WebSocketReader( *** frameCallback = this, *** )&#125;internal fun writePingFrame() &#123; //*** try &#123; writer.writePing(ByteString.EMPTY) &#125; catch (e: IOException) &#123; failWebSocket(e, null) &#125;&#125; 这个方法主要干了两件事： 实例化输出流输入流工具类，也就是WebSocketWriter和WebSocketReader，用来处理数据的收发。 设置心跳包事件。如果pingIntervalMillis参数不为0，就通过计时器，每隔pingIntervalNanos发送一个ping消息。其中writePingFrame方法就是发送了ping帧数据。 3.2 接收消息处理消息3.2.1 loopReader接着看看这个loopReader方法是干什么的，看这个名字我们大胆猜测下，难道这个方法就是用来循环读取数据的？去代码里找找答案： 1234567fun loopReader() &#123; while (receivedCloseCode == -1) &#123; // This method call results in one or more onRead* methods being called on this thread. reader!!.processNextFrame() &#125;&#125; 代码很简单，一个while循环，循环条件是receivedCloseCode == -1的时候，做的事情是reader!!.processNextFrame()方法。继续： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//WebSocketWriter.ktfun processNextFrame() &#123; //读取头部信息 readHeader() if (isControlFrame) &#123; //如果是控制帧，读取控制帧内容 readControlFrame() &#125; else &#123; //读取普通消息内容 readMessageFrame() &#125;&#125;//读取头部信息@Throws(IOException::class, ProtocolException::class)private fun readHeader() &#123; if (closed) throw IOException(&quot;closed&quot;) try &#123; //读取数据，获取数据帧的前8位 b0 = source.readByte() and 0xff &#125; finally &#123; source.timeout().timeout(timeoutBefore, TimeUnit.NANOSECONDS) &#125; //*** //获取数据帧的opcode（数据格式） opcode = b0 and B0_MASK_OPCODE //是否为最终帧 isFinalFrame = b0 and B0_FLAG_FIN != 0 //是否为控制帧（指令） isControlFrame = b0 and OPCODE_FLAG_CONTROL != 0 //判断最终帧，获取帧长度等等&#125; //读取控制帧（指令） @Throws(IOException::class)private fun readControlFrame() &#123; if (frameLength &gt; 0L) &#123; source.readFully(controlFrameBuffer, frameLength) &#125; when (opcode) &#123; OPCODE_CONTROL_PING -&gt; &#123; //ping 帧 frameCallback.onReadPing(controlFrameBuffer.readByteString()) &#125; OPCODE_CONTROL_PONG -&gt; &#123; //pong 帧 frameCallback.onReadPong(controlFrameBuffer.readByteString()) &#125; OPCODE_CONTROL_CLOSE -&gt; &#123; //关闭 帧 var code = CLOSE_NO_STATUS_CODE var reason = &quot;&quot; val bufferSize = controlFrameBuffer.size if (bufferSize == 1L) &#123; throw ProtocolException(&quot;Malformed close payload length of 1.&quot;) &#125; else if (bufferSize != 0L) &#123; code = controlFrameBuffer.readShort().toInt() reason = controlFrameBuffer.readUtf8() val codeExceptionMessage = WebSocketProtocol.closeCodeExceptionMessage(code) if (codeExceptionMessage != null) throw ProtocolException(codeExceptionMessage) &#125; //回调onReadClose方法 frameCallback.onReadClose(code, reason) closed = true &#125; &#125;&#125;//读取普通消息@Throws(IOException::class)private fun readMessageFrame() &#123; readMessage() if (readingCompressedMessage) &#123; val messageInflater = this.messageInflater ?: MessageInflater(noContextTakeover).also &#123; this.messageInflater = it &#125; messageInflater.inflate(messageFrameBuffer) &#125; if (opcode == OPCODE_TEXT) &#123; frameCallback.onReadMessage(messageFrameBuffer.readUtf8()) &#125; else &#123; frameCallback.onReadMessage(messageFrameBuffer.readByteString()) &#125;&#125; 代码还是比较直观，这个processNextFrame其实就是读取数据用的，首先读取头部信息，获取数据帧的类型，判断是否为控制帧，再分别去读取控制帧数据或者普通消息帧数据。 3.2.2 数据帧格式问题来了，什么是数据头部信息，什么是控制帧？ 这里就要说下WebSocket的数据帧了，先附上一个数据帧格式： 1234567891011121314151617 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7+-+-+-+-+-------+ +-+-------------+ +-----------------------------+|F|R|R|R| OP | |M| LENGTH | Extended payload length|I|S|S|S| CODE | |A| | （if LENGTH=126）|N|V|V|V| | |S| || |1|2|3| | |K| |+-+-+-+-+-------+ +-+-------------+| Extended payload length（if LENGTH=127）+ +-------------------------------| Extended payload length | Masking-key，if Mask set to 1+----------------------------------+-------------------------------| Masking-key | Data+----------------------------------+-------------------------------| Data+----------------------------------+------------------------------- 我承认，我懵逼了。 冷静冷静，一步一步分析下吧。 首先每一行代表4个字节，一共也就是32位数，哦，那也就是几个字节而已嘛，每个字节有他自己的代表意义呗，这样想是不是就很简单了，下面来具体看看每个字节。 第1个字节： 第一位是FIN码，其实就是一个标示位，因为数据可能多帧操作嘛，所以多帧情况下，只有最后一帧的FIN设置成1，标示结束帧，前面所有帧设置为0。 第二位到第四位是RSV码，一般通信两端没有设置自定义协议，就默认为0。 后四位是opcode，我们叫它操作码。这个就是判断这个数据帧的类型了，一般有以下几个被定义好的类型： 1） 0x0 表示附加数据帧2） 0x1 表示文本数据帧3） 0x2 表示二进制数据帧4） 0x3-7 保留用于未来的非控制帧5） 0x8 表示连接关闭6） 0x9 表示ping7） 0xA 表示pong8） 0xB-F 保留用于未来的非控制帧 是不是发现了些什么，这不就对应了我们应用中的几种格式吗？2和3对应的是普通消息帧，包括了文本和二进制数据。567对应的就是控制帧格式，包括了close，ping，pong。 第2个字节： 第一位是Mask掩码，其实就是标识数据是否加密混淆，1代表数据经过掩码的，0是没有经过掩码的，如果是1的话，后续就会有4个字节代表掩码key，也就是数据帧中Masking-key所处的位置。 后7位是LENGTH，用来标示数据长度。因为只有7位，所以最大只能储存1111111对应的十进制数127长度的数据，如果需要更大的数据，这个储存长度肯定就不够了。 所以规定来了，1) 小于126长度则数据用这七位表示实际长度。2) 如果长度设置为126，也就是二进制1111110，就代表取额外2个字节表示数据长度，共是16位表示数据长度。3) 如果长度设置为127，也就是二进制1111111，就代表取额外8个字节，共是64位表示数据长度。 需要注意的是LENGHT的三种情况在一个数据帧里面只会出现一种情况，不共存，所以在图中是用if表示。同样的，Masking-key也是当Mask为1的时候才存在。 所以也就有了数据帧里面的Extended payload length（LENGTH=126）所处的2个字节，以及Extended payload length（LENGTH=127）所处的8个字节。 最后的字节部分自然就是掩码key（Mask为1的时候才存在）和具体的传输数据了。还是有点晕吧😷，来张图总结下： 好了，了解了数据帧格式后，我们再来读源码就清晰多了。 先看看怎么读的头部信息并解析的： 12345678//取数据帧前8位数据b0 = source.readByte() and 0xff//获取数据帧的opcode（数据格式）opcode = b0 and B0_MASK_OPCODE（15）//是否为最终帧isFinalFrame = b0 and B0_FLAG_FIN（128） != 0//是否为控制帧（指令）isControlFrame = b0 and OPCODE_FLAG_CONTROL（8） != 0 第一句获取头信息，and是按位与计算，and 0xff意思就是按位与11111111，所以头部信息其实就是取了数据帧的前8位数据，一个字节。 第二句获取opcode，and 15也就是按位与00001111，其实也就是取了后四位数据，刚好对应上opcode的位置，第一个字节的后四位。 第三句获取是否为最终帧，刚才数据帧格式中说过，第一位FIN标识了是否为最后一帧数据，1代表结束帧，所以这里and 128也就是按位与10000000，也就是取的第一位数。 第四句获取是否为控制帧，and 8也就是按位与00001000，取得是第五位，也就是opcode的第一位，这是什么意思呢？我们看看刚才的数据帧格式，发现从0x8开始就是所谓的控制帧了。0x8对应的二进制是1000，0x7对应的二进制是0111。发现了吧，如果为控制帧的时候，opcode第一位肯定是为1的，所以这里就判断的第五位。 后面还有读取第二个字节的代码，大家可以自己沿着这个思路自己看看，包括了读取MASK，读取数据长度的三种长度等。 所以这个processNextFrame方法主要做了三件事： readHeader方法中，判断了是否为控制帧，是否为结束帧，然后获取了Mask标识，帧长度等参数 readControlFrame方法中，主要处理了该帧数据为ping，pong，close三种情况，并且在收到close关闭帧的情况下，回调了onReadClose方法，这个待会要细看下。 readMessageFrame方法中，主要是读取了消息后，回调了onReadMessage方法。 至此可以发现，其实WebSocket传输数据并不是一个简单的事，只是OkHttp都帮我们封装好了，我们只需要直接传输数据即可，感谢这些三方库为我们开发作出的贡献，不知道什么时候我也能做出点贡献呢🤔。 对了，刚才说回调也很重要，接着看看。onReadClose和onReadMessage回调到哪了呢？还记得上文初始化WebSocketWriter的时候设置了回调接口吗。所以就是回调给RealWebSocket了： 12345678910111213141516171819202122232425262728293031323334353637//RealWebSocket.ktoverride fun onReadClose(code: Int, reason: String) &#123; require(code != -1) var toClose: Streams? = null var readerToClose: WebSocketReader? = null var writerToClose: WebSocketWriter? = null synchronized(this) &#123; check(receivedCloseCode == -1) &#123; &quot;already closed&quot; &#125; receivedCloseCode = code receivedCloseReason = reason //... &#125; try &#123; listener.onClosing(this, code, reason) if (toClose != null) &#123; listener.onClosed(this, code, reason) &#125; &#125; finally &#123; toClose?.closeQuietly() readerToClose?.closeQuietly() writerToClose?.closeQuietly() &#125;&#125;@Throws(IOException::class)override fun onReadMessage(text: String) &#123; listener.onMessage(this, text)&#125;@Throws(IOException::class)override fun onReadMessage(bytes: ByteString) &#123; listener.onMessage(this, bytes)&#125; onReadClose回调方法里面有个关键的参数，receivedCloseCode。还记得这个参数吗？上文中解析消息的循环条件就是receivedCloseCode == -1，所以当收到关闭帧的时候，receivedCloseCode就不再等于-1（规定大于1000），也就不再去读取解析消息了。这样整个流程就结束了。 其中还有一些WebSocketListener的回调，比如onClosing，onClosed，onMessage等，就直接回调给用户使用了。至此，接收消息处理消息说完了。 3.3 发消息好了。接着说发送，看看send方法： 123456789@Synchronized private fun send(data: ByteString, formatOpcode: Int): Boolean &#123; // *** // Enqueue the message frame. queueSize += data.size.toLong() messageAndCloseQueue.add(Message(formatOpcode, data)) runWriter() return true&#125; 首先，把要发送的data封装成Message对象，然后入队列messageAndCloseQueue。最后执行runWriter方法。这都不用猜了，runWriter肯定就要开始发送消息了，继续看： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//RealWebSocket.ktprivate fun runWriter() &#123; this.assertThreadHoldsLock() val writerTask = writerTask if (writerTask != null) &#123; taskQueue.schedule(writerTask) &#125;&#125;private inner class WriterTask : Task(&quot;$name writer&quot;) &#123; override fun runOnce(): Long &#123; try &#123; if (writeOneFrame()) return 0L &#125; catch (e: IOException) &#123; failWebSocket(e, null) &#125; return -1L &#125;&#125; //以下是schedule方法转到WriterTask的runOnce方法过程//TaskQueue.ktfun schedule(task: Task, delayNanos: Long = 0L) &#123; synchronized(taskRunner) &#123; if (scheduleAndDecide(task, delayNanos, recurrence = false)) &#123; taskRunner.kickCoordinator(this) &#125; &#125;&#125;internal fun scheduleAndDecide(task: Task, delayNanos: Long, recurrence: Boolean): Boolean &#123; //*** if (insertAt == -1) insertAt = futureTasks.size futureTasks.add(insertAt, task) // Impact the coordinator if we inserted at the front. return insertAt == 0&#125; //TaskRunner.ktinternal fun kickCoordinator(taskQueue: TaskQueue) &#123; this.assertThreadHoldsLock() if (taskQueue.activeTask == null) &#123; if (taskQueue.futureTasks.isNotEmpty()) &#123; readyQueues.addIfAbsent(taskQueue) &#125; else &#123; readyQueues.remove(taskQueue) &#125; &#125; if (coordinatorWaiting) &#123; backend.coordinatorNotify(this@TaskRunner) &#125; else &#123; backend.execute(runnable) &#125;&#125; private val runnable: Runnable = object : Runnable &#123; override fun run() &#123; while (true) &#123; val task = synchronized(this@TaskRunner) &#123; awaitTaskToRun() &#125; ?: return logElapsed(task, task.queue!!) &#123; var completedNormally = false try &#123; runTask(task) completedNormally = true &#125; finally &#123; // If the task is crashing start another thread to service the queues. if (!completedNormally) &#123; backend.execute(this) &#125; &#125; &#125; &#125; &#125;&#125;private fun runTask(task: Task) &#123; try &#123; delayNanos = task.runOnce() &#125; &#125; 代码有点长，这里是从runWriter开始跟的几个方法，拿到writerTask实例后，存到TaskQueue的futureTasks列表里，然后到runnable这里可以看到是一个while死循环，不断的从futureTasks中取出Task并执行runTask方法，直到Task为空，循环停止。 其中涉及到两个新的类： TaskQueue类主要就是管理消息任务列表，保证按顺序执行 TaskRunner类主要就是做一些任务的具体操作，比如线程池里执行任务，记录消息任务的状态（准备发送的任务队列readyQueues，正在执行的任务队列busyQueues等等） 而每一个Task最后都是执行到了WriterTask的runOnce方法，也就是writeOneFrame方法： 123456789101112131415161718192021222324252627282930313233343536373839404142internal fun writeOneFrame(): Boolean &#123; synchronized(this@RealWebSocket) &#123; if (failed) &#123; return false // Failed web socket. &#125; writer = this.writer pong = pongQueue.poll() if (pong == null) &#123; messageOrClose = messageAndCloseQueue.poll() if (messageOrClose is Close) &#123; &#125; else if (messageOrClose == null) &#123; return false // The queue is exhausted. &#125; &#125; &#125; //发送消息逻辑，包括`pong`消息，普通消息，关闭消息 try &#123; if (pong != null) &#123; writer!!.writePong(pong) &#125; else if (messageOrClose is Message) &#123; val message = messageOrClose as Message writer!!.writeMessageFrame(message.formatOpcode, message.data) synchronized(this) &#123; queueSize -= message.data.size.toLong() &#125; &#125; else if (messageOrClose is Close) &#123; val close = messageOrClose as Close writer!!.writeClose(close.code, close.reason) // We closed the writer: now both reader and writer are closed. if (streamsToClose != null) &#123; listener.onClosed(this, receivedCloseCode, receivedCloseReason!!) &#125; &#125; return true &#125; finally &#123; streamsToClose?.closeQuietly() readerToClose?.closeQuietly() writerToClose?.closeQuietly() &#125;&#125; 这里就会执行发送消息的逻辑了，主要有三种消息情况处理： pong消息，这个主要是为服务器端准备的，发送给客户端回应心跳包。 普通消息，就会把数据类型Opcode和具体数据发送过去 关闭消息，其实当用户执行close方法关闭WebSocket的时候，也是发送了一条Close控制帧消息给服务器告知这个关闭需求，并带上code状态码和reason关闭原因，然后服务器端就会关闭当前连接。 好了。最后一步了，就是把这些数据组装成WebSocket数据帧并写入流，分成控制帧数据和普通消息数据帧： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//写入（发送）控制帧private fun writeControlFrame(opcode: Int, payload: ByteString) &#123; if (writerClosed) throw IOException(&quot;closed&quot;) val length = payload.size require(length &lt;= PAYLOAD_BYTE_MAX) &#123; &quot;Payload size must be less than or equal to $PAYLOAD_BYTE_MAX&quot; &#125; val b0 = B0_FLAG_FIN or opcode sinkBuffer.writeByte(b0) var b1 = length if (isClient) &#123; b1 = b1 or B1_FLAG_MASK sinkBuffer.writeByte(b1) random.nextBytes(maskKey!!) sinkBuffer.write(maskKey) if (length &gt; 0) &#123; val payloadStart = sinkBuffer.size sinkBuffer.write(payload) sinkBuffer.readAndWriteUnsafe(maskCursor!!) maskCursor.seek(payloadStart) toggleMask(maskCursor, maskKey) maskCursor.close() &#125; &#125; else &#123; sinkBuffer.writeByte(b1) sinkBuffer.write(payload) &#125; sink.flush()&#125;//写入（发送）普通消息数据帧@Throws(IOException::class)fun writeMessageFrame(formatOpcode: Int, data: ByteString) &#123; if (writerClosed) throw IOException(&quot;closed&quot;) messageBuffer.write(data) var b0 = formatOpcode or B0_FLAG_FIN val dataSize = messageBuffer.size sinkBuffer.writeByte(b0) var b1 = 0 if (isClient) &#123; b1 = b1 or B1_FLAG_MASK &#125; when &#123; dataSize &lt;= PAYLOAD_BYTE_MAX -&gt; &#123; b1 = b1 or dataSize.toInt() sinkBuffer.writeByte(b1) &#125; dataSize &lt;= PAYLOAD_SHORT_MAX -&gt; &#123; b1 = b1 or PAYLOAD_SHORT sinkBuffer.writeByte(b1) sinkBuffer.writeShort(dataSize.toInt()) &#125; else -&gt; &#123; b1 = b1 or PAYLOAD_LONG sinkBuffer.writeByte(b1) sinkBuffer.writeLong(dataSize) &#125; &#125; if (isClient) &#123; random.nextBytes(maskKey!!) sinkBuffer.write(maskKey) if (dataSize &gt; 0L) &#123; messageBuffer.readAndWriteUnsafe(maskCursor!!) maskCursor.seek(0L) toggleMask(maskCursor, maskKey) maskCursor.close() &#125; &#125; sinkBuffer.write(messageBuffer, dataSize) sink.emit()&#125; 大家应该都能看懂了吧，其实就是组装数据帧，包括Opcode，mask，数据长度等等。两个方法的不同就在于普通数据需要判断数据长度的三种情况，再组装数据帧。最后都会通过sinkBuffer写入到输出数据流。 终于，基本的流程说的差不多了。其中还有很多细节，同学们可以自己花时间看看琢磨琢磨，比如Okio部分。还是那句话，希望大家有空自己也读一读相关源码，这样理解才能深刻，而且你肯定会发现很多我没说到的细节，欢迎大家讨论。我也会继续努力，最后大家给我加个油点个赞吧，感谢感谢。","categories":[],"tags":[]},{"title":"HTTPS 学习整理","slug":"HTTPS-学习整理","date":"2022-05-13T00:23:15.000Z","updated":"2022-05-14T04:38:51.000Z","comments":true,"path":"2022/05/13/HTTPS-学习整理/","link":"","permalink":"http://example.com/2022/05/13/HTTPS-%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86/","excerpt":"","text":"HTTPS 学习整理1.HTTPS 连接及握手过程第一步，客户端发送给服务器Client Hello，叫做Client Hello 其实是一个一字节的数据 发送Client Hello 还会附加一些信息 可选的TLS版本 可选的加密套件 可选的对称加密算法 可选的非对称加密算法 可选的hash算法 客户端随机数（这个随机数随后会用到，等于是第一个随机数客户端和服务器都会使用到） 第二步，服务端返回Server Hello 也是一个单字节数据，并把Client Hello 附加信息的确认值返回给客户端，同时生成服务端的随机数，返回给客户端 第三步，服务端下发证书，然后客户端这里会做证书的较验，这里的过程比较麻烦和复杂 如图所示，证书中包含 服务器公钥 服务器主机名 服务器公钥的签名 证书签发机构的公钥 证书签发机构的公角的签名 …. 较验的顺序也是如此，链式去使用签名去较验公钥是否准确，防止公钥被修改，一层层直到找到根证书，根证书一般都安装在pc或者手机里，然后逐层去较验公钥的正确性，最后证明服务器的公钥确实是真的，而不是假的 如图所示，访问hencoder.com 然后证书链中的三级证书，客户端验证服务器证书的真实性，还通过主机名确认对方的身份，确实是我要访问的服务器，而不是其他在ca公签的服务器 第四步，客户端拿到服务器公钥后，和服务器一起通过公钥生成加密的Pre-master secret ，双方就公同持有了三个东西 客户端随机数 服务器随机数 Pre-master secret 通过这三个东西会各自独立的生成master secret 所以注意啦，最终的对称密钥并不是客户端生成后发给服务器的，而是由前面交互的随机数，及加密后的公钥独立生成的 而且，生成的对称加密的密钥并不是简单的一个密码 那么有人可能会有疑问，为什么要很麻烦的生成客户端的加密密钥，服务端的加密密钥？用一个不行么？ 第五步，客户端告诉服务器，我将使用加密通信，还有把前面几步合一起加密发给服务器，生送Finished 同样服务器也返回客户端：将使用加密通信，同时Finished握手 服务端返回 2.在Android中合理使用HTTPSCA公签的就不讨论了，使用很方便，根据所使用的网络框架，可以自行百度，非常简单方便。这里说下如何较验主机名 12345678910111213141516171819// Create an HostnameVerifier that hardwires the expected hostname.// Note that is different than the URL&#x27;s hostname:// example.com versus example.orgHostnameVerifier hostnameVerifier = new HostnameVerifier() &#123; @Override public boolean verify(String hostname, SSLSession session) &#123; HostnameVerifier hv = HttpsURLConnection.getDefaultHostnameVerifier(); return hv.verify(&quot;example.com&quot;, session); &#125;&#125;;// Tell the URLConnection to use our HostnameVerifierURL url = new URL(&quot;https://example.org/&quot;);HttpsURLConnection urlConnection = (HttpsURLConnection)url.openConnection();urlConnection.setHostnameVerifier(hostnameVerifier);InputStream in = urlConnection.getInputStream();copyInputStreamToOutputStream(in, System.out); 还有一种情况，有一些公司使用自签名证书，或者非知名机构颁发的证书，如果不做处理，会报https的网络异常，那么这时候上网上查的话，很多都是告诉不做较验，放开所有的证书，当然这样可以走的通，但是同时也失去了使用HTTPS的作用，是不认真负责的。 我们看官网上对这一过程的描述，之所以之前我们记不住，也是因为我们对HTTPS的握手和证书较验过程不够理解，现在看这段话 在这种情况下，由于您的 CA 不受系统信任，将发生 SSLHandshakeException。原因可能是您有一个由 Android 尚不信任的新 CA 颁发的证书，或您的应用在没有 CA 的较旧版本上运行。CA 未知的原因通常是因为它不是公共 CA，而是由政府、公司或教育机构等组织颁发的仅供其自己使用的私有 CA。 幸运的是，您可以指示 HttpsURLConnection 信任特定的 CA 集。这个过程可能有点复杂，下面的示例展示了这个过程：从 InputStream 获取一个特定的 CA，用该 CA 创建 KeyStore，然后用后者创建和初始化 TrustManager。TrustManager 是系统用于验证来自服务器的证书的工具，可以通过包含一个或多个 CA 的 KeyStore 创建，而创建的 TrustManager 将仅信任这些 CA。 由于 TrustManager 是新建的，此示例将启动一个新的 SSLContext，它会提供一个 SSLSocketFactory，可用于替换来自 HttpsURLConnection 的默认 SSLSocketFactory。这样一来，连接将使用您的 CA 来验证证书。 这下你知道，为啥Android客户会有一个证书文件了吧 123456789101112131415161718192021222324252627282930313233343536 // Load CAs from an InputStream// (could be from a resource or ByteArrayInputStream or ...)CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;);// From https://www.washington.edu/itconnect/security/ca/load-der.crtInputStream caInput = new BufferedInputStream(new FileInputStream(&quot;load-der.crt&quot;));Certificate ca;try &#123; ca = cf.generateCertificate(caInput); System.out.println(&quot;ca=&quot; + ((X509Certificate) ca).getSubjectDN());&#125; finally &#123; caInput.close();&#125;// Create a KeyStore containing our trusted CAsString keyStoreType = KeyStore.getDefaultType();KeyStore keyStore = KeyStore.getInstance(keyStoreType);keyStore.load(null, null);keyStore.setCertificateEntry(&quot;ca&quot;, ca);// Create a TrustManager that trusts the CAs in our KeyStoreString tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);tmf.init(keyStore);// Create an SSLContext that uses our TrustManagerSSLContext context = SSLContext.getInstance(&quot;TLS&quot;);context.init(null, tmf.getTrustManagers(), null);// Tell the URLConnection to use a SocketFactory from our SSLContextURL url = new URL(&quot;https://certs.cac.washington.edu/CAtest/&quot;);HttpsURLConnection urlConnection = (HttpsURLConnection)url.openConnection();urlConnection.setSSLSocketFactory(context.getSocketFactory());InputStream in = urlConnection.getInputStream();copyInputStreamToOutputStream(in, System.out); 这个SSLContext很关键，由得到的SSLContextFactory是我们很多网络框架可以进行替换和设置，这样就可以通过自签名的ca集来检验较验证书的合法性了。 之所以说SSLContext很关键，因为不光HTTP可以使用SSL较验，很多上层加密都使用了SSL层的加密特性，比如我们可能会遇到的WSS Websocket的加密协议，怎么处理，一样的道理。","categories":[],"tags":[]},{"title":"Jetpack系列—LiveData原理解析","slug":"Jetpack系列—LiveData","date":"2022-03-20T10:43:51.000Z","updated":"2022-05-14T04:38:51.000Z","comments":true,"path":"2022/03/20/Jetpack系列—LiveData/","link":"","permalink":"http://example.com/2022/03/20/Jetpack%E7%B3%BB%E5%88%97%E2%80%94LiveData/","excerpt":"","text":"什么是LiveData LiveData几种衍生类 LiveData核心方法 LiveData实现原理 1.什么是LiveData LiveData组件是Jetpack新推出的基于观察者的消息订阅&#x2F;分发组件，具有宿主(Activity&#x2F;Fragment)生命周期感知能力，这种感知能力可确保LiveData仅分发消息给处于活跃状态的观察者，即只有处于活跃状态的观察者才能收到消息 LiveData的消息分发机制，是以往的Handler，EventBus，RxJavaBus无法比拟的，它们不会顾及当前页面是否可见，一股脑的有消息就转发。导致即便应用在后台，页面不可见，还在做一些无用的绘制，计算(细心的同学可以发现微信消息列表是在可见状态时才会更新列表最新信息的) 活跃状态：Observer所在宿主处于started,resumed状态 12345678910111213141516171819202122class MainActivity extends AppcompactActivity&#123; public void onCreate(Bundle bundle)&#123; @Ovderride public void handleMessage(@NonNull Message msg)&#123; //无论页面可见不可见，都会去执行页面刷新,IO。更有甚者弹出对话框 &#125; &#125; //1.无论当前页面是否可见，这条消息都会被分发。——消耗资源 //2.无论前宿主是否还存活，这条消息都会被分发。——内存泄漏 handler.sendMessage(msg); liveData.observer(this,new Observer&lt;User&gt;)&#123; void onChanged(User user)&#123; &#125; &#125; //1.减少资源占用 —— 页面不可见时不会派发消息 //2.确保页面始终保持最新状态——页面可见时，会立刻派发新新的一条消息给所有观察者——保证页面最新状态 //3.不再需要手动处理生命周期——避免NPE //4.livedata默认是不能跨页面使用的，但是我们有办法，可以打造一款不用反注册，不会内存泄漏的消息总线——取代eventbus liveData.postValue(data);&#125; 2.LiveData的几种用法2.1 MutableLiveData我们在使用LiveData在做消息分发的时候，需要使用这个子类。之所以这么设计，是考虑到单一开闭原则，只有拿到MutableLiveData对象才可以发送消息，LiveData对象只能接收消息，避免拿到LiveData对象时既能发消息也能收到消息的混乱使用。 1234567891011public class MutableLiveData&lt;T&gt; extends LiveData&lt;T&gt;&#123; @Override public void postValue(T value)&#123; super.postValue(value); &#125; @Override public void setValue(T value)&#123; super.setValue(value); &#125;&#125; 2.2 MediatorLiveData 可以统一观察多个LiveData的发射的数据进行统一的处理 同时也可以做为一个LiveData，被其他Observer观察。 1234567891011121314151617//创建两个长的差不多的LiveData对象LiveData&lt;Integer&gt; liveData1 = new MutableLiveData();LiveData&lt;Integer&gt; liveData2 = new MutableLiveData();//再创建一个聚合类MediatorLiveDataMediatorLiveData&lt;Integer&gt; liveDataMerger = new MediatorLiveData();//分别把上面创建的LiveData添加进来liveDataMerger.addSource(liveData1,observer);liveDataMerger.addSource(liveData2,observer);Observer observer = new Observer&lt;Integer&gt;&#123; @Override public void onChanged(@Nullable Integer s)&#123; titleTextView.setText(s); &#125;&#125;//一旦liveData1或者liveData2发送了新的数据，observer便能观察到，以便统一处理更新UI 2.3 Transformations.map 操作符可以对liveData进行变化，并且返回一个新的livedata对象 1234567891011MutableLiveData&lt;Integer&gt; data = new MutableLiveData&lt;&gt;();//数据转换LiveData&lt;String&gt; transformData = Transformations.map(data,input -&gt; String.valueOf(input));//使用转换后生成的transformData去观察数据transformData.observe(this,output -&gt; &#123; &#125;);//使用原始的livedata发送数据data.setValue(10); 3.LiveData核心方法 方法名 作用 observe(LifecycleOwner owner,Observer observer) 注册和宿主生命周期关联的观察者 observeForever(Observer observer) 注册观察者，不会反注册，需要自行维护 setValue(T data) 发送数据，没有活跃的观察者时不会分发。只能在主线程。 postValue(T data) 和setValue一样。不受线程环境限制。 onActive 当且仅当有一个活跃的观察者时会触发 inActive 不存在活跃的观察者时会触发 4.LiveData实现原理 LiveData使用的有很多好处 确保UI符合数据状态 不需要手动处理生命周期 始终保持最新的数据 事件总线LiveDataBus 确保UI符合数据状态 因为livedata实现了观察者模式 它里面的数据发生变化的时候，会向注册的Observer观察者发送通知，这时可以在观察者的onChanged里面更改UI 以保持数据的最新化 不需要手动处理生命周期 在注册observe的时候，会将当前宿主的生命周期进行绑定，当宿主被销毁时，就自动的进行销毁 始终保持最新的数据 可以这么理解，当宿主的生命周期变为非活跃状态的时候，那么它将在再次变为活跃状态的时候，接收到最新的数据，比如activity 从前台返回到后台，再从后台返回前台。再比如actvity和fragment由于配置的更改，而重新创建，也是能够接收到最新可用的数据，来保持最新的数据和UI 事件总线LiveDataBus 使用livedata来实现消息总线，替代使用eventbus 1234567891011//有参数构造 mVersion = 0 public LiveData(T value) &#123; mData = value; mVersion = START_VERSION + 1;&#125;//无参数构造，mVersion = -1 mData = NOT_SETpublic LiveData() &#123; mData = NOT_SET; mVersion = START_VERSION;&#125; 那么为什么livedata需要一个version呢？ 因为livedata通过version来控制数据分发，通过mVersion来进行数据的比对，本次是否需要进行数据的分发，因为不能livedata发送一次数据，而observable能接收到2，3次数据 123456789101112131415161718192021//把宿主和observer进行绑定public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? super T&gt; observer) &#123; assertMainThread(&quot;observe&quot;); if (owner.getLifecycle().getCurrentState() == DESTROYED) &#123; // ignore return; &#125; //把lifecycle 和 observer包装成了一个LifecycleBoundObserver，也就是一个有边界的的observer LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer); //包装完后，把wrapper放入一个hashmap里 ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper); if (existing != null &amp;&amp; !existing.isAttachedTo(owner)) &#123; throw new IllegalArgumentException(&quot;Cannot add the same observer&quot; + &quot; with different lifecycles&quot;); &#125; if (existing != null) &#123; return; &#125; //注意这里传入的是包装后的wrapper lifecycleboundobserver owner.getLifecycle().addObserver(wrapper);&#125; 通过observe可以向livedata注册一个观察者对象 owner.getLifecycle().addObserver(wrapper) 进入 会进行到实现 LifecycleRegistry.addObserver(observer)方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public void addObserver(@NonNull LifecycleObserver observer) &#123; enforceMainThreadIfNeeded(&quot;addObserver&quot;); //判断当前宿主的生命周期状态 State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED; //判断完后，会把当前宿主的生命周期和观察者进行包装 ObserverWithState statefulObserver = new ObserverWithState(observer, initialState); //包装完成后也会存储到hashmap里 ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver); //为什么要再进行这么包装呢？主要是为了分发当前宿主的生命周期状态给每个observer if (previous != null) &#123; return; &#125; LifecycleOwner lifecycleOwner = mLifecycleOwner.get(); if (lifecycleOwner == null) &#123; // it is null we should be destroyed. Fallback quickly return; &#125; boolean isReentrance = mAddingObserverCounter != 0 || mHandlingEvent; State targetState = calculateTargetState(observer); mAddingObserverCounter++; while ((statefulObserver.mState.compareTo(targetState) &lt; 0 &amp;&amp; mObserverMap.contains(observer))) &#123; pushParentState(statefulObserver.mState); final Event event = Event.upFrom(statefulObserver.mState); if (event == null) &#123; throw new IllegalStateException(&quot;no event up from &quot; + statefulObserver.mState); &#125; //分发宿主的生命周期状态 给observer statefulObserver.dispatchEvent(lifecycleOwner, event); popParentState(); // mState / subling may have been changed recalculate targetState = calculateTargetState(observer); &#125; if (!isReentrance) &#123; // we do sync only on the top level. sync(); &#125; mAddingObserverCounter--;&#125;void dispatchEvent(LifecycleOwner owner, Event event) &#123; State newState = event.getTargetState(); mState = min(mState, newState); //这个lifecycleobserver就是我们传递进来的lifecyclebounderobserver mLifecycleObserver.onStateChanged(owner, event); mState = newState;&#125; 这个接口是 LifecycleEventObserver的 1234public interface LifecycleEventObserver extends LifecycleObserver &#123; //这个回调的是宿主生命周期的变化 有两个参数，一个是宿主 一个是Event void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event);&#125; 12345678910111213141516171819202122232425262728293031public enum Event &#123; /** * Constant for onCreate event of the &#123;@link LifecycleOwner&#125;. */ ON_CREATE, /** * Constant for onStart event of the &#123;@link LifecycleOwner&#125;. */ ON_START, /** * Constant for onResume event of the &#123;@link LifecycleOwner&#125;. */ ON_RESUME, /** * Constant for onPause event of the &#123;@link LifecycleOwner&#125;. */ ON_PAUSE, /** * Constant for onStop event of the &#123;@link LifecycleOwner&#125;. */ ON_STOP, /** * Constant for onDestroy event of the &#123;@link LifecycleOwner&#125;. */ ON_DESTROY, /** * An &#123;@link Event Event&#125; constant that can be used to match all events. */ ON_ANY;&#125; 宿主的每个生命周期的改变都会回调到onStateChanged 我们看下它的实现 LifecycleBoundObserver 实现了LifecycleEventObserver LifecycleBoundObserver.onStateChanged 1234567891011121314151617public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) &#123; Lifecycle.State currentState = mOwner.getLifecycle().getCurrentState(); //如果当前状态是destroyed if (currentState == DESTROYED) &#123; //自行移除，自行反注册这个observer removeObserver(mObserver); return; &#125; Lifecycle.State prevState = null; while (prevState != currentState) &#123; prevState = currentState; //否则就执行活跃状态的变更 看shouldBeActive方法 activeStateChanged(shouldBeActive()); currentState = mOwner.getLifecycle().getCurrentState(); &#125;&#125; 1234//这里判断了只有宿主的生命周期大于start的时候 才代表宿主是活跃的boolean shouldBeActive() &#123; return mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);&#125; 继续看activeStateChanged 12345678910111213void activeStateChanged(boolean newActive) &#123; if (newActive == mActive) &#123; return; &#125; mActive = newActive; changeActiveCounter(mActive ? 1 : -1); if (mActive) &#123; dispatchingValue(this); &#125;&#125; 1234567891011121314151617181920212223void changeActiveCounter(int change) &#123; int previousActiveCount = mActiveCount; mActiveCount += change; if (mChangingActiveState) &#123; return; &#125; mChangingActiveState = true; try &#123; while (previousActiveCount != mActiveCount) &#123; boolean needToCallActive = previousActiveCount == 0 &amp;&amp; mActiveCount &gt; 0; boolean needToCallInactive = previousActiveCount &gt; 0 &amp;&amp; mActiveCount == 0; previousActiveCount = mActiveCount; if (needToCallActive) &#123;//首次注册会执行onActive onActive(); &#125; else if (needToCallInactive) &#123;//当最后一个观察者被移除时，会执行onInactive onInactive(); &#125; &#125; &#125; finally &#123; mChangingActiveState = false; &#125;&#125; 123protected void onInactive() &#123;//可以初始化&#125; 123protected void onActive() &#123;//可以反注册，释放资源，清理 paging就利用了这里&#125; 接着看 传入true 执行dispatchingValue 把当前的observer传入进去 123if (mActive) &#123; dispatchingValue(this);&#125; 123456789101112131415161718192021222324void dispatchingValue(@Nullable ObserverWrapper initiator) &#123; if (mDispatchingValue) &#123; mDispatchInvalidated = true; return; &#125; mDispatchingValue = true; do &#123; mDispatchInvalidated = false; //不为空，走到considerNotify 里，见considerNotify if (initiator != null) &#123; considerNotify(initiator); initiator = null; &#125; else &#123; for (Iterator&lt;Map.Entry&lt;Observer&lt;? super T&gt;, ObserverWrapper&gt;&gt; iterator = mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123; considerNotify(iterator.next().getValue()); if (mDispatchInvalidated) &#123; break; &#125; &#125; &#125; &#125; while (mDispatchInvalidated); mDispatchingValue = false;&#125; 1234567891011121314151617181920private void considerNotify(ObserverWrapper observer) &#123; //如果 observer是不活跃的，也是不进行分发的 if (!observer.mActive) &#123; return; &#125; //再判断宿主的生命周期是否大于start状态 if (!observer.shouldBeActive()) &#123; //如果不活跃，就把actvityStateChanged状态转为false observer.activeStateChanged(false); return; &#125; //mVersion是在livedata的构造里创建的 只有当observer.mLastVersion 小于mVersion的时候才会进行分发 if (observer.mLastVersion &gt;= mVersion) &#123; return; &#125; //这里是分发后，要把mLastVersion 和mVersion进行同步赋值 observer.mLastVersion = mVersion; //这里才是真正的分发回调onChaned 把livedata里的泛型数据传入进去 observer.mObserver.onChanged((T) mData);&#125; livedata中还有一个方法 12345678910111213public void observeForever(@NonNull Observer&lt;? super T&gt; observer) &#123; assertMainThread(&quot;observeForever&quot;); AlwaysActiveObserver wrapper = new AlwaysActiveObserver(observer); ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper); if (existing instanceof LiveData.LifecycleBoundObserver) &#123; throw new IllegalArgumentException(&quot;Cannot add the same observer&quot; + &quot; with different lifecycles&quot;); &#125; if (existing != null) &#123; return; &#125; wrapper.activeStateChanged(true);&#125; 如果注册了这个方法，在宿主被销毁时，livedata是不会帮我们反注册的，需要我们自行去调用removeObserver 接着来看postValue 1234567891011protected void postValue(T value) &#123; boolean postTask; synchronized (mDataLock) &#123; postTask = mPendingData == NOT_SET; mPendingData = value; &#125; if (!postTask) &#123; return; &#125; ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);&#125; 如果当前在子线程中，则必须调用postvalue 不能调用 setvalue 1234567protected void setValue(T value) &#123; assertMainThread(&quot;setValue&quot;); //新的数据需要进行分发，这里mLastVersion就小于mVersion了，可以进行分发，如果调用了onChanged的，消费了这个事件和数据，mLastVersion就同步了 mVersion++; mData = value; dispatchingValue(null);&#125; dispatchingValue 传了null值 这个要区别于上面activeStateChanged中的dispatchingValue 1234567891011121314151617181920212223242526void dispatchingValue(@Nullable ObserverWrapper initiator) &#123; if (mDispatchingValue) &#123; mDispatchInvalidated = true; return; &#125; mDispatchingValue = true; do &#123; mDispatchInvalidated = false; if (initiator != null) &#123; considerNotify(initiator); initiator = null; &#125; else &#123; //这里传了null 所以，走下面的这个逻辑 遍历这个observers //这个observers就是我们之前addObserver添加进去的 for (Iterator&lt;Map.Entry&lt;Observer&lt;? super T&gt;, ObserverWrapper&gt;&gt; iterator = mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123; //遍历之后，就会调用considerNoity进行数据的分发，调用onChanged considerNotify(iterator.next().getValue()); if (mDispatchInvalidated) &#123; break; &#125; &#125; &#125; &#125; while (mDispatchInvalidated); mDispatchingValue = false;&#125; livedata 这个方法，判断是否有活跃的观察者 123public boolean hasActiveObservers() &#123; return mActiveCount &gt; 0;&#125; 看下livedata的子类，实现 123456789101112131415161718192021public class MutableLiveData&lt;T&gt; extends LiveData&lt;T&gt; &#123; public MutableLiveData(T value) &#123; super(value); &#125; public MutableLiveData() &#123; super(); &#125; @Override public void postValue(T value) &#123; super.postValue(value); &#125; @Override public void setValue(T value) &#123; super.setValue(value); &#125;&#125; 这个类好像什么都没做，只是复写了postvalue和setvalue并把方法改成了public而已，那么原因是什么？ 因为livedata作为数据发送组件，必定是一方发送一方接收，不能既发送又接收，所以MutableLiveData 是为了规避这个问题才存在的，只有拿到的对象是MutableLiveData它才能进行一个数据的发送","categories":[{"name":"Jetpack系列","slug":"Jetpack系列","permalink":"http://example.com/categories/Jetpack%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"},{"name":"Jetpack","slug":"Jetpack","permalink":"http://example.com/tags/Jetpack/"}]},{"title":"提升海量用户极致体验的Hybrid架构设计[转]","slug":"[转]提升海量用户极致体验的 Hybrid 架构设计","date":"2022-03-17T20:23:47.000Z","updated":"2022-05-12T07:29:40.000Z","comments":true,"path":"2022/03/18/[转]提升海量用户极致体验的 Hybrid 架构设计/","link":"","permalink":"http://example.com/2022/03/18/[%E8%BD%AC]%E6%8F%90%E5%8D%87%E6%B5%B7%E9%87%8F%E7%94%A8%E6%88%B7%E6%9E%81%E8%87%B4%E4%BD%93%E9%AA%8C%E7%9A%84%20Hybrid%20%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"原文链接 引言上一篇原理篇，我们已经详细地阐述了 Hybrid App 的基础原理，了解了 Native 端 和 H5 端 是如何通信的，还有 bridge 的设计和接入。而本篇文章将开始把这些原因进一步实践，用代码真正地去实现一套完整且稳定的 Hybrid 方案。如果对原理还有疑问的小伙伴，请移步提升海量用户极致体验的 Hybrid 架构设计（原理篇），只有在理解了理论的基础上，进一步与实践相结合，才能真正地去深入一项技术。 摩天大楼说了那么一大堆理论知识，可能有小伙伴会说：“ 你是不是吹流弊啊。”那就先来简单介绍下我们已经使用这套方案落地的项目之一。 这是一个完全内置在 App 里的 Hybrid 模块，由 Native 与 H5 深度协作完成，总共有 4 个页面，其中首页和制作页由 H5 制作，而相机页和保存页是复用 Native 页面。 项目上线一年累积使用次数已经超过 10 亿次。这套方案经受住了考验，并在过程中仍然在不断的优化和拓展。 使用这套实现方案是基于以下几点考虑： 整个模块的风格多变，整体 UI 是与妆容所搭配的，而整个模块一直都在持续不断的迭代之中； 项目逻辑流程的可变性大，需要 H5 强大的热更新能力，及时应对数据的变化，快速的试错和纠正； 拍摄页与保存页是客户端已经有的模块，可以略微定制后直接复用； 需要由客户端协助接入多套 SDK，例如使用算法 SDK 进行复杂的图像处理。 简单看完项目，我们接下来开始 bridge.js 的构建。由于本系列文章主要面向前端童鞋，因此我们主要展开 H5 的部分，即会注入到每个页面头部的 bridge.js 的实现，客户端中的 SDK 部分就不详细解构了，只会提到一些细节。 搭建地基 — bridge.js 架构基于上篇文章阐述的结构，我们进一步去完善细节部分，先整理成下面这样的流程结构图，大家先看下图，有个大致的概念： 接下来我们会细看里面各个部分的代码实现。 (一) 业务方使用姿势首先，我们先看下在这套方案中，业务方是如何使用的，下面以获取网络状态为例： (二) H5 –&gt; Native接下来直接来看 nativeCall 的内部实现： 里面可以解构成下面 4 个步骤: 1.生成唯一 handler 标识，从 0 开始累加； 2.将参数按 handler 值的规则存入参数池(_paramsStore)中； 3.以 handler 注册自定义事件，绑定 callback，并将 callback 也存入 _callbackStore 中，addEvent()，储存的目的主要是为了事件解绑时使用； 4.以 iframe 的形式发送协议，并携带唯一标识 handler，send()； Native: 客户端接收到请求后，会使用 handler 调用 getParam 从参数池中获取对应的参数。 执行协议对应的功能； 这样即走通了 H5 –&gt; Native 的这个流程，在客户端完成了对应的功能后，既开始回传执行结果。 (三) Native –&gt; H5Native： Native 完成功能后，直接调用 Bridge.postMessage(handler, data)，将 执行结果 和 之前 nativeCall 传过来的 标识 回传给 H5； H5： H5 在接收到唯一标识后初始化对应的自定义事件，挂载数据后触发，这里涉及的就是 fireEvent 这个函数: 这样，我们就已经完成了双端之间的双向交互机制了，梳理出了整个 bridge.js 的核心代码了，包含了： 最重要的开放 API: nativeCall 与 postMessage ； 客户端获取参数函数: getParam ； 事件回调系统中的 addEvent 和 fireEvent ； 用于发送协议的 send。 安卓兼容性如果看过上一篇提升海量用户极致体验的 Hybrid 架构设计（原理篇）的童鞋，这时可能会有个疑问：在 Android 4.4 以下时，使用的 loadUrl 进行 js 函数的调用，而此时是无法获取函数的返回值的，也就是说 4.4- 时，安卓并无法通过 getParam 这个函数来获取到协议的参数，这里需要做兼容性的处理，而我们这里可以使用一个曲线救国的骚操作，使用到的原理就是上一篇文章中有提到的另一种 H5 -&gt; Native 的方案：WebView 中的 prompt 拦截 方案如下: 当安卓接受到协议，并拿到 handler 值； 使用无兼容性问题的 loadUrl 执行 js：Bridge.getParam(handler) ，直接将返回值直接通过 js 中的 prompt 发出： 通过重写 onJsPrompt 这个方法，拦截上一步发出的 prompt 的内容，并解析出相应的参数； 通过这样的方式，安卓全平台都可以完成参数的获取，并且方式统一，不需要分平台兼容，这就非常的 skrskr 啦。 现在看下来，是不是觉得炒鸡简单？。分分钟能写 100 个。没错！其实核心的原理就是这么的简单，但这只是一个最基础的地基而已，而基于地基之上，我们就可以开始一层一层建造我们的大楼了！ 建造大楼 — 协议的定制在完成最基础的架构后，我们就可以开始来进一步完成一些上层建筑了，制定一系列真正开放给业务方使用的协议 API，完善整套方案。 首先我们可以将这些协议分成 功能协议 和 业务协议。 功能协议这类协议是指用于完善整套方案的基础功能的一些通用协议，以 command:&#x2F;&#x2F;作为通用头，封装在 SDK 之中，可以在全线 App、全线 WebView 中使用： 1.初始化机制上篇文章有提到由于 bridge.js 注入的异步性，我们需要由客户端在注入完成后通知 H5。 这里我们可以约定一个通用的初始化事件，这里我们约定为 init，因此前端就可以进行入口的监听, 类似于我们常用的 DOMContentLoaded: 大家可以看到，这里用了个标记位用于避免事件被重复触发，这是由于客户端中是通过监听 WebView 的生命周期钩子来触发的，而 iframe 之类的操作会导致这些钩子的多次触发，因此需要双方各做一层防御性措施。 接下来，我们可以通过该事件，直接初始化传给 H5 一些环境参数和系统信息等，下面是我们使用到的： 同样的，我们可以约定更多的页面生命周期事件，例如因为 App 很经常性的隐藏到后台，因此在被激活时，我们可以设置个生命周期: resume，可以用于告知 H5 页面被激活。 Tips: 这里就能体现出我们通过事件机制来作为回调系统的优势了，我们可以以最习惯的方式进行事件的监听，而客户端可以直接使用 bridge.fireEvent(‘init’, data)触发事件，这样便可以优雅地实现 Native -&gt; H5 的单方向交互。 2.打包机制Hybrid 模块 的其中一种方式是将前端代码打包后内置于 App 本地，以便拥有最快的启动性能和离线访问能力。而这种方式最大的麻烦点，就是代码的更新，我们不可能每次有修改时就手动重新打包给客户端童鞋替换，而且这样也失去了我们的热更新机制。 因此这里就需要一套新的热更新机制，这套机制需要由客户端&#x2F;前端&#x2F;服务端 三端的童鞋提供对应的资源，共同协作完成整套流程。 资源： H5: 每个代码包都有一个唯一且递增的版本号； Native: 提供包下载且解压到对应目录的服务，前端可以由下面这个协议来调用该功能。 服务端: 提供一个接口，可以获取线上最新代码包的版本号和下载地址。 流程： 前端更新代码打包后按版本号上传至指定的服务器上； 每次打开页面时，H5 请求接口获取线上最新代码包版本号，并与本地包进行版本号比对，当线上的版本号 大于 本地包版本号时，发起包下载协议： 客户端接受到协议后，直接去线上地址下载最新的代码包，并解压替换到当前目录文件。 拥有这样的机制后，H5 在开发后，就可以直接打包将包上传到对应的服务器上，这样在 App 中打开页面后，即可以实时的热更新。 3.环境系统 和 多语言系统通常，我们会将项目分成多个不同的环境，相互隔离。而由于 Hybrid 模块是置于 App 中的，因此环境需要与 App 进行匹配，这里就可以直接使用上面第一点提到的，通过 init 中携带的数据 data.env 来匹配： env: 0 - 正式环境； 1 - 测试环境； 2 - 开发环境； 同理， 多语言也可以直接使用 e.data.language 直接进行匹配； Tips： 环境机制我们通常主要用于匹配后端的环境，正式环境和测试环境对应不同的接口。而这里还有一点特别的，就是需要注意代码包的更新，上述的包更新条件要包含三个方面: 版本号、环境和 App 版本，在不同环境不同 App 版本下，也应该更新到相应的最新代码包。 4. 事件中转站由于页面是 H5 开发，而 Native 可能需要控制 H5 页面，例如最常用的场景: 当页面中有弹窗或者 SPA 切换页面时，安卓的返回实体键应该能完成对应的回退，而不是因为 WebView 没有 history 就直接关闭。 类似于这类需求，这里就可以定制一个事件中心(eventListeners )，用于监听客户端的实体返回键： 5. 数据传递机制在业务中，很多场景需要做到 Native 与 H5 保持数据的同步，此时就可以使用类似上面的原理，制定一套数据传递协议: Tips： Hybrid 模块通常需要从对应的入口进入，因此这里有一种可以优化的方式： 由 App 在启动时先去获取线上数据，在进入 WebView 后直接通过 init 或者触发 getData 直接发送给 H5，这样能减少请求数量，优化用户体验。 6. 代理请求H5 中最常用的就是请求，通常我们可以直接使用 ajax，但是这里有几个问题比较棘手: 最常见的请求跨域； 数据算法加密； 用户登录校验； 而客户端的请求便不会出现这些问题，因此我们可以由客户端代理我们发出的请求，可以定制 4 个协议: getProxy，postProxy， getProxyLogined，postProxyLogined，其中带有 Logined 的协议代表着在请求时会自动携带已登录用户的 token 和 uid 等参数，使用在一些需要登录信息的接口上。这样做的好处是： H5 方就无需处理繁多的各项复杂信息，不需要进行跨端传输； 能够对 H5 与 Native 的请求出口进行统一，方便加工处理。 7.更多除了这些重要的功能外，我们还可以非常自由地定制很多协议，让 H5 拥有更多更强大的功能，下面是我们所定制的一些功能： getNetwork：获取网络状态； openApp：唤起其它 App； setShareInfo 与 callShare：分享内容到第三方平台； link：使用新的 WebView 打开页面； closeWebview：关闭 WebView； setStorage 与 getStorage：设置与获取缓存数据； loading：调用客户端通用 Loading； setWebviewTitle：设置 WebView 标题； saveImage：保存图片到本地； … 这里可以定义更多的通用性协议，这里有个原则可以遵守，即这部分协议应该是基础性功能，应该是纯净的，适用于所有的业务方。根据上篇文章提到的理念，这部分是当成通用 SDK 进行维护与升级的，因此不应该耦合业务层的任何逻辑。 而有时我们会遇到需要定制一些业务上的逻辑，例如上面提到的项目中，我们要将用户图片通过算法处理成卡通画。这样的需求就是非常的业务化，不适用于其它项目，因此我们应该定制成业务协议。 业务协议这类协议区别于功能协议，它们会杂合一定程度的业务逻辑，而这些逻辑只是针对于特定的项目。其实对于 H5 的使用上，差别并不大，只是使用对应特殊的协议头用于区分，例如: 这类协议通常不包含在 SDK 中，因此需要由客户端的童鞋针对项目的 WebView 进行定制，使用 bridge.js 提供的基础功能实现对应的复杂功能。而在其它的项目入口中，就无法使用这些协议。 总结看到总结两个字，有没有长舒了一口气。通过这两篇文章，我们终于将 Hybrid 方案的前端部分完全的解构清楚了，是不是有种神清气爽的感觉，完全可以马上开启你们的 Hybrid 之旅了。鼓掌鼓掌！ 但这也远非终点，或者说这永无终点。~大楼建成后，离真正的摩天大楼还是差着一步 — 内部装修，其实接下来我们还需要做很多的优化措施，来解决一些仍然存在的问题，这部分其实我们也一直还在努力的阶段。 受篇幅所限，有时间会将这部分再写一篇优化篇，主要来与大家探讨下我们所能想到的一些优化方案，非常期待大佬们也能给我们提供更多的建议和解决办法。感恩~~😇","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"webview","slug":"webview","permalink":"http://example.com/tags/webview/"},{"name":"hybrid","slug":"hybrid","permalink":"http://example.com/tags/hybrid/"}]},{"title":"提升海量用户极致体验的Hybrid架构设计（原理篇）[转]","slug":"[转]提升海量用户极致体验的 Hybrid 架构设计（原理篇）","date":"2022-03-16T20:23:47.000Z","updated":"2022-05-12T07:31:29.000Z","comments":true,"path":"2022/03/17/[转]提升海量用户极致体验的 Hybrid 架构设计（原理篇）/","link":"","permalink":"http://example.com/2022/03/17/[%E8%BD%AC]%E6%8F%90%E5%8D%87%E6%B5%B7%E9%87%8F%E7%94%A8%E6%88%B7%E6%9E%81%E8%87%B4%E4%BD%93%E9%AA%8C%E7%9A%84%20Hybrid%20%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E5%8E%9F%E7%90%86%E7%AF%87%EF%BC%89/","excerpt":"","text":"原文链接 一、引言随着 Web 技术和移动设备的快速发展，Hybrid 技术已经成为一种最主流最常见的方案。一套好的 Hybrid 架构方案能让 App 既能拥有极致的体验和性能，同时也能拥有 Web 技术灵活的开发模式、跨平台能力以及热更新机制，想想是不是都鸡冻不已…本系列文章是美图公司在这方面实践的一个总结，包含了原理解析、方案选型与实现、实践优化等方面。 大家可以到 github (https://github.com/xd-tayde/blog/blob/master/hybrid-1.md)上和作者进行讨论哈！ 二、现有混合方案Hybrid App，俗称混合应用，即混合了 Native 技术 与 Web 技术进行开发的移动应用。现在比较流行的混合方案主要有三种，主要是在 UI 渲染机制上的不同： 1.基于 WebView UI 的基础方案，市面上大部分主流 App 都有采用，例如微信 JS-SDK ，通过 JSBridge 完成 H5 与 Native 的双向通讯，从而赋予 H5 一定程度的原生能力。 2.基于 Native UI 的方案，例如 React-Native、Weex。在赋予 H5 原生 API 能力的基础上，进一步通过 JSBridge 将 js 解析成的虚拟节点树( Virtual DOM )传递到 Native 并使用原生渲染。 3.另外还有近期比较流行的小程序方案，也是通过更加定制化的 JSBridge，并使用双 WebView 双线程的模式隔离了 JS 逻辑与 UI 渲染，形成了特殊的开发模式，加强了 H5 与 Native 混合程度，提高了页面性能及开发体验。 以上的三种方案，其实同样都是基于 JSBridge 完成的通讯层，第二三种方案，其实可以看做是在方案一的基础上，继续通过不同的新技术进一步提高了应用的混合程度。因此，JSBridge 也是整个混合应用最关键的部分，例如我们在设置微信分享时用到的 JS-SDK，wx 对象便是我们最常见的 JSBridge: 三、方案选型任何技术方案的选型，其实都应该基于使用场景和现有条件。基于公司现有情况的几点考虑，在方案一上进一步优化，更加适合我们的需求。 需求 Web 技术 快速迭代、灵活开发的特点和线上热更新的机制。 产品的核心能力是强大的拍照与底层图片处理能力，因此单纯的 H5 技术能做的事非常有限，不能满足需求，通过 Hybrid 技术来强化 H5 ，便是一种必需。 公司业务上，并没有非常复杂的 UI 渲染需求，而且 App 中的一系列原生 UI 组件 已经非常成熟，因此我们并不强需类似 RN 这样的方案。 因此，如何既能利用 H5 强大的开发和迭代能力，又能赋予 H5 强大的底层能力和用户体验，同时能复用现有的成熟 Native 组件，便成为了我们最大的需求点 – 一套完整又强大的 Hybrid 技术架构方案。 四、Hybrid 技术原理Hybrid App 的本质，其实是在原生的 App 中，使用 WebView 作为容器直接承载 Web 页面。因此，最核心的点就是 Native 端与 H5 端之间的双向通讯层，其实这里也可以理解为我们需要一套跨语言通讯方案，来完成 Native(Java&#x2F;Objective-c&#x2F;…) 与 JavaScript 的通讯。这个方案就是我们所说的 JSBridge，而实现的关键便是作为容器的 WebView，一切的原理都是基于 WebView 的机制。 4.1 JavaScript 通知 Native基于 WebView 的机制和开放的 API , 实现这个功能有三种常见的方案： API 注入，原理其实就是 Native 获取 JavaScript 环境上下文，并直接在上面挂载对象或者方法，使 js 可以直接调用，Android 与 IOS 分别拥有对应的挂载方式。 WebView 中的 prompt&#x2F;console&#x2F;alert 拦截，通常使用 prompt ，因为这个方法在前端中使用频率低，比较不会出现冲突； WebView URL Scheme 跳转拦截； 第二三种机制的原理是类似的，都是通过对 WebView 信息冒泡传递的拦截，从而达到通讯的，接下来我们主要从 原理-定制协议-拦截协议-参数传递-回调机制 5 个方面详细阐述下第三种方案 – URL 拦截方案。 4.1.1 实现原理在 WebView 中发出的网络请求，客户端都能进行监听和捕获 4.1.2 协议的定制我们需要制定一套 URL Scheme 规则，通常我们的请求会带有对应的协议开头，例如常见的 https://xxx.com 或者 file:&#x2F;&#x2F;1.jpg ，代表着不同的含义。我们这里可以将协议类型的请求定制为: xxcommand:&#x2F;&#x2F;xxxx?param1&#x3D;1&amp;param2&#x3D;2 这里有几个需要注意点的是: (1) xxcommand:&#x2F;&#x2F; 只是一种规则，可以根据业务进行制定，使其具有含义，例如我们定义 xxcommand:&#x2F;&#x2F; 为公司所有 App 系通用，为通用工具协议： xxcommand:&#x2F;&#x2F;getProxy?h&#x3D;1 而定义 xxapp:&#x2F;&#x2F; 为每个 App 单独的业务协议。 xxapp:&#x2F;&#x2F;openCamera?h&#x3D;2 不同的协议头代表着不同的含义，这样便能清楚知道每个协议的适用范围。 (2) 这里不要使用 location.href 发送，因为其自身机制有个问题是同时并发多次请求会被合并成为一次，导致协议被忽略，而并发协议其实是非常常见的功能。我们会使用创建 iframe 发送请求的方式。 (3) 通常考虑到安全性，需要在客户端中设置域名白名单或者限制，避免公司内部业务协议被第三方直接调用。 4.1.3 协议的拦截客户端可以通过 API 对 WebView 发出的请求进行拦截： IOS 上: shouldStartLoadWithRequest Android: shouldOverrideUrlLoading 当解析到请求 URL 头为制定的协议时，便不发起对应的资源请求，而是解析参数，并进行相关功能或者方法的调用，完成协议功能的映射。 4.1.4 协议回调由于协议的本质其实是发送请求，这属于一个异步的过程，因此我们便需要处理对应的回调机制。这里我们采用的方式是 JS 的事件系统，这里我们会用到 window.addEventListener 和 window.dispatchEvent 这两个基础 API； 1.发送协议时，通过协议的唯一标识注册自定义事件，并将回调绑定到对应的事件上。 2.客户端完成对应的功能后，调用 Bridge 的 dispatch API ，直接携带 data 触发该协议的自定义事件。 通过事件的机制，会让开发更符合我们前端的习惯，例如当你需要监听客户端的通知时，同样只需要在通过 addEventListener 进行监听即可。 Tips: 这里有一点需要注意的是，应该避免事件的多次重复绑定，因此当唯一标识重置时，需要 removeEventListener 对应的事件。 4.1.5 参数传递方式由于 WebView 对 URL 会有长度的限制，因此常规的通过 search 参数 进行传递的方式便具有一个问题，既 当需要传递的参数过长时，可能会导致被截断，例如传递 base64 或者传递大量数据时。 因此我们需要制定新的参数传递规则，我们使用的是函数调用的方式。这里的原理主要是基于:Native 可以直接调用 JS 方法并直接获取函数的返回值。 我们只需要对每条协议标记一个唯一标识，并把参数存入参数池中，到时客户端再通过该唯一标识从参数池中获取对应的参数即可。 4.2 Native 通知 Javascript由于 Native 可以算作 H5 的宿主，因此拥有更大的权限，上面也提到了 Native 可以通过 WebView API 直接执行 Js 代码。这样的权限也就让这个方向的通讯变得十分的便捷。 IOS: stringByEvaluatingJavaScriptFromString Android: loadUrl (4.4-) Tips: 当系统低于 4.4 时，evaluateJavascript 是无法使用的，因此单纯的使用 loadUrl 无法获取 JS 返回值，这时我们需要使用前面提到的 prompt 的方法进行兼容，让 H5 端 通过 prompt 进行数据的发送，客户端进行拦截并获取数据。 Android: evaluateJavascript (4.4+) 基于上面的原理，我们已经明白 JSBridge 最基础的原理，并且能实现 Native &lt;&#x3D;&gt; H5 的双向通讯机制了。 4.3 JSBridge 的接入接下来，我们来理下代码上需要的资源。实现这套方案，从上图可以看出，其实可以分为两个部分: JS 部分(bridge): 在 JS 环境中注入 bridge 的实现代码，包含了协议的拼装&#x2F;发送&#x2F;参数池&#x2F;回调池等一些基础功能。 Native 部分(SDK): 在客户端中 bridge 的功能映射代码，实现了 URL 拦截与解析&#x2F;环境信息的注入&#x2F;通用功能映射等功能。 我们这里的做法是，将这两部分一起封装成一个 Native SDK，由客户端统一引入。客户端在初始化一个 WebView 打开页面时，如果页面地址在白名单中，会直接在 HTML 的头部注入对应的 bridge.js。这样的做法有以下的好处： 双方的代码统一维护，避免出现版本分裂的情况。有更新时，只要由客户端更新 SDK 即可，不会出现版本兼容的问题； App 的接入十分方便，只需要按文档接入最新版本的 SDK ，即可直接运行整套 Hybrid 方案，便于在多个 App 中快速的落地； H5 端无需关注，这样有利于将 bridge 开放给第三方页面使用。 这里有一点需要注意的是，协议的调用，一定是需要确保执行在 bridge.js 成功注入后。由于客户端的注入行为属于一个附加的异步行为，从 H5 方很难去捕捉准确的完成时机，因此这里需要通过客户端监听页面完成后，基于上面的事件回调机制通知 H5 端，页面中即可通过 window.addEventListener(‘bridgeReady’, e &#x3D;&gt; {})进行初始化。 4.4 App 中 H5 的接入方式将 H5 接入 App 中通常有两种方式：在线 H5 和内置包 H5。 (1) 在线 H5，这是最常见的一种方式。我们只需要将 H5 代码部署到服务器上，只要把对应的 URL 地址 给到客户端，用 WebView 打开该 URL，即可嵌入。该方式的好处在于: 独立性强，有非常独立的开发&#x2F;调试&#x2F;更新&#x2F;上线能力； 资源放在服务器上，完全不会影响客户端的包体积； 接入成本很低，完全的热更新机制。 但相对的，这种方式也有对应的缺点: 完全的网络依赖，在离线的情况下无法打开页面； 首屏加载速度依赖于网络，网络较慢时，首屏加载也较慢； 通常，这种方式更适用在一些比较轻量级的页面上，例如一些帮助页、提示页、使用攻略等页面。这些页面的特点是功能性不强，不太需要复杂的功能协议，且不需要离线使用。在一些第三方页面接入上，也会使用这种方式，例如我们的页面调用微信 JS-SDK 。 (2) 内置包 H5，这是一种本地化的嵌入方式，我们需要将代码进行打包后下发到客户端，并由客户端直接解压到本地储存中。通常我们运用在一些比较大和比较重要的模块上。其优点是: 由于其本地化，首屏加载速度快，用户体验更为接近原生； 可以不依赖网络，离线运行； 但同时，它的劣势也十分明显: 开发流程&#x2F;更新机制复杂化，需要客户端，甚至服务端的共同协作； 会相应的增加 App 包体积； 这两种接入方式均有自己的优缺点，应该根据不同场景进行选择。 五、总结本文主要解析了现在 Hybrid App 的发展现状和其基础原理，包含了 JavaScript 通知 Native Native 通知 Javascript JSBridge 的接入 H5 的接入 只有在了解了其最本质的实现原理后，才能对这套方案进行实现以及进一步的优化。接下来，我们将基于上面的理论，继续探讨如何把这套方案的真正代码实现以及方案优化方案，欢迎大家一起讨论！","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"webview","slug":"webview","permalink":"http://example.com/tags/webview/"},{"name":"hybrid","slug":"hybrid","permalink":"http://example.com/tags/hybrid/"}]},{"title":"Android 实现水印背景效果[转]","slug":"Android 实现水印背景效果","date":"2022-03-14T20:23:47.000Z","updated":"2022-05-13T00:19:38.000Z","comments":true,"path":"2022/03/15/Android 实现水印背景效果/","link":"","permalink":"http://example.com/2022/03/15/Android%20%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%8D%B0%E8%83%8C%E6%99%AF%E6%95%88%E6%9E%9C/","excerpt":"","text":"[转]Android 实现水印背景效果项目中有需要加水印的需求，实现完效果图是这样的 什么看不清… 为了让大家看清效果，字体改了一下，正常应该是文章最上面那个的效果。话不多说，直接上代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332import android.annotation.SuppressLint;import android.content.Context;import android.content.res.TypedArray;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.graphics.Rect;import android.graphics.Typeface;import android.text.TextPaint;import android.util.AttributeSet;import android.view.MotionEvent;import android.view.View; import com.hkdc.commonlib.R; public class WaterMarkView extends View &#123; private static final String DEFAULT_SEPARATOR = &quot;///&quot;; private TextPaint mTextPaint = new TextPaint(); private String[] mText; private int mDegrees; private int mTextColor; private int mTextSize=35; private boolean mTextBold; private int mDx; private int mDy; private Paint.Align mAlign; private boolean mSync; private int textWidth, textHeight; public WaterMarkView(Context context) &#123; this(context, null); &#125; public WaterMarkView(Context context, AttributeSet attrs) &#123; super(context, attrs); TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.WaterMarkView); mDegrees = typedArray.getInt(R.styleable.WaterMarkView_water_mark_degree, WaterMarkManager.INFO != null ? WaterMarkManager.INFO.getDegrees() : -30); String text = typedArray.getString(R.styleable.WaterMarkView_water_mark_text); if (text != null) &#123; mText = text.split(DEFAULT_SEPARATOR); &#125; mTextColor = typedArray.getColor(R.styleable.WaterMarkView_water_mark_textColor, WaterMarkManager.INFO != null ? WaterMarkManager.INFO.getTextColor() : Color.parseColor(&quot;#33000000&quot;)); mTextSize = typedArray.getDimensionPixelSize(R.styleable.WaterMarkView_water_mark_textSize, WaterMarkManager.INFO != null ? WaterMarkManager.INFO.getTextSize() : 42); mTextBold = typedArray.getBoolean(R.styleable.WaterMarkView_water_mark_textBold, WaterMarkManager.INFO != null &amp;&amp; WaterMarkManager.INFO.isTextBold()); mDx = typedArray.getDimensionPixelSize(R.styleable.WaterMarkView_water_mark_dx, WaterMarkManager.INFO != null ? WaterMarkManager.INFO.getDx() : 100); mDy = typedArray.getDimensionPixelSize(R.styleable.WaterMarkView_water_mark_dy, WaterMarkManager.INFO != null ? WaterMarkManager.INFO.getDy() : 240); int align = typedArray.getInt(R.styleable.WaterMarkView_water_mark_align, WaterMarkManager.INFO != null ? WaterMarkManager.INFO.getAlignInt() : 1); mAlign = align == 0 ? Paint.Align.LEFT : align == 2 ? Paint.Align.RIGHT : Paint.Align.CENTER; mSync = typedArray.getBoolean(R.styleable.WaterMarkView_water_mark_sync, true); typedArray.recycle(); setBackgroundColor(Color.TRANSPARENT); mTextPaint.setAntiAlias(true); mTextPaint.setFlags(Paint.ANTI_ALIAS_FLAG); mTextPaint.setColor(mTextColor); mTextPaint.setTextSize(mTextSize); mTextPaint.setTypeface(mTextBold ? Typeface.DEFAULT_BOLD : Typeface.DEFAULT); mTextPaint.setTextAlign(mAlign); mText = mText == null &amp;&amp; mSync ? WaterMarkManager.CONTENT : mText; textWidth = 0; textHeight = 0; if (mText != null &amp;&amp; mText.length &gt; 0) &#123; for (String s : mText) &#123; Rect tvRect = new Rect(); mTextPaint.getTextBounds(s, 0, s.length(), tvRect); textWidth = textWidth &gt; tvRect.width() ? textWidth : tvRect.width(); textHeight += (tvRect.height() + 10); &#125; &#125; if (mSync) &#123; WaterMarkManager.LIST.add(this); &#125; &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if (mText != null &amp;&amp; mText.length &gt; 0) &#123; int measuredWidth = getMeasuredWidth(); int measuredHeight = getMeasuredHeight(); if (measuredWidth == 0 || measuredHeight == 0) &#123; return; &#125; int canvasLength = measuredWidth &gt; measuredHeight ? measuredWidth : measuredHeight; canvas.save(); canvas.rotate(mDegrees, measuredWidth / 2, measuredHeight / 2); canvas.save(); int y = 0; boolean odd = true; while (y &lt; canvasLength + textHeight) &#123; int x = odd ? 0 : -(textWidth + mDx) / 2; while (x &lt; canvasLength + textWidth) &#123; drawTexts(mText, mTextPaint, canvas, x, y); x = x + textWidth + mDx; &#125; y = y + textHeight + mDy; odd = !odd; &#125; canvas.restore(); &#125; &#125; private void drawTexts(String[] ss, Paint paint, Canvas canvas, int x, int y) &#123; Paint.FontMetrics fontMetrics = paint.getFontMetrics(); float top = fontMetrics.top; float bottom = fontMetrics.bottom; int length = ss.length; float total = (length - 1) * (bottom - top) + (fontMetrics.descent - fontMetrics.ascent); float offset = total / 2 - bottom; for (int i = 0; i &lt; length; i++) &#123; float yAxis = -(length - i - 1) * (bottom - top) + offset; canvas.drawText(ss[i], x, y + yAxis + 10, paint); &#125; &#125; /** * 设置水印文字内容 * * @param text 文字内容 */ public void setText(String... text) &#123; mText = text; textWidth = 0; textHeight = 0; if (mText != null &amp;&amp; mText.length &gt; 0) &#123; for (String s : mText) &#123; Rect tvRect = new Rect(); mTextPaint.getTextBounds(s, 0, s.length(), tvRect); textWidth = textWidth &gt; tvRect.width() ? textWidth : tvRect.width(); textHeight += (tvRect.height() + 10); &#125; &#125; postInvalidate(); &#125; /** * 同步设置水印文字内容 * * @param text 文字内容 */ void setSyncText(String... text) &#123; if (mSync) &#123; setText(text); &#125; &#125; /** * 设置水印倾斜角度 * * @param degrees 倾斜角度(默认:-30) */ public void setDegrees(int degrees) &#123; mDegrees = degrees; postInvalidate(); &#125; /** * 同步设置水印倾斜角度 * * @param degrees 倾斜角度(默认:-30) */ void setSyncDegrees(int degrees) &#123; if (mSync) &#123; setDegrees(degrees); &#125; &#125; /** * 设置水印字体颜色 * * @param textColor 字体颜色(默认:#33000000) */ public void setTextColor(int textColor) &#123; mTextColor = textColor; mTextPaint.setColor(mTextColor); postInvalidate(); &#125; /** * 同步设置水印字体颜色 * * @param textColor 字体颜色(默认:#33000000) */ void setSyncTextColor(int textColor) &#123; if (mSync) &#123; setTextColor(textColor); &#125; &#125; /** * 设置水印字体大小（单位：px） * * @param textSize 字体大小(默认:42px) */ public void setTextSize(int textSize) &#123; mTextSize = textSize; mTextPaint.setTextSize(30); postInvalidate(); &#125; /** * 同步设置水印字体大小（单位：px） * * @param textSize 字体大小(默认:42px) */ void setSyncTextSize(int textSize) &#123; if (mSync) &#123; setTextSize(30); &#125; &#125; /** * 设置水印字体是否粗体 * * @param textBold 是否粗体(默认:false) */ public void setTextBold(boolean textBold) &#123; mTextBold = textBold; mTextPaint.setTypeface(mTextBold ? Typeface.DEFAULT_BOLD : Typeface.DEFAULT); postInvalidate(); &#125; /** * 同步设置水印字体是否粗体 * * @param textBold 是否粗体(默认:false) */ void setSyncTextBold(boolean textBold) &#123; if (mSync) &#123; setTextBold(textBold); &#125; &#125; /** * 设置水印X轴偏移量（单位：px） * * @param dx X轴偏移量(默认:100px) */ public void setDx(int dx) &#123; this.mDx = dx; postInvalidate(); &#125; /** * 同步设置水印X轴偏移量（单位：px） * * @param dx X轴偏移量(默认:100px) */ void setSyncDx(int dx) &#123; if (mSync) &#123; setDx(dx); &#125; &#125; /** * 设置水印Y轴偏移量（单位：px） * * @param dy Y轴偏移量(默认:240px) */ public void setDy(int dy) &#123; this.mDy = dy; postInvalidate(); &#125; /** * 同步设置水印Y轴偏移量（单位：px） * * @param dy Y轴偏移量(默认:240px) */ void setSignDy(int dy) &#123; if (mSync) &#123; setDy(dy); &#125; &#125; /** * 设置水印对齐方式 * * @param align 对齐方式(默认:Center) */ public void setAlign(Paint.Align align) &#123; this.mAlign = align; postInvalidate(); &#125; /** * 同步设置水印对齐方式 * * @param align 对齐方式(默认:Center) */ void setSignAlign(Paint.Align align) &#123; if (mSync) &#123; setAlign(align); &#125; &#125; /** * 销毁相关页面时调用（切记） */ public void onDestroy() &#123; if (mSync) &#123; WaterMarkManager.LIST.remove(this); &#125; &#125; @Override public boolean dispatchTouchEvent(MotionEvent event) &#123; return false; &#125; @SuppressLint(&quot;ClickableViewAccessibility&quot;) @Override public boolean onTouchEvent(MotionEvent event) &#123; return false; &#125;&#125; 123456789101112131415&lt;declare-styleable name=&quot;WaterMarkView&quot;&gt; &lt;attr name=&quot;water_mark_degree&quot; format=&quot;integer|reference&quot; /&gt; &lt;attr name=&quot;water_mark_text&quot; format=&quot;string|reference&quot; /&gt; &lt;attr name=&quot;water_mark_textColor&quot; format=&quot;color|reference&quot; /&gt; &lt;attr name=&quot;water_mark_textSize&quot; format=&quot;dimension|reference&quot; /&gt; &lt;attr name=&quot;water_mark_textBold&quot; format=&quot;boolean&quot; /&gt; &lt;attr name=&quot;water_mark_dx&quot; format=&quot;dimension|reference&quot; /&gt; &lt;attr name=&quot;water_mark_dy&quot; format=&quot;dimension|reference&quot; /&gt; &lt;attr name=&quot;water_mark_align&quot; format=&quot;dimension&quot;&gt; &lt;enum name=&quot;LEFT&quot; value=&quot;0&quot; /&gt; &lt;enum name=&quot;CENTER&quot; value=&quot;1&quot; /&gt; &lt;enum name=&quot;RIGHT&quot; value=&quot;2&quot; /&gt; &lt;/attr&gt; &lt;attr name=&quot;water_mark_sync&quot; format=&quot;boolean&quot; /&gt; &lt;/declare-styleable&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187package com.hkdc.commonlib.warkmark; import android.annotation.SuppressLint;import android.app.Activity;import android.graphics.Paint;import android.view.LayoutInflater; import com.hkdc.commonlib.R; import java.util.ArrayList;import java.util.List; /** * @author Leon (wshk729@163.com) * @date 2018/8/24 * &lt;p&gt; */public class WaterMarkManager &#123; static WaterMarkInfo INFO = null; static String[] CONTENT = null; static List&lt;WaterMarkView&gt; LIST = new ArrayList&lt;&gt;(); /** * 设置水印全局配置信息 * * @param info 配置信息 */ public static void setInfo(WaterMarkInfo info) &#123; INFO = info; &#125; /** * 获取一个满屏水印View * * @param activity activity */ @SuppressLint(&quot;InflateParams&quot;) public static WaterMarkView getView(Activity activity) &#123; return (WaterMarkView) LayoutInflater.from(activity).inflate(R.layout.view_water_mark, null); &#125; /** * WaterMarkInfo初始化判断 */ private static void assertInitialized() &#123; if (INFO == null) &#123; INFO = WaterMarkInfo.create().generate(); &#125; &#125; /** * 同步设置全部水印文字信息 * * @param content 文字信息 */ public static void setText(String... content) &#123; assertInitialized(); CONTENT = content; if (LIST.size() &gt; 0) &#123; for (WaterMarkView view : LIST) &#123; if (view != null) &#123; view.setSyncText(content); &#125; &#125; &#125; &#125; /** * 同步设置全部水印倾斜角度 * * @param degrees 倾斜角度(默认:-30) */ public static void setDegrees(int degrees) &#123; assertInitialized(); INFO.setDegrees(degrees); if (LIST.size() &gt; 0) &#123; for (WaterMarkView view : LIST) &#123; if (view != null) &#123; view.setSyncDegrees(degrees); &#125; &#125; &#125; &#125; /** * 同步设置全部水印字体颜色 * * @param textColor 字体颜色(默认:#33000000) */ public static void setTextColor(int textColor) &#123; assertInitialized(); INFO.setTextColor(textColor); if (LIST.size() &gt; 0) &#123; for (WaterMarkView view : LIST) &#123; if (view != null) &#123; view.setSyncTextColor(textColor); &#125; &#125; &#125; &#125; /** * 同步设置全部水印字体大小（单位：px） * * @param textSize 字体大小(默认:42px) */ public static void setTextSize(int textSize) &#123; assertInitialized(); INFO.setTextSize(textSize); if (LIST.size() &gt; 0) &#123; for (WaterMarkView view : LIST) &#123; if (view != null) &#123; view.setSyncTextSize(textSize); &#125; &#125; &#125; &#125; /** * 同步设置全部水印字体是否粗体 * * @param textBold 是否粗体(默认:false) */ public static void setTextBold(boolean textBold) &#123; assertInitialized(); INFO.setTextBold(textBold); if (LIST.size() &gt; 0) &#123; for (WaterMarkView view : LIST) &#123; if (view != null) &#123; view.setSyncTextBold(textBold); &#125; &#125; &#125; &#125; /** * 同步设置全部水印X轴偏移量（单位：px） * * @param dx X轴偏移量(默认:100px) */ public static void setDx(int dx) &#123; assertInitialized(); INFO.setDx(dx); if (LIST.size() &gt; 0) &#123; for (WaterMarkView view : LIST) &#123; if (view != null) &#123; view.setSyncDx(dx); &#125; &#125; &#125; &#125; /** * 同步设置全部水印Y轴偏移量（单位：px） * * @param dy Y轴偏移量(默认:240px) */ public static void setDy(int dy) &#123; assertInitialized(); INFO.setDy(dy); if (LIST.size() &gt; 0) &#123; for (WaterMarkView view : LIST) &#123; if (view != null) &#123; view.setSignDy(dy); &#125; &#125; &#125; &#125; /** * 同步设置全部水印对齐方式 * * @param align 对齐方式(默认:Center) */ public static void setAlign(Paint.Align align) &#123; assertInitialized(); INFO.setAlign(align); if (LIST.size() &gt; 0) &#123; for (WaterMarkView view : LIST) &#123; if (view != null) &#123; view.setSignAlign(align); &#125; &#125; &#125; &#125;&#125; view_water_mark.xml 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;com.commonlib.WaterMarkView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206import android.graphics.Color;import android.graphics.Paint; /** * @author Leon (wshk729@163.com) * @date 2018/8/24 * &lt;p&gt; */public class WaterMarkInfo &#123; private int mDegrees; private int mTextColor; private int mTextSize; private boolean mTextBold; private int mDx; private int mDy; private Paint.Align mAlign; private WaterMarkInfo(int degrees, int textColor, int textSize, boolean textBold, int dx, int dy, Paint.Align align) &#123; mDegrees = degrees; mTextColor = textColor; mTextSize = textSize; mTextBold = textBold; mDx = dx; mDy = dy; mAlign = align; &#125; public int getDegrees() &#123; return mDegrees; &#125; public int getTextColor() &#123; return mTextColor; &#125; public int getTextSize() &#123; return mTextSize; &#125; public int getDx() &#123; return mDx; &#125; public int getDy() &#123; return mDy; &#125; public Paint.Align getAlign() &#123; return mAlign; &#125; public int getAlignInt() &#123; switch (mAlign) &#123; case LEFT: return 0; case RIGHT: return 2; default: return 1; &#125; &#125; public boolean isTextBold() &#123; return mTextBold; &#125; void setDegrees(int degrees) &#123; mDegrees = degrees; &#125; void setTextColor(int textColor) &#123; mTextColor = textColor; &#125; void setTextSize(int textSize) &#123; mTextSize = textSize; &#125; void setTextBold(boolean textBold) &#123; mTextBold = textBold; &#125; void setDx(int dx) &#123; mDx = dx; &#125; void setDy(int dy) &#123; mDy = dy; &#125; void setAlign(Paint.Align align) &#123; this.mAlign = align; &#125; public static Builder create() &#123; return new Builder(); &#125; public static class Builder &#123; private int mDegrees; private int mTextColor; private int mTextSize; private boolean mTextBold; private int mDx; private int mDy; private Paint.Align mAlign; private Builder() &#123; mDegrees = -30; mTextColor = Color.parseColor(&quot;#33000000&quot;); mTextSize = 35; mTextBold = false; mDx = 100; mDy = 240; mAlign = Paint.Align.CENTER; &#125; /** * 设置水印文字倾斜度 * * @param degrees 文字倾斜度(默认:-30) * @return Builder */ public Builder setDegrees(int degrees) &#123; mDegrees = degrees; return this; &#125; /** * 设置水印文字颜色 * * @param textColor 文字颜色(默认:#33000000) * @return Builder */ public Builder setTextColor(int textColor) &#123; mTextColor = textColor; return this; &#125; /** * 设置水印文字大小（单位：px） * * @param textSize 文字大小(默认:42px) * @return Builder */ public Builder setTextSize(int textSize) &#123; mTextSize = textSize; return this; &#125; /** * 设置水印文字是否加粗 * * @param textBold 文字加粗(默认:false) * @return Builder */ public Builder setTextBold(boolean textBold) &#123; mTextBold = textBold; return this; &#125; /** * 设置水印文字X轴间距（单位：px） * * @param dx 文字X轴间距(默认:100px) * @return Builder */ public Builder setDx(int dx) &#123; mDx = dx; return this; &#125; /** * 设置水印文字Y轴间距（单位：px） * * @param dy 文字Y轴间距(默认:240px) * @return Builder */ public Builder setDy(int dy) &#123; mDy = dy; return this; &#125; /** * 设置水印文字对齐方式 * * @param align 对齐方式(默认:Center) * @return Builder */ public Builder setAlign(Paint.Align align) &#123; mAlign = align; return this; &#125; /** * 生成水印全局配置信息 * * @return 配置信息 */ public WaterMarkInfo generate() &#123; return new WaterMarkInfo(mDegrees, mTextColor, mTextSize, mTextBold, mDx, mDy, mAlign); &#125; &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import android.content.Context;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.ColorFilter;import android.graphics.Paint;import android.graphics.PixelFormat;import android.graphics.drawable.Drawable;import android.support.annotation.IntRange;import android.support.annotation.NonNull;import android.support.annotation.Nullable; import java.util.List; public class WaterMarkBg extends Drawable &#123; private Paint paint = new Paint(); private List&lt;String&gt; labels; private Context context; private int degress;//角度 private int fontSize;//字体大小 单位sp /** * 初始化构造 * @param context 上下文 * @param labels 水印文字列表 多行显示支持 * @param degress 水印角度 * @param fontSize 水印文字大小 */ public WaterMarkBg(Context context, List&lt;String&gt; labels, int degress, int fontSize) &#123; this.labels = labels; this.context = context; this.degress = degress; this.fontSize = fontSize; &#125; @Override public void draw(@NonNull Canvas canvas) &#123; int width = getBounds().right; int height = getBounds().bottom; canvas.drawColor(Color.parseColor(&quot;#40F3F5F9&quot;)); paint.setColor(Color.parseColor(&quot;#50AEAEAE&quot;)); paint.setAntiAlias(true); paint.setTextSize(sp2px(context,fontSize)); canvas.save(); canvas.rotate(degress); float textWidth = paint.measureText(labels.get(0)); int index = 0; for (int positionY = height / 10; positionY &lt;= height; positionY += height / 10+80) &#123; float fromX = -width + (index++ % 2) * textWidth; for (float positionX = fromX; positionX &lt; width; positionX += textWidth * 2) &#123; int spacing = 0;//间距 for(String label:labels)&#123; canvas.drawText(label, positionX, positionY+spacing, paint); spacing = spacing+50; &#125; &#125; &#125; canvas.restore(); &#125; @Override public void setAlpha(@IntRange(from = 0, to = 255) int alpha) &#123; &#125; @Override public void setColorFilter(@Nullable ColorFilter colorFilter) &#123; &#125; @Override public int getOpacity() &#123; return PixelFormat.UNKNOWN; &#125; public static int sp2px(Context context, float spValue) &#123; final float fontScale = context.getResources().getDisplayMetrics().scaledDensity; return (int) (spValue * fontScale + 0.5f); &#125;&#125; xml中 引用 1234567891011121314&lt;com.commonlib.WaterMarkView android:singleLine=&quot;false&quot; android:id=&quot;@+id/wm&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:water_mark_align=&quot;CENTER&quot; app:water_mark_degree=&quot;-30&quot; app:water_mark_dx=&quot;100px&quot; app:water_mark_dy=&quot;240px&quot; app:water_mark_sync=&quot;true&quot; app:water_mark_text=&quot;再见孙悟空&quot; app:water_mark_textBold=&quot;false&quot; app:water_mark_textColor=&quot;@color/black&quot; app:water_mark_textSize=&quot;30px&quot; /&gt; activity中 12345678910private WaterMarkView wm; wm = (WaterMarkView) findViewById(R.id.wm); private void water() &#123; SharedPreferences jobcede = getSharedPreferences(&quot;jobcede&quot;, MODE_PRIVATE); String userName = jobcede.getString(&quot;username&quot;, &quot;&quot;); String name = jobcede.getString(&quot;name&quot;, &quot;&quot;); wm.setText(name,userName);&#125; ————————————————版权声明：本文为CSDN博主「再见孙悟空_」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/shaoyezhangliwei/article/details/109849305","categories":[{"name":"UI","slug":"UI","permalink":"http://example.com/categories/UI/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}]},{"title":"Temp","slug":"Temp","date":"2022-03-04T00:54:24.000Z","updated":"2022-05-14T04:38:51.000Z","comments":true,"path":"2022/03/04/Temp/","link":"","permalink":"http://example.com/2022/03/04/Temp/","excerpt":"","text":"RecycleView设置滑动监听：mRecycleView.addOnScrollListener(new RecyclerView.OnScrollListener() {undefined @Override public void onScrollStateChanged(@NonNull RecyclerView recyclerView, int newState) {undefined super.onScrollStateChanged(recyclerView, newState); } @Override public void onScrolled(@NonNull RecyclerView recyclerView, int dx, int dy) &#123;undefined super.onScrolled(recyclerView, dx, dy); &#125; }); 判断滑动方向： @Override public void onScrolled(@NonNull RecyclerView recyclerView, int dx, int dy) {undefined if (dy &gt; 0) {&#x2F;&#x2F;下滑动作 } if (dy &lt; 0) &#123;//上滑动作 &#125; super.onScrolled(recyclerView, dx, dy); &#125; 判断是否滑动到顶部、底部：@Overridepublic void onScrollStateChanged(@NonNull RecyclerView recyclerView, int newState) { if(newState &#x3D;&#x3D; RecyclerView.SCROLL_STATE_IDLE){&#x2F;&#x2F;停止滑动 if(recyclerView.canScrollVertically(1)){ Toast.show(“滑动到顶部”); } if(recyclerView.canScrollVertically(-1)){ Toast.show(“滑动到底部”); } } super.onScrollStateChanged(recyclerView, newState);} recyclerView.canScrollVertically(1); false表示不能往上滑动，即代表到顶部了；recyclerView.canScrollVertically(-1); false表示不能往下滑动，即代表到底部了； controller 通过service 来操作数据的增删改查 service 通过 mapper接口来操作数据库 每一个mapper的实体接口类对应一个xml 中的mapper 中的sql的语句来具体的操作数据库 redis高速缓存用户信息 lsof -i :5088 create-react-app https://create-react-app.dev/docs/getting-started antdesign https://ant.design/docs/react/use-with-create-react-app-cn 3.9vscode下函数自动补全括号https://www.jianshu.com/p/676d1833db5e JavaScript 中 call()、apply()、bind() 的用法https://www.runoob.com/w3cnote/js-call-apply-bind.html JavaScript this 关键字https://www.runoob.com/js/js-this.html Linux find 命令https://www.runoob.com/linux/linux-comm-find.html 1. VMessVMess 协议是由 V2Ray 原创并使用于 V2Ray 的加密传输协议，如同 Shadowsocks 一样为了对抗墙的深度包检测而研发的。在 V2Ray 上客户端与服务器的通信主要是通过 VMess 协议通信。 本小节给出了 VMess 的配置文件，其实也就是服务器和客户端的基本配置文件，这是 V2Ray 能够运行的最简单的配置。 V2Ray 使用 inbound(传入) 和 outbound(传出) 的结构，这样的结构非常清晰地体现了数据包的流动方向，同时也使得 V2Ray 功能强大复杂的同时而不混乱，清晰明了。形象地说，我们可以把 V2Ray 当作一个盒子，这个盒子有入口和出口(即 inbound 和 outbound)，我们将数据包通过某个入口放进这个盒子里，然后这个盒子以某种机制（这个机制其实就是路由，后面会讲到）决定这个数据包从哪个出口吐出来。以这样的角度理解的话，V2Ray 做客户端，则 inbound 接收来自浏览器数据，由 outbound 发出去(通常是发到 V2Ray 服务器)；V2Ray 做服务器，则 inbound 接收来自 V2Ray 客户端的数据，由 outbound 发出去(通常是如 Google 等想要访问的目标网站)。 V2Ray高级技巧：流量伪装https://v2xtls.org/v2ray%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%EF%BC%9A%E6%B5%81%E9%87%8F%E4%BC%AA%E8%A3%85/ Android 动画之Lottie动画使用https://segmentfault.com/a/1190000039131272 Android矢量动画实践https://juejin.cn/post/6844903491652026375 矢量动画 svg 矢量图形 大前端训练营 模块一 函数式编程与JS异步编程，手写Promise 1.为什么说函数是一等公民？ 2.如何把一个函数赋值给变量？ 3.如何把一个函数赋值给另一个函数？ 注意：赋值的是函数定义而不是调用 4.什么是高阶函数？ 5.手写 数组 forEach 和 filter? 6.什么是函数式编程？有什么好处？ 7.什么是闭包？ 8.闭包的本质是什么？ 9.闭包的好处是什么？ 10.什么是纯函数？ 3.111.JSJS数组reduce()方法详解及高级技巧https://www.jianshu.com/p/e375ba1cfc47 大前端训练营 1.函数式编程规范 1.组合函数 2.lodash 中的组合函数 3.组合函数的原理及实现 4.组合函数的结合率 5.如何调试组合函数？ 6.lodash中的fp 2.kotlinKotlin中，函数作为参数，T.()-&gt;Unit 和 ()-&gt;Unit 的区别https://blog.csdn.net/weixin_33676492/article/details/92520157?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;utm_relevant_index=1 函数类型Kotlin 使用类似 (Int) -&gt; String 的一系列函数类型来处理函数的声明： val onClick: () -&gt; Unit = ……。 这些类型具有与函数签名相对应的特殊表示法，即它们的参数和返回值： 所有函数类型都有一个圆括号括起来的参数类型列表以及一个返回类型：(A, B) -&gt; C 表示接受类型分别为 A 与 B 两个参数并返回一个 C 类型值的函数类型。 参数类型列表可以为空，如 () -&gt; A。Unit 返回类型不可省略。 函数类型可以有一个额外的接收者类型，它在表示法中的点之前指定： 类型 A.(B) -&gt; C 表示可以在 A 的接收者对象上以一个 B 类型参数来调用并返回一个 C 类型值的函数。 带有接收者的函数字面值通常与这些类型一起使用。 3.121.JS1.变量声明提升 2.形参也是局部变量 3.作用域链 函数只有在调用的时候才会形成作用域，声明的时间不会形成作用域 数组的解构对应位置声明变量 只要第三个成员 剩余所有的都解构出来 小于长度，按顺序提取 大于长度，undifined 和设置默认值 应用 对象的解构 冲突 重命名解决 应用 模板字符串也用· 要转义 带标签的模板字符串 字符串拓展 参数默认值 剩余参数 展开数组参数 箭头函数 箭头函数与this 对象字面量 Object.assign 方法 Object.assign 是浅拷贝还是深拷贝？实现深拷贝的方法有哪些？https://juejin.cn/post/6844903895550918669 3.131.jsProxy 对象 Proxy和Object.defineProperty()的区别 deleteProperty 方法调用等也能监听到 defineProperty 只能监听属性的设置和访问 Reflect 避免使用各种乱七八糟的方法，而是把这些方法进行统一管理 PromiseClasses6以前 es6 静态方法 继承 super指的就是父类，可以调用父类的方法 Set Map 3.141.jsfor of 遍历 数组 遍历 Set 遍历 Map ES2015之对象计算属性值http://liunian.github.io/blog/es2015-computed-property-name/ JavaScript Node let const","categories":[],"tags":[]},{"title":"Jetpack系列—paging框架使用和原理(基于paging-runtime-2.1.0版本)","slug":"Jetpack系列—paging框架原理","date":"2022-02-24T20:23:47.000Z","updated":"2022-05-14T04:38:51.000Z","comments":true,"path":"2022/02/25/Jetpack系列—paging框架原理/","link":"","permalink":"http://example.com/2022/02/25/Jetpack%E7%B3%BB%E5%88%97%E2%80%94paging%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/","excerpt":"","text":"Jetpack系列—paging框架使用和原理(基于paging-runtime-2.1.0版本) 基于paging-runtime-2.1.0版本 先看下pageing的基本使用 1.构造一个pageData对象 1234567LiveData&lt;PagedList&lt;T&gt;&gt; pageData = new LivePagedListBuilder(factory, config) //加载初始化数据时需要传递的参数，首页就给传个0就行了，如果是多个参数，需要把多个参数组装成一个 javabean对象 .setInitialLoadKey(0) //.setFetchExecutor() //这个callback可以知道pagelist加载数据的状态，可以判定界面上有没有数据等异常的状态,看名字就知道，是边界情况回调，但 不是每一次分页 都会回调这里 .setBoundaryCallback(callback) .build(); 2.先看更新数据接收和更新的地方 12345//触发页面初始化数据加载的逻辑mViewModel.getPageData().observe(this, pagedList -&gt; submitList(pagedList));//监听分页时有无更多数据,以决定是否关闭上拉加载的动画mViewModel.getBoundaryPageData().observe(this, hasData -&gt; finishRefresh(hasData)); 本质通过这个pageData去observe进行数据的分发事件通知，进而刷新页面数据，本质上是使用了livedata的能力。 3.看具体构造pageData对象时还需要一个factory config callback这些都是什么 config 1234567891011PagedList.Config config = new PagedList.Config.Builder() //一页加载多少条数据 .setPageSize(10) //设置默认加载多少条数据 .setInitialLoadSizeHint(12) //知道列表一共多少条数据 //.setMaxSize(100) //还有多少条的时候的预加载，默认是pageSize 如果不想有这个功能，就让setInitialLoadSizeHint 大于pageSize //要不一开始它加载了10条，它马上就执行loadMore了 //.setPrefetchDistance(4) .build(); factory 12345678910DataSource.Factory factory = new DataSource.Factory() &#123; @NonNull @Override public DataSource create() &#123; if (dataSource == null || dataSource.isInvalid()) &#123; dataSource = createDataSource(); &#125; return dataSource; &#125;&#125;; callback 边界 123456789101112131415161718PagedList.BoundaryCallback&lt;T&gt; callback = new PagedList.BoundaryCallback&lt;T&gt;() &#123; @Override public void onZeroItemsLoaded() &#123; //新提交的PagedList中没有数据 boundaryPageData.postValue(false); &#125; @Override public void onItemAtFrontLoaded(@NonNull T itemAtFront) &#123; //新提交的PagedList中第一条数据被加载到列表上 boundaryPageData.postValue(true); &#125; @Override public void onItemAtEndLoaded(@NonNull T itemAtEnd) &#123; //新提交的PagedList中最后一条数据被加载到列表上 &#125;&#125;; 看到了吧，在第一次时没有数据，在onZeroItemsLoaded会发送一条boundaryPageData.postValue(false) 这也是livedata.postValue 所以触发第一次加载时页面更新，后续加载更多 那么具体的实现逻辑，看下原代码 基于paging-runtime-2.1.0版本 1234public LiveData&lt;PagedList&lt;Value&gt;&gt; build() &#123; return create(mInitialLoadKey, mConfig, mBoundaryCallback, mDataSourceFactory, ArchTaskExecutor.getMainThreadExecutor(), mFetchExecutor);&#125; mInitialLoadKey——第一次加载数据时的入参 mConfig——配置了maxsize pagesize PrefetchDistance 等等参数 mBoundaryCallback——数据加载边界的回调 mDataSourceFactory——提供数据源 ArchTaskExecutor.getMainThreadExecutor()——主线程 mFetchExecutor——异步线程 静态方法create 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private static &lt;Key, Value&gt; LiveData&lt;PagedList&lt;Value&gt;&gt; create( @Nullable final Key initialLoadKey, @NonNull final PagedList.Config config, @Nullable final PagedList.BoundaryCallback boundaryCallback, @NonNull final DataSource.Factory&lt;Key, Value&gt; dataSourceFactory, @NonNull final Executor notifyExecutor, @NonNull final Executor fetchExecutor) &#123; //实际上return的是ComputableLiveData.getLiveData return new ComputableLiveData&lt;PagedList&lt;Value&gt;&gt;(fetchExecutor) &#123; @Nullable private PagedList&lt;Value&gt; mList; @Nullable private DataSource&lt;Key, Value&gt; mDataSource; private final DataSource.InvalidatedCallback mCallback = new DataSource.InvalidatedCallback() &#123; @Override public void onInvalidated() &#123; invalidate(); &#125; &#125;; @SuppressWarnings(&quot;unchecked&quot;) // for casting getLastKey to Key @Override protected PagedList&lt;Value&gt; compute() &#123; @Nullable Key initializeKey = initialLoadKey; if (mList != null) &#123; initializeKey = (Key) mList.getLastKey(); &#125; do &#123; if (mDataSource != null) &#123; mDataSource.removeInvalidatedCallback(mCallback); &#125; mDataSource = dataSourceFactory.create(); mDataSource.addInvalidatedCallback(mCallback); mList = new PagedList.Builder&lt;&gt;(mDataSource, config) .setNotifyExecutor(notifyExecutor) .setFetchExecutor(fetchExecutor) .setBoundaryCallback(boundaryCallback) .setInitialKey(initializeKey) .build(); &#125; while (mList.isDetached()); return mList; &#125; &#125;.getLiveData();&#125; 看看ComputableLiveData里都做了啥 构造方法 1234567891011public ComputableLiveData(@NonNull Executor executor) &#123; mExecutor = executor; //new了livedata 并且复写了onActive方法 mLiveData = new LiveData&lt;T&gt;() &#123; @Override protected void onActive() &#123; //onActive方法执行时机？当且仅当第一个活跃的observer被注册到livedata里的时候就会触发activie mExecutor.execute(mRefreshRunnable); &#125; &#125;;&#125; 也就是说，只要用调用了pageData.observe(Observer) 就会立马触发 ComputableLiveData里的livedata的onActive的回调 看下mRefreshRunnable 里做了什么，刷新了数据 123456789101112131415161718192021222324252627final Runnable mRefreshRunnable = new Runnable() &#123; @WorkerThread @Override public void run() &#123; boolean computed; do &#123; computed = false; if (mComputing.compareAndSet(false, true)) &#123; // as long as it is invalid, keep computing. try &#123; T value = null; while (mInvalid.compareAndSet(true, false)) &#123; computed = true; value = compute(); &#125; if (computed) &#123; mLiveData.postValue(value); &#125; &#125; finally &#123; // release compute lock mComputing.set(false); &#125; &#125; &#125; while (computed &amp;&amp; mInvalid.get()); &#125;&#125;; 1protected abstract T compute(); 是一个抽象，具体实现在ComputeLiveData的匿名实现里 12345678910111213141516171819protected PagedList&lt;Value&gt; compute() &#123; Key initializeKey = initialLoadKey; if (this.mList != null) &#123; initializeKey = this.mList.getLastKey(); &#125; do &#123; if (this.mDataSource != null) &#123; this.mDataSource.removeInvalidatedCallback(this.mCallback); &#125; //通过create方法，生成了一个datasource对象 是一个抽象方法，由用户在上层实现 this.mDataSource = dataSourceFactory.create(); this.mDataSource.addInvalidatedCallback(this.mCallback); this.mList = (new androidx.paging.PagedList.Builder(this.mDataSource, config)).setNotifyExecutor(notifyExecutor).setFetchExecutor(fetchExecutor).setBoundaryCallback(boundaryCallback).setInitialKey(initializeKey).build(); &#125; while(this.mList.isDetached()); return this.mList;&#125; 由用户在上层实现 1public abstract DataSource&lt;Key, Value&gt; create(); 我们在viewmodel中的实现 12345678910DataSource.Factory factory = new DataSource.Factory() &#123; @NonNull @Override public DataSource create() &#123; if (dataSource == null || dataSource.isInvalid()) &#123; dataSource = createDataSource(); &#125; return dataSource; &#125;&#125;; 进而由每个具体的viewmodel中的new的datasource对象 12345678910111213141516171819202122232425262728class FeedDataSource extends ItemKeyedDataSource&lt;Integer, Feed&gt; &#123; @Override public void loadInitial(@NonNull LoadInitialParams&lt;Integer&gt; params, @NonNull LoadInitialCallback&lt;Feed&gt; callback) &#123; //加载初始化数据的 Log.e(&quot;homeviewmodel&quot;, &quot;loadInitial: &quot;); loadData(0, params.requestedLoadSize, callback); witchCache = false; &#125; @Override public void loadAfter(@NonNull LoadParams&lt;Integer&gt; params, @NonNull LoadCallback&lt;Feed&gt; callback) &#123; //向后加载分页数据的 Log.e(&quot;homeviewmodel&quot;, &quot;loadAfter: &quot;); loadData(params.key, params.requestedLoadSize, callback); &#125; @Override public void loadBefore(@NonNull LoadParams&lt;Integer&gt; params, @NonNull LoadCallback&lt;Feed&gt; callback) &#123; callback.onResult(Collections.emptyList()); //能够向前加载数据的 &#125; @NonNull @Override public Integer getKey(@NonNull Feed item) &#123; return item.id; &#125;&#125; 接着往下看 1this.mDataSource.addInvalidatedCallback(this.mCallback); 为什么要给datasource注册一个callback呢？先往下看，这个callback干了什么 12345678public void invalidate() &#123; //通过原子的方式，把mInvalide标志位设为true if (mInvalid.compareAndSet(false, true)) &#123; for (InvalidatedCallback callback : mOnInvalidatedCallbacks) &#123; callback.onInvalidated(); &#125; &#125;&#125; 这就会走到 12345private final InvalidatedCallback mCallback = new InvalidatedCallback() &#123; public void onInvalidated() &#123; invalidate(); &#125;&#125;; 走到 ComputableLivedata.invalidate() 123public void invalidate() &#123; ArchTaskExecutor.getInstance().executeOnMainThread(mInvalidationRunnable);&#125; 123456789101112final Runnable mInvalidationRunnable = new Runnable() &#123; @MainThread @Override public void run() &#123; boolean isActive = mLiveData.hasActiveObservers(); if (mInvalid.compareAndSet(false, true)) &#123; if (isActive) &#123; mExecutor.execute(mRefreshRunnable); &#125; &#125; &#125;&#125;; 这个mRefreshRunnable同样在onActive方法中被执行过 如何通过下拉刷新去触发 执行mRefreshRunnable呢？ 上层执行 1mViewModel.getDataSource().invalidate(); 就会再次触发我们创建的ComputableLiveData中的mCallback中的onInvalidated方法进而实现invalidate的调用，并执行里面的mRefreshRunnable去刷新数据，所以 我们第一次创建时会刷新一次，后面就可以通这个注册的callback 上层调用 去主动刷新数据 再看mRefreshRunnable的后面 1234567891011121314151617181920212223242526272829final Runnable mRefreshRunnable = new Runnable() &#123; @WorkerThread @Override public void run() &#123; boolean computed; do &#123; computed = false; // compute can happen only in 1 thread but no reason to lock others. if (mComputing.compareAndSet(false, true)) &#123; // as long as it is invalid, keep computing. try &#123; T value = null; while (mInvalid.compareAndSet(true, false)) &#123; computed = true; //拿到value pagedlist value = compute(); &#125; if (computed) &#123; //通过livedata发送pagelist分发数据，这样注册的地方就可以接收到数据了 mLiveData.postValue(value); &#125; &#125; finally &#123; // release compute lock mComputing.set(false); &#125; &#125; &#125; while (computed &amp;&amp; mInvalid.get()); &#125;&#125;;","categories":[{"name":"Jetpack系列","slug":"Jetpack系列","permalink":"http://example.com/categories/Jetpack%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"},{"name":"Jetpack","slug":"Jetpack","permalink":"http://example.com/tags/Jetpack/"}]},{"title":"Socket网络编程-UDP","slug":"Socket网络编程-UDP","date":"2022-02-22T20:02:51.000Z","updated":"2022-05-14T04:38:51.000Z","comments":true,"path":"2022/02/23/Socket网络编程-UDP/","link":"","permalink":"http://example.com/2022/02/23/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-UDP/","excerpt":"socket网络编程系列之二","text":"socket网络编程系列之二 Socket网络编程-UDP1.UPD是什么那么前面一个章节呢咱们算是过得轻松又愉快，因为前面一个章节是一个基础的章节，那本章节呢其实也是一个基础章节，本章节名字叫做socket - u d p快速入门。那么在本章节当中呢最主要的收获是 第一，带领大家明白u d p是什么。二、udp的主要作用是什么？三、udp的简要用法及其api的学习。第四、就是理解网络当中的单播、广播以及多播的概念。 当然了，关于api的学习以及广播、多播的概念和运算，那么这是重点，也是本章节需要掌握的重点知识点。好的，废话不多说，我们进入到第一个章节，udp是什么？udp的英文单词是user datagram Protocol，缩写为udp。那么udp是一种用户数据报协议，又称为用户数据报文协议。它是一种基于报文的协议，而不是面向链接的一种协议，它与tcp不同。tcp是基于链接的协议，而udp是基于一种用户数据报的协议，它是一个简单的面向数据报的传输层的协议，正式的规范为rfc 768。那么这个文件呢我们不做细究。好了，我们继续往下看，它是一个用户数据协议，非连接协议，这是重点，它不是连接协议。udp的发起和接收是不需要进通过连接，仅仅只需要直接发送以及你在对应端口上进行监听接收即可，它不需要两个客户端一定是连接的。 常常我们会说tcp和udp最大的区别是什么？tcp是面向连接的，然后tcp是传输可靠的，而udp是面向数据报的，那么他们两个是不一样的，从而也导致了udp在大家的认知当中是不可靠的。那我们来说一下它为什么不可靠。第一点，它一旦把应用程序给到应用层的数据发送出去之后，就不进行保留数据备份是什么意思呢？就是说在udp的数据层面，他只管发送或者是接收数据，而不对这个数据进行保存、备份、重发等等。ud p在ip数据报的头部，仅仅加入了复用和数据校验的字段. 那么在后面呢我们会给大家讲解一下它具体加了一些什么样的东西。在发送端是产生数据，而在接收端从网络当中去抓取数据，所以说它们两者是不需要进行连接的。 但是也正因为它不是一个连接的协议，它是靠客户端发送协议，服务器端从网络当中去抓取协议，它抓取的时间以及你发送的时机如果说不相同，那么可能会导致客户端发送的数据服务器端没有接收到。 在udp当中其实是没有标准的客户端与服务器端的。 udp结构简单、没有校验速度快、容易丢包。但是呢它有一个优点可以广播，那么广播呢也是我们后面讲解的一个重点。 好的，我们来看一下udp它的主要职能是什么，udp能够做些什么这样的事情。那么第一点是可以作为dns、tftp、snmp当然说一下最后一点，s n m p就是我们之前说的一个网络数据协议传输当中的一个监控的一个协议。t f t p呢跟f t p差不了太多，其实也就是用一种文件传输的协议dns，这是非常常见的一个东西。在咱们访问一个网站防百度、访问谷歌的时候，其实要进行的第一步操作就是dns解析。那么dns解析呢其实实则就是用的udp来完成的的相关功能。那么还可以做什么事情呢可以用于视频、音频的传输以及普通的数据。那么这个普通数据呢要求的是无关紧要的数据，因为咱们前面也说了，udp是不保证传输的可靠性的，udp存在一定的丢包，以及可能存在udp的数据混乱的一个问题。那么所以这里的普通数据一定要是一个无关紧要的数据。那么音频然后视频呢这个就不多说了，因为音频和视频本身就比较大。当然了，音频和视频一般而言是用于咱们的一个实际的直播，或者是用于一个我们家里面的有线电视之类的，那么就是用于udp进行传输。 而如果说你要下载一个视频或者是一个音频文件，这个时候还用udp吗？肯定不是，他使用的tcp，因为这是一个文件传输，也要保证它的可靠性，所以说这个时候是使用的tcp。 好的，我们这个来看一下咱们的这个udp的前面的一个报文头，他做了些什么样的事情，也就是咱们的一个数据协议前面udp加了什么东西。 然后我们首先看一下它一共有多少个位一共有64位对不对？64位怎么看前面的第一行是32位，第二行32位加在一起也就是64位。因为四位呢我们来看一下前面的这一个部分，也就是0到15的这个部分，它一共是多少是16位。16位呢的话它存储的是什么存储的是发送源的ip地址，那么后面的16位来存储的是咱们的一个接收者的，也就是目标的一个端口号，对不对？而前面呢16位存储的是我们发送的端口号，对吧？紧跟着后面的16位存储的是什么是一个字节长度，对不对存储的是一个字节长度，以及再到后面这个位置，是咱们的一个头部以及数据的一个校验字段，所以说都在这里了都在这里，它一共是16位。那么加在一起呢也就是64位。好了，这里呢我们需要进行一定的细化，给大家讲解一些从图上面不能直接看出的一些东西。首先我们看第一点，端口号的保存。前面分别用了32位保存端口号，那么这里呢其实有一个点需要说明的是，第一个0到15是多少？是16位，16位的话它其实是多少个字节是2个字节对不对？两个字节其实就是一个短整型。那么紧接着我们往后面看一点，这前面的端口用短整型来存储，这是够的，对吧？因为咱们端口是多少0到65535，对不对？好的。往后面看一下，紧跟着的它的存储的，咱们传输的这个后面的数据的长度是多少数据的长度是放在这16个位当中，而这16个位呢也是相当关于一个短整型，也就是一个短整型的一个长度，用来存储我们的后面的数据部分的长度，对不对用一个短点型存储。那么后面是一个校验的教研的部分呢，我们就不多说，我们来说一下，我们发送一个udp究竟能够带多大的数据出去它究竟能够发多大的包一次udp最多能够发多长的数据出去？一个udp包最大的长度是多少呢？首先我们来看一下，16位，也就是2个字节，也就是咱们说的一个短整型存储的长度信息对吧存储长度信息，那么它的二了16位减去一也就是等于64k减去一也就等于65536减1其实也就等于65535个字节长度。那么是不是我们就可以发六五三五个字节长度呢？其实不是，因为咱们前面的头部还占用了一部分的信息。头部。诶我们说我们前面的头部有多少，未来的64个位，对吧？自身协议其实是占用了多少64位是多少啊？32加32位等于64位，其实也就等于咱们的8字节对吧八字节的长度，65535减去八个字，也就等于六五零七个字节。所以说咱们最多发送的数据长度是六五五零七，这个点一定要记住。 当你要发送的数据长度大于六五零七的时候，一定要记住自己要进行一次分包然后交给udp进行传输，udp最大的传输一次包的一个大小最多是六五零七个字节长度。好的，当本章节的内容就到此结束，那么下一个章节呢会给大家讲解一下咱们u d p的核心api信息。请大家。 2.UDP核心API咱们接着往下讲，那么我们在本小节来讲解一下u d p 的一些核心a p i 讲解为什么要有这个章节呢？主要是因为为了咱们后面写代码的时候，不至于让大家一下就懵逼了。所以说我们专门有一个小节讲解一下核心的a p i 信息。当然了，这个章节是一个比较小的章节，因为毕竟不是跳代码，所以说咱们只是在p p t 当中过一遍咱们的a p i 即可。好的，我们进入到课程内容。首先咱们来看一下a p i 当中的第一个类datagramsocket。 这个呢是用于接收与发送u d p 的一个类。这个类是咱们u d p 当中最重要的一个类，它的主要作用与职责是用于接收和发送u d p 信息的一个类。所有的u d p 信息，可以说都是经过disagrees socket 发送出去以及接收u d p 的一个包的协议。也是通过data grasp 的接收到了。负责发送某一个udp 包或者接收一个ud p 包不同于t c p, u d p 的协议，并没有被合并到socket a p i 当中。因为在咱们的t c p 当中，我们的t c p 的操作其实是有合并到咱们的一个socket 协议当中去。咱们的开头就是某某什么什么socket。那么我们有一个socket 的一个服务器，以及有一个socket 的一个客户端的存在。 但是在咱们的u d p 当中是没有服务器与客户端的概念。你的datagramsocket既是你的服务器，也是你的客户端，他可以发送，也可以接受。他不需要去监听某一个客户端，因为他不涉及客户端跟他的连接，所以说他不像t c p 一样，需要先去监听一个t c p 的一个来源，然后连接t c p，然后再进行通讯。这里面相当于其实就是直接两个服务器之间的参数了。或者说你可以理解为就是两个客户端之间的传输，它没有服务器端，也没有客户端，它既是服务器也是客户端。接着往下说一下datagramsocket就是它的构造函数用于创建一个简单的实例。这个实例当中没有传递任何参数，所以说它不指定端口 i p。如果说这个时候你用这个datagramsocket进行发送，那么它会自动复用你本地的可用的一个端口进行发送数据。当然了，i p 就是你自己本机的i p 了，datagramsocket(int port) 指定端口，那么就是创建一个监听固定端口的一个实例。这是用于监听某一个端口的实例，就是说你的数据来源可以通过这个端口进行收到信息。但是你的发送并不是这里指定的这个端口。假如说你想要通过datagramsocket 发送一个数据包出去，你就算在这里指定了两千的端口。那么你想把一个数据发送出去的时候，是发送到哪呢？是发送到这个两千吗？其实并不是你并不是发送到这里指定的那个port 这个端口上面。这个port 端口其实只是指你接收数据的端口。datagramsocket(int port,inetaddress localaddr)这个时候是一个两个构造参数的一个构造函数。那么它创建的是一个固定端口以及指定i p 的一个实例。当你的计算机本地有多个i p 地址的时候，那么这个时候有效你可以指定只监听你的绝网的某一个端口，或者是你想监听你的一个互联网的一个i p 地址的一个端口。因为你的电脑可能具备多个i p 地址，因为你可能处于某一个子网。同时你的电脑下面还有一个子网。那么这个时候你其实是有两个机器以上的i p 地址存在的。接着往下说。我们调用datagramsocket.receive(DatagramPacket d) 的时候。这个时候就是你接收一个什么，接收一个DatagramPacket 这就是一个咱们u d p 报文的一个封装类。他完成了工作呢，咱们后面再讲解发送也是一样，就是DatagramPacket 传输进去的也就是一个DatagramPacket 。可以看到这里我们发送和接收其实都是传入的一个DatagramPacket 这样的一个实例。这个实例既可以用于接收，也可以用发送数据。那么我们看一下一些设置项did so turn out。那么设置一个超时时间，这是用于咱们进行传输或者是监听的时候的一个超时时间。当然还有一个最重要的就是close 关闭以及释放资源。好了，我们来看一下前面所说的describe packet disagreement。packet 是一个用于处理报文。 同时将byte数组目标地址、目标的端口等数据包封装成报文，或者将报文拆成byte数组的一个封装类。 它的这个类主要作用是什么呢？就是将咱们的这个byte数组，byte数组是什么？就是咱们要传输的内容，这个数字的长度是多少？我们之前前面有讲过65507，那么这个东西呢就是我们要传输的实际的一个数据，将这个数据以及咱们目标的一个端口地址。其实这个地方没有目标地址，这个目标地址虽然我们可以指定一个目标地址，但是呢它其实是用于发送当中的一个传输协议去做的。而实际的咱们的一个报文呢是没有目标地址的。那么其实相当于就是将byte 数组以及目标端口混装成咱们的报文，或者是将报文反向拆解成为一个bad 数据，以及咱们的一个目标端口。但目标地址就是属于咱们传输当中的一个另外的一个。i p 层面的一个传输地址的协议。data ground package 是u d p 的一个发送实体，也是接收实体。 我们来看一下它的一些构造函数，这是ground packet。这里呢是传递进去的一个bad 数组，以及一个bad 数组可用的一个区间的指定。这两个参数就是用于指定咱disagree packet 里面的这个buffer 这个内容，它具体的可用区间。那么后面那两个参数是用于指定咱们的接收者的一个地址信息。前三个参数指定的是buffer 以及buffer 的一个使用。后面两个参数主要指定是目标机器地址与端口。那么这个目标机器地址与端口仅仅用于发送时有效。那么在咱们发送一个数据的时候，是通过data grand package 这个东西来指定你具体的接收者的一个信息。他的信息是什么？是通过这些grand packet 来进行设置它接收的信息。我们想要接收别人发过来的信息，那么我们要用的是这是grand socket，也是我们前面用的这是grand socket 去进行一个监听，这也是这个grand packet 的一个各自函数。前面三个不用多说是一样的。那么后面传递的是一个socket address。其实socket address 其实就相当于electorates 加quite electorates，其实就是一个什么呀目标主机的地址，再加上一个端口，socket 其实相对两者的一个封装，以及它的一些协议的封装。那么我们来看一下data ground package 的一些使用方面的一些信息。那么首先第一点shed data。那么我们可以在构造函数创建的时候传入一个吧。同理，我们也可以在构造函数中不传递任何东西。我们传递无参构造函数，然后在后面的过程，我们set data 用于替换一个buffer 音律。buffer 呢可以传递一个buffer 进去，也就是一个bad 数组。然后同时指定这个bad 数组当中的一个长度信息。我们究竟哪部分数据是有效的？那我们可以在这里指定，当然你也可以不指定信息。那么自然也就是从零开始到你整个buffer 结束，就用于单独设置你这个buffer 留下的区间有多长啊？get data, get off, fit, get lunch. 那么这三个方法呢就是前面它的三个信息的一个返回。紧接着我们往下看一下一些设置的信息，sit to s 当然这里也是一样，就是设置目标的地址端口以及目标地址的一个i p 地址信息。get 呢也是一样，get address, get pot 是一样的。后面就是set scott dress 前面我们说了scottish 其实就相当于我们前面的i like dress 和pot 的一个封装。当然了get socket dress 其实也是一样的道理。那么这里我再次重申一下咱们data grand package 这个当中设置的这个目标地址以及端口，其实是用于发送时有效。在我们接收的时候其实是无效的。你指定的端口或者是目标地址其实是无效的。只有仅仅用于你要把一个describe packet 这个信息发送出去的时候，那么这个是有效的。而你接受的时候，这些东西有什么作用呢？这个在你接触的时候，其实这个操作是由系统帮你完成的。当你接收到一个数据报的时候，相当于是他会把报文解析之后给你set 这个信息，以及set 了你的这个八份信息。那么你就可以拿到你接收到的发送过来的就是说你是。你的电脑我的电脑给你发的信息，那么你就可以收到我的电脑的i p 以及我的电脑的端口。那么你就能知道那这个data grandpa 是从哪个电脑的哪个端口传输过来的。那么我想要监听别人发送过来数据肯定要有一个端口。这个端口呢就是在咱们的data grass socket 当中指定的。那么本章节讲解了两个，最主要的类也就是data ground socket 和data ground packet 两个。适用于咱们u d p 传输当中的一个主要的a p i。我们主要的a p i 讲解。最后啊我们下一个章节讲解一下咱们的一个广播以及多播的概念。好的，谢谢大家。 3.UDP单播、广播、多播我们前面呢进行了一些基础的一些信息的一些讲解，以及咱们a p i的一个讲解。这个章节呢给大家讲解一下咱们u d p当中的一个单播、多播以及广播三个概念是什么呢？要给大家讲解一下。这也是u d p最区别于tcp的一个地方，就是单播、多播或者是广播。然后首先第一点，单播。咱们的单播究竟是什么东西呢？就是点对点。假如我的电脑和你的电脑之间发生数据，你的电脑也和我的电脑之间回送数据，我们两个数据不被其他人的电脑所感知，那么这就称之为单播。 顾名思义，假如你在公司，你的老板单独来说，我想要找编号为89757的这个人，叫他来我来办公室一趟，那么这个时候编号89757一定是一个指定的人，一定是一个固定的人，那么这个时候就是一个单播，那么就直接找到你对吧？你就是89757。那么找到一。就是你所以说这就是单播用于单线，两者之间与其他人无关，那么这就是单播的一个概念。要来说一下第二点，多播。 多多是什么意思啊就是说我们从这个图当中可以看得出，红色的点是咱们的一个发送者，对吧？接受的是什么接受者有黄点和咱们的一个绿点，而绿点呢三个都是绿点黄点三个都是黄点。多播是什么意思啊？其实多播它并不叫多播，其实应该叫做组播，它是给一组设备发送。这个当中其实就分为了两个组，一个组呢是咱们的一个绿色组成的一个组，还有一个组呢是咱们的这个黄色组成的组。那么我现在发出来就是给所有绿色的这些设备发送信息，那么黄色的设备自然它无法接收到这个信息，这就称之为多播，或者是叫做组播，组播更为恰当一点。因为它不是说你给多个人发的意思，它其实是给一个组发的一个意思。那么这个东西也很好理解，在你在街上你直接说一下，所有的男生请过来。那么这时候男生和女生是不一样的，男生是一个组，女生以及其他位置性别的一些人，那么就是无关的，对吧？那么你要的其实就是是一部分男性的东西，你要给他们传输什么、说什么，这是你的信息，你要做的事情与其他人无关，他们也不会收到这样的信息，这就称之为多播。 那么最后一点也就是咱们的广播，广播是什么意思？ 就是给所有的设备都发送信息，那么这就称之为广播。就是一个局域网内的所谓设备，或者是你给你局域网以外的设备发送一个广播。那么这里要说的，咱们的广播一定比多播更强嘛？其实不是的，其实最先出来的概念是单播，然后是广播。这也是为什么咱们的title叫做单播广播，最后才是多播。其实多播是后面出来的概念，而多播这个概念它其实涵盖了单播与广播的优点。广播是什么意思？广播就是你在它广场上拿着一个喇叭直接吼了一句，那么所有的人，无论男女老少，全部都能收到你的这个信息对吧？那么至于究竟有哪些人真正有用，那这就是无干的了。就比如你在广场上直接拿着广播，吼了一句，所有的年轻人请过来一下。那么这个时候虽然说你要的是年轻人，但是你在广场上直接用喇叭去吼的，那么所有的年轻人、老年人或者是小孩、或者是男生、女生都能收到你的信息。而之所以只有这部分年轻人过来了，是因为其他设备认为这个信息与我无关，所以说他就选择了不处理。那么这就是广播，广播就是说你对你所在的。网段之内的所有设备直接发送一条信息，究竟这个网段之内哪些设备对你这个信息感兴趣，那么就是对你的设备应该要做的事情的一个处理了。那么当然这会找到造成的问题，就是如果说一旦某一个设备或者是某一批设备一直发送广播的话，会导致咱们的一个局域网或者是某一个网络段之类的一些信息带宽被占满，也就导致了咱们的一个信息的一个混乱。所以说咱们现在的路由器都具备一个拒绝发送广播的一个策略。当你的广播发送出去之后，一般而言仅仅只能够在你的路由器内部进行广播，而不能在你路由器以外的地方去广播。我现在在我家里面我发一个广播，你家里面的电脑能收到吗？肯定不能啊，这就是因为我的广播发送之后，在我家的路由器上面已经被拦截了，仅仅只在咱们家里面的这个路由器下面的这。设备之间进行广播，而路由器以外的设备是无法感知的。而多播的优势是什么呢？ 它能够直接给指定的设备发送这些信息。那同理，我们举的广场上吼喇叭的这个例子来说，我们之前说的是我们直接去吼喇叭，这个时候呢我们换一种东西。我看见下面有男生、有女生、有年轻人对吧，我这时候直接过去，我把所有的男性全部挑出来，挑出来之后我直接对这一部分男性说，这个时候是什么呢？我虽然也是直接对一批人说，但是我提前会进行一步什么筛选，我能够提取出我真正有用的这一部分的设备，然后我再对这一部分设备进行发送信息。那么这个时候呢我这一批设备一定是对这个东西感兴趣。我对来信的这部分人说，我给你们介绍一个找女朋友的机会对吧，那么这个事就是我对他们说的心，他们都是感兴趣的。这就是多播与广播之间的区别，多播他一定是能够先进行一定的分组以及筛选之后我直接对这一部分数据发送数据。它的优势是比广播更好，性能也更优越，但是它相对实现起来要复杂一点。当然多播其实有专门的多播的一个地址广播有广播的地址，而我们常用的其实这个广播。所以说咱们后面有个例子呢其实也是用的一个广播。多播呢大家可以了解一下，在今后的一些实现当中呢，自己去实现一下咱们的一个多播，其实多播比广播更优越。当然单播其实这个东西你只是说点对点之间是非常优越的。如果说你想要一次性对六个人发消息，那么你采用点对点的话，你需要给六个目标地址重复发，那么这是你需要发六次。而多么和广播呢其实你只需要发一次，你并不是说你给这些人发了这么多次，你仅仅只需要发一次。至于他们怎么收到这个信息，是由路由器来负责转播的那么。这个操作过程当中不需要你进行操作，所以说你电脑的s带宽以及你电脑cpu的性能消耗是非常低的。前面说了单播广播以及咱们的多播。那么来说一下，具体这几者之间的区别是什么呢？这就涉及到ip地址一个类别的一个选择了。 这是一个abc de五个网络ip地址的一个类别的一个图，a类地址呢也就是咱们最外围的一部分的地址。那么这部分点前面我们说过，已经被分配完成了，对吧？啊b类以及咱们的c类，其实我们常规使用的家庭里面的这部分设备都是属于c类的。我们的子网源码一般而言都是二五五点二五点零。其实我们可以看得出，指往年嘛，abc分别是前面每到后面就多了一个二五，对吧？那么到我们的cn的时候，其实二五五后面是点名，然后我们的ip地址一般而言是幺九。二点幺六八点多少多少，对吧？所以说这就是幺九二到二二三之间，这就是属于咱们c类的一个地址。第一类呢是从二二四到二三九之间的一个基准。这个地址呢是专门为多播预留的，所以说多播之所以比广播更优越，也是因为多播它是专门有一部分地址用于多播的，这部分地址是一份预留的地址，这是能够被所有的路由器所感知的，所以多播其实是更为优越的。那么一类地址呢是实验性的，用于研究的，那么这部分地址我们不做考究。 来说一下我们怎么样去得到一个广播地址。首先我们看一下二五，五点二五点二五，四个二五其实是一个受限的广播地址。假如你往这个二五五点二五点二五这下面的两千端口号发送一个信息，其实只有你的局域网内的设备能够收到你发送这个信息。至于他究竟对这个信息感不感兴趣，就看他对没对两千的这个端口进行监听。那么c网的一个广播地址一般而言是前面三位当然是不固定的，那当然了第一位是固定的幺九二对吧，第一位是咱们的幺九二到二二三，至于后面两个呢是不固定的。咱们后面的一个就是二五五，这是咱们的一个非网的一个广播地址。一般而言就是幺九二点幺六、八点幺点二五五。如果说你想要为你家里面的路由器下面的所有设备发送一个广播呢，两个办法。一个呢是发送全二五五的一个授权广播地址，或者是直接发送幺九二点幺六、八点幺点二五，这就是给你下面的设备发送一个广播。当你除了给c网，还可以给b网的一个子网段下面的设备发送一个广播，那么这就涉及到你不同的广播地址的运算了。一般而言，咱们的广播地址就是最后一位为二五五。第一类的ip地址为多报预留，这是我们前面讲过的。来看一下咱们的一个寻常的一个网络信息。这是我的电脑的一个信息。 可以看出我的电脑的一个信息是ipv四地址对吧，幺九二点幺六、八点幺二、四点七，这是我的ip地址。那么我的路由器的地址是多少呢？幺九二点幺六、八点幺二四点幺，对吧。我的指望颜码是二五五点二五点二五五点零，这是我的指望野马。而指望野马呢一般。而言，最后一位是您，但是您并不是百分百的。我们前面的三位是固定的二五五点二五点二五，那么后面一位并不一定就是零，前面三位都是二五，就是c网地址。那么最后一个呢取决于咱们的一个路由器的一个分配策略。我们后面来看一下ip地址的一个构成。 这是一个ip地址，幺九二点幺六八点一百点一，我们把它分为四个部分，其实四个部分加在一起，每一个部分呢是一个int，对吧？其实呢正方我们用的不是一个硬的去存储这个值，这一个整体呢是用了一个什么短点型去存储的，这是一个八位这也是一个八位。其实这个东西用一个bat这一个bad case，一共就是四个比特，四个字节去惩处它。那么其实四个字节就是int，指咱们的一个ip地址，用一个int值全部就可以完成。就是有人说。明明这里是四个int对吧？那么这里要说的是这个地方的四个input，它最大数是多少是零到多少，零到二五或者是负的幺二七到幺二八之间，对不对？那么这是咱们的一个范围。那么这个范围呢其实并不是占用了一个全部的int的值范围，我们把它进行一定的概括之后的话，在下面可以看得出其实是八位八位加八位，其实这一共就是高八位以及低八位的一个过程嘛对吧？我们把四个八位加在一起其实就是三十二位，三十二位其实就相当于一个intent值，我们把这一个东西全部加在一起，其实可以直接构成一个intent值。那么来看一下幺九二，其实就是幺幺后面六个零对吧，这个地方比较重要。幺九二前面两位是幺幺，后面几位是零。而最后一个点幺的话那么就是最后一个为零，这个东西呢涉及到一个二进制的一个转换，那么这个点大家记一下就好。来看一下我们一个广播地址的一个运算。广播地其实是可以运算出来的，而不是固定的。来看一下我们的ip地址，就拿我的电脑来说，幺九二点幺六、八点幺二、四点七对吧，就是我的电脑的ip地址。而我的磁网源码是多少呢？是二五五点二五点二、五点零。二五五相当于什么二五五相当于我们前面刚刚说的那个地方是多少三十二位对吧三十二位当中分为八位八位八位八位的对吧分别是四个八位，那么二五五就相当于八位全部为一零就相当于八位全部为零对吧，所以前面就是八位全部唯一八位后面全部为零。那么我的网络地址是多少呢？我的网络地址其实相当于就是把一和上面的这个东西进行一个以后运算，那么最后得到的就是幺九二点幺六、八点幺二、四点零，因为我最后一位是零，那么您与前面的每一个运算中其实就是一个零。那么我的广播地址是多少呢？前面的。个网段的最后一位就是我的广播地址我前面网络地址，这个网段磁网源码是二五五点二五点零。那么我具备的设备是多少多少位？我基本的设备是二百五十五个设备我允许分配二百五十五个ip地址，那么我的第一个ip地址是我的网络地址，最后一个ip地址是我的广播地址。这个问题就比较简单，你把你的指纹源码和你ip的进行一个有效运算，然后最终会得到你的网络地址，而网络地址得到之后同时再去看最后一位，最后一位如果是零，您的话代表着我的八个比特全部都是，八个比的全部都是零的情况下，我允许分配二百五十五个ip地址，那么我的第一个零就代表我的网络地址，我的最后一位二五五就代表我的广播地址。那么是不是所有的推广的广播地址后面都是点二五五的？错的。那继续往下看一下，这里也是一个网络列表。也是我的本级地理幺九二点幺六、八点幺二、四点七。假如我的指网点码是二五五点二五五点二五点幺九二呢，那么这时候我的网络地址是多少？一样的，网上面以后运算掉我的值是一样的，依然是幺九二点幺六、八点幺二、四点零。而我的广播地址是多少？广播地址其实后面并不是点二五五了，为什么呢？因为在这里有多少个一就代表着我有多少个网段地址，那么网的地址怎么运算呢？其实我们说了，它其实是八个位，八个位的话前面两位为幺幺，后面是零零。那么幺幺就带有两个对吧？我们按照二进制来算，二的两次方其实就是四我可以分为四个段。而我的幺幺九、二点幺六、八点幺二、四点七是处于咱们的第一个段当中，所以说我的ip地址是属于我的第一个段的最后一个ip。那么我第一个段的最后一个id就是幺九二点幺六。八点幺二、四点六三。我们需要往后面再给大家看一下。怎么算的呢？二五五点二五点二五点幺九二，其实它相当于就是三十二个比特，对吧？前面都是幺幺幺，最后一个把握的前面是幺幺，后面是六个零。那么我允许划分的网段是二的多少次方呢？两个幺二的二次方，也就是四个网段。分别是哪四个网段？分别是最后一位为零到六十三，六十四到一百二十七、一百二十八到一百九十一，一百九十二到二五五。而我前面一台我自己的设备是属于幺九二点幺六、八点幺二、四点七，对吧？那么七是属于第一个网站。第一个我的我的一个保留地址是多少？幺九二点幺六八点幺二、四点零，那我的广播地址是最后一位，也就是幺九二点幺六八点幺二、四点六三，这也就是。我的广播地址，所以说广播地址最后一位不一定是二五五。同理，我们来说一下广播通讯的一个问题。我们来说一下两台主机之间是否允许广播直接通讯。第一个主机幺九二点幺六，八点幺二四点七，它的主板源码是二五五点二五点二、五点幺九二。第二台主机幺九二点幺六、八点幺二、四点一百，它的子网源码呢也是一样的。那么这两台主机可以直接允许广播通讯，把我的主机发送广播之后，主机二能够收到吗？其实这是不能的。为什么呢？我们前面也说了，运算广播地址之后，其实主机的广播地址是幺九二点幺六、八点幺二四点六三，而我的主机二是处于第二个网段内，我主机二的广播地址只是幺九二点幺六、八点幺二、四点幺二七，那么它两个的广播地址本身就不一样，你在主机一类发的广播，其实主机二并不能收到。就算你发送的是一个受限广播地址二五五点。二、五点二五点二五，那么依然指标也无法收到，这就是广播通讯之间的一个广播地址的运算的问题。那么大家呢在后面的过程当中可以自己再去查询一下我们的一个广播地址如何运算。那么好的，我们本章节呢就差不多到此结束了。那后面一个章节呢我们会进行一个案例的一个实操，真正的来进行实现一个广播的一个发送以及广播的一个信息接收。谢谢大家。","categories":[],"tags":[]},{"title":"Socket网络编程-入门","slug":"Socket网络编程-入门","date":"2022-02-21T20:29:25.000Z","updated":"2022-05-14T04:38:51.000Z","comments":true,"path":"2022/02/22/Socket网络编程-入门/","link":"","permalink":"http://example.com/2022/02/22/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%85%A5%E9%97%A8/","excerpt":"socket网络编程系列之一","text":"socket网络编程系列之一 Socket网络编程-入门网络模型-对应关系 Socket 与TCP、UDPsocket 是什么呢？其实socket 就是一个套节字，在不同的操作系统，安卓或者是windows 或者是mac 当中都有提供套节字a p i 的一个基础的功能。那么我们通过调用socket 的对应的功能去使用t c p 或者是u d p 进行对应的一个数据发送。 那么为什么要这样呢？这里来给大家进行一个扩展。在我们前面我们有说到对于计算机而言，我们把数据从a 手机传递到b 手机。我们最主要的就是把一个数串传递过去，对吧？那么我们怎么样才能传递过去呢？我们需要把这个数据加工成最底层的一个网络的电信号或者是光信号进行一个传输。那么在这个过程当中，我们是不是一定要去关心我们的一句话，比如说hello word这个字母，它究竟变成了光信号的哪一个东西呢？ 其实我们不需要关心这个东西。因为如果说你每次都要去关心这些东西的话，那么对你的程序开发也是非常非常麻烦的。而且对于整个系统的稳定性而言，是非常不健壮的。所以说就会出现我们前面所说的网络汽车模型。 那么在这里呢也给大家再进行一个巩固。打个比方，我们从a 公司和b 公司之间的一个关系，a 公司要把一个货物发送到b 公司，对吧？首先a 公司要做什么事情？a 公司要把这个货物进行一个包装，对吧？他把货物进行包装，那么这个包装它其实就是一个层面的一个操作。就它的底层公司与公司之间的一个约定，你需要把这个货物进行一个包装，对吧？再后面一点，首先包装了之后的话，你要把你包装的这个货物进行一个标签的打包，对不对？你要打包。那么这就是说货物部门之间的一个关系了，你贴标签、打包以及后面你要进行运输过程当中呢。就涉及到你可能要走水路，走空运，走铁路，对吧？这个时候你要涉及到，你要贴上你对应的一个方式，你的车厢号。那么这个就是物理层面的一个传输了。所以说当你把你的货物丢到了一个火车上的，到了对应的地址的时候，火车上拿出来。他首先要看见的是什么？看见的就是我是从什么地方到达我这里来的，那么我需要做什么事情呢？我首先把我的这个车厢到了，对吧？我就把它卸货。然后呢，我看一下标签，哎，标签上面说的是到哪一个哪一个区，对吧？我要把它丢到哪一个区里面去。然后区里面呢它又一层一层的往下走，最终呢才能走到b 公司去，这就是不同协议层之间的一个交互过程。而如果说你一个公司要去管究竟这个货物走空运还是走水运，通过什么样的汽车去送你自己去把这个货物送到b 公司去。那么其实非常浪费人力的，你自己去把你的货物送到公司，一个货物还好多个货物的话。其实就非常麻烦了，所以说就不同层级之间的一个关系，运输交给快递来做就好，对不对？ 所以说这就是咱们的一个传输模型的一个七层网络模型的概念。之所以存在的一个原理，那么socket 与tcp udp之间的关系呢，其实socket 就是对tcp udp 之间的一个封装。 还有我们来说一下socket 究竟是什么？简单来说socket 就是i p 地址与端口的一个结合协议。这个协议名称叫做RFC 793。那么大家可以去查询一下，是一种地址与端口结合的一个描述协议。 因为它是一个描述协议，对不对？它用来描述什么，描述地址与端口之间的一个关系。这个就是i p 地址端口，就是我们电脑上所谓的端口。这里呢给大家提一下端口。比如说你访问一个网站，那么你访问的其实就是80端口，就是咱们约定好的一个h t t p 协议的一个简单的端口。其实就是80端口。 接着往下走，TCP&#x2F;IP协议的相关a p i 的一个总称是网络a p i 的集合实现，对吧？它其实呢就是对t c p i p 的协议，相关的a p i 的一个总称。TCP&#x2F;IP 它有对应的协议，对吧？说起来就是对这些协议的一个实现一个描述，然后集合在一起。 涵盖了什么呢？涵盖了我们的流套接字，以及咱们的其实这个地方就是咱们的t c p 和udp 了。 那我们来说一下socket 的一个组成与作用。首先在网络传输当中，它是用于标识两个端点之间的连接，什么意思呢？在传输的整个过程当中，比如说你的a 计算机和b 计算机之间，我们通过socket 进行连接。 在你看来，认为是物理层面的连接吗？不一定，它物理层面不一定是时时刻刻都有连接的，它有可能断开，有可能在你这个程序之外它还连接。所以说你的程序这个socket 并不管物理层面的一个连接，它是用来标识的，是唯一标识两个端点之间的连接。 那我们接着往下说端点包括什么？包括i p 和的一个端口 Port。一个计算机有非常多的端口，那么它对外有一个i p 我们的作用。所谓的作用就是标识这个i p 一个i p 代表一个计算机的话，它就代表的是两个计算机之间某一个端口上面连接，这个怎么说呢？ 就好比你的家i p 就是你的家，端口就是你的窗户，通过你家卧室的窗户打开门，就能看见你对面女神的那个窗户口，对吧？这个之间你们之间通过眼神进行连接，对吧？所以说这就是端点与端点之间的一个连接。 它最主要的四个要素就是客户端的地址，客户端的端口以及服务器端的地址和服务器端的端口。 我们接着往下讲socket 的一个传输原理，在这里给大家描述的是一个客户端和一个服务器。 首先呢我们的客户端呢它有一个地址等于i p 一，服务器端的地址等于i p 二，就是满足两个条件之一了，对吧？i p 地址有了。那么首先第二点我们来说一下它的端口是什么，端口是二五端口，对不对？二十五号端口。那么我们的i p 地址加上端口，就等于咱们的socket 的一个协议。同时呢它做了一个什么作用？就是email 对吧？它是一个email 服务，就是咱们那个web server。我们的数据呢其实就通过咱们的这个i p 地址与端口之间的这种连接方式，我们就能实现客户端与服务器端之间的一个交互。你要去取一个邮件，对吧？你就通过二十五号端口去取邮件说唉我有没有邮件，有的话，我去给我一个返回，对吧？这个过程就是咱们那个socket 它的一个传输原理的一个过程。 再往下细讲，socket. 当中的一个t c p，我们来说一下t c p 是什么呢？t c p 是面向连接的一个通讯协议，面向连接对方。要注意一点是面向连接的，它是通过三次握手建立连接通讯完成时要拆除连接。就说你和你的女神要进行连接的时候，你首先要问他一下，哎，你有没有空啊，我可不可以给你说说话。然后你的女生跟你说，哎，我有空对吧？那么这个时候呢才会进行到第三次说，哎，好吧，我们现在连接连接之后呢，那么你们之间就可以交流进行谈话了。然后后面到拆除连接，拆除连接就是说你们两个之间说哎，我要走了，我有事我要走了，对面就说好吧，那你走吧。然后你对面说，那我就能走了，然后对面说好吧，你走了，然后最后你走了，他断开了，他也不再关注你的窗户了。那么你们两个之间就不会再经过窗户之间的一个对望了，对吧？你要告诉他 就走了，对面的人才知道。接着我们往下说，由于t c p 是面向连接的，所以只能通信于端到端的一个通信。什么意思啊？你在看你的女神的时候，你在跟你的女神之间进行交流的时候，你是不能去看其他人。这就是t c p 的一个东西。你在某一个时刻你只能去连接到它的某一个端口。所以说它是端到端的一个通信，是面向端到端的一个通信。 我们再说一下u d p，u d p 这个东西啊跟t c p 差别是蛮大的。首先第一点u d p 是面向无连接的通信方式，你不需要连接。u d p 的数据包括目的端口号和原端口号的信息。什么意思呢？u d p 的数据里面它涵盖了一个目的的端口号，就是说包括了目标的端口号和你自己的一个端口号。你在对外说的时候，比如说现在你要说一句话，对你的女生讲对吧？这时候你你女神是不在的，你是可能说给了他的妈妈，你给他说，我想要对某某人说，哎，我喜欢你，对吧？这句话首先呢你说出这句话的时候，你妈妈作为一个转接者，那么她给她的女儿讲的时候怎么说呢？哎，某某某某公子对你说了一句，我喜欢你这句话，对不对？他的妈妈之所以能够找到他的女儿，那么就一定能够知道说你是对他女儿说的。那么这时候就包括了目标端口号。当他妈妈在转述这句话的时候呢，其实就包括了说某某公子，对吧？某某公子就是原端口号。哎，对，就是说的你。由于通讯是不需要连接的，所以说可以实现广播的发送并不局限于端到端之间的一个发送。这个东西很简单，假如说你是一个老师要传输学校的一个通知，让你的班上去，对吧？你是一个一个学生的，找学生对他说某一个安排呢，还是说你在上课的时候直接对着全班说一下这样来的哈，对吧？这个时候就是t c p 和u d p 最大的区别了，t c p 是一个一个个的来。那么u d p 你可以在班上直接说，哎呦，吼一句，明天不上课对不对？这个东西就完成了。那么ok 这就是咱们的一个u d p 的一个协议。当然。 我们后面还会讲解一下t c p u d p 具体的一些区别。 我们来说一下t c p 的一个传输图解。 t c p 的传输图解，一个设备传输到服务器上。唉，它首先是进行一个t c p 的数据发送，同时呢或它会收到一条t c p 的回复，代表这条数据收到了。那么这个回复呢并不是由你来完成的，而是t c p 层面，数据层面已经完成了这个工装。当你要发送一个数据的服务器的时候，其实这条数据只有两种状态，一种是发送成功，一种是发送失败。只有这两个状态，只有成功与失败，没有说发送一半，他接收到一半的情况一定是你发送过去，他真的收到了。同时他给你了一次回送之后，他收到了这条数据才代表成功了。所以他只有两个状态，要么成功，要么失败。 udp就不一样了，他只管发送数据，他不管回送的，他只管把数据往下发。他不管回送的，比如说你现在去班上给那些学生说明天不上课吧。哎，假如这个学生他没在班上怎么办？你难道还单独去找一下这个学生？不会的，u d p 其实不会的，他直接就吼一句，明天不上课，ok 完了就完了。他对全班同学一说，说完了就完事了，不存在一个某个学生，他有没有听到要对你进行一个反馈，不存在这个东西，不存在说每个学生还要对你说，哎，我听到了，我明天不会来上课了，不存在这个东西。 所以说这就是u d p 和t c p 最大的一个区别。好的，我们本小节讲了一个t c p u d p 的一个图解，也讲了咱们的socket 究竟是一些什么东西。那么我们前面两个小节都讲了一些理论的知识，后面一个章节我们会给大家讲解一下一个实际的案例。那么在讲解实际的案例之前呢，给大家说一下一个cat serious i p u d i c a t i o n 就是咱们所谓的c s 模型。在t c p i p 协议当中，两个之间的主要方式就是。c s 模型c s 其实就是客户端与服务器之间交互的一个模型，就称之为c s 模型。最主要的目的就是协同网络当中的计算机资源，服务器模式进程间的数据共享。为什么要有c s 模型？比如说你访问一个网站，你有没有想过为什么这个网站一定要部署在服务器上？这个呢其实也蛮好理解的。比如说你自己做一个网站，你难道把你的这个网页发给全世界的每个人都发一份备份给他，说我的网站是这个。然后呢，你的网站有更新的时候，你难道给全世界的人都说一下你的网站有副本更新的，全部叫他们更新一下吗？不会的，你直接把你的网站部署在一个服务上当某人真正需要看的时候，他通过这个c s 模型，他的客户端去访问你的这个服务器，得到你的网站，来看你的网站。所以 说这就是c s 模型，也就是协同的计算机当中的一个网络资源服务器模式以及进程间的一个数据共享。进程间的网络数据模型共享呢，其实这个也蛮简单的。在你的实际的开发过程中，可能你的某一个软件提供的某一个服务，对吧？比如你现在一个网站，你自己的有有一个程序提供了一个一加一等于二的这个过程，你不想其他软件再去实现，一加一等于二的这个过程。那么你可以把你的这个软件对外暴露出去，说我可以实现某个数据加上某个数据，等于某个数据的过程。其他人呢就只需要把前面两个数据传递给你，然后他就能得到他的结果，这就是进程之间进行数据共享。常见的呢就是f t p ，sm t p 和h t t p 这就是本小节主要的讲解。 Socket TCP牛刀小试报文、协议、Mac地址同学们，我们前面一个章节来讲解了一些简单的代码，那么在这里呢我们紧接着要进行的是一些理论知识的一个扩充。之所以要讲这些理论知识，并不是说这些理论知识你一定能够在后面的开发当中能够用上，但是这有助于你对整个socket体系的一个了解，以及也是扩充你的一个思维上的一种思考方式的一种额外知识点。所以说我认为理论还是蛮重要的。首先我们来讲报文段。什么是报文？报文是指tcpip协议传输过程呢起着路由导航作用的一个东西。那么在tcpip协议当中，你要发送一个数据到b客户端。就拿我们上一节所讲的demo来说，你要从a这个进程发送一个数据到b进程，它其实并不是说简单地把一个字符串转换成byte数据传递过去而已。它在整个过程当中还需要把拜托数据进行一定的报文解析，然后加上对应的字节头，然后再把这个字节头信息传递到b程序。然后在b程序当中，呢，他会把头解析开之后，最终得到我们后面的报文段。然后也就是咱们的一个buffer数据。拿了buffer数据之后再丢给应用层，应用层最终再把buffer数据解析成咱们的这个字符串，也就实现了咱们一个字符串的一个交互过程。它的主要作用呢，报文段是用以查询各个路由段的ip地址、交换协议的ip数据包，那么这个报文数据呢就包括这些信息，同样的报文充当整个tcp协议数据包的一个路由功能。报文在传输过程中是会不断地封装成组封装成包、封装成针来进行传输。 那么这些东西呢主要的目的是为了什么？ 当你的一个数据过于太大了时候，那么他会把你的一批大数据转换成对应的一些组合，是包或者是帧，然后解析成一个一个小的数据点，然后通过小的数据点传输过去。 比如说你想发送一个大文件，对吧，文件是一个很长很长的一个包数据，但是呢你在发送的过程当中，它是需要不断的校验的，tcpip协议当中是先要发送，然后收到一个返回的信息，对不对？它是有一个校验的过程，所以说我需要先发送一部分过去，然后呢在回送这一部分成功与否，那么整个过程呢它会把你的整个buffer解析成很多很多小的buffer，然后在前面加上一定的咱们的一个报文头，然后呢进行一个批量的发送，每一批数据它都有一定的校验作用。封装的方式呢就像我说的，就是在一些控制信息上面加上一个头部及报文头。 然后后面来说一下我们所谓的传输协议。顾名思义就是一种规定、一种约束。约定待遇配置在网络传输过程依然是适用的，网络传输的流程之所以是健壮的、稳定的，其实也是得益于咱们的一个基础的协议的构成，必须要双方遵守共同的协议。简单来说就是a到b的一个传输数据，b能够识别，反之b返回给a的传输数据a也能识别，这就是协议。两个人之间遵循这样一个协议的关系。那我举个例子来说，你想要打电话给你的妈妈，那你首先需要进行一个拨号，然后你的妈妈手机会进行响铃，然后你妈妈接电话，然后呢跟你进行通话，你说一句话，他回一句话，对吧？然后你们直接进行一个交互的一个过程。 那么在这里你首先是需要进行拨号，你妈妈电话才能够响铃，同时他要接听电话之后，你们俩这样才可以进行通话。那么这整个过程当中要经过一系列约定好的、规定好的一个过程，这就称之为协议。 那么同样的，你去访问一个网站，你首先是需要输入这个网站的地址，那么它需要进行一个网站的一个地址查询，然后呢去访问这个网站对应的服务器上面的ip地址和端口号，然后呢网站会返回它的首页信息给你，那么整个过程就依次往下进行交互，所以说这样的一个过程就称之为传输协议。 那么第三点，我们来讲一下mac地址。mac地址呢是一个media accept control的一个缩写，译为媒体控制访问。媒体访问控制或称之为物理地址、硬件地址。在所有所有的硬件地址上都有这样的一个信息，叫做mac地址，无论是你的手机还是。你的路由器，还是你的电脑，以及你的每一台通讯设备，其实都有一个地址叫做mac地址，其实它用的重就是标识这个物理设备它在网络上的一个地址。那mac地址其实是有限的，mac地址用来定义网络设备的一个位置，对吧 形如：44-45-53-54-00-00 就是一个mac地址，其实就是与你的身份证类似，你有你的身份证，每个人都有自己的身份证，那么就用来标识你这个人。那么每一台可以上网的设备它都有这样的一个mac地址，用来标识这个设备它的位置。 哎我们来看一下，这是一个手机端的一个检测图，我们来看一下这里面有些什么样的信息。在这里我们可以看到安卓对吧系统是安卓，然后呢有一些蓝牙版本啊什么什么之类的。那么我们在这里呢并不关注这些东西，我们。需要关注的是什么mac地址在这里。 这就是咱们的一个mac地址，当然这前面还有一个b s s id，然后它也是一个类似mac地址一样的东西，它是一个无线的网络的一个他自己的一个网卡的一个地址。所以说这个地方那它是和mac地址非常类似的。当然下面还有一个咱们的ip地址，是咱们当前的一个网络的ip地址，对吧，以及这边有咱们的一个普通网络的一个信息。好了，我们再接着往下看一下。 这是第二幅图。第二幅图上的话把上面的一些细节进行一个简单的归类、总结。那我们接着来看一下ip地址，这是咱们的一些基础的ip信息的一个设置，以及咱们的mac地址对吧那么可以说咱们每一台设备都有这样的信息的存在，有咱们的ip地址，有咱们的mac地址。 我们之所以有ip地址。其实也是因为咱们先要有mac地址，mac地址代表你这台硬件设备的一个物理地址，同时你的i p地址呢是当前局域网根据你的mac地址分配给你的一个临时的、可用的一个ip地址而已。 IP、端口、远程服务器我们上一个章节来讲解了一下咱们那个报文、mac地址，以及咱们的一些协议方面的一些信息，那我们本章节来讲解一下咱们的ip以及咱们端口、以及远程服务器的概念。本章节呢我会用一些示意图给大家讲解一下基础的一些原理，尽可能的让大家不感到枯燥。好了，我们首先来说一下ip地址。ip地址即互联网当中的一个协议地址，缩写为一个ip地址。那么当然上面就是咱们一个互联网的一个协议地址，是分配给网络上使用，网际协议设备，数字标签。常见的ip地址分为ipv4和ipv6两大类。 那我们来看一下，ip地址由三十二位二进制组成，常以192.168.0.1的形式出现 xxx.xxx.xxx.xxx每一组叉叉代表着小于或等于255的十进制数，当然它是大于零的。 比如说208.80.152.2 后面我们来说一下ip地址分为abcd一大类，其中e类属于特殊的保留的地址，总的数量是多长啊总的数量是四十二亿个。最终的时候是在二零幺幺年二月三日的时候，其实所有的地址就已经被分配尽了，所有的ip地址其实已经被分配完成了，你现在所用的ip地址其实并不是整个因特网的一个ip地址，你的ip地址其实只是一个局域网类的一个地址，你的局域网上面可能还有局域网。那么一直到整个因特网的时候呢，它的那个地址其实是已经固定好了，不可变的。如果主机号全部都是1，那么这个地址直接为广播地址，就比如说1.1.1.1，这就是一个直接广播地址， 地址255.255.255.255 受限的广播地址代表着你当天局域网的一个广播地址。你如果说使用udp往这个ip地址发送信息，那么你的局域网内的其他设备全部会收到你的udp的广播。 如果说你往1.1.1.1的这个地址发送一个udp的话，理论来说它会往整个因特网发送一个udp协议，但是其实它是会被对应的局域网的防火墙所拦截，并不会发送出去。紧接着来说一下ipv6，因为ipv4的一个数量是有限的，而且比较少，四十二亿了，所以说它已经被分配完成了。那么在后面呢为了解决新增的一些设备在因特网当中的一个地位，就提出了i p v6的概念，总共有128位长ipv6的地址表达形式一般采用32十六进制数，也可以想象成是1632。 有两个逻辑部分组成，这六十四位的网络前缀和一个六十四位的主机地址，主机地址常常是根据物理地址自动生成，这个地方的主机地址呢就是一般而言是会根据你的mac地址啊或者是你的一些硬件设备信息来组成。那么一个六十四位的网络前缀呢就在代表着你的当前网络的一个状态，那么加在一起其实就形成了你的ipv6地址，这就是一个ipv六地址，看起来比较复杂。 ipv6和ipv4之间的关系是什么？因为ipv6是大于ipv4的，它的数量是大于它的，同时ipv4的地址一定是可以转换成一个ipv6的一个地址的，但是ipv6的地址是不一定能够转换成ipv4的地址。 那我简单来说一下第二个大点端口。如果说把ip地址当作一间房子端口，就是进入这个房子的门或者是窗户，这是咱们之前提过的概念，在不同的窗户后有不同的人。那么房子当中的用户与外界交流的出口就是咱们的房子和端口组成了这个人对外交流的一个出口。外界的鸽子也就是信息飞到不同的窗口，也就是给不同的人传递信息。那么你在一个房子里面有不同的人，就代表着你的不同的程序的进程，而外面不同的鸽子飞来的时候，就代表着不同的进程发送信息。从0到1023端口以及1024到49151端口都是特殊端口。那么特殊端口呢后面我会补充到一份文档当中，特殊端口里面有非常多的一些特殊意义。那么这些端口呢是我们不能够直接使用的一个端口号地址，这是一些基本的一些特殊端口号。 那么首先我们来说一下二零二幺号端口一般会用作于f t p协议，它是一个tcp的一个端口号。二十二号端口呢。一个s s h，二十三号是care night，二十五号是s m t p。当然五十三号是dns。你说之所以能够访问一个网站，其实是因为它首先去进行一个dns解析，然后拿到你的域名对应的i p地址和端口号之后才能够进行访问。那么当然还有t f t p、h t t p对吧，h t p是咱们非常常见的八零端口，还有咱们邮件协议等等，还有h tt ps是四四三协议。 上面来讲了下特殊的端口，那么紧接着往下说，计算机之间依照互联网传输层面的tcpip协议通讯，不同的协议对应的不同的端口号，这是我们上面已经说。后面的49152到65535端口是属于动态端口范围。就比如说我们之前客户端连接到服务器的时候，生成的这个端口号，其实就是处于这个区间的一个动态的一个端口。没有端口是可以被正式的注册使用的，就是说你不可能说某个端口号就是我一定要用的，你不能对外面的人说这个端口号就一定是我用的，外面的人不能用这个端口不能这样的，这个端口号都是一个动态的端口。所以说你不能够固化它。那么来说问题第一点，端口号的总数是六五五三六，那么能够建立多少个连接？六五三六个?其实不是。这个地方的六五三六是代表着你自己的本地的电脑的端口号。那么这个端口号呢有几个点，首先端口它对应的ip你可以理解为ip，就是房子，端口就是窗户。不同的ip就是不同的房子。所以说不同的房子之间就有不同的这个端口号。也就说你的电脑如果说一旦具备多个ip地址的一个方法的话，那么你可以有多个端口号。也就是说你的端口号虽然说每一个ip地址都是这么多，但。在你有多个ip地址的情况下，你的本地的电脑可以建立的连接数会远远大于六五三六个。当然了，你依然是有限的，但是对于服务器而言，端口是复用的。比如说服务器他监听八零幺端口，无论多少个客户端来，他都是通过把你号端口进行交互的，不会创建额外多余的端口。来说一下数据传输的一个层次，这是咱们的之前说的四层模型。 程序也就咱们数据进入到传输层面的时候，传输层面有一个udp的数据，那么udp数据他会干一件事情，加上一个udp的头部，进入到后面的一个internet课程，那么这时候会进入ip数据。ip数据呢前面会被加上ip header，也是ip头部，他会把前面的udp的这个一个整体全部转换成ip的一个数据，前面加上一个ip的投。那么再到后面数据链接层的时候，它会把你上面的整个协议全部转换成一个真数据，代表的一帧数据，那么它会有一个帧的头部和帧的尾部。这样的话它发送给b的手b的链路层，它会把头部和尾部去掉，然后得到ip数据层，往上一次丢，最终到程序层的时候又是咱们的原始数据了。所以说咱们数据的发送过程是会经过层层的一个头部的追加。 那么来说一下远程服务器是什么?远程服务器一般而言局域网，也就是指你家里面或者是你公司里面的网络都是属于局域网的。我和你们的电脑之间是属于互联网的，而非局域网。我的电脑和你的电脑之间的关系属于互联网的关系，而不是局域网，但是你的电脑和你的手机之间的关系是属于一个局域网，当然你的手机很简。和电脑要连接同一个无线路由器才行。默认的我的电脑是无法直接链接到你们的电脑的，因为你们的电脑在你们的局域网当中我的电脑在我的局域网当中，你虽然电脑上有一个ip地址，但是那个ip地址并不是你的互联网ip地址，而是你的局域网ip地址，我的电脑上也有ip地址，我的地址呢也是我的局网地址。所以说我就算知道你的ip，只知道你的端口，你能够建立一个socket的一个服务器，但是我是无法连接你的，我连接的永远是我的这个局域网进行扫描的。如果说我想要连接你怎么办呢？看后面。 这是咱们的一个局网里面的一些设备，这个是另外一个局网里面也是一些设备。我们尝试把这台电脑跟这台电脑之间进行连接，传输数据能不能呢？对不对？这也是说了两个局域网之间内部的设备是无法直接进行通讯的，无法直接进。连接的。你可以说哎为什么你的qq可以给我的qq发送消息，那么一定是你的手机跟我的手机之间直接连接的吗？不是。其实是这样的，这也是一个局域网这也是另外一个局域网。 我们通过一个服务器，这个服务器来具备的外网地址，就我们前面说的ipv四、ipv六，它前面都有一部分已经分配的地址，分配的这个地址就是咱们整个互联网外部的一个id，这部分地址是已经分配出去了，已经是固定的。比如说咱们的一些政府的服务器，或者说咱们的主干上面的一些服务器，它的ip地址永远是固定的，而且是一个对外所有的设备都有效的一个ip地址。你的电脑连接到服务器，然后呢服务器呢也连接到我的电脑，然后就实现了一个数据的交换，你把数据先发送到服务器，服务器呢再把数据通知到我，ok。这就实现了我们之间的数据交互，也就是qq的一个作用。qq它之所以能够你发送下去给我也是这样。请接着我们来说一下我们的一个web请求流程。 你的电脑去访问一个网页，你请求一个网页的时候，你的地址是幺九二点幺六八点幺点幺幺二，这个地址是你的局域网地址幺九二点幺六八。遇到这样的地址一定是你的局有网地址，那么外网服务器的地址你要想访问的地址一定是一个外网服务器的地址，它的地址是什么幺幺零点九、零点四、五点六，这是一台外网地址的服务器。那么首先你要进行的是你访问，比如你访问百度，你首先你你输入的是一个百度点com，对吧？那么这个东西是一个域名，首先它要进行一个域名服务器的一个查询，所以说它会经过一个域名服务器的一个udp五三的这个端口。下面我们也说了，五十三号端口是一个udp的一个协议端口，去查询它的地址，你的电脑就会拿。好，想访问的这个百度这个服务器的具体的地址以及它的端口号。他的地址假如他就是幺幺零点九、零点四、五点六，它的端口号是什么呀？你访问网页端口号永远都是八零后，当你没有指定的情况下，那么就或者是八连号端口就进行一个http的协议，ok，就进行交互，然后你们两个人就可以进行传数据了。当然对https就是443号端口号，都是tcp协议。我们所谓的http或者是h tt ps，其实都是基于tcp进行的一个封装。好的。这就是我们本章节的一个主要的一些知识点。那么下个章节呢我们会开始讲解一下udp相关的一些知识点，以及udp的案例。好的，谢谢大家。","categories":[],"tags":[]},{"title":"Android - 在Fragment中观察LiveData时，为什么要使用viewLifecycleOwner[转]","slug":"Android - 在Fragment中观察LiveData时，为什么要使用viewLifecycleOwner","date":"2022-02-16T02:37:54.000Z","updated":"2022-05-12T07:32:47.000Z","comments":true,"path":"2022/02/16/Android - 在Fragment中观察LiveData时，为什么要使用viewLifecycleOwner/","link":"","permalink":"http://example.com/2022/02/16/Android%20-%20%E5%9C%A8Fragment%E4%B8%AD%E8%A7%82%E5%AF%9FLiveData%E6%97%B6%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8viewLifecycleOwner/","excerpt":"使用LiveData 在调用observe时传入this会报提醒，要求使用viewLifecycleOwner原因是什么？","text":"使用LiveData 在调用observe时传入this会报提醒，要求使用viewLifecycleOwner原因是什么？ 原文链接 Android - 在Fragment中观察LiveData时，为什么要使用viewLifecycleOwner官网建议使用viewLifecycleOwner 在Fragment中对LiveData对象调用Observe方法的时候，如果传递的LifecycleOwner参数为this，也就是Fragment的时候，会受到AndroidStudio的提醒，要求使用viewLifecycleOwner： fragment.png 从类型上来说，Fragment与viewLifecycleOwner的类型FragmentViewLifecycle两者都继承了LifecycleOwner，像之前那样直接this，大部分情况下运行也是正常的，那么这里的Lint提醒是什么呢？ 通过在官网寻找androidx.fragment:fragment的文档，可以看到1.2.0版本更新的内容有一条： 26005601-ff3b75c18a8b2c79.png 可以知道，这肯定是有他的道理。我们来一起分析一下原因： 123456789101112131415161718192021222324252627282930313233viewLifecycleOwner相关生命周期找到viewLifecycleOwner相关代码( 只看关键点 )：//Fragment.java中void performCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123;mChildFragmentManager.noteStateNotSaved(); mPerformedCreateView =true; mViewLifecycleOwner =new FragmentViewLifecycleOwner(); //此处创建了FragmentViewLifecycleOwner mView = onCreateView(inflater, container, savedInstanceState); //创建完成之后，调用了onCreateView()方法 ... //省略无关代码&#125;//FragmentManager.javaprivate void destroyFragmentView(@NonNull Fragment fragment) &#123; fragment.performDestroyView(); //此方法中执行了onDestroyView()方法 fragment.mViewLifecycleOwner =null; //在执行完onDestroyView()方法之后，将viewLifecycleOwner置空&#125;//Fragment.javavoid performDestroyView() &#123; ... onDestroyView(); // fragment.performDestroyView()方法调用中，执行了onDestroyView()方法 ...&#125;可以发现mViewLifecycleOwner的赋值在onCreateView()之前，置空在onDestroyView()之后，mViewLifecycleOwner的注释也说明了这点： // 这在performCreateView中初始化，在外部不可用 // This is initialized in performCreateView and unavailable outside of the // onCreateView/onDestroyView生命周期 // onCreateView/onDestroyView lifecycle @Nullable FragmentViewLifecycleOwner mViewLifecycleOwner; 正如类名所示，这个FragmentViewLifecycle代表的是Fragment中View的LifecycleOwner，Fragment中View的生命周期与Fragment本身并不相同。 看到这里，想必有些同学对Fragment的生命周期也半知半解，顺便温习一下： Fragment.png Fragment入back stack的过程会执行onDestroyView但不执行之后的onDestroy与onDetach，而出back stack是从onCreateView开始执行，而没有之前的onAttach与onCreate。 LiveData的observe过程温习了相关生命周期后，下面来看一下LiveData的observe过程。 我们知道在LiveData的observe方法内，会将参数owner与observer包装起来，使得observer的回调受owner的生命周期的影响，只有在owner处于活跃状态才回调observer，而活跃状态指的是当前owner的生命周期至少为STARTED，即如下（1）处，owner与observer的包装类中否活跃的判断方法。 12345678910111213141516171819202122class LifecycleBoundObserver extends ObserverWrapper implements LifecycleEventObserver &#123; @NonNull final LifecycleOwner mOwner; LifecycleBoundObserver(@NonNull LifecycleOwner owner, Observer&lt;? super T&gt; observer) &#123; super(observer); mOwner = owner; &#125; @Override boolean shouldBeActive() &#123; return mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED); &#125;//(1) @Override public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) &#123; if (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123; removeObserver(mObserver);//(2) return; &#125; activeStateChanged(shouldBeActive()); &#125; ...&#125; 可是，Fragment与Fragment中的View在活跃的生命周期状态是一致的，这里的owner使用fragment还是viewLifecycleOwner并无不同，二者只有在onCreateView到onDestroyView之外有区别。 包装类中的onStateChanged方法会执行observer的适时移除工作，而（2）处的移除observer正是在owner处于DESTROYED时发生的。对于Fragment，状态会在onDestroyView执行前夕，变为DESTROYED，如下所示： 12345678910//Fragment.java 也对应了上边的内容 void performDestroyView() &#123; mChildFragmentManager.dispatchDestroyView(); if (mView != null) &#123; mViewLifecycleOwner.handleLifecycleEvent(Lifecycle.Event.ON_DESTROY); &#125; mState = CREATED; onDestroyView(); ... &#125; 原因此时，一切都解释得通了，在Fragment中对LiveData对象调用observe方法时，使用viewLifecycleOwner代替this的原因是：Fragment与Fragment中的View的生命周期并不一致，需要让observer感知Fragment中的View的生命周期而非Fragment，因此Android专门构造了Fragment中的View的LifecycleOwner，即viewLifecycleOwner。","categories":[],"tags":[]}],"categories":[{"name":"Jetpack系列","slug":"Jetpack系列","permalink":"http://example.com/categories/Jetpack%E7%B3%BB%E5%88%97/"},{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"},{"name":"UI","slug":"UI","permalink":"http://example.com/categories/UI/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"},{"name":"Jetpack","slug":"Jetpack","permalink":"http://example.com/tags/Jetpack/"},{"name":"webview","slug":"webview","permalink":"http://example.com/tags/webview/"},{"name":"hybrid","slug":"hybrid","permalink":"http://example.com/tags/hybrid/"}]}