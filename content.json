{"meta":{"title":"SteveZhang博客","subtitle":"","description":"","author":"张龙","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Jetpack系列—底部导航路由BottomNavigationView原理","slug":"Jetpack系列—底部导航路由原理","date":"2022-02-09T02:49:29.000Z","updated":"2022-02-09T22:20:05.000Z","comments":true,"path":"2022/02/09/Jetpack系列—底部导航路由原理/","link":"","permalink":"http://example.com/2022/02/09/Jetpack%E7%B3%BB%E5%88%97%E2%80%94%E5%BA%95%E9%83%A8%E5%AF%BC%E8%88%AA%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86/","excerpt":"主要介绍BottomNavigationView及其实现原理","text":"主要介绍BottomNavigationView及其实现原理 bottom_nav_menu.xml 配置底部item的显示内容和个数 1234567891011&lt;fragment android:id=&quot;@+id/nav_host_fragment_activity_main&quot; android:name=&quot;androidx.navigation.fragment.NavHostFragment&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:defaultNavHost=&quot;true&quot; app:layout_constraintBottom_toTopOf=&quot;@id/nav_view&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:navGraph=&quot;@navigation/mobile_navigation&quot; /&gt; 1app:defaultNavHost=&quot;true&quot; 是否和系统的返回键相关联 如果相关联，如果回退栈中有fragment 那么就会拦截返回键 如果没有的话就执行返回键的默认行为 1app:navGraph=&quot;@navigation/mobile_navigation&quot; 底部路由结构 1234567891011121314151617181920212223242526&lt;navigation xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/mobile_navigation&quot; app:startDestination=&quot;@+id/navigation_home&quot;&gt; &lt;--节点所配置的fragment --&gt; &lt;fragment android:id=&quot;@+id/navigation_home&quot; android:name=&quot;com.steve.ppjoke_android.ui.home.HomeFragment&quot; android:label=&quot;@string/title_home&quot; tools:layout=&quot;@layout/fragment_home&quot; /&gt; &lt;fragment android:id=&quot;@+id/navigation_dashboard&quot; android:name=&quot;com.steve.ppjoke_android.ui.dashboard.DashboardFragment&quot; android:label=&quot;@string/title_dashboard&quot; tools:layout=&quot;@layout/fragment_dashboard&quot; /&gt; &lt;fragment android:id=&quot;@+id/navigation_notifications&quot; android:name=&quot;com.steve.ppjoke_android.ui.notifications.NotificationsFragment&quot; android:label=&quot;@string/title_notifications&quot; tools:layout=&quot;@layout/fragment_notifications&quot; /&gt;&lt;/navigation&gt; 1app:startDestination=&quot;@+id/navigation_home&quot; 默认要显示的页面是哪一个 通过可视化界面配置fragment 123456789101112131415161718&lt;fragment android:id=&quot;@+id/navigation_home&quot; android:name=&quot;com.steve.ppjoke_android.ui.home.HomeFragment&quot; android:label=&quot;@string/title_home&quot; tools:layout=&quot;@layout/fragment_home&quot;&gt; &lt;!-- 当前fragment跳转到下一页的动作，所以必须指定目标页--&gt; &lt;action android:id=&quot;@+id/id_action&quot; app:destination=&quot;@id/navigation_dashboard&quot; /&gt; &lt;!--指的是创建当前fragment时需要传递的参数 --&gt; &lt;argument android:name=&quot;arg1&quot; app:argType=&quot;integer&quot; /&gt; &lt;!--通过url拉起页面，隐式意图 就是页面路由 --&gt; &lt;deepLink android:id=&quot;@+id/deepLink&quot; app:uri=&quot;www.imooc.com&quot; /&gt;&lt;/fragment&gt; 先看承载的Fragment的实现逻辑 NavHostFragment.java 123456789101112131415161718192021222324252627282930313233343536373839404142public void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); final Context context = requireContext(); //切换fragment的能力委托给NavHostController mNavController = new NavHostController(context); ... //添加了两个导航器 onCreateNavController(mNavController); Bundle navState = null; if (savedInstanceState != null) &#123; navState = savedInstanceState.getBundle(KEY_NAV_CONTROLLER_STATE); if (savedInstanceState.getBoolean(KEY_DEFAULT_NAV_HOST, false)) &#123; mDefaultNavHost = true; getParentFragmentManager().beginTransaction() .setPrimaryNavigationFragment(this) .commit(); &#125; mGraphId = savedInstanceState.getInt(KEY_GRAPH_ID); &#125; if (navState != null) &#123; // Navigation controller state overrides arguments mNavController.restoreState(navState); &#125; if (mGraphId != 0) &#123; // Set from onInflate() mNavController.setGraph(mGraphId); &#125; else &#123; // See if it was set by NavHostFragment.create() final Bundle args = getArguments(); final int graphId = args != null ? args.getInt(KEY_GRAPH_ID) : 0; final Bundle startDestinationArgs = args != null ? args.getBundle(KEY_START_DESTINATION_ARGS) : null; if (graphId != 0) &#123; mNavController.setGraph(graphId, startDestinationArgs); &#125; &#125;&#125; onCreateNavController 1234567protected void onCreateNavController(@NonNull NavController navController) &#123; navController.getNavigatorProvider().addNavigator( //第一个，给dialogframgent提供跳转，切换的能力 new DialogFragmentNavigator(requireContext(), getChildFragmentManager())); //第二个，是给fragment提供跳转 navController.getNavigatorProvider().addNavigator(createFragmentNavigator());&#125; 除此之外，还在NavController的构造函数里添加了两个默认的navigator 1234567891011121314public NavController(@NonNull Context context) &#123; mContext = context; while (context instanceof ContextWrapper) &#123; if (context instanceof Activity) &#123; mActivity = (Activity) context; break; &#125; context = ((ContextWrapper) context).getBaseContext(); &#125; //这个导航器的作用是配置的默认启动的页面，启动后会跳转，唯一被用到的地方 mNavigatorProvider.addNavigator(new NavGraphNavigator(mNavigatorProvider)); //为activity跳转提供支持 mNavigatorProvider.addNavigator(new ActivityNavigator(mContext));&#125; 为什么把navigator添加到provider里呢？ privoder本质是一个hashmap，存储导航器的实例 这4个导航器有什么相同点有什么不同点？ 都继承自Navigator 12345678910111213141516171819202122232425262728//泛型必须继承NavDestination 而NavDestination就是dialog activity fragment 之所以这么设计泛型，是需要activity的navigator只能创建activity的navigator 而fragment只能创建fragment的导航器public abstract class Navigator&lt;D extends NavDestination&gt; &#123; //1.每一个navigator的子类都必须标注一个Name的注解，只有这样，才会把它添加到provider里，我们之前说provider是一个hashmap 它的key就是我们标注的name的名字，value是navigator的实例本身 //2.navigator在创建destination的时候,它会解析navigator上的name，以此来得到导航器的名称 public @interface Name &#123; String value(); &#125; ... //创建Destination 看下面Destination的构造 public abstract D createDestination(); //跳转逻辑 public abstract NavDestination navigate(@NonNull D destination, @Nullable Bundle args,@Nullable NavOptions navOptions, @Nullable Extras navigatorExtras); //是否拦截系统的返回键，实现回退栈的操作 public abstract boolean popBackStack(); //空接口，实现用来做额外的事情，比如过渡元素，转场动画 public interface Extras &#123; &#125;&#125; 123456789//传入一个navigatorpublic NavDestination(@NonNull Navigator&lt;? extends NavDestination&gt; navigator) &#123; this(NavigatorProvider.getNameForNavigator(navigator.getClass()));&#125;//传入一个navigatorName 这个name就是通过标注在navigator上面的name的注解得到的public NavDestination(@NonNull String navigatorName) &#123; mNavigatorName = navigatorName;&#125; 那么为什么要传入navigatorName呢？ NavDestination就是我们跳转的一个个页面，我们通过传入的navigatorName在provider这个hashmap中得到destination实例，就是这么得到我们的跳转的实例的 我们接着看Navigator中的navigate方法 12//跳转逻辑public abstract NavDestination navigate(@NonNull D destination, @Nullable Bundle args,@Nullable NavOptions navOptions, @Nullable Extras navigatorExtras); 由于activity fragment dialog的具体跳转方法都不一样，所以，不会交由父类来实现，所以这里是抽象的，使用了模板方法 Navigator父类了解后，我们来了了解其子类的实现 ActivityNavigator 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119//provider中的key的名字就是activity@Navigator.Name(&quot;activity&quot;)public class ActivityNavigator extends Navigator&lt;ActivityNavigator.Destination&gt; &#123; public final Destination setIntent(@Nullable Intent intent) &#123; mIntent = intent; return this &#125; ... public final Destination setTargetPackage(@Nullable String packageName) &#123; if (mIntent == null) &#123; mIntent = new Intent(); &#125; mIntent.setPackage(packageName); return this; &#125; public Destination setData()&#123; ... &#125; public Destination setComponentName()&#123; ... &#125; //上面这些类都是为了构造或传入Intent对象 ... //核心方法navigate public NavDestination navigate(@NonNull Destination destination, @Nullable Bundle args, @Nullable NavOptions navOptions, @Nullable Navigator.Extras navigatorExtras) &#123; //1.获取跳转Intent if (destination.getIntent() == null) &#123; throw new IllegalStateException(&quot;Destination &quot; + destination.getId() + &quot; does not have an Intent set.&quot;); &#125; Intent intent = new Intent(destination.getIntent()); if (args != null) &#123; intent.putExtras(args); String dataPattern = destination.getDataPattern(); if (!TextUtils.isEmpty(dataPattern)) &#123; // Fill in the data pattern with the args to build a valid URI StringBuffer data = new StringBuffer(); Pattern fillInPattern = Pattern.compile(&quot;\\\\&#123;(.+?)\\\\&#125;&quot;); Matcher matcher = fillInPattern.matcher(dataPattern); while (matcher.find()) &#123; String argName = matcher.group(1); if (args.containsKey(argName)) &#123; matcher.appendReplacement(data, &quot;&quot;); //noinspection ConstantConditions data.append(Uri.encode(args.get(argName).toString())); &#125; else &#123; throw new IllegalArgumentException(&quot;Could not find &quot; + argName + &quot; in &quot; + args + &quot; to fill data pattern &quot; + dataPattern); &#125; &#125; matcher.appendTail(data); intent.setData(Uri.parse(data.toString())); &#125; &#125; // extra 获取额外的flag if (navigatorExtras instanceof Extras) &#123; Extras extras = (Extras) navigatorExtras; intent.addFlags(extras.getFlags()); &#125; //设置intent的跳转的flag if (!(mContext instanceof Activity)) &#123; // If we&#x27;re not launching from an Activity context we have to launch in a new task. intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); &#125; if (navOptions != null &amp;&amp; navOptions.shouldLaunchSingleTop()) &#123; intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP); &#125; //设置跳转的当前页面的hostid 用来做页面溯源 if (mHostActivity != null) &#123; final Intent hostIntent = mHostActivity.getIntent(); if (hostIntent != null) &#123; final int hostCurrentId = hostIntent.getIntExtra(EXTRA_NAV_CURRENT, 0); if (hostCurrentId != 0) &#123; intent.putExtra(EXTRA_NAV_SOURCE, hostCurrentId); &#125; &#125; &#125; final int destId = destination.getId(); intent.putExtra(EXTRA_NAV_CURRENT, destId); //设置跳转的动画 if (navOptions != null) &#123; // For use in applyPopAnimationsToPendingTransition() intent.putExtra(EXTRA_POP_ENTER_ANIM, navOptions.getPopEnterAnim()); intent.putExtra(EXTRA_POP_EXIT_ANIM, navOptions.getPopExitAnim()); &#125; //使用context.startActivity来进行真正的跳转 if (navigatorExtras instanceof Extras) &#123; Extras extras = (Extras) navigatorExtras; ActivityOptionsCompat activityOptions = extras.getActivityOptions(); if (activityOptions != null) &#123; ActivityCompat.startActivity(mContext, intent, activityOptions.toBundle()); &#125; else &#123; mContext.startActivity(intent); &#125; &#125; else &#123; mContext.startActivity(intent); &#125; if (navOptions != null &amp;&amp; mHostActivity != null) &#123; int enterAnim = navOptions.getEnterAnim(); int exitAnim = navOptions.getExitAnim(); if (enterAnim != -1 || exitAnim != -1) &#123; enterAnim = enterAnim != -1 ? enterAnim : 0; exitAnim = exitAnim != -1 ? exitAnim : 0; mHostActivity.overridePendingTransition(enterAnim, exitAnim); &#125; &#125; return null; &#125; &#125; 接下来DialogFragment 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Navigator.Name(&quot;dialog&quot;)public final class DialogFragmentNavigator extends Navigator&lt;DialogFragmentNavigator.Destination&gt; &#123; //同样的创建，传入navigator通过navigator来取出它的名字 public Destination createDestination() &#123; return new Destination(this); &#125; //设置className public final Destination setClassName(@NonNull String className) &#123; mClassName = className; return this; &#125; //核心跳转navigate public NavDestination navigate(@NonNull final Destination destination, @Nullable Bundle args, @Nullable NavOptions navOptions, @Nullable Navigator.Extras navigatorExtras) &#123; if (mFragmentManager.isStateSaved()) &#123; Log.i(TAG, &quot;Ignoring navigate() call: FragmentManager has already&quot; + &quot; saved its state&quot;); return null; &#125; String className = destination.getClassName(); //1.获取classname 全类名 if (className.charAt(0) == &#x27;.&#x27;) &#123; className = mContext.getPackageName() + className; &#125; //2.通过classname 反射构造一个fragment的对象 instantiate这个方法 final Fragment frag = mFragmentManager.getFragmentFactory().instantiate( mContext.getClassLoader(), className); //3.如果不是dialogfragment的子类，就抛异常 if (!DialogFragment.class.isAssignableFrom(frag.getClass())) &#123; throw new IllegalArgumentException(&quot;Dialog destination &quot; + destination.getClassName() + &quot; is not an instance of DialogFragment&quot;); &#125; //4.强转成DialogFragment final DialogFragment dialogFragment = (DialogFragment) frag; dialogFragment.setArguments(args); dialogFragment.getLifecycle().addObserver(mObserver); //5.通过show方法就把dialogfragment展示出来 dialogFragment.show(mFragmentManager, DIALOG_TAG + mDialogCount++); return destination; &#125;&#125; 再来看FragmentNavigator 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697@Navigator.Name(&quot;fragment&quot;)public class FragmentNavigator extends Navigator&lt;FragmentNavigator.Destination&gt; &#123; public Destination createDestination() &#123; return new Destination(this); &#125; @NavDestination.ClassType(Fragment.class) public static class Destination extends NavDestination &#123; //同上，设置全类名 public final Destination setClassName(@NonNull String className) &#123; mClassName = className; return this; &#125; &#125; public NavDestination navigate(@NonNull Destination destination, @Nullable Bundle args, @Nullable NavOptions navOptions, @Nullable Navigator.Extras navigatorExtras) &#123; if (mFragmentManager.isStateSaved()) &#123; Log.i(TAG, &quot;Ignoring navigate() call: FragmentManager has already&quot; + &quot; saved its state&quot;); return null; &#125; //1.通过destination获取classname 全类名 String className = destination.getClassName(); if (className.charAt(0) == &#x27;.&#x27;) &#123; className = mContext.getPackageName() + className; &#125; //2.实例化一个fragment对象，并设置arguments final Fragment frag = instantiateFragment(mContext, mFragmentManager, className, args); frag.setArguments(args); //3.得到Transaction对象 final FragmentTransaction ft = mFragmentManager.beginTransaction(); //跳转动画 int enterAnim = navOptions != null ? navOptions.getEnterAnim() : -1; int exitAnim = navOptions != null ? navOptions.getExitAnim() : -1; int popEnterAnim = navOptions != null ? navOptions.getPopEnterAnim() : -1; int popExitAnim = navOptions != null ? navOptions.getPopExitAnim() : -1; if (enterAnim != -1 || exitAnim != -1 || popEnterAnim != -1 || popExitAnim != -1) &#123; enterAnim = enterAnim != -1 ? enterAnim : 0; exitAnim = exitAnim != -1 ? exitAnim : 0; popEnterAnim = popEnterAnim != -1 ? popEnterAnim : 0; popExitAnim = popExitAnim != -1 ? popExitAnim : 0; ft.setCustomAnimations(enterAnim, exitAnim, popEnterAnim, popExitAnim); &#125; //4.通过replace跳转，这种方式不好，会告诉页面生命周期重启，需要自己再构建一个使用hide和show的FragmentNavigator ft.replace(mContainerId, frag); ft.setPrimaryNavigationFragment(frag); final @IdRes int destId = destination.getId(); final boolean initialNavigation = mBackStack.isEmpty(); // TODO Build first class singleTop behavior for fragments final boolean isSingleTopReplacement = navOptions != null &amp;&amp; !initialNavigation &amp;&amp; navOptions.shouldLaunchSingleTop() &amp;&amp; mBackStack.peekLast() == destId; boolean isAdded; if (initialNavigation) &#123; isAdded = true; &#125; else if (isSingleTopReplacement) &#123; // Single Top means we only want one instance on the back stack if (mBackStack.size() &gt; 1) &#123; // If the Fragment to be replaced is on the FragmentManager&#x27;s // back stack, a simple replace() isn&#x27;t enough so we // remove it from the back stack and put our replacement // on the back stack in its place mFragmentManager.popBackStack( generateBackStackName(mBackStack.size(), mBackStack.peekLast()), FragmentManager.POP_BACK_STACK_INCLUSIVE); ft.addToBackStack(generateBackStackName(mBackStack.size(), destId)); &#125; isAdded = false; &#125; else &#123; ft.addToBackStack(generateBackStackName(mBackStack.size() + 1, destId)); isAdded = true; &#125; if (navigatorExtras instanceof Extras) &#123; Extras extras = (Extras) navigatorExtras; for (Map.Entry&lt;View, String&gt; sharedElement : extras.getSharedElements().entrySet()) &#123; ft.addSharedElement(sharedElement.getKey(), sharedElement.getValue()); &#125; &#125; ft.setReorderingAllowed(true); ft.commit(); // The commit succeeded, update our view of the world if (isAdded) &#123; mBackStack.add(destId); return destination; &#125; else &#123; return null; &#125; &#125;&#125; 最后来看NavGraphNavigator 1234567891011@Navigator.Name(&quot;navigation&quot;)public class NavGraphNavigator extends Navigator&lt;NavGraph&gt; &#123; //这里没有new Destination对象，而是new了一个NavGraph,传入Navigator public NavGraph createDestination() &#123; return new NavGraph(this); &#125; &#125; NavGraph.java 是NavDestination的子类，是特殊的子类 123456789public class NavGraph extends NavDestination implements Iterable&lt;NavDestination&gt; &#123; //node数组，这里就是存储了一个个跳转节点的的实例，也就是我们在 mobile_navigation.xml中声明的一个个fragment activity实例，都会被存储到mNodes中 final SparseArrayCompat&lt;NavDestination&gt; mNodes = new SparseArrayCompat&lt;&gt;(); //这个就是对应mobile_navigation.xml中指定的app:startDestination=&quot;@+id/navigation_dashboard&quot; 而一旦xml被解析，这里就获取到我们指定的页面id private int mStartDestId;&#125; 那么又是在哪里解析的，什么时候解析的呢？ 还记得我们上面的宿主fragment NavHostFragment 我们在oncreate中创建了NavHostController 我们看下Controller中的逻辑 123456789101112public class NavController &#123; public void setGraph(@NavigationRes int graphResId) &#123; setGraph(graphResId, null); &#125; public void setGraph(@NavigationRes int graphResId, @Nullable Bundle startDestinationArgs) &#123; //调用navinflater的inflate方法来解析xml文件 setGraph(getNavInflater().inflate(graphResId), startDestinationArgs); &#125;&#125; 这个inflate方法 12345678910111213141516171819202122232425262728293031323334public NavGraph inflate(@NavigationRes int graphResId) &#123; Resources res = mContext.getResources(); //1.获取xml parser来解析xml文件 XmlResourceParser parser = res.getXml(graphResId); //2.获取属性 final AttributeSet attrs = Xml.asAttributeSet(parser); try &#123; int type; while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; // Empty loop &#125; if (type != XmlPullParser.START_TAG) &#123; throw new XmlPullParserException(&quot;No start tag found&quot;); &#125; String rootElement = parser.getName(); //3.实际上是另一个inflate方法来解析构造出的具体的NavDestion对象 这里主要通过parser获取标签名，再通过name 在provider中拿到navigator 再通过navigator来创建各自的navigation NavDestination destination = inflate(res, parser, attrs, graphResId); if (!(destination instanceof NavGraph)) &#123; throw new IllegalArgumentException(&quot;Root element &lt;&quot; + rootElement + &quot;&gt;&quot; + &quot; did not inflate into a NavGraph&quot;); &#125; return (NavGraph) destination; &#125; catch (Exception e) &#123; //也就是说我们在编写mobile_navigation.xml中的根节点必须是navigation 否则解析后会抛出异常 throw new RuntimeException(&quot;Exception inflating &quot; + res.getResourceName(graphResId) + &quot; line &quot; + parser.getLineNumber(), e); &#125; finally &#123; parser.close(); &#125;&#125; 通过navigator来创建具体的跳转navigation实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051private NavDestination inflate(@NonNull Resources res, @NonNull XmlResourceParser parser, @NonNull AttributeSet attrs, int graphResId) throws XmlPullParserException, IOException &#123; //1.通过provider获取具体的navigator对象 parser.getName 得到的就是标签的名fragment dialog activity Navigator&lt;?&gt; navigator = mNavigatorProvider.getNavigator(parser.getName()); //2.得到navigator后，就通过调用 createDestination方法来得到创建NavDestination 最后也是返回的是这个dest final NavDestination dest = navigator.createDestination(); dest.onInflate(mContext, attrs); final int innerDepth = parser.getDepth() + 1; int type; int depth; while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; ((depth = parser.getDepth()) &gt;= innerDepth || type != XmlPullParser.END_TAG)) &#123; if (type != XmlPullParser.START_TAG) &#123; continue; &#125; if (depth &gt; innerDepth) &#123; continue; &#125; final String name = parser.getName(); //3.中间解析各个子标签 //如查是argument标签，就把argument数据inflate到destination中 if (TAG_ARGUMENT.equals(name)) &#123; inflateArgumentForDestination(res, dest, attrs, graphResId); &#125; else if (TAG_DEEP_LINK.equals(name)) &#123; //如果是deeplink 就把信息inflate到destination inflateDeepLink(res, dest, attrs); &#125; else if (TAG_ACTION.equals(name)) &#123; //如果是action就把信息infalte到destinatioin中的actioin中 inflateAction(res, dest, attrs, parser, graphResId); &#125; else if (TAG_INCLUDE.equals(name) &amp;&amp; dest instanceof NavGraph) &#123; final TypedArray a = res.obtainAttributes( attrs, androidx.navigation.R.styleable.NavInclude); final int id = a.getResourceId( androidx.navigation.R.styleable.NavInclude_graph, 0); ((NavGraph) dest).addDestination(inflate(id)); a.recycle(); //如查是NavGraph &#125; else if (dest instanceof NavGraph) &#123; //就递归去调用 inflate解析子标签，然后把子标签生成的destinatioin加入到NavGraph的mNodes中去 ((NavGraph) dest).addDestination(inflate(res, parser, attrs, graphResId)); &#125; &#125; return dest;&#125; 解析完Navgraph后，把graph和controller相关联 12345678910public void setGraph(@NonNull NavGraph graph, @Nullable Bundle startDestinationArgs) &#123; if (mGraph != null) &#123; // Pop everything from the old graph off the back stack popBackStackInternal(mGraph.getId(), true); &#125; //把graph 赋值给controller中的mGraph变量 mGraph = graph; //这里就会把默认显示的页面给打开 onGraphCreated(startDestinationArgs);&#125; 回头看看NavGraphNavigator.java 的navigate方法 1234567891011121314151617181920212223public NavDestination navigate(@NonNull NavGraph destination, @Nullable Bundle args, @Nullable NavOptions navOptions, @Nullable Extras navigatorExtras) &#123; //拿到默认展示页面的id int startId = destination.getStartDestination(); if (startId == 0) &#123; throw new IllegalStateException(&quot;no start destination defined via&quot; + &quot; app:startDestination for &quot; + destination.getDisplayName()); &#125; //有这个id后，就能拿到默认展示页面的destination对象 NavDestination startDestination = destination.findNode(startId, false); if (startDestination == null) &#123; final String dest = destination.getStartDestDisplayName(); throw new IllegalArgumentException(&quot;navigation destination &quot; + dest + &quot; is not a direct child of this NavGraph&quot;); &#125; //然后通过name在provider中拿到navigator 这个navigator可能是fragmentnavigator activitynavigator dialognavigator Navigator&lt;NavDestination&gt; navigator = mNavigatorProvider.getNavigator( startDestination.getNavigatorName()); //执行具体的navigator的naigate方法把默认页面启动起来 return navigator.navigate(startDestination, startDestination.addInDefaultArgs(args), navOptions, navigatorExtras);&#125; Navigation各类之间的关系","categories":[],"tags":[]},{"title":"Gradle基础","slug":"Gradle基础","date":"2022-02-08T20:40:17.000Z","updated":"2022-02-09T22:21:28.000Z","comments":true,"path":"2022/02/09/Gradle基础/","link":"","permalink":"http://example.com/2022/02/09/Gradle%E5%9F%BA%E7%A1%80/","excerpt":"讲解Gradle基础知识，语法及生命周期","text":"讲解Gradle基础知识，语法及生命周期 Gradle 基础使用 .&#x2F;gradlew clean -q 来过滤只显示我们的自己的输出日志 一 语法1.1 基础语法123456789101112131415161718192021222324252627int a = 10def b = 10String str = &quot;Hello,&quot; + &quot;World&quot;String str2 = str.toUpperCase()//列表def array = [1,2,3,4]array.add(5)array.each&#123;//闭包特性，只有一个参数默认为it 可以省略 it -&gt; 不写 println(&quot;each item is $it&quot;)&#125;//映射表def map = [&quot;name&quot;:&quot;mooc&quot;,&quot;age&quot;:&quot;100&quot;]println(&quot;age is $&#123;map[&quot;age&quot;]&#125;&quot;)//循环for(int i = 0;i&lt;10;i++)&#123; println(&quot;i is $i&quot;)&#125;//函数def hello(String name)&#123; println(&quot;Hello, $name&quot;)&#125; 1.2 DSL Domain Specific Language 领域专用语言 只能用于构建，不能干别的，所以说是领域专用语言 这个是android build.gradle 的DSL 12345678910111213141516171819202122232425262728android &#123; compileSdkVersion 30 buildToolsVersion &quot;30.0.3&quot; defaultConfig &#123; applicationId &quot;com.steve.gradle_study&quot; minSdkVersion 21 targetSdkVersion 30 versionCode 1 versionName &quot;1.0&quot; testInstrumentationRunner &quot;androidx.test.runner.AndroidJUnitRunner&quot; &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile(&#x27;proguard-android-optimize.txt&#x27;), &#x27;proguard-rules.pro&#x27; &#125; &#125; compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 &#125; kotlinOptions &#123; jvmTarget = &#x27;1.8&#x27; &#125;&#125; 1.3 闭包DSL的实现是基于groovy中的闭包实现的 开放匿名的代码块，可以接受参数，具有返回值，也可以被分配给变量 定义规则:{ [params -&gt; ] statements } 123456789101112131415161718def c = &#123; println(&quot;hello closure&quot;)&#125;c()def c2 = &#123; it -&gt; println (&quot;it is $it&quot;)&#125;c2(&quot;yt&quot;)def c3 = &#123; println (&quot;it is $it&quot;)&#125;c3(&quot;yt&quot;)def c4 = &#123; name,age -&gt; println (&quot;name is $name&quot;) println (&quot;age is $age&quot;)&#125;c4(&quot;wwww&quot;,33) 1.4 实现自己的DSL123456&#123; compileSdkVersion 25 defaultConfig&#123; versionName &quot;1.0&quot; &#125;&#125; 用户配置成这样，我们怎么能取到对应的配置的值，使用对象关联起来 里面的defaultconfig 闭包对应的对象 123456class DefalutConfig&#123; private String versionName def versionName(String versionName)&#123; this.versionName = versionName &#125;&#125; 外面的android 闭包对应的对象 1234567891011121314151617181920class Android&#123; private int compileSdkVersion private DefalutConfig defalutConfig Android()&#123; this.defalutConfig = new DefalutConfig() &#125; def compileSdkVersion(int compileSdkVersion)&#123; this.compileSdkVersion =compileSdkVersion &#125; //传入一个闭包，接收到闭包后跟我们的DefaultConfig成员变量关联起来 def defaultConfig(Closure closure)&#123; //关联之后，对象就获到到闭包中对应同名的值了 closure.setDelegate(defalutConfig) closure.call() &#125;&#125; 使用 123456789101112def myAndroid = &#123; compileSdkVersion 25 defaultConfig&#123; versionName &quot;1.0&quot; &#125;&#125;Android a = new Android()//将闭包与具体对象关联起来，这样在闭包中设置的值就到了对象a中了，我们可以打印a 获取a中的值myAndroid.delegate = amyAndroid.call() 运行 1./graldew clean -q 二 Gradle构建脚本基础几个关键的文件 settings.gradle—定义全局参与构建的模块 build.gradle—有两类build.gradle文件，一个是全局的定义共用参数，各个单独的定义自己的配置 gradle.properties—定义开关型参数的文件 三 Gradle构建的生命周期 初始化阶段—收集所有要参与构建的子工程，创建一个项目层次结构，并且为每一个项目创建一个project实例，和这个阶段关系最大的就是我们的settings.gradle文件 配置阶段—执行各个子工程自己的build.gradle，对project进行配置，并且根据配置形成一个任务依赖链，以便在下一个阶段执行阶段，方便执行任务 执行阶段—执行上一阶段的tasks 我们在settings.gradle中添加生命周期的监听函数 1234567891011121314151617181920//添加构建的生命周期gradle.addBuildListener(new BuildAdapter()&#123; @Override void settingsEvaluated(Settings settings) &#123; super.settingsEvaluated(settings) println (&quot;[life-cycle] 初始化阶段完成&quot;) &#125; @Override void projectsEvaluated(Gradle gradle) &#123; super.projectsEvaluated(gradle) println (&quot;[life-cycle] 配置阶段完成&quot;) &#125; @Override void buildFinished(BuildResult result) &#123; super.buildFinished(result) println (&quot;[life-cycle] 构建结束&quot;) &#125;&#125;) 打印结果 几个主要角色 初始化阶段-root project 配置阶段-project 执行阶段-task","categories":[],"tags":[]},{"title":"Kotlin 委托属性","slug":"Kotlin-委托属性","date":"2022-02-06T22:06:04.000Z","updated":"2022-02-09T00:14:15.000Z","comments":true,"path":"2022/02/07/Kotlin-委托属性/","link":"","permalink":"http://example.com/2022/02/07/Kotlin-%E5%A7%94%E6%89%98%E5%B1%9E%E6%80%A7/","excerpt":"","text":"Kotlin委托属性Kotlin常见的委托属性包括两种：延迟属性(lazy properties) 与可观察属性(observable properties)。 委托属性的语法1var/val &lt;属性名&gt;:&lt;类型&gt; by &lt;表达式&gt; 用例123val INSTANCE:Singleton by lazy(mode = LazyThreadSafetyMode.SYNCHRONIZED)&#123; Singleton()&#125; 这里所说的委托就是在by 后面的表达式； 属性对应的get()（与set()）会被委托给它的getValue()与setValue()函数； 属性的委托需要提供一个getValue函数； 接下来我们重点介绍下上文中我们用到的延迟属性lazy: 在Lazy.kt 文件中，声明了Lazy接口的getValue扩展函数，所以最终赋值的时候会调用该函数： 12@kotlin .interal.InlineOnlypublic inline operator fun &lt;T&gt; Lazy&lt;T&gt;.getValue(thieRef:Any?,property:KProperty&lt;*&gt;):T = value","categories":[],"tags":[]},{"title":"Vue - 动画","slug":"Vue-动画","date":"2022-02-02T10:39:12.000Z","updated":"2022-02-06T03:58:29.000Z","comments":true,"path":"2022/02/02/Vue-动画/","link":"","permalink":"http://example.com/2022/02/02/Vue-%E5%8A%A8%E7%94%BB/","excerpt":"","text":"在CSS过渡和动画中自动应用class 可以配合使用第三方CSS动画库，如Animate.css 在过渡钩子函数中使用JavaScript直接操作DOM 可以配合全名用第三方JavaScript动画库，如Velocity.js","categories":[],"tags":[]},{"title":"Kotlin 单例object & Kotlin和 Java 单例模式","slug":"kotlin 单例","date":"2022-02-02T08:29:10.000Z","updated":"2022-02-09T00:14:06.000Z","comments":true,"path":"2022/02/02/kotlin 单例/","link":"","permalink":"http://example.com/2022/02/02/kotlin%20%E5%8D%95%E4%BE%8B/","excerpt":"","text":"单例objectobject的定义Java123public class Singleton&#123; public static final Singleton INSTANCE = new Singleton();&#125; Kotlin1object Singleton&#123;&#125;//定义单例，类加载时实例化对象Singleton既是类名也是对象名 饿汉式——类一旦加载就马上初始化 访问object的成员Kotlin1234object Singleton&#123; var x:Int = 2 fun y()&#123;...&#125;&#125; 12Singleton.xSingleton.y Java123Singleton.INSTANCE.getX();Singleton.INSTANCE.setX(2);Singleton.INSTANCE.y(); 静态成员 @JvmStatic kotlin中没有静态成员，想要模拟需要@JvmStatic 注解 Kotlin1234object Singleton&#123; @JvmStatic var x:Int = 2 @JvmStatic fun y()&#123;...&#125;&#125; 12Singleton.xSingleton.y() Java123Singleton.getX();Singleton.setX(2);Singleton.y(); object的成员直接按照Java静态成员生成字节码，对Kotlin内部使用无任何影响，Java调用object成员可直接视同调用静态成员一般。 不生成getter&#x2F;setter @JvmFieldKotlin1234object Singleton&#123; @JvmField var x:Int = 2 @JvmField fun y()&#123;...&#125;&#125; 12Singleton.xSingleton.y() 这里object 会生成静态的，如果不是object 其实不会生成静态的 Java12Singleton.x; //属性x不生成getter/setter 访问方式等同于java fieldSingleton.y(); 普通类的静态成员123class Foo&#123; @JvmStatic fun y()&#123;&#125; //Only members in named ojbects and companion objects can be annotated with &#x27;@JvmStatic&#x27;&#125; Kotlin12345class Foo&#123; companion object&#123; @JvmStatic fun y()&#123;&#125; &#125;&#125; Java123public class Foo&#123; public static void y()&#123;&#125;&#125; 123class Foo&#123; @JvmField var x:Int = 2 // 生成非静态的Field 不带getter/setter的写法&#125; Kotlin和 Java 单例模式饿汉式 空间换时间 Java 1234567public class Singleton1Java &#123; public static Singleton1Java INSTANCE = new Singleton1Java(); public static Singleton1Java getInstance()&#123; return INSTANCE; &#125;&#125; Kotlin 1object Singleton1Kotlin &#123;&#125; Kotlin to Java 1234567public final class Singleton1Kotlin &#123; @NotNull public static final Singleton1Kotlin INSTANCE = new Singleton1Kotlin(); private Singleton1Kotlin() &#123; &#125;&#125; 懒汉式 时间换空间","categories":[],"tags":[]},{"title":"借助v2ray,记一次VPN内网穿透实践","slug":"记一次vpn内网穿透实践","date":"2022-02-02T08:29:10.000Z","updated":"2022-02-09T00:14:29.000Z","comments":true,"path":"2022/02/02/记一次vpn内网穿透实践/","link":"","permalink":"http://example.com/2022/02/02/%E8%AE%B0%E4%B8%80%E6%AC%A1vpn%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%AE%9E%E8%B7%B5/","excerpt":"花了一天搞了下公司的内网穿透，先给出参考的链接原文及原理，再给出自己的实践记录，可以直接拷贝，换下端口和你们阿里云(或者自己使用的云，这里都以阿里云做例子)的外网IP就OK了","text":"花了一天搞了下公司的内网穿透，先给出参考的链接原文及原理，再给出自己的实践记录，可以直接拷贝，换下端口和你们阿里云(或者自己使用的云，这里都以阿里云做例子)的外网IP就OK了 反向代理&#x2F;内网穿透 原理简单点说，就是，最终实现了，你在家里，通过阿里云服务器，通过公司的局域网服务器来访问公司的局域网资源，这个特别适用于，你个人没法使用公司外网IP做内网映射，局域网服务器(或者在公司的某一台电脑)可以访问外网的情况。当然更习惯于用远程的当我没说。原理就是，两个服务器都部署v2ray，然后公司的局域网连接阿里云服务器，再反向代理回来，最终客户机通过客户端连接阿里云服务器，最终通过公司的服务器访问内网。 配置1.阿里云服务器先配置中间的阿里云服务器，别忘了阿里云服务器要保证你的vpn服务的端口要设置为开放状态，因为本来是要客户机和内网的服务器走两个inbounds的，但还需要让领导再开一个端口就没好意思提，这里用同一个vemess inbound 来接收来自两端的请求，做简化处理也是可行的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&#123; &quot;reverse&quot;:&#123;//反向代理设置，正常搭vpn不需要 &quot;portals&quot;:[ &#123; &quot;tag&quot;:&quot;portal&quot;, &quot;domain&quot;:&quot;private.cloud.com&quot; //这个域名可以随便取，但要和下面保持一致 &#125; ] &#125;, &quot;log&quot;: &#123; &quot;access&quot;: &quot;&quot;, &quot;error&quot;: &quot;&quot;, &quot;loglevel&quot;: &quot;warning&quot; &#125;, &quot;inbounds&quot;: [ &#123; &quot;tag&quot;:&quot;interconn&quot;, &quot;port&quot;: 10086, //开放的端口 &quot;protocol&quot;: &quot;vmess&quot;, &quot;settings&quot;: &#123; &quot;clients&quot;: [//设置访问账户的id 可随机生成 但要注意对应 &#123; &quot;id&quot;: &quot;0c15dd83-3552-4b53-b835-907e6c262d9b&quot;, &quot;alterId&quot;: 64 &#125; ] &#125; &#125; ], &quot;routing&quot;:&#123; &quot;rules&quot;:[ &#123; &quot;type&quot;:&quot;field&quot;, &quot;inboundTag&quot;:[ &quot;external&quot; ], &quot;outboundTag&quot;:&quot;portal&quot; &#125;, &#123; &quot;type&quot;:&quot;field&quot;, &quot;inboundTag&quot;:[ &quot;tunnel&quot; ], &quot;domain&quot;:[ &quot;full:private.cloud.com&quot; ], &quot;outboundTag&quot;:&quot;portal&quot; &#125; ] &#125;&#125; 因为公司阿里云服务器是windows服务器，所以也学习了下windows版本的v2ray服务器的部署，其实非常简单。 网上下载v2ray-windows-64 v2ray.exe执行就是把控制台显示出来并启动v2ray，它会自动使用当前目录下的config配置，可以看到访问的ip wv2ray.exe也是启动v2ray，但是它是后台启动，能在任务进程中看到及关闭该进程服务 2.内网服务器因为一直拉取github的内容拉不下来，自动安装一直不成功，所以内网的linux服务器是手动部署的，其实效果是一样的，就是稍微麻烦些 v2ray完全使用教程 2-2手动安装 我这里是通过自己的电脑下载下来v2ray-linux-64.zip 然后scp到服务器上解压，然后进行手动部署的 然后把各个文件mv到相应的目录中 123456sudo mkdir /etc/v2ray /usr/bin/v2ray /var/log/v2ray # 创建目录sudo chmod +x v2ray v2ctl # 赋予可执行权限sudo mv v2ray v2ctl geoip.dat geosite.dat -t /usr/bin/v2ray # 移动文件touch /etc/v2ray/config.json # 仅创建配置文件的空文件sudo mv systemd/v2ray.service /etc/systemd/system/sudo systemctl enable v2ray # 用于程序开机启动并且崩溃时自动重启程序 但要注意对应的目录，而且要看下v2ray.service中的配置，执行的命令的v2ray相应的文件是否存在，在这里卡了好久，一直启不起来服务，结果发现是v2ray和config.json相应的目录不对 12345678#启用和禁用sudo systemctl enable v2raysudo systemctl disable v2ray#启动、停止、重启v2raysudo systemctl start v2raysudo systemctl stop v2raysudo systemctl restart v2ray 下面给出内网服务器的配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&#123; &quot;reverse&quot;:&#123; &quot;bridges&quot;:[ &#123; &quot;tag&quot;:&quot;bridge&quot;, &quot;domain&quot;:&quot;private.cloud.com&quot; // A 和 B 反向代理通信的域名，可以自己取一个，可以不是自己购买的域名，但必须跟上面 阿里云 中的 reverse 配置的域名一致 &#125; ] &#125;, &quot;outbounds&quot;:[ &#123; //内网连接阿里云的outbound &quot;tag&quot;:&quot;tunnel&quot;, &quot;protocol&quot;:&quot;vmess&quot;, &quot;settings&quot;:&#123; &quot;vnext&quot;:[ &#123; &quot;address&quot;:&quot;serveraddr.com&quot;, // 阿里云外网 地址，IP 或 实际的域名 &quot;port&quot;:10086, &quot;users&quot;:[ &#123; &quot;id&quot;:&quot;0c15dd83-3552-4b53-b835-907e6c262d9b&quot;, &quot;alterId&quot;:64 &#125; ] &#125; ] &#125; &#125;, // 另一个 outbound，最终连接私有网盘 &#123; &quot;protocol&quot;:&quot;freedom&quot;, &quot;settings&quot;:&#123; &#125;, &quot;tag&quot;:&quot;out&quot; &#125; ], &quot;routing&quot;:&#123; &quot;rules&quot;:[ &#123; // 配置 A 主动连接 B 的路由规则 &quot;type&quot;:&quot;field&quot;, &quot;inboundTag&quot;:[ &quot;bridge&quot; ], &quot;domain&quot;:[ &quot;full:private.cloud.com&quot; ], &quot;outboundTag&quot;:&quot;tunnel&quot; &#125;, &#123; // 反向连接访问私有网盘的规则 &quot;type&quot;:&quot;field&quot;, &quot;inboundTag&quot;:[ &quot;bridge&quot; ], &quot;outboundTag&quot;:&quot;out&quot; &#125; ] &#125;&#125; 3.客户端配置看你使用的系统，我的是客户端设置完后自动生成json的，没啥特殊要说的，可以自己生成，也可以直接使用这个配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&#123; &quot;routing&quot; : &#123; &quot;name&quot; : &quot;all_to_main&quot;, &quot;domainStrategy&quot; : &quot;AsIs&quot;, &quot;rules&quot; : [ &#123; &quot;type&quot; : &quot;field&quot;, &quot;outboundTag&quot; : &quot;ip_60&quot;, &quot;port&quot; : &quot;0-65535&quot; &#125; ] &#125;, &quot;inbounds&quot; : [ &#123; &quot;listen&quot; : &quot;127.0.0.1&quot;, &quot;protocol&quot; : &quot;socks&quot;, &quot;settings&quot; : &#123; &quot;ip&quot; : &quot;127.0.0.1&quot;, &quot;auth&quot; : &quot;noauth&quot;, &quot;udp&quot; : false &#125;, &quot;tag&quot; : &quot;socksinbound&quot;, &quot;port&quot; : 1081 &#125;, &#123; &quot;listen&quot; : &quot;127.0.0.1&quot;, &quot;protocol&quot; : &quot;http&quot;, &quot;settings&quot; : &#123; &quot;timeout&quot; : 0 &#125;, &quot;tag&quot; : &quot;httpinbound&quot;, &quot;port&quot; : 8001 &#125; ], &quot;dns&quot; : &#123; &quot;servers&quot; : [ &quot;localhost&quot; ] &#125;, &quot;log&quot; : &#123; &quot;loglevel&quot; : &quot;info&quot; &#125;, &quot;outbounds&quot; : [ &#123; &quot;sendThrough&quot; : &quot;0.0.0.0&quot;, &quot;mux&quot; : &#123; &quot;enabled&quot; : false, &quot;concurrency&quot; : 8 &#125;, &quot;protocol&quot; : &quot;vmess&quot;, &quot;settings&quot; : &#123; &quot;vnext&quot; : [ &#123; &quot;address&quot; : &quot;serveraddr.com&quot;, &quot;users&quot; : [ &#123; &quot;id&quot; : &quot;0c15dd83-3552-4b53-b835-907e6c262d9b&quot;, &quot;alterId&quot; : 64, &quot;security&quot; : &quot;auto&quot;, &quot;level&quot; : 0 &#125; ], &quot;port&quot; : 10086 &#125; ] &#125;, &quot;tag&quot; : &quot;ip_60&quot;, &quot;streamSettings&quot; : &#123; &quot;wsSettings&quot; : &#123; &quot;path&quot; : &quot;&quot;, &quot;headers&quot; : &#123; &#125; &#125;, &quot;quicSettings&quot; : &#123; &quot;key&quot; : &quot;&quot;, &quot;header&quot; : &#123; &quot;type&quot; : &quot;none&quot; &#125;, &quot;security&quot; : &quot;none&quot; &#125;, &quot;tlsSettings&quot; : &#123; &quot;allowInsecure&quot; : false, &quot;alpn&quot; : [ &quot;http\\/1.1&quot; ], &quot;serverName&quot; : &quot;server.cc&quot;, &quot;allowInsecureCiphers&quot; : false &#125;, &quot;httpSettings&quot; : &#123; &quot;path&quot; : &quot;&quot; &#125;, &quot;kcpSettings&quot; : &#123; &quot;header&quot; : &#123; &quot;type&quot; : &quot;none&quot; &#125;, &quot;mtu&quot; : 1350, &quot;congestion&quot; : false, &quot;tti&quot; : 20, &quot;uplinkCapacity&quot; : 5, &quot;writeBufferSize&quot; : 1, &quot;readBufferSize&quot; : 1, &quot;downlinkCapacity&quot; : 20 &#125;, &quot;tcpSettings&quot; : &#123; &quot;header&quot; : &#123; &quot;type&quot; : &quot;none&quot; &#125; &#125;, &quot;security&quot; : &quot;none&quot;, &quot;network&quot; : &quot;tcp&quot; &#125; &#125; ]&#125;","categories":[],"tags":[]}],"categories":[],"tags":[]}