{"meta":{"title":"SteveZhang博客","subtitle":"","description":"","author":"张龙","url":"http://example.com","root":"/"},"pages":[{"title":"分类","date":"2022-02-17T19:39:33.000Z","updated":"2022-02-17T19:44:01.000Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-02-17T19:42:42.000Z","updated":"2022-02-17T19:43:25.000Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"CMake学习笔记","slug":"CMake学习笔记","date":"2022-11-17T07:51:27.000Z","updated":"2022-11-17T07:56:14.000Z","comments":true,"path":"2022/11/17/CMake学习笔记/","link":"","permalink":"http://example.com/2022/11/17/CMake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"","categories":[{"name":"NDK","slug":"NDK","permalink":"http://example.com/categories/NDK/"}],"tags":[]},{"title":"CMake语言-详解CMakeLists.txt[转]","slug":"CMake语言-详解CMakeLists-txt-转","date":"2022-11-17T06:45:47.000Z","updated":"2022-11-17T07:56:14.000Z","comments":true,"path":"2022/11/17/CMake语言-详解CMakeLists-txt-转/","link":"","permalink":"http://example.com/2022/11/17/CMake%E8%AF%AD%E8%A8%80-%E8%AF%A6%E8%A7%A3CMakeLists-txt-%E8%BD%AC/","excerpt":"","text":"https://www.jianshu.com/p/528eeb266f83 作者：红橙Darren CMake 是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装(编译过程)。他能够输出各种各样的 Makefile 或者 project 文件，CMake 并不直接建构出最终的软件，而是产生标准的建构档（如 Makefile 或 projects）。 以前做 NDK 开发都是基于 Android.mk、Application.mk 来构建项目的，但从 AS 2.2 之后便开始采用 CMake 的这种方式来构建，采用 CMake 相比与之前的 Android.mk、Application.mk 方便简单了许多。但公司有一些古老的项目还是采用 Android.mk 和 Application.mk 来构建的，因此大家还是有必要花些时间去了解这种构建方式。但重心得放在 CMake 的构建方式上，因此本文主要来说说 CMake 的构建语法基础。 语法和关键字要大家全部记住是不太可能的，个人也不建议大家去死记硬背。我们只需要知道目前有哪些内容，需要生成哪些内容即可，有不太了解甚至不知道的可以查笔记或资料。我们来详细看下以下四个事例，相信对于以后的 CMake 构建基本就可以不怕了。 1. 初试 cmake 的 helloworld现在新建一个 hello.cpp 源码文件，代码如下： 1234#include &lt;stdio.h&gt;int main(int argc, char* argv[])&#123; printf(&quot;Hello CMake!\\n&quot;);&#125; 之前都是采用 gcc hello.cpp -o hello 命令来生成可执行文件，但现在我们用 CMake 这种方式来生成，新建一个 CMakeLists.txt 文件名大小写都按照这个来： 12345678910111213141516# 指定工程名PROJECT (HELLO)# 现阶段，你只需要了解 SET 指令可以用来显式的定义变量即可# 将 hello.cpp 赋值给 SRC_LIST 变量，也可以指定多个源文件，用空格隔开# SET(SRC_LIST hello.cpp add.cpp sub.cpp)SET(SRC_LIST hello.cpp)# 输出打印构建目录MESSAGE(STATUS &quot;This is HELLO_BINARY_DIR &quot; $&#123;HELLO_BINARY_DIR&#125;)# 输出打印资源目录MESSAGE(STATUS &quot;This is HELLO_SOURCE_DIR &quot; $&#123;HELLO_SOURCE_DIR&#125;)# 输出打印资源目录，与HELLO_SOURCE_DIR 一样 MESSAGE(STATUS &quot;This is PROJECT_SOURCE_DIR &quot; $&#123;PROJECT_SOURCE_DIR&#125;)# 输出打印 CMake 资源目录，与 PROJECT_SOURCE_DIR 一样 MESSAGE(STATUS &quot;This is CMAKE_SOURCE_DIR &quot; $&#123;CMAKE_SOURCE_DIR&#125;)# 生成可执行文件 hello ，$&#123;SRC_LIST&#125;是引用变量，也就是源文件 hello.cppADD_EXECUTABLE(hello $&#123;SRC_LIST&#125;) 新建 build 目录，cd 到 build 目录下，敲 cmake .. 命令，ls 一下会发现 CMake 帮我们生成了 Makefile 等等一些文件。敲 make 命令生成 hello 可执行文件，ls 文件列表如下： 12ubuntu@VM-0-9-ubuntu:~/NDK_Day88/t1/build$ lsCMakeCache.txt CMakeFiles cmake_install.cmake hello Makefile 2. 构建生成 .so 动态库上面的例子看不出有啥优势，甚至说还不如用 gcc hello.cpp -o hello 来得快，但像 FFmpeg 、OpenCV 等等，类似这样复杂的项目，我们敲命令去构建项目是很麻烦的。下面我们来讲一个稍微复杂一点的例子： mkdir 新建 3 个目录分别为 src、libs、include 。src 用来存放源文件 add.ccp、sub.cpp、div.cpp。include 用来存放头文件 add.h、div.h、sub.h 。源码如下： 1234567891011121314#include &quot;add.h&quot;int add(int num1, int num2)&#123; return num1 + num2;&#125;#include &quot;sub.h&quot; int sub(int num1, int num2)&#123; return num1 - num2; &#125;#include &quot;div.h&quot; int div(int num1, int num2)&#123; return num1 / num2; &#125; 基于这些准备工作，我们想用 CMake 来构建一个 libmath.so 动态库，并且将其生成在 libs 目录文件夹下。 12345678910111213141516# 指定 cmake 最低编译版本CMAKE_MINIMUM_REQUIRED(VERSION 3.14)PROJECT (MATH)# 把当前工程目录下的 src 目录的下的所有 .cpp 和 .c 文件赋值给 SRC_LIST# AUX_SOURCE_DIRECTORY($&#123;PROJECT_SOURCE_DIR&#125;/src SRC_LIST)FILE(GLOB SRC_LIST &quot;$&#123;PROJECT_SOURCE_DIR&#125;/src/*.cpp&quot;)# 打印 SRC_LIST 文件列表# MESSAGE(STATUS $&#123;SRC_LIST&#125;)# 指定头文件目录INCLUDE_DIRECTORIES($&#123;PROJECT_SOURCE_DIR&#125;/include)# 指定输出 .so 动态库的目录位置SET(LIBRARY_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/lib)# 指定生成动态库ADD_LIBRARY(math SHARED $&#123;SRC_LIST&#125;)# 指定生成版本号，VERSION指代动态库版本，SOVERSION指代API版本# SET_TARGET_PROPERTIES(math PROPERTIES VERSION 1.2 SOVERSION 1) 3. 链接外部动态库和头文件将 libs 目录和 include 目录 copy 到 hello.cpp 同级目录下，修改 hello.cpp 源码如下： 12345678910111213#include &lt;stdio.h&gt;#include &quot;add.h&quot;#include &quot;sub.h&quot;#include &quot;div.h&quot;int main(int argc, char* argv[])&#123; int a = 20; int b = 10; printf(&quot;%d+%d=%d\\n&quot;,a,b,add(a,b)); printf(&quot;%d-%d=%d\\n&quot;,a,b,sub(a,b)); printf(&quot;%d/%d=%d\\n&quot;,a,b,div(a,b)); return 0;&#125; 现在我引用了 include 目录下的头文件，同时需要链接 libs 目录下的 libmath.so ，我们再次创建一个 CMakeLists.txt 来生成可执行文件 hello。 123456789101112# 指定cmake最低编译版本CMAKE_MINIMUM_REQUIRED(VERSION 3.14)# 指定工程的名称PROJECT(HELLO)#指定头文件目录位置INCLUDE_DIRECTORIES($&#123;PROJECT_SOURCE_DIR&#125;/include)#添加共享库搜索路径LINK_DIRECTORIES($&#123;PROJECT_SOURCE_DIR&#125;/lib)#生成可执行文件ADD_EXECUTABLE(hello hello.cpp)#为hello添加共享库链接TARGET_LINK_LIBRARIES(hello math) 4. 基于 FFmpeg 开发的 CMakeLists.txt音视频的播放，在线直播，音视频通话开发，后面可能都得基于 FFmpeg 来写。那么首先我们需要编译 .so 动态库，然后把动态库和头文件 copy 到 AS 来开发，这里我已经编译好了一个 3.3.9 的版本，至于怎么写 shell 编译脚本，会在下篇文章中介绍。目前大伙先直接拿过来用就行了。我把编译好的 .so 动态库和 include 目录拷贝到 AS 工程的 jniLibs 目录下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# For more information about using CMake with Android Studio, read the# documentation: https://d.android.com/studio/projects/add-native-code.html# Sets the minimum version of CMake required to build the native library.cmake_minimum_required(VERSION 3.4.1)# 需要引入我们头文件,以这个配置的目录为基准include_directories(src/main/jniLibs/include)include_directories(src/main/jniLibs/other)# Creates and names a library, sets it as either STATIC# or SHARED, and provides the relative paths to its source code.# You can define multiple libraries, and CMake builds them for you.# Gradle automatically packages shared libraries with your APK.#添加共享库搜索路径LINK_DIRECTORIES($&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs/armeabi)# 指定源文件目录AUX_SOURCE_DIRECTORY($&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp SRC_LIST)add_library( # Sets the name of the library. native-lib # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). # src/main/cpp/native-lib.cpp $&#123;SRC_LIST&#125; )# Searches for a specified prebuilt library and stores the path as a# variable. Because CMake includes system libraries in the search path by# default, you only need to specify the name of the public NDK library# you want to add. CMake verifies that the library exists before# completing its build.find_library( # Sets the name of the path variable. log-lib # Specifies the name of the NDK library that # you want CMake to locate. log)# Specifies libraries CMake should link to your target library. You# can link multiple libraries, such as libraries you define in this# build script, prebuilt third-party libraries, or system libraries.target_link_libraries( # Specifies the target library. # 链接额外的 ffmpeg 的编译 native-lib # 编解码(最重要的库) avcodec-57 # 设备信息 avdevice-57 # 滤镜特效处理库 avfilter-6 # 封装格式处理库 avformat-57 # 工具库(大部分库都需要这个库的支持) avutil-55 # 后期处理 postproc-54 # 音频采样数据格式转换库 swresample-2 # 视频像素数据格式转换 swscale-4 -landroid # Links the target library to the log library # included in the NDK. $&#123;log-lib&#125;) 在真正实际的开发过程中，可能会比这些事例要复杂，因此给的文档大家需要用心过一遍，实际开发过程中有些不会的，可以查阅文档或者笔记。下面我给一份真实项目开发的 CMake 给大家看一下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510#-------------------------------------------------------------------# This file is part of the CMake build system for OGRE# (Object-oriented Graphics Rendering Engine)# For the latest info, see http://www.ogre3d.org/## The contents of this file are placed in the public domain. Feel# free to make use of it in any way you like.#-------------------------------------------------------------------####################################################################### OGRE BUILD SYSTEM# Welcome to the CMake build system for OGRE.# This is the main file where we prepare the general build environment# and provide build configuration options.######################################################################cmake_minimum_required(VERSION 3.3.0)set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED ON)set(CMAKE_CXX_EXTENSIONS OFF)if(CMAKE_VS_PLATFORM_NAME STREQUAL &quot;Tegra-Android&quot;) set(CMAKE_LINK_LIBRARY_FLAG &quot;&quot;)endif()# Use relative paths# This is mostly to reduce path size for command-line limits on windowsif(WIN32) # This seems to break Xcode projects so definitely don&#x27;t enable on Apple builds set(CMAKE_USE_RELATIVE_PATHS true) set(CMAKE_SUPPRESS_REGENERATION true)endif()if (APPLE AND NOT ANDROID) SET(CMAKE_SIZEOF_VOID_P 4) set(CMAKE_XCODE_ATTRIBUTE_GCC_VERSION &quot;com.apple.compilers.llvm.clang.1_0&quot;) set(CMAKE_XCODE_ATTRIBUTE_CLANG_CXX_LANGUAGE_STANDARD &quot;c++11&quot;) set(CMAKE_XCODE_ATTRIBUTE_CLANG_CXX_LIBRARY &quot;libc++&quot;) # otherwise apple defines a macro named check that conflicts with boost add_definitions(-D__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES=0)endif ()project(OGRE)# Include necessary submodulesset(CMAKE_MODULE_PATH &quot;$&#123;OGRE_SOURCE_DIR&#125;/CMake&quot; &quot;$&#123;OGRE_SOURCE_DIR&#125;/CMake/Utils&quot; &quot;$&#123;OGRE_SOURCE_DIR&#125;/CMake/Packages&quot;)include(CMakeDependentOption)include(MacroLogFeature)include(OgreConfigTargets)include(PreprocessorUtils)set(OGRE_TEMPLATES_DIR &quot;$&#123;OGRE_SOURCE_DIR&#125;/CMake/Templates&quot;)set(OGRE_WORK_DIR $&#123;OGRE_BINARY_DIR&#125;)###################################################################### Set up the basic build environment#####################################################################if (NOT CMAKE_BUILD_TYPE) # CMake defaults to leaving CMAKE_BUILD_TYPE empty. This screws up # differentiation between debug and release builds. set(CMAKE_BUILD_TYPE &quot;RelWithDebInfo&quot; CACHE STRING &quot;Choose the type of build, options are: None (CMAKE_CXX_FLAGS or CMAKE_C_FLAGS used) Debug Release RelWithDebInfo MinSizeRel.&quot; FORCE)endif ()# determine Ogre version numbersinclude(OgreGetVersion)ogre_get_version($&#123;OGRE_SOURCE_DIR&#125;/OgreMain/include/OgrePrerequisites.h)message(STATUS &quot;Configuring OGRE $&#123;OGRE_VERSION&#125;&quot;)# Configure version file for use by scriptsconfigure_file(&quot;$&#123;OGRE_TEMPLATES_DIR&#125;/version.txt.in&quot; &quot;$&#123;OGRE_BINARY_DIR&#125;/version.txt&quot; @ONLY)# determine if we are compiling for a 32bit or 64bit systeminclude(CheckTypeSize)CHECK_TYPE_SIZE(&quot;void*&quot; OGRE_PTR_SIZE BUILTIN_TYPES_ONLY)if (OGRE_PTR_SIZE EQUAL 8) set(OGRE_PLATFORM_X64 TRUE)else () set(OGRE_PLATFORM_X64 FALSE)endif ()if (WIN32) # Create debug libraries with _d postfix set(CMAKE_DEBUG_POSTFIX &quot;_d&quot;)endif ()# Set compiler specific build flagsif (NOT ANDROID AND UNIX OR MINGW) include(CheckCXXCompilerFlag) check_cxx_compiler_flag(-msse OGRE_GCC_HAS_SSE) if (OGRE_GCC_HAS_SSE) set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -msse&quot;) endif ()endif()if(UNIX) # This is a set of sensible warnings that provide meaningful output set(OGRE_WARNING_FLAGS &quot;-Wall -Winit-self -Wcast-qual -Wwrite-strings -Wextra -Wundef -Wmissing-declarations -Wno-unused-parameter -Wshadow -Wno-missing-field-initializers -Wno-long-long&quot;) if (EMSCRIPTEN) set(OGRE_WARNING_FLAGS &quot;$&#123;OGRE_WARNING_FLAGS&#125; -Wno-warn-absolute-paths&quot;) endif () set(CMAKE_CXX_FLAGS &quot;$&#123;OGRE_WARNING_FLAGS&#125; $&#123;CMAKE_CXX_FLAGS&#125;&quot;)endif ()if (MSVC) add_definitions(-D_MT -D_USRDLL) # MSVC does not like Ogre::Singleton (header pragma is enough for MSVC2015+ though) add_definitions(/wd4661) if (CMAKE_BUILD_TOOL STREQUAL &quot;nmake&quot;) # set variable to state that we are using nmake makefiles set(NMAKE TRUE) endif () set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; /fp:fast&quot;) # Enable intrinsics on MSVC in debug mode set(CMAKE_CXX_FLAGS_DEBUG &quot;$&#123;CMAKE_CXX_FLAGS_DEBUG&#125; /Oi&quot;) if (CMAKE_CL_64) # Visual Studio bails out on debug builds in 64bit mode unless # this flag is set... set(CMAKE_CXX_FLAGS_DEBUG &quot;$&#123;CMAKE_CXX_FLAGS_DEBUG&#125; /bigobj&quot;) set(CMAKE_CXX_FLAGS_RELWITHDEBINFO &quot;$&#123;CMAKE_CXX_FLAGS_RELWITHDEBINFO&#125; /bigobj&quot;) endif () if (OGRE_PROJECT_FOLDERS) # Turn on the ability to create folders to organize projects (.vcproj) # It creates &quot;CMakePredefinedTargets&quot; folder by default and adds CMake # defined projects like INSTALL.vcproj and ZERO_CHECK.vcproj set_property(GLOBAL PROPERTY USE_FOLDERS ON) endif() if (MSVC_VERSION GREATER 1500 OR MSVC_VERSION EQUAL 1500) option(OGRE_BUILD_MSVC_MP &quot;Enable build with multiple processes in Visual Studio&quot; TRUE) else() set(OGRE_BUILD_MSVC_MP FALSE CACHE BOOL &quot;Compiler option /MP requires at least Visual Studio 2008 (VS9) or newer&quot; FORCE) endif() if(OGRE_BUILD_MSVC_MP) set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; /MP&quot;) endif () if(MSVC_VERSION GREATER 1400 OR MSVC_VERSION EQUAL 1400) option(OGRE_BUILD_MSVC_ZM &quot;Add /Zm256 compiler option to Visual Studio to fix PCH errors&quot; TRUE) else() set(OGRE_BUILD_MSVC_ZM FALSE CACHE BOOL &quot;Compiler option /Zm256 requires at least Visual Studio 2005 (VS8) or newer&quot; FORCE) endif() if(OGRE_BUILD_MSVC_ZM) set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; /Zm256&quot;) endif ()endif ()if (MINGW) add_definitions(-D_WIN32_WINNT=0x0501) if( CMAKE_SIZEOF_VOID_P EQUAL 4 ) # set architecture to i686, since otherwise some versions of MinGW can&#x27;t link # the atomic primitives set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -march=i686&quot;) endif () # disable this optimisation because it breaks release builds (reason unknown) set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -fno-tree-slp-vectorize&quot;) # Ignore some really annoying warnings which also happen in dependencies set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -Wno-error=cast-qual -Wno-unused-local-typedefs&quot;)endif ()include(GenerateExportHeader)set(CMAKE_CXX_VISIBILITY_PRESET hidden)set(CMAKE_VISIBILITY_INLINES_HIDDEN TRUE)if((CMAKE_CXX_COMPILER_ID MATCHES &quot;Clang|GNU&quot;) AND NOT OGRE_STATIC) set(OGRE_VISIBILITY_FLAGS &quot;-DOGRE_GCC_VISIBILITY&quot;) # for legacy headersendif()# determine system endianessif (MSVC OR ANDROID OR EMSCRIPTEN OR APPLE_IOS) # This doesn&#x27;t work on VS 2010 # MSVC only builds for intel anyway # all IOS devices are little endian set(OGRE_TEST_BIG_ENDIAN FALSE)else() include(TestBigEndian) test_big_endian(OGRE_TEST_BIG_ENDIAN)endif()# Add OgreMain include pathif (APPLE_IOS) # Set static early for proper dependency detection set(OGRE_STATIC TRUE)endif()# definitions for samplesset(OGRE_LIBRARIES OgreMain)set(OGRE_MeshLodGenerator_LIBRARIES OgreMeshLodGenerator)set(OGRE_Paging_LIBRARIES OgrePaging)set(OGRE_Terrain_LIBRARIES OgreTerrain)set(OGRE_Volume_LIBRARIES OgreVolume)set(OGRE_Plugin_PCZSceneManager_LIBRARIES Plugin_PCZSceneManager)set(OGRE_Plugin_OctreeZone_LIBRARIES Plugin_OctreeZone)# Specify build pathsset(CMAKE_ARCHIVE_OUTPUT_DIRECTORY &quot;$&#123;OGRE_BINARY_DIR&#125;/lib&quot;)set(CMAKE_LIBRARY_OUTPUT_DIRECTORY &quot;$&#123;OGRE_BINARY_DIR&#125;/lib&quot;)set(CMAKE_RUNTIME_OUTPUT_DIRECTORY &quot;$&#123;OGRE_BINARY_DIR&#125;/bin&quot;)if (WIN32 OR APPLE) if (CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT) # We don&#x27;t want to install in default system location, install is really for the SDK, so call it that set(CMAKE_INSTALL_PREFIX &quot;$&#123;OGRE_BINARY_DIR&#125;/sdk&quot; CACHE PATH &quot;OGRE install prefix&quot; FORCE ) endif (CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)endif(WIN32 OR APPLE)# Set up iOS overrides.if (APPLE_IOS) set(CMAKE_EXE_LINKER_FLAGS &quot;-framework OpenGLES -framework Foundation -framework CoreGraphics -framework QuartzCore -framework UIKit&quot;) set(XCODE_ATTRIBUTE_GCC_UNROLL_LOOPS &quot;YES&quot;) set(XCODE_ATTRIBUTE_LLVM_VECTORIZE_LOOPS &quot;YES&quot;) set(XCODE_ATTRIBUTE_CODE_SIGN_IDENTITY &quot;iPhone Developer&quot;) set(XCODE_ATTRIBUTE_GCC_PRECOMPILE_PREFIX_HEADER &quot;YES&quot;) set(OGRE_BUILD_RENDERSYSTEM_GLES2 TRUE CACHE BOOL &quot;Forcing OpenGL ES 2 RenderSystem for iOS&quot; FORCE) set(OGRE_STATIC TRUE CACHE BOOL &quot;Forcing static build for iOS&quot; FORCE) set(MACOSX_BUNDLE_GUI_IDENTIFIER &quot;com.yourcompany.\\$&#123;PRODUCT_NAME:rfc1034identifier&#125;&quot;)elseif (ANDROID) set(TargetPlatform &quot;Android&quot;) set(OGRE_PLATFORM OGRE_PLATFORM_ANDROID) set(OGRE_CONFIG_ENABLE_VIEWPORT_ORIENTATIONMODE FALSE CACHE BOOL &quot;Disable viewport orientation Android&quot; FORCE) option(OGRE_BUILD_ANDROID_JNI_SAMPLE &quot;Enable JNI Sample&quot; FALSE) set(OGRE_BUILD_RENDERSYSTEM_GLES2 TRUE CACHE BOOL &quot;Forcing OpenGL ES 2 RenderSystem for Android&quot; FORCE) set(OGRE_BUILD_PLUGIN_PCZ FALSE CACHE BOOL &quot;Disable pcz on Android&quot; FORCE) set(OGRE_BUILD_PLUGIN_BSP FALSE CACHE BOOL &quot;Disable bsp scenemanager on Android&quot; FORCE) set(OGRE_BUILD_TOOLS FALSE CACHE BOOL &quot;Disable tools on Android&quot; FORCE) set(OGRE_STATIC TRUE CACHE BOOL &quot;Forcing static build for Android&quot; FORCE) # workaround for the legacy android toolchain set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++11&quot;)elseif(EMSCRIPTEN) add_definitions(-DEMSCRIPTEN=1 -D__EMSCRIPTEN__=1) set(TargetPlatform &quot;Emscripten&quot;) set(OGRE_PLATFORM OGRE_PLATFORM_EMSCRIPTEN) set(OGRE_BUILD_RENDERSYSTEM_GLES2 TRUE CACHE BOOL &quot;Forcing OpenGL ES 2 RenderSystem for Emscripten&quot; FORCE) set(OGRE_BUILD_RENDERSYSTEM_GL FALSE CACHE BOOL &quot;Disable OpenGL RenderSystem for Emscripten&quot; FORCE) set(OGRE_BUILD_PLUGIN_STBI TRUE CACHE BOOL &quot;Enable STBIImageCodec on Emscripten (Smaller Footprint)&quot; FORCE) set(OGRE_BUILD_PLUGIN_FREEIMAGE FALSE CACHE BOOL &quot;Disable Freeimage on Emscripten (Smaller Footprint)&quot; FORCE) set(OGRE_BUILD_PLUGIN_PCZ FALSE CACHE BOOL &quot;Disable pcz on Emscripten&quot; FORCE) set(OGRE_BUILD_PLUGIN_BSP FALSE CACHE BOOL &quot;Disable pcz on Emscripten&quot; FORCE) set(OGRE_BUILD_TOOLS FALSE CACHE BOOL &quot;Disable tools on Emscripten&quot; FORCE) set(OGRE_BUILD_TESTS FALSE CACHE BOOL &quot;Disable tests on Emscripten&quot; FORCE) set(OGRE_BUILD_COMPONENT_VOLUME FALSE CACHE BOOL &quot;Disable volume component on Emscripten&quot; FORCE) set(OGRE_BUILD_COMPONENT_PAGING FALSE CACHE BOOL &quot;Disable paging component on Emscripten&quot; FORCE) set(OGRE_BUILD_COMPONENT_TERRAIN FALSE CACHE BOOL &quot;Disable terrain component on Emscripten&quot; FORCE) set(OGRE_STATIC TRUE CACHE BOOL &quot;Forcing static build for Emscripten&quot; FORCE) set(OGRE_CONFIG_THREADS &quot;0&quot; CACHE STRING &quot;Threading is unstable on Emscripten&quot; FORCE)elseif (APPLE AND NOT APPLE_IOS) set(XCODE_ATTRIBUTE_SDKROOT macosx) if(CMAKE_GENERATOR STREQUAL &quot;Unix Makefiles&quot;) execute_process(COMMAND xcodebuild -version -sdk &quot;$&#123;XCODE_ATTRIBUTE_SDKROOT&#125;&quot; Path | head -n 1 OUTPUT_VARIABLE CMAKE_OSX_SYSROOT) string(REGEX REPLACE &quot;(\\r?\\n)+$&quot; &quot;&quot; CMAKE_OSX_SYSROOT &quot;$&#123;CMAKE_OSX_SYSROOT&#125;&quot;) else() set(CMAKE_OSX_SYSROOT macosx) endif() if (NOT CMAKE_OSX_ARCHITECTURES) if(OGRE_BUILD_RENDERSYSTEM_GL3PLUS) if(CMAKE_GENERATOR STREQUAL &quot;Unix Makefiles&quot;) set(CMAKE_OSX_ARCHITECTURES &quot;$&#123;ARCHS_STANDARD_64_BIT&#125;&quot;) else() set(CMAKE_OSX_ARCHITECTURES &quot;$(ARCHS_STANDARD_64_BIT)&quot;) endif() else() if(CMAKE_GENERATOR STREQUAL &quot;Unix Makefiles&quot;) set(CMAKE_OSX_ARCHITECTURES &quot;$&#123;ARCHS_STANDARD_32_64_BIT&#125;&quot;) else() set(CMAKE_OSX_ARCHITECTURES &quot;$(ARCHS_STANDARD_32_64_BIT)&quot;) endif() endif() endif() # Make sure that the OpenGL render system is selected for non-iOS Apple builds set(OGRE_BUILD_RENDERSYSTEM_GLES2 FALSE)endif ()if(OGRE_BUILD_COMPONENT_MESHLODGENERATOR) set(OGRE_CONFIG_ENABLE_MESHLOD TRUE CACHE BOOL &quot;Forcing Mesh Lod&quot; FORCE)endif()# Enable the PVRTC codec if OpenGL ES is being builtif(OGRE_BUILD_RENDERSYSTEM_GLES2) set(OGRE_CONFIG_ENABLE_PVRTC TRUE CACHE BOOL &quot;Forcing PVRTC codec for OpenGL ES&quot; FORCE) set(OGRE_CONFIG_ENABLE_ETC TRUE CACHE BOOL &quot;Forcing ETC codec for OpenGL ES&quot; FORCE)endif()# Enable the ETC codec if OpenGL 3+ is being builtif(OGRE_BUILD_RENDERSYSTEM_GL3PLUS) set(OGRE_CONFIG_ENABLE_ETC TRUE CACHE BOOL &quot;Forcing ETC codec for OpenGL 3+&quot; FORCE)endif()# Find dependenciesinclude(Dependencies)####################################################################### Provide user options to customise the build process####################################################################### Customise what to buildoption(OGRE_STATIC &quot;Static build&quot; FALSE)option(OGRE_ENABLE_PRECOMPILED_HEADERS &quot;Use precompiled headers to speed up build&quot; TRUE)set(OGRE_RESOURCEMANAGER_STRICT &quot;2&quot; CACHE STRING &quot;Make ResourceManager strict for faster operation. Possible values: 0 - OFF search in all groups twice - for case sensitive and insensitive lookup [DEPRECATED] 1 - PEDANTIC require an explicit resource group. Case sensitive lookup. 2 - STRICT search in default group if not specified otherwise. Case sensitive lookup. &quot;)set_property(CACHE OGRE_RESOURCEMANAGER_STRICT PROPERTY STRINGS 0 1 2)cmake_dependent_option(OGRE_BUILD_RENDERSYSTEM_D3D9 &quot;Build Direct3D9 RenderSystem&quot; TRUE &quot;WIN32;DirectX9_FOUND;NOT WINDOWS_STORE;NOT WINDOWS_PHONE&quot; FALSE)cmake_dependent_option(OGRE_BUILD_RENDERSYSTEM_D3D11 &quot;Build Direct3D11 RenderSystem&quot; TRUE &quot;WIN32;DirectX11_FOUND OR WINDOWS_STORE OR WINDOWS_PHONE&quot; FALSE)cmake_dependent_option(OGRE_BUILD_RENDERSYSTEM_GL3PLUS &quot;Build OpenGL 3+ RenderSystem&quot; TRUE &quot;OPENGL_FOUND;NOT WINDOWS_STORE;NOT WINDOWS_PHONE&quot; FALSE)cmake_dependent_option(OGRE_BUILD_RENDERSYSTEM_GL &quot;Build OpenGL RenderSystem&quot; TRUE &quot;OPENGL_FOUND;NOT APPLE_IOS;NOT WINDOWS_STORE;NOT WINDOWS_PHONE&quot; FALSE)cmake_dependent_option(OGRE_BUILD_RENDERSYSTEM_GLES2 &quot;Build OpenGL ES 2.x RenderSystem&quot; FALSE &quot;OPENGLES2_FOUND;NOT WINDOWS_STORE;NOT WINDOWS_PHONE&quot; FALSE)option(OGRE_BUILD_PLUGIN_BSP &quot;Build BSP SceneManager plugin&quot; TRUE)option(OGRE_BUILD_PLUGIN_OCTREE &quot;Build Octree SceneManager plugin&quot; TRUE)option(OGRE_BUILD_PLUGIN_PFX &quot;Build ParticleFX plugin&quot; TRUE)cmake_dependent_option(OGRE_BUILD_PLUGIN_PCZ &quot;Build PCZ SceneManager plugin&quot; TRUE &quot;&quot; FALSE)cmake_dependent_option(OGRE_BUILD_COMPONENT_PAGING &quot;Build Paging component&quot; TRUE &quot;&quot; FALSE)cmake_dependent_option(OGRE_BUILD_COMPONENT_MESHLODGENERATOR &quot;Build MeshLodGenerator component&quot; TRUE &quot;&quot; FALSE)cmake_dependent_option(OGRE_BUILD_COMPONENT_TERRAIN &quot;Build Terrain component&quot; TRUE &quot;&quot; FALSE)cmake_dependent_option(OGRE_BUILD_COMPONENT_VOLUME &quot;Build Volume component&quot; TRUE &quot;&quot; FALSE)cmake_dependent_option(OGRE_BUILD_COMPONENT_PROPERTY &quot;Build Property component&quot; TRUE &quot;&quot; FALSE)cmake_dependent_option(OGRE_BUILD_PLUGIN_CG &quot;Build Cg plugin&quot; TRUE &quot;Cg_FOUND;NOT APPLE_IOS;NOT WINDOWS_STORE;NOT WINDOWS_PHONE&quot; FALSE)cmake_dependent_option(OGRE_BUILD_COMPONENT_OVERLAY &quot;Build Overlay component&quot; TRUE &quot;FREETYPE_FOUND&quot; FALSE)option(OGRE_BUILD_COMPONENT_HLMS &quot;Build HLMS component&quot; TRUE)cmake_dependent_option(OGRE_BUILD_COMPONENT_BITES &quot;Build OgreBites component&quot; TRUE &quot;OGRE_BUILD_COMPONENT_OVERLAY&quot; FALSE)cmake_dependent_option(OGRE_BUILD_COMPONENT_PYTHON &quot;Build Python bindings&quot; TRUE &quot;NOT OGRE_STATIC&quot; FALSE)option(OGRE_BUILD_COMPONENT_JAVA &quot;Build Java (JNI) bindings&quot; TRUE)option(OGRE_BUILD_COMPONENT_RTSHADERSYSTEM &quot;Build RTShader System component&quot; TRUE)cmake_dependent_option(OGRE_BUILD_RTSHADERSYSTEM_CORE_SHADERS &quot;Build RTShader System FFP core shaders&quot; TRUE &quot;OGRE_BUILD_COMPONENT_RTSHADERSYSTEM&quot; FALSE)cmake_dependent_option(OGRE_BUILD_RTSHADERSYSTEM_EXT_SHADERS &quot;Build RTShader System extensions shaders&quot; TRUE &quot;OGRE_BUILD_COMPONENT_RTSHADERSYSTEM&quot; FALSE)cmake_dependent_option(OGRE_BUILD_SAMPLES &quot;Build Ogre demos&quot; TRUE &quot;OGRE_BUILD_COMPONENT_OVERLAY;OGRE_BUILD_COMPONENT_BITES&quot; FALSE)cmake_dependent_option(OGRE_BUILD_TOOLS &quot;Build the command-line tools&quot; TRUE &quot;NOT APPLE_IOS;NOT WINDOWS_STORE;NOT WINDOWS_PHONE&quot; FALSE)cmake_dependent_option(OGRE_BUILD_XSIEXPORTER &quot;Build the Softimage exporter&quot; FALSE &quot;Softimage_FOUND&quot; FALSE)cmake_dependent_option(OGRE_BUILD_LIBS_AS_FRAMEWORKS &quot;Build frameworks for libraries on OS X.&quot; TRUE &quot;APPLE;NOT OGRE_BUILD_PLATFORM_APPLE_IOS&quot; FALSE)option(OGRE_BUILD_TESTS &quot;Build the unit tests &amp; PlayPen&quot; FALSE)option(OGRE_CONFIG_DOUBLE &quot;Use doubles instead of floats in Ogre&quot; FALSE)option(OGRE_CONFIG_NODE_INHERIT_TRANSFORM &quot;Tells the node whether it should inherit full transform from it&#x27;s parent node or derived position, orientation and scale&quot; FALSE)set(OGRE_CONFIG_THREADS &quot;3&quot; CACHE STRING &quot;Enable Ogre thread safety support for multithreading. Possible values: 0 - no thread safety. DefaultWorkQueue is not threaded. 1 - background resource preparation and loading is thread safe. Threaded DefaultWorkQueue. [DEPRECATED] 2 - only background resource preparation is thread safe. Threaded DefaultWorkQueue. [DEPRECATED] 3 - no thread safety. Threaded DefaultWorkQueue.&quot;)set_property(CACHE OGRE_CONFIG_THREADS PROPERTY STRINGS 0 1 2 3)set(OGRE_CONFIG_THREAD_PROVIDER &quot;std&quot; CACHE STRING &quot;Select the library to use for thread support. Possible values: boost - Boost thread library. [DEPRECATED] poco - Poco thread library. [DEPRECATED] tbb - ThreadingBuildingBlocks library. [DEPRECATED] std - STL thread library (requires compiler support).&quot;)set_property(CACHE OGRE_CONFIG_THREAD_PROVIDER PROPERTY STRINGS boost poco tbb std)cmake_dependent_option(OGRE_BUILD_PLUGIN_FREEIMAGE &quot;Build FreeImage codec.&quot; TRUE &quot;FreeImage_FOUND&quot; FALSE)cmake_dependent_option(OGRE_BUILD_PLUGIN_EXRCODEC &quot;Build EXR Codec plugin&quot; TRUE &quot;OPENEXR_FOUND;&quot; FALSE)option(OGRE_BUILD_PLUGIN_STBI &quot;Enable STBI image codec.&quot; TRUE)option(OGRE_CONFIG_ENABLE_MESHLOD &quot;Enable Mesh Lod.&quot; TRUE)option(OGRE_CONFIG_ENABLE_DDS &quot;Build DDS codec.&quot; TRUE)option(OGRE_CONFIG_ENABLE_PVRTC &quot;Build PVRTC codec.&quot; FALSE)option(OGRE_CONFIG_ENABLE_ETC &quot;Build ETC codec.&quot; TRUE)option(OGRE_CONFIG_ENABLE_ASTC &quot;Build ASTC codec.&quot; FALSE)option(OGRE_CONFIG_ENABLE_QUAD_BUFFER_STEREO &quot;Enable stereoscopic 3D support&quot; FALSE)cmake_dependent_option(OGRE_CONFIG_ENABLE_ZIP &quot;Build ZIP archive support. If you disable this option, you cannot use ZIP archives resource locations. The samples won&#x27;t work.&quot; TRUE &quot;ZZip_FOUND&quot; FALSE)option(OGRE_CONFIG_ENABLE_VIEWPORT_ORIENTATIONMODE &quot;Include Viewport orientation mode support.&quot; FALSE)cmake_dependent_option(OGRE_CONFIG_ENABLE_GLES2_CG_SUPPORT &quot;Enable Cg support to ES 2 render system&quot; FALSE &quot;OGRE_BUILD_RENDERSYSTEM_GLES2&quot; FALSE)cmake_dependent_option(OGRE_CONFIG_ENABLE_GLES2_GLSL_OPTIMISER &quot;Enable GLSL optimiser use in GLES 2 render system&quot; FALSE &quot;OGRE_BUILD_RENDERSYSTEM_GLES2&quot; FALSE)cmake_dependent_option(OGRE_CONFIG_ENABLE_GL_STATE_CACHE_SUPPORT &quot;Enable OpenGL state cache management&quot; FALSE &quot;OGRE_BUILD_RENDERSYSTEM_GL OR OGRE_BUILD_RENDERSYSTEM_GLES2 OR OGRE_BUILD_RENDERSYSTEM_GL3PLUS&quot; FALSE)cmake_dependent_option(OGRE_CONFIG_ENABLE_GLES3_SUPPORT &quot;Enable OpenGL ES 3.x Features&quot; FALSE &quot;OPENGLES3_FOUND;OGRE_BUILD_RENDERSYSTEM_GLES2&quot; FALSE)option(OGRE_CONFIG_ENABLE_TBB_SCHEDULER &quot;Enable TBB&#x27;s scheduler initialisation/shutdown.&quot; TRUE)# Customise what to installoption(OGRE_INSTALL_CMAKE &quot;Install CMake scripts.&quot; TRUE)option(OGRE_INSTALL_SAMPLES &quot;Install Ogre demos.&quot; TRUE)option(OGRE_INSTALL_TOOLS &quot;Install Ogre tools.&quot; TRUE)option(OGRE_INSTALL_DOCS &quot;Install documentation.&quot; TRUE)option(OGRE_INSTALL_SAMPLES_SOURCE &quot;Install samples source files.&quot; FALSE)cmake_dependent_option(OGRE_INSTALL_PDB &quot;Install debug pdb files&quot; TRUE &quot;MSVC&quot; FALSE)option(OGRE_PROFILING &quot;Enable internal profiling support.&quot; FALSE)cmake_dependent_option(OGRE_CONFIG_STATIC_LINK_CRT &quot;Statically link the MS CRT dlls (msvcrt)&quot; FALSE &quot;MSVC&quot; FALSE)set(OGRE_LIB_DIRECTORY &quot;lib$&#123;LIB_SUFFIX&#125;&quot; CACHE STRING &quot;Install path for libraries, e.g. &#x27;lib64&#x27; on some 64-bit Linux distros.&quot;)if (WIN32) option(OGRE_INSTALL_VSPROPS &quot;Install Visual Studio Property Page.&quot; FALSE) if (OGRE_INSTALL_VSPROPS) configure_file($&#123;OGRE_TEMPLATES_DIR&#125;/OGRE.props.in $&#123;OGRE_BINARY_DIR&#125;/OGRE.props) install(FILES $&#123;OGRE_BINARY_DIR&#125;/OGRE.props DESTINATION &quot;$&#123;CMAKE_INSTALL_PREFIX&#125;&quot;) endif ()endif ()# determine threading optionsinclude(PrepareThreadingOptions)# For Visual studio enable project folders by default.# Hide option from other compilers.if (MSVC) option(OGRE_PROJECT_FOLDERS &quot;Organize project into project folders.&quot; TRUE)endif ()# hide advanced optionsmark_as_advanced( OGRE_BUILD_RTSHADERSYSTEM_CORE_SHADERS OGRE_BUILD_RTSHADERSYSTEM_EXT_SHADERS OGRE_CONFIG_DOUBLE OGRE_CONFIG_NODE_INHERIT_TRANSFORM OGRE_CONFIG_ENABLE_MESHLOD OGRE_CONFIG_ENABLE_DDS OGRE_CONFIG_ENABLE_PVRTC OGRE_CONFIG_ENABLE_ETC OGRE_CONFIG_ENABLE_ASTC OGRE_CONFIG_ENABLE_VIEWPORT_ORIENTATIONMODE OGRE_CONFIG_ENABLE_ZIP OGRE_CONFIG_ENABLE_GL_STATE_CACHE_SUPPORT OGRE_CONFIG_ENABLE_GLES2_CG_SUPPORT OGRE_CONFIG_ENABLE_GLES2_GLSL_OPTIMISER OGRE_CONFIG_ENABLE_GLES3_SUPPORT OGRE_CONFIG_ENABLE_TBB_SCHEDULER OGRE_INSTALL_SAMPLES_SOURCE OGRE_PROFILING OGRE_CONFIG_STATIC_LINK_CRT OGRE_LIB_DIRECTORY)#################################################################### configure global build settings based on selected build options###################################################################include(ConfigureBuild)set(CMAKE_INSTALL_RPATH &quot;$&#123;CMAKE_INSTALL_PREFIX&#125;/$&#123;OGRE_LIB_DIRECTORY&#125;&quot;)set(CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE)#################################################################### disable way too common compiler warnings on project level###################################################################if(MSVC) add_definitions( /wd4251 /wd4275 )endif()################################################################### Now setup targets################################################################### install resource filesinclude(InstallResources)# enable PCH supportinclude(PrecompiledHeader)# Setup OgreMain projectadd_subdirectory(OgreMain)# Setup RenderSystemsadd_subdirectory(RenderSystems)# Setup Pluginsadd_subdirectory(PlugIns)# Setup Componentsadd_subdirectory(Components)# Setup tests (before samples so that PlayPen is included in browser)if (OGRE_BUILD_TESTS) # enable CTest ENABLE_TESTING() INCLUDE(CTest) add_subdirectory(Tests)endif ()# Setup samplesadd_subdirectory(Samples)# Setup command-line toolsif (OGRE_BUILD_TOOLS) add_subdirectory(Tools)endif ()# Setup XSIExporterif (OGRE_BUILD_XSIEXPORTER) add_subdirectory(Tools/XSIExport)endif ()# Install documentationadd_subdirectory(Docs)# Install media filesif (OGRE_INSTALL_SAMPLES OR OGRE_INSTALL_SAMPLES_SOURCE) add_subdirectory(Samples/Media)endif ()# Install CMake modulesif (OGRE_INSTALL_CMAKE) add_subdirectory(CMake)endif ()# Provide CPack packaging targetinclude(Packaging)# Show feature summaryinclude(FeatureSummary)","categories":[{"name":"NDK","slug":"NDK","permalink":"http://example.com/categories/NDK/"}],"tags":[]},{"title":"apk加固-整体dex加密方式研究","slug":"apk加固-整体dex加密方式研究","date":"2022-11-04T05:15:20.000Z","updated":"2022-11-17T07:56:15.000Z","comments":true,"path":"2022/11/04/apk加固-整体dex加密方式研究/","link":"","permalink":"http://example.com/2022/11/04/apk%E5%8A%A0%E5%9B%BA-%E6%95%B4%E4%BD%93dex%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F%E7%A0%94%E7%A9%B6/","excerpt":"","text":"加壳脱壳流程加固流程上就是 1.解压原apk拿到classes.dex文件，对classes.dex文件进行加密，得到新的dex文件，这里的dex文件是不能直接通过d2j-dex2jar 进行还原。 2.将脱壳程序aar 中的classes.jar转成dex，并把dex和之前的解压后的文件加密后的文件进行压缩成新的apk文件 3.对新的apk进行zipaligned进行对齐，并重新签名，新生成的就是加壳后的apk文件 对原dex文件进行加密其实很简单，就是对原apk进行zip解压，然后遍历所有的.dex文件，对dex文件进行AES对称加密，这块在java层就可以完成了，解密要使用so文件，对密钥进行遮盖。 12345678910111213141516171819202122//遍历dex 给dex加密File apkUnZipFile = new File(unzipApkFilePath);ArrayList&lt;File&gt; dexFiles = new ArrayList&lt;&gt;(8);for (File file : apkUnZipFile.listFiles()) &#123; if (file.getName().endsWith(&quot;.dex&quot;))&#123; System.out.println(file.getAbsolutePath()); dexFiles.add(file); &#125;&#125;AES aes = new AES(AES.Companion.getDEFAULT_PWD());for (File dexFile : dexFiles) &#123; byte[] bytes = ToolsKt.getBytes(dexFile); byte[] encryptedBytes = aes.encrypt(bytes); File tempFile = new File(apkUnZipFile,&quot;jit-&quot; + dexFile.getName()); FileOutputStream fos = new FileOutputStream(tempFile); fos.write(encryptedBytes); fos.flush(); fos.close(); dexFile.delete();&#125; 脱壳程序(重点)脱壳程序 aar 承担着重要的任务，因为我们在运行时才拿到加密的dex进行解密，但是光解密并没有什么用，因为程序默认加载的是我们脱壳程序的dex并不会加载解密后的源程序的dex这样就不会执行原程序的逻辑。所以脱壳程序需要找到加密的dex并解密，还要加载解密后的dex并替换当前的程序。 我们脱壳需要尽量的早，所以在attachBaseContext方法中脱壳 1234@Override protected void attachBaseContext(Context base) &#123; super.attachBaseContext(base); &#125; 1.在运行时获取当前的apk文件，下面的getApplicationInfo().sourceDir就是本应用apk安装文件的全路径 1File apkFile = new File(getApplicationInfo().sourceDir); 大概是这样 2.我们在加壳的时候把真实的原app的Application的名字写到了meta-data标签下 123&lt;meta-data android:name=&quot;app_name&quot; android:value=&quot;cn.com.jit.reinforcedemo.App&quot; /&gt; 我们现在需要把这个真实的Application读出来，获取ApplicationInfo 读取metaData 123456789101112131415161718ApplicationInfo applicationInfo = null;applicationInfo = getPackageManager().getApplicationInfo( getPackageName(), PackageManager.GET_META_DATA);Bundle metaData = applicationInfo.metaData;if (metaData != null) &#123; // 检查是否存在 app_name 元数据 if (metaData.containsKey(&quot;app_name&quot;)) &#123; app_name = metaData.getString(&quot;app_name&quot;).toString(); &#125; // 检查是否存在 app_version 元数据 if (metaData.containsKey(&quot;app_version&quot;)) &#123; app_version = metaData.getString(&quot;app_version&quot;).toString(); &#125;&#125; 3.创建用户的私有目录，将apk文件解压到该目录中 1File privateDir = getDir(app_name + &quot;_&quot; + app_version, MODE_PRIVATE); 如果没有写入app_version 这里就是null 路径是这样的 4.分别在私有目录下，创建appdir和dexdir两个文件夹，将apk中的文件解压到appdir中 1ZipUtils.unZipApk(apkFile, appDir); 5.将需要解密的dex文件解密后放在dexdir中 6.此时我们已经拿到了解密后的需要加载的dex文件，执行loadDex方法 基本思路是 创建自己的 Element[] dexElements 数组，然后将 系统加载的 Element[] dexElements 数组 与 我们自己的 Element[] dexElements 数组进行合并操作 需要执行的步骤1 . 获得系统 DexPathList 中的 Element[] dexElements 数组 ( libcore&#x2F;dalvik&#x2F;src&#x2F;main&#x2F;java&#x2F;dalvik&#x2F;system&#x2F;DexPathList.java ) 1234567891011// 阶段一二 : 调用 getClassLoader() 方法可以获取 PathClassLoader 对象// 从 PathClassLoader 对象中获取 private final DexPathList pathList 成员Field pathListField = ReflexUtils.reflexField(getClassLoader(), &quot;pathList&quot;);// 获取 classLoader 对象对应的 DexPathList pathList 成员Object pathList = pathListField.get(getClassLoader());//阶段三 : 获取封装在 DexPathList 类中的 Element[] dexElements 数组Field dexElementsField = ReflexUtils.reflexField(pathList, &quot;dexElements&quot;);// 获取 pathList 对象对应的 Element[] dexElements 数组成员Object[] dexElements = (Object[]) dexElementsField.get(pathList); 2 . 在本应用中创建 Element[] dexElements 数组 , 用于存放解密后的 dex 文件 1234567891011121314151617181920212223242526272829303132/* 2 . 在本应用中创建 Element[] dexElements 数组 , 用于存放解密后的 dex 文件 不同的 Android 版本中 , 创建 Element[] dexElements 数组的方法不同 , 这里需要做兼容 */Method makeDexElements;Object[] addElements = null;if (Build.VERSION.SDK_INT &lt;= Build.VERSION_CODES.M) &#123; // 5.0, 5.1 makeDexElements // 反射 5.0, 5.1, 6.0 版本的 DexPathList 中的 makeDexElements 方法 makeDexElements = ReflexUtils.reflexMethod( pathList, &quot;makeDexElements&quot;, ArrayList.class, File.class, ArrayList.class); ArrayList&lt;IOException&gt; suppressedExceptions = new ArrayList&lt;IOException&gt;(); addElements = (Object[]) makeDexElements.invoke(pathList, dexFiles, optimizedDirectory, suppressedExceptions);&#125; else if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; // 7.0 以上版本 makePathElements // 反射 7.0 以上版本的 DexPathList 中的 makeDexElements 方法 makeDexElements = ReflexUtils.reflexMethod(pathList, &quot;makePathElements&quot;, List.class, File.class, List.class); ArrayList&lt;IOException&gt; suppressedExceptions = new ArrayList&lt;IOException&gt;(); addElements = (Object[]) makeDexElements.invoke(pathList, dexFiles, optimizedDirectory, suppressedExceptions);&#125; 3 . 将 系统加载的 Element[] dexElements 数组 与 我们自己的 Element[] dexElements 数组进行合并操作 1234567891011121314151617/* 3 . 将 系统加载的 Element[] dexElements 数组 与 我们自己的 Element[] dexElements 数组进行合并操作 首先创建数组 , 数组类型与 dexElements 数组类型相同 将 dexElements 数组中的元素拷贝到 newElements 前半部分, 拷贝元素个数是 dexElements.size 将 addElements 数组中的元素拷贝到 newElements 后半部分, 拷贝元素个数是 dexElements.size */ Object[] newElements = (Object[]) Array.newInstance( dexElements.getClass().getComponentType(), dexElements.length + addElements.length); // 将 dexElements 数组中的元素拷贝到 newElements 前半部分, 拷贝元素个数是 dexElements.size System.arraycopy(dexElements, 0, newElements, 0, dexElements.length); // 将 addElements 数组中的元素拷贝到 newElements 后半部分, 拷贝元素个数是 dexElements.size System.arraycopy(addElements, 0, newElements, dexElements.length, addElements.length); 4 . 替换 ClassLoader 加载过程中的 Element[] dexElements 数组 ( 封装在 DexPathList 中 ) 1234/* 4 . 替换 ClassLoader 加载过程中的 Element[] dexElements 数组 ( 封装在 DexPathList 中 ) */ dexElementsField.set(pathList, newElements);","categories":[{"name":"加固","slug":"加固","permalink":"http://example.com/categories/%E5%8A%A0%E5%9B%BA/"}],"tags":[]},{"title":"Android平台的虚拟机是基于栈的吗？","slug":"Android平台的虚拟机是基于栈的吗?","date":"2022-10-26T11:46:26.000Z","updated":"2022-11-17T07:56:14.000Z","comments":true,"path":"2022/10/26/Android平台的虚拟机是基于栈的吗?/","link":"","permalink":"http://example.com/2022/10/26/Android%E5%B9%B3%E5%8F%B0%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%98%AF%E5%9F%BA%E4%BA%8E%E6%A0%88%E7%9A%84%E5%90%97?/","excerpt":"","text":"JVM运行时数据区 class文件通过ClassLoader被加载 字节码执行引擎会在运行时执行字节码 运行时数据区其实就是字节码在运行时的一个状态， 运行时数据区里最重要的一个地方就是堆，垃圾回收主要针对的就是这个部分 方法区就是存放字节码加载出来的类信息 堆和方法区是线程共享的 非线程共享区，程序计数器，虚拟机栈，本地方法栈 栈数据结构-栈：FILO（先进后出） 方法的调用是基于栈的，在一个方法中调用另一个方法，后被调用的方法最先结束，最早被调用的方法最后结束。 Android平台的Activity，同一时间只有最上层的activity是可见的，其他activity想要显示的话，就只有让最上层的activity出栈 运行时栈帧虚拟机栈 记录线程内方法的执行状态 栈帧 栈中的元素，对应每一个方法执行情况 123456fun main()&#123; foo() ...&#125;fun foo()&#123;&#125; 先调用main()方法，main方法入栈，再调用foo方法，foo方法再入栈，foo方法就在栈顶，foo方法执行完，就会出线，并释放所有的局部变量，这就是为什么虚拟机栈部分不需要垃圾回收。而堆需要垃圾回收的原因。 12345fun foo()&#123; val a = 1 val b = 2 val c = (a + b)*9&#125; 运行时栈帧 下面的东西都是线程私有的 局部变量表：存放局部变量的区域，有4个 this,a,b,c 操作数栈：用于字节码执行时处理一些中间状态的一块内存区域，在这个例子里，操作数栈的容量是2个，为什么是2个呢？其实是在编译期间，根据代码的逻辑推算出来的，然后再把这个数值记录在字节码里，foo方法只需要2个容量的操作数栈就可以完成运算。所谓的基于栈实现的栈，并不是前面所说的虚拟机栈，而是操作数栈 方法出口：方法该返回给谁，返回什么 程序计数器：它能帮助记录当前执行的字节码是哪一行 我们看foo方法的字节码 字节码：每一个单元就是一个字节，有的指令是一个字节，有的指令是两个字节，比如第7行，占用两个单元。 助记符：帮助我们记住每个字节码的含义 1）当执行第0行的时候，把一个int型的1推送至栈顶，此时程序计数器指向第0行 2）接下来看第1行，将栈顶的int型数据存入第1个本地变量(局部变量)，并弹出栈，然后程序计数器指向1 3）第2行，同上，把int型的数据2推送至栈顶，程序计数器变为2 4）第3行，把栈顶的int型存入第2个局部变量b，并出栈 5）第4行，第5行都是iload 把两个局部变量中的值，放入在操作栈上分别是1，2 因为要开始计算了 6）第6行，将栈顶的两个数相加，并压入栈顶，那么栈顶上就是一个int型数据3 7）第7行，将单字节的常量，这里是一个9 压入栈顶，这一行占用了两个字节码，所以下一行的行号是9 8）这一行将栈顶的两上元素相乘，并将结果压入栈顶，那现在栈顶的数值是27 9）第a行，把栈顶的数据存入第三个本地变量，并出栈 10）最后执行return这个函数的执行就结束了。 每初始化一个变量，每做一步运算，都要把数据放入操作数栈的栈顶，所有的指令都是操作这个操作数栈的，所以这个名字才叫做操作数栈，这就是基于栈的虚拟机的最基本的一个实现思路 Dalvik虚拟寄存器 Dalvik虚拟寄存器，只有两个虚拟寄存器v0v1 和程序计数器，计数器的功能是一样的，记录程序执行的行号，同样的逻辑，指令条数就少了很多，字节码的单元增大了，变成了两个字节，让这段代码跑起来 1）第0行，把指定的字面量int 1移动到指定的寄存器中 2）第1行，指定的int 2 移动到指定的v1寄存器中 2）第2行，对两个寄存器进行二元运算，是加法，并把结果存到第一个寄存器v0中 3）第3行，指定int 9 并把两数相乘，并存储到寄存器v0中 编译优化：发现a的值不见了，但不影响最终的结果，节约了内存，a在计算之后就没意义了。如果后面又用到了a 那么编译器会帮我们申请带3个插槽的虚拟寄存器 各自特点 基于于栈JVM DALVIK(基于寄存器) 字节码单元长度 8位（1字节） 16位（2字节） 单元指令长度 短 几乎翻倍 同样逻辑指令条数 多 少 同样逻辑数据移动次数 多 尽可能少 同样逻辑临时结果存储次数 多 尽可能少 如何看待基于栈的虚拟机设计？ JVM基于栈设计的初衷之一，是压缩代码体积 Java设计之初最重要的一个特性就是跨平台，支持嵌入式设备和手持设备（J2ME），这里的手持设备不是我们的现在的移动设备 Java设计之初，另一个特性是，支持远程传输执行字节码，要降低传输开销。 基于栈的虚拟机，字节码实现简单。 指的是生成字节码的过程简单，而不是虚拟机本身简单，或者说是编译器的实现简单。 操作时，不用去考虑寄存器的地址（绝对位置 ），只需要把想要操作的数据出栈，入栈，然后再实现如何针对栈进行操作就可以了。 基于栈的虚拟机，可移植性高。 为了提高效率，虚拟寄存器要映射到真实机器的寄存器，增加移植难度。 代码移植到其他硬件平台的时候，不用考虑真实机器寄存器的差异，因为操作栈的指令是通用的。 如何看待Android平台基于寄存器的设计？ 更快！更省内存！ 指令条数少 数据移动次数少、临时结果存放次数少 映射真实机器的寄存器 Android不需要解决移植性问题 Android平台的操作系统是统一的 Android平台用其他方式解决了代码体积的问题 dex文件优化","categories":[{"name":"Android基础","slug":"Android基础","permalink":"http://example.com/categories/Android%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"由一道面试题,说一下Java双亲委派模型","slug":"由一道面试题,说一下Java双亲委派模型","date":"2022-10-24T21:39:59.000Z","updated":"2022-11-17T07:56:15.000Z","comments":true,"path":"2022/10/25/由一道面试题,说一下Java双亲委派模型/","link":"","permalink":"http://example.com/2022/10/25/%E7%94%B1%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98,%E8%AF%B4%E4%B8%80%E4%B8%8BJava%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"面试题 你能不能自己写一个，叫做java.lang.Object的类？ 背后要考的是Classloader和双亲委派模型 ClassLoader是做什的？加载过程，加载给谁？ 双亲委派模型的源码，原理 这样设计的好处是什么？有些情况要打破双亲委派模型？ 字节码加载 class文件由ClassLoader加载到运行时数据区的方法区 方法区在内存中，存放class文件的逻辑结构，也就是类的元(meta)信息 包括常量池、类信息、字段、方法、属性等。 方法区的实现JVM只是一个规范，所以方法区也只是一个规范，有不同的实现方式。 在Java8以前的版本，被实现“永久代”，名称与堆中的“年轻代”、“养老代”相对应，和堆一样，同为线程共有，但又没有垃圾回收，所以又被称为“非堆”。（没有垃圾回收也是能理解的，如果方法区里的元信息被回收了，我们就不能创建类的实例了） 在Java8以后的版本，被称为元空间（meta space），直接放在本地内存，所以理论上没有大小上限。 Java程序的双亲委派模型 双亲委派模型其实是一个约定俗成的翻译，其实双亲的双并没有实际的意义，大家可以理解为家长委派，其实这个更符合ClassLoader的本意。 图中画了5个ClassLoader，它们互为父子ClassLoader的关系 记住，父子ClassLoader并不是父子类的关系。 先看辈分最低的，我们自定义的ClassLoader 可以用来加载额外的Class 没有特殊需求，我们平时不太需要自己去写ClassLoader，上面深 红色的三个是系统所提供的，也是程序运行所必须的。 两个自定义ClassLoader的直接父ClassLoader是ApplicationClassLoader也就是应用类加载器，应用类加载器换句话说呢，也就是用来加载我们自己写出的代码的类加载器。 应用类ClassLoder的直接父ClassLoader呢就是扩展类加载器ExtensionClassLoader，用于加载jre&#x2F;lib&#x2F;ext目录下的jar。 最顶层的加载器叫做启动类加载器BootstrapClassLoader，它加载的是最核心的类库，也就是jre&#x2F;lib目录下的类库，比如我们jre&#x2F;lib目录下有一个叫做rt.jar，我们平时最常用的一些系统类，比如java.lang&#x2F;java.io&#x2F;java.net&#x2F;java.util其实都是在这个jar包中，所以我们在题目中提到的java.lang.Object就是用启动类加载器加载的。 Android中的双亲委派模型 其实整体上区别并不大，只不过系统提供的类加载器从三个变成了两个，额外加载自定义的变成了DexClassLoader，因为我们加载的是Dex文件，再往上一层呢，是PathClassLoader，和java中的应用类加载器一样，用于加载我们自己实现的代码，最顶层的加载器是BootClassLoader，类似于Java中的BootstrapClassLoader用于加载framework层的class Android程序的双亲委派模型类图 ClassLoader是一个抽象类，每一个ClassLoader都有一个parent属性，用来记录自己的父类是谁，还有两个关键的方法，一个是loadClass一个是findClass BootClassLoader是ClassLoader的子类。 BaseDexClassLoader也是ClassLoader的子类。它的作用呢就是，提供一些加载dex文件的基本方式。 PathClassLoader是BaseDexClassLoader的子类，用于加载我们实现的代码的class，因为最终会被编译成dex文件 DexClassLoader也是BaseDexClassLoader的子类 ClassLoader源码1234567891011121314151617181920212223242526public abstract class ClassLoader&#123; /** * Finds the class with the specified &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt;. * This method should be overridden by class loader implementations that * follow the delegation model for loading classes, and will be invoked by * the &#123;@link #loadClass &lt;tt&gt;loadClass&lt;/tt&gt;&#125; method after checking the * parent class loader for the requested class. The default implementation * throws a &lt;tt&gt;ClassNotFoundException&lt;/tt&gt;. * * @param name * The &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt; of the class * * @return The resulting &lt;tt&gt;Class&lt;/tt&gt; object * * @throws ClassNotFoundException * If the class could not be found * * @since 1.2 * *真正从字节码文件中根据类名，返回Class实例的方法，应该被子类实现者重写 * */ protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; throw new ClassNotFoundException(name); &#125;&#125; findClass的实现细节由子类来决定，这一样一来不同层级的ClassLoader就可以从不同的位置加载不同的代码，比如启动类加载器就可以加载jre&#x2F;lib下的class，应用类加载器就可以加载我们编译出来的class 然后就是我们的loadClass方法 12345678910111213141516171819 //外部通过loadClass获取Class实例 protected Class&lt;?&gt; loadClass(String className) throws ClassNotFoundException &#123; Class&lt;?&gt; clazz = findLoadedClass(className);//已经被加载的类直接返回结果 if(clazz == null)&#123; if(parent!=null)&#123; c = parent.loadClass(className);//递归调用父类加载器的loadClass &#125; &#125; if (clazz == null) &#123; clazz = findClass(className); &#125; return clazz; &#125; 这个方法暴露给外部，外部通过这个方法来获得class实例 第一行首先调用了一个findLoadedClass的方法，可以理解为读取缓存的操作，当前的类加载器如果已经加载过某个类，可以直接返回结果，不用考虑其他因素 然后就是没有缓存的情况下，如果有父类加载器，就会递归调用父类加载器loadClass方法，直到某一个父类加载器能够返回一个非空结果，或者说一直调用到最顶层的类加载器，才会跳出递归。 如果所有的类加载器都加载不到这个类的话，就会交给当前的类加载器，才会调用自己的findClass方法，才会真正的加载class 加载自己写的Object类会发生什么？ 所以自己写的java.lang.Object 正常情况下，只能被编译，但不会被类加器加载 Class的双亲委派模型有什么好处？ 能够对类划分优先级层次关系（系统的类永远比我们的类的层次要高） 避免类的重复加载（已经加载过的类，就不会再有机会再次加载，父类加载器一旦加载过某个类，相关的子类加载器就不会再有机会重复加载同一个类了） 沙箱安全机制，避免代码被篡改（系统的核心类库，相对来说就是一个沙箱，我们无法通过常规手段干扰核心类库的执行，同样的自定义类加载器也无法干预我们写的程序的代码） 为什么要打破双亲委派模型呢？解决某些版本冲突问题 热部署（重复加载已经被加载的类）","categories":[{"name":"Android基础","slug":"Android基础","permalink":"http://example.com/categories/Android%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"气象数据-第2章如何保证服务程序永不停机-6-Linux共享内存","slug":"气象数据-第2章如何保证服务程序永不停机-6-Linux共享内存","date":"2022-10-24T00:27:43.000Z","updated":"2022-11-17T07:56:15.000Z","comments":true,"path":"2022/10/24/气象数据-第2章如何保证服务程序永不停机-6-Linux共享内存/","link":"","permalink":"http://example.com/2022/10/24/%E6%B0%94%E8%B1%A1%E6%95%B0%E6%8D%AE-%E7%AC%AC2%E7%AB%A0%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E6%B0%B8%E4%B8%8D%E5%81%9C%E6%9C%BA-6-Linux%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/","excerpt":"","text":"前言Linux中每个进程是互相独立的，互相不能访问，共享内存允许多个进程访问同一块内存，是进程之间共享和传递数据最高效的方式，没有之一。 共享内存的操作 1.调用shmget函数获取或创建共享内存。（也就是说共享内存如果不存在，就创建它，如果已经存在就获取它） 2.调用shmat函数把共享内存连接到当前进程的地址空间。 3.调用shmdt函数把共享内存从当前进程中分离。（比如进程要退出了） 4.调用shmctl函数删除共享内存。（一般共享内存创建了，一般不删除，除非整个项目服务程序都要停止运行） shmgetint shmget(key_t key, size_t size, int shmflg) 获取或者创建共享内存的函数 key：在进程通信中不管是消息队列，共享内存还是信号量，每个对象都有一个key，不同的进程通过key来识别不同的对象，key是一个整数 size：第2个参数是共享内存的大小 shmflg：第3个参数是共享内存的标志，操作权限，如0640|IPC_CREAT 前面是操作权限，和文件的操作权限一样，后面的标志位表示，如果共享内存不存在就创建它，后面基本没选择，前面的看项目需要。 get函数成功返回共享内存的id，失败返回-1 book.cpp 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;//shmget函数需要头文件#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;struct st_pid&#123; int pid;//进程编号 char name[51]; //进程名称&#125;;int main(int argc,char *argv[])&#123; //共享内存的标志。 int shmid; if((shmid = shmget(0x5005,sizeof(struct st_pid),0640|IPC_CREAT)) == -1)&#123; printf(&quot;错误提示&quot;); return -1; &#125; return 0;&#125; 通过ipcs -m 命令查询我们创建的共享内存 shmid就是创建的共享内存的id 权限也是我们指定的640 通过ipcrm -m &lt;shmid&gt; 可以删除我们创建的共享内存 已经没有了 shmatvoid *shmat(int shmid, const void *shmaddr, int shmflg) at就是把共享内存连接到当前进程的地址空间，dt就是分离出去 第2，3个参数都填0就行 返回的是共享内存的地址，我们可以通过地址操作共享内存，很方便 在程序中我们用一个指针指向共享内存的地址，就像操作本地的变量，非常方便 shmdtint shmdt(const void *shmaddr) 参数就是共享内存的地址 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;struct st_pid&#123; int pid;//进程编号 char name[51]; //进程名称&#125;;int main(int argc,char *argv[])&#123; //共享内存的标志。 int shmid; //获取或者创建共享内存，键值为0x5005 if((shmid = shmget(0x5005,sizeof(struct st_pid),0640|IPC_CREAT)) == -1)&#123; printf(&quot;错误提示&quot;); return -1; &#125; //用于指向共享内存的结构体变量 struct st_pid *stpid = 0; //把共享内存连接到当前进程的地址空间 if((stpid =(struct st_pid *)shmat(shmid,0,0)) == (void *)-1)&#123; printf(&quot;shmat 0x5005 failed\\n&quot;); return -1; &#125; printf(&quot;pid=%d,name=%s\\n&quot;,stpid-&gt;pid,stpid-&gt;name); stpid-&gt;pid = getpid(); strcpy(stpid-&gt;name,argv[1]); //把共享内存从当前进程中分离 shmdt(stpid); return 0;&#125; 不同的进程分别执行.&#x2F;book aaa .&#x2F;book bbb .&#x2F;book ccccc 不同的进程把自己进程的内容写进了共享内存中，共享内存中的值会不断的变化 shmctl删除或者操作共享内存 int shmctl(int shmid, int cmd, struct shmid_ds *buf) 第一个参数是共享内存的id 第二个参数是命令，我们一般只用它来删除，所以传IPC_RMID 第三个参数是结构体，我们删除时传0 123456789101112131415161718192021222324252627282930313233343536373839404142434445include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;struct st_pid&#123; int pid;//进程编号 char name[51]; //进程名称&#125;;int main(int argc,char *argv[])&#123; //共享内存的标志。 int shmid; if((shmid = shmget(0x5005,sizeof(struct st_pid),0640|IPC_CREAT)) == -1)&#123; printf(&quot;错误提示&quot;); return -1; &#125; struct st_pid *stpid = 0; if((stpid =(struct st_pid *)shmat(shmid,0,0)) == (void *)-1)&#123; printf(&quot;shmat 0x5005 failed\\n&quot;); return -1; &#125; printf(&quot;pid=%d,name=%s\\n&quot;,stpid-&gt;pid,stpid-&gt;name); stpid-&gt;pid = getpid(); strcpy(stpid-&gt;name,argv[1]); printf(&quot;pid=%d,name=%s\\n&quot;,stpid-&gt;pid,stpid-&gt;name); shmdt(stpid); if(shmctl(shmid,IPC_RMID,0) == -1)&#123; printf(&quot;shmctl failed\\n&quot;); return -1; &#125; return 0;&#125; 执行.&#x2F;book aaaa 再用ipcs -m 查看共享内存情况，发现已经删除成功了 如图，已经没有我们创建的共享内存了。","categories":[{"name":"C气象数据项目","slug":"C气象数据项目","permalink":"http://example.com/categories/C%E6%B0%94%E8%B1%A1%E6%95%B0%E6%8D%AE%E9%A1%B9%E7%9B%AE/"}],"tags":[]},{"title":"由undefined reference to __gxx_personality_v0错误，看下g++和gcc的区别","slug":"由undefined-reference-to-gxx-personality-v0错误看下g-和gcc的区别","date":"2022-10-21T20:56:13.000Z","updated":"2022-11-17T07:56:15.000Z","comments":true,"path":"2022/10/22/由undefined-reference-to-gxx-personality-v0错误看下g-和gcc的区别/","link":"","permalink":"http://example.com/2022/10/22/%E7%94%B1undefined-reference-to-gxx-personality-v0%E9%94%99%E8%AF%AF%E7%9C%8B%E4%B8%8Bg-%E5%92%8Cgcc%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"一个编译例子之前编译一个cpp文件 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;int main(int argc,char *argv[])&#123; char *pargv[argc]; for(int ii =2;ii&lt;argc;ii++)&#123; pargv[ii -2] = argv[ii]; &#125; pargv[argc-2] = NULL; while(true)&#123; if(fork() == 0)&#123; execv(argv[2],pargv); &#125;else&#123; int status; wait(&amp;status); sleep(atoi(argv[1])); &#125; &#125; return 0;&#125; 使用指令进行编译 1gcc -o procctl procctl.cpp 然后报错了 没有去链接c++的标准库，我们使用gcc编译就要加上-lstdc++ 1gcc -o procctl procctl.cpp -lstdc++ 这样才会去链接c++的标准库，可以编译成功 实际上使用g++编译就不会有问题了 1g++ -o procctl procctl.cpp 也是可以编译的 g++和gcc的区别gcc 最开始的时候是 GNU C Compiler, 如你所知，就是一个c编译器。但是后来因为这个项目里边集成了更多其他不同语言的编译器，GCC就代表 the GNU Compiler Collection，所以表示一堆编译器的合集。 g++则是GCC的c++编译器。 gcc 和 g++ 的区别无非就是调用的编译器不同, 并且传递给链接器的参数不同. 具体而言 g++ 会把 .c 文件当做是 C++ 语言 (在 .c 文件前后分别加上 -xc++ 和 -xnone, 强行变成 C++), 从而调用 cc1plus 进行编译. g++ 遇到 .cpp 文件也会当做是 C++, 调用 cc1plus 进行编译. g++ 还会默认告诉链接器, 让它链接上 C++ 标准库. gcc 会把 .c 文件当做是 C 语言. 从而调用 cc1 进行编译. gcc 遇到 .cpp 文件, 会处理成 C++ 语言. 调用 cc1plus 进行编译. gcc 默认不会链接上 C++ 标准库. 我们编译c的时候最好使用gcc 编译c++的时候最好使用g++能避免麻烦","categories":[],"tags":[]},{"title":"气象数据-第2章如何保证服务程序永不停机-5-服务程序调度","slug":"气象数据-第2章如何保证服务程序永不停机-5-服务程序调度","date":"2022-10-18T23:37:40.000Z","updated":"2022-11-17T07:56:15.000Z","comments":true,"path":"2022/10/19/气象数据-第2章如何保证服务程序永不停机-5-服务程序调度/","link":"","permalink":"http://example.com/2022/10/19/%E6%B0%94%E8%B1%A1%E6%95%B0%E6%8D%AE-%E7%AC%AC2%E7%AB%A0%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E6%B0%B8%E4%B8%8D%E5%81%9C%E6%9C%BA-5-%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E8%B0%83%E5%BA%A6/","excerpt":"","text":"服务程序的调度 周期性的启动后台服务程序。 常驻内存中的服务程序异常中止，在短时间内重启。 execl函数，执行ls命令 procctl.cpp 12345678910#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;int main()&#123; execl(&quot;/usr/bin/ls&quot;,&quot;/usr/bin/ls&quot;,&quot;-lt&quot;,&quot;./&quot;,(char*)0); return 0;&#125; 第一个参数，传入执行程序全路径 第二个参数，伟入执行程序（可不传全路径） 第三个参数后开始传入执行程序的可变参数 。。。 最后一个参数传入(char*)0 我们再来看 procctl1.cpp 12345678910111213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;int main()&#123; printf(&quot;aaa\\n&quot;); execl(&quot;/usr/bin/ls&quot;,&quot;/usr/bin/ls&quot;,&quot;-lt&quot;,&quot;./&quot;,(char*)0); printf(&quot;bbb\\n&quot;); return 0;&#125; 发现只打印了aaa ，没有打印bbb exec是用参数中指定程序替换了当前进程的正文段、数据段、堆和栈。 调用execl 使用ls的影像替换了当前进程，当前进程已经不存在了，所以后面bbb的代码都不会执行，写再多也没用。如果调用失败，后面的代码还是会执行的。 解决方案 先执行fork函数，创建一个子进程，让子进程调用execl执行新的程序。 新程序将替换子进程，不会影响父进程。 在父进程中，可以调用wait函数等待新程序运行的结果，这样就可以实现调度的功能。 实现程序每隔5秒执行一次ls procctl2.cpp 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;int main()&#123; while(true)&#123; if(fork() == 0)&#123; execl(&quot;/usr/bin/ls&quot;,&quot;/usr/bin/ls&quot;,&quot;-lt&quot;,&quot;./&quot;,(char*)0); &#125;else&#123; int status; wait(&amp;status); sleep(5); &#125; &#125; return 0;&#125; 我们把程序按传参的形式补全 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;int main(int argc,char *argv[])&#123; //execl(&quot;/usr/bin/ls&quot;,&quot;/usr/bin/ls&quot;,&quot;-lt&quot;,&quot;./&quot;,(char*)0); while(true)&#123; if(fork() == 0)&#123; if(argc == 3) execl(argv[2],argv[2],(char*)0); if(argc == 4) execl(argv[2],argv[2],argv[3],(char*)0); if(argc == 5) execl(argv[2],argv[2],argv[3],argv[4],(char*)0); if(argc == 6) execl(argv[2],argv[2],argv[3],argv[4],argv[5],(char*)0); &#125;else&#123; int status; wait(&amp;status); sleep(5); &#125; &#125; return 0;&#125; 会发现，我们要不停的判断参数的个数，来补全execl函数，好麻烦，一般要提前判断20个参数左右才行。为了支持参数不确定的情况，我们使用exec家族另一个函数比较合适。 execv procctl3.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;int main(int argc,char *argv[])&#123; //关闭信号和IO，本程序不希望被打扰。 for(int ii = 0;ii&lt;64;ii++)&#123; signal(ii,SIG_IGN);close(ii); &#125; //生成子进程，父进程退出，让程序运行在后台，由系统1号进程托管 if(fork()!=0) exit(0); //启用SIGCHILD信号，让父进程可以wait子进程的退出的状态。 signal(SIGCHLD,SIG_DFL); //1.声明一个长度为argc的字符数组 char *pargv[argc]; for(int ii =2;ii&lt;argc;ii++)&#123; //2.把从命令开始的参数，赋值给pargv //argv[0]是procctl argv[1]是执行次数 argv[2] 才是/usr/bin/ls pargv[ii -2] = argv[ii]; &#125; //3.设置指令结尾为NULL pargv[argc-2] = NULL; while(true)&#123; if(fork() == 0)&#123; //4.第一人参数为指令，第二个参数为可变参数 execv(argv[2],pargv); //这行代码在execv成功的时候不会执行，在execv失败的时候会退。 exit(0); &#125;else&#123; int status; wait(&amp;status); sleep(atoi(argv[1])); &#125; &#125; return 0;&#125;","categories":[{"name":"C气象数据项目","slug":"C气象数据项目","permalink":"http://example.com/categories/C%E6%B0%94%E8%B1%A1%E6%95%B0%E6%8D%AE%E9%A1%B9%E7%9B%AE/"}],"tags":[]},{"title":"气象数据-第2章如何保证服务程序永不停机-4-Linux多进程","slug":"气象数据项目-第2章如何保证服务程序永不停机-4-Linux多进程","date":"2022-10-12T23:27:53.000Z","updated":"2022-11-17T07:56:15.000Z","comments":true,"path":"2022/10/13/气象数据项目-第2章如何保证服务程序永不停机-4-Linux多进程/","link":"","permalink":"http://example.com/2022/10/13/%E6%B0%94%E8%B1%A1%E6%95%B0%E6%8D%AE%E9%A1%B9%E7%9B%AE-%E7%AC%AC2%E7%AB%A0%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E6%B0%B8%E4%B8%8D%E5%81%9C%E6%9C%BA-4-Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/","excerpt":"","text":"Linux的0、1、2号进程 idel进程：系统创建的第一个进程，加载系统。系统启动的时候，它开始加载系统，加载完成后，演变成1号和2号进程。 systemd进程：系统初始化，是所有其它用户进程的祖先。负责启动系统服务，例如网络服务、防火墙，SSH服务，ftp服务。有些系统叫init kthreadd进程：负责所有内核线程的调度和管理。 进程标识 每个进程都有一个非负整数表示的唯一进程ID。 查看进程：ps -ef|grep 进程名 可以查看进程的详细信息 可以分别去查看进程的详情，能看到层层的父进程ID getpid(void)，获取进程ID。 getppid(void)，获取父进程ID。 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;int main()&#123; printf(&quot;getpid()=%d\\n&quot;,getpid()); printf(&quot;getppid()=%d\\n&quot;,getppid()); sleep(50);&#125; fork函数 一个现有的进程调用函数fork创建一个新的进程。新的进程叫做子进程，原有的进程叫做父进程。 子进程和父进程继续执行fork函数后的代码。 fork函数调用一次返回两次。 子进程返回0，父进程返回子进程的进程ID。 子进程是父进程的副本。 子进程获得了父进程的数据空间、堆和栈的副本，不是共享。 父进程中打开文件描述符也被复制到子进程中。 如果父进程先退出，子进程会成为孤儿进程。 如果子进程先退出，内核向父进程发送SIGCHLD信号，如果父进程不处理这个信号，子进程会成为僵尸进程。 book03.cpp 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;//- 一个现有的进程调用函数fork创建一个新的进程。新的进程叫做子进程，原有的进程叫做父进程。//- 子进程和父进程继续执行fork函数后的代码。int main()&#123; printf(&quot;aaa=%d\\n&quot;,getpid()); sleep(10); printf(&quot;bbb=%d\\n&quot;,getpid()); fork(); printf(&quot;ccc=%d\\n&quot;,getpid()); sleep(30); printf(&quot;ddd=%d\\n&quot;,getpid());&#125; 结果，子进程和父进程都打印了ccc 和ddd 而且两个进程的id是不同的 book04.cpp 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;//- fork函数调用一次返回两次。//- 子进程返回0，父进程返回子进程的进程ID。int main()&#123; printf(&quot;aaa=%d\\n&quot;,getpid()); sleep(10); printf(&quot;bbb=%d\\n&quot;,getpid()); int pid = fork(); printf(&quot;pid=%d\\n&quot;,pid); printf(&quot;ccc=%d\\n&quot;,getpid()); sleep(30); printf(&quot;ddd=%d\\n&quot;,getpid());&#125; 看运行结果，fork后面，pid打印了两次，一个是0 一个非0 子进程的返回0 父进程的返回子进程的id。fork函数中一个进程分叉成了两个进程，fork返回了两次。 book05.cpp 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;int main()&#123; int pid = fork(); if(pid == 0)&#123; printf(&quot;这是子进程%d，将执行子进程的任务。\\n&quot;,getpid()); sleep(20); &#125; if(pid&gt;0)&#123; printf(&quot;这是父进程%d,将执行父进程的任务。\\n&quot;,getpid()); sleep(30); &#125;&#125; getpid()调用失败，返回-1 一般是子进程太多，或者内存不足，比较极端的情况 我们来做这样一个事情，在父进程中定义一个变量，然后在子进程中修改变量的值，然后看变量是否会改变 book06.cpp 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;//- 子进程是父进程的副本。//- 子进程获得了父进程的数据空间、堆和栈的副本，不是共享。int main()&#123; int ii = 1; int pid = fork(); if(pid == 0)&#123; printf(&quot;这是子进程%d，将执行子进程的任务。\\n&quot;,getpid()); printf(&quot;aaaaaa ii = %d\\n&quot;,ii++); sleep(1); printf(&quot;aaaaaa ii = %d\\n&quot;,ii++); sleep(1); printf(&quot;aaaaaa ii = %d\\n&quot;,ii++); sleep(1); printf(&quot;aaaaaa ii = %d\\n&quot;,ii++); sleep(1); printf(&quot;aaaaaa ii = %d\\n&quot;,ii++); sleep(1); &#125; if(pid&gt;0)&#123; printf(&quot;这是父进程%d,将执行父进程的任务。\\n&quot;,getpid()); printf(&quot;bbbb ii = %d\\n&quot;,ii); sleep(1); printf(&quot;bbbb ii = %d\\n&quot;,ii); sleep(1); printf(&quot;bbbb ii = %d\\n&quot;,ii); sleep(1); printf(&quot;bbbb ii = %d\\n&quot;,ii); sleep(1); printf(&quot;bbbb ii = %d\\n&quot;,ii); sleep(1); printf(&quot;bbbb ii = %d\\n&quot;,ii); sleep(1); printf(&quot;bbbb ii = %d\\n&quot;,ii); sleep(1); &#125;&#125; 子进程做了改变，父进程不会改变，原因就是子进程是父进程的一个副本，子进程获得了父进程的数据空间、堆和栈的副本，不是共享。就像把一张纸复印了一份，你在复印件上修改，并不会影响原件上的内容，同样在原件上修改，也不会影响复印件。 补充一点： 父进程打开的文件描述符也被复制到子进程中 book07.cpp 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;int main()&#123; FILE *fp = fopen(&quot;./tmp/tmp.txt&quot;,&quot;a+&quot;); fprintf(fp,&quot;我要成为优秀的程序员。\\n&quot;); int ii = 1; int pid = fork(); if(pid == 0)&#123; printf(&quot;这是子进程%d，将执行子进程的任务。\\n&quot;,getpid()); fprintf(fp,&quot;aaaa 我我我我我我我&quot;); &#125; if(pid&gt;0)&#123; printf(&quot;这是父进程%d,将执行父进程的任务。\\n&quot;,getpid()); fprintf(fp,&quot;bbbb 我我我多我我我&quot;); &#125; fclose(fp);&#125; 看现象，我要成为优秀的程序员，这句话写入两次，原因是刚开始写在了内存中，然后内存被复制，所以父子进程各最终写入了一次。这是因为有内存缓冲区，写入文件会先写到缓冲区上，缓冲区满了才会一次性写入文件，如果想到达到我们理想的状态，那在fork调用之前，要刷新一次缓冲区，把缓冲区内容强制刷到文件上，就没问题了。 fork之前数据空间被复制了一份，数据空间包括缓冲区，父进程的缓冲区有这个内容，子进程的缓冲区也有这个内容。改一下加入fflush(fp); 强刷。 book08.cpp 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;int main()&#123; FILE *fp = fopen(&quot;./tmp/tmp.txt&quot;,&quot;a+&quot;); fprintf(fp,&quot;我要成为优秀的程序员。\\n&quot;); fflush(fp); int ii = 1; int pid = fork(); if(pid == 0)&#123; printf(&quot;这是子进程%d，将执行子进程的任务。\\n&quot;,getpid()); fprintf(fp,&quot;aaaa 我我我我我我我&quot;); &#125; if(pid&gt;0)&#123; printf(&quot;这是父进程%d,将执行父进程的任务。\\n&quot;,getpid()); fprintf(fp,&quot;bbbb 我我我多我我我&quot;); &#125; fclose(fp);&#125; 这回的输出就对了 说明：bbb我我我我我我 和aaaa我我我我我 这两个的写入顺序是不确定的，因为执行fork以后，父子进程执行的顺序是不确定的，跟操作系统的算法有关，一般来说，我们也不关注哪个进程先执行。 父进程和子进程虽然是父子进程，但是是两个独立的进程，如果在子进程中关闭的文件，不会影响父进程，如果在父进程中关闭的文件，也不会影响子进程。 我们在子进程关闭文件操作符，在父进程中每隔1秒接着往文件里继续写。 book09.cpp 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;int main()&#123; FILE *fp = fopen(&quot;./tmp/tmp.txt&quot;,&quot;a+&quot;); fprintf(fp,&quot;我要成为优秀的程序员。\\n&quot;); fflush(fp); int ii = 1; int pid = fork(); if(pid == 0)&#123; printf(&quot;这是子进程%d，将执行子进程的任务。\\n&quot;,getpid()); fclose(fp); fprintf(fp,&quot;aaaa 我我我我我我我。\\n&quot;); &#125; if(pid&gt;0)&#123; printf(&quot;这是父进程%d,将执行父进程的任务。\\n&quot;,getpid()); fprintf(fp,&quot;bbbb 我我我多我我我。\\n&quot;); sleep(1); fprintf(fp,&quot;bbbb 我我我多我我我。\\n&quot;); sleep(1); fprintf(fp,&quot;bbbb 我我我多我我我。\\n&quot;); sleep(1); fprintf(fp,&quot;bbbb 我我我多我我我。\\n&quot;); sleep(1); fprintf(fp,&quot;bbbb 我我我多我我我。\\n&quot;); sleep(1); fprintf(fp,&quot;bbbb 我我我多我我我。\\n&quot;); sleep(1); &#125; fclose(fp);&#125; 发现子进程关闭操作符后，子进程不能再写入，但父进程不受影响，还能继续写入文件。 僵尸进程什么是僵尸进程？我们接下来看看僵尸进程 如果子进程先退出，内核向父进程发送SIGCHLD信号，如果父进程不处理这个信号，子进程会成为僵尸进程。 book10.cpp 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;int main()&#123; int pid = fork(); if(pid == 0)&#123; printf(&quot;这是子进程%d，将执行子进程的任务。\\n&quot;,getpid()); sleep(5); &#125; if(pid&gt;0)&#123; printf(&quot;这是父进程%d,将执行父进程的任务。\\n&quot;,getpid()); sleep(20); &#125;&#125; 让子进程sleep 5秒后退出，父进程sleep 10秒后退出，然后通过ps -ef|grep book10来查看父子进程 5秒后，子进程退出，出现了僵尸进程 20秒后，父进程也退出，僵尸进程也消失了，这就是僵尸进程 僵尸进程的危害： 如果子进程在父进程之前终止，内核为每个子进程保留了一个数据结构，包括进程编号、终止状态和使用CPU时间等，父进程如果处理了子进程退出的信息，内核就会释放这个数据结构，如果父进程没有处理子进程退出的信息，内核就不会释放这个数据结构，子进程编号就会一直被占用，但是系统可用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，这就是僵尸进程的危害。 僵尸进程解决方法方法一：直接忽略这个信号 book11.cpp 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;int main()&#123; signal(SIGCHLD,SIG_IGN); int pid = fork(); if(pid == 0)&#123; printf(&quot;这是子进程%d，将执行子进程的任务。\\n&quot;,getpid()); sleep(5); &#125; if(pid&gt;0)&#123; printf(&quot;这是父进程%d,将执行父进程的任务。\\n&quot;,getpid()); sleep(20); &#125;&#125; 我们再观察结果，发现5秒后子进程退了，并没有产生僵尸进程 方法二：父进程wait子进程退出 book12.cpp 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;int main()&#123;// signal(SIGCHLD,SIG_IGN); int pid = fork(); if(pid == 0)&#123; printf(&quot;这是子进程%d，将执行子进程的任务。\\n&quot;,getpid()); sleep(5); &#125; if(pid&gt;0)&#123; printf(&quot;这是父进程%d,将执行父进程的任务。\\n&quot;,getpid()); int sts; wait(&amp;sts); sleep(20); &#125;&#125; wait函数 父进程等待子进程的退出，子进程退出后，父进程才执行wait后面的代码。 这种方法有一个问题，就是阻塞在这里。 方法三：设置CHLD这个信号的处理函数，在这个处理函数中wait 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;void func(int sig)&#123; int sts; wait(&amp;sts);&#125;int main()&#123; signal(SIGCHLD,func); int pid = fork(); if(pid == 0)&#123; printf(&quot;这是子进程%d，将执行子进程的任务。\\n&quot;,getpid()); sleep(5); &#125; if(pid&gt;0)&#123; printf(&quot;这是父进程%d,将执行父进程的任务。\\n&quot;,getpid()); sleep(10); &#125;&#125; 这样不影响父进程执行后面的函数，信号到达了，就执行func，注意这里面并不代表父进程一定会等待子进程的退出，因为父进程可能会先退出，如果sleep(1) 那么父进程退出后就不再关心信号处理函数了。 如果父进程先退出，子进程会成为孤儿进程，将被1号进程收养，由1号进程对它们完成状态收集工作。 如果子进程先退出，内核向父进程发送SIGCHLD信号，如果父进程不处理这个信号，子进程会成为僵尸进程。","categories":[{"name":"C气象数据项目","slug":"C气象数据项目","permalink":"http://example.com/categories/C%E6%B0%94%E8%B1%A1%E6%95%B0%E6%8D%AE%E9%A1%B9%E7%9B%AE/"}],"tags":[]},{"title":"气象数据-第2章如何保证服务程序永不停机-3-Linux信号","slug":"气象数据项目-第2章如何保证服务程序永不停机-3-Linux信号","date":"2022-10-11T23:31:10.000Z","updated":"2022-11-17T07:56:15.000Z","comments":true,"path":"2022/10/12/气象数据项目-第2章如何保证服务程序永不停机-3-Linux信号/","link":"","permalink":"http://example.com/2022/10/12/%E6%B0%94%E8%B1%A1%E6%95%B0%E6%8D%AE%E9%A1%B9%E7%9B%AE-%E7%AC%AC2%E7%AB%A0%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E6%B0%B8%E4%B8%8D%E5%81%9C%E6%9C%BA-3-Linux%E4%BF%A1%E5%8F%B7/","excerpt":"","text":"程序实践先来看一段程序 1234567891011121314#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;int main()&#123; while(1)&#123; printf(&quot;执行了一次任务。\\n&quot;); sleep(1); &#125;&#125; 程序运行结果如图所示。每一秒执行一次任务，然后我们通过control + c 或者 killall book都可以终止程序。其实是发送了信号linux进程一共有64个信号，我们往程序里添加一段代码，把它们都打印出来。 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;void handler(int sig)&#123; printf(&quot;接收到了信号%d\\n&quot;,sig);&#125;int main()&#123; for(int ii = 1;ii &lt;= 64; ii++) signal(ii,handler); while(1)&#123; printf(&quot;执行了一次任务。\\n&quot;); sleep(1); &#125;&#125; sighandler_t signal(int signum, sighandler_t handler); 信号处理函数，第一个参数是信号值，0-64。第二个参数是信号处理函数。如果我们给信号设置了处理函数，那么当我们发送信号，比如control + c 或者 killall book 的时候，会执行信号处理函数；如果没有设置处理函数，则会执行系统缺省的行为，也就是系统默认的信号处理行为就是杀死进程。 程序如图所示 在接到信号2和15的时候，并没有像之前一样被杀死。而是执行了我们的信号处理函数。直到我们发送了信号9，强制杀死进程，进程才终止。 signal(int signum,SIG_IGN); 对信号进行忽略处理 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;void handler(int sig)&#123; printf(&quot;接收到了信号%d\\n&quot;,sig);&#125;int main()&#123; for(int ii = 1;ii &lt;= 64; ii++) signal(ii,handler); //信号忽略 signal(15,SIG_IGN); while(1)&#123; printf(&quot;执行了一次任务。\\n&quot;); sleep(1); &#125;&#125; 我们对15信号进行了忽略，那么我们就不会接到15信号，尽管我们发送了killall book 发送了15号信号，但是处理函数并没有处理。 能处理信号2，但信号9并没有处理。 信号9 既不能捕获处理，也不能忽略。 signal(15,SIG_DFL) 信号缺省处理 对该信号进行捕获，并进行系统默认缺省处理，也就是杀死进程 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;void handler(int sig)&#123; printf(&quot;接收到了信号%d\\n&quot;,sig);&#125;int main()&#123; for(int ii = 1;ii &lt;= 64; ii++) signal(ii,handler); signal(15,SIG_IGN); //信号缺省处理 signal(15,SIG_DFL); while(1)&#123; printf(&quot;执行了一次任务。\\n&quot;); sleep(1); &#125;&#125; 信号的概念信号signal是软件中断，是进程之间相互传递消息的一种方法，用于通知进程发生了事件，但是，不能给进程传递任何数据。 信号产生的原因很多，在Linux下，可以用kill和killall命令发送信号。kill后面要跟进程id 通过ps -ef|grep book 可以查book的pid 然后通过kill进行信号发送 常用信号 发送时钟信号ALRM12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;void handler(int sig)&#123; printf(&quot;接收到了信号%d\\n&quot;,sig);&#125;//时钟处理函数void alarmfunc(int num)&#123; printf(&quot;接收到了时钟信号%d。\\n&quot;,num); alarm(3);&#125;int main()&#123; for(int ii = 1;ii &lt;= 64; ii++) signal(ii,handler); //时钟信号捕获 signal(SIGALRM,alarmfunc); //发送时钟信号，第3秒开始，只会发送一次，如果想要每隔3秒发送一次，要在处理函数中发送alarm(3) alarm(3); signal(15,SIG_DFL); while(1)&#123; printf(&quot;执行了一次任务。\\n&quot;); sleep(1); &#125;&#125; 只发送一次 每隔3秒发送一次 信号有什么用服务程序运行在后台，如果想让中止它，杀掉不是个好办法，因为程序被杀的时候，程序突然死亡，没有安排善后工作。 如果向服务程序发送一个信号，服务程序收到这个信号后，调用一个函数，在函数中编写善后的代码，程序就可以有计划的退出。 向服务程序发送0的信号，可以检测程序是否存活。 信号应用示例在实际开发中，在main开始的地方，程序会先屏蔽全部的信号。 for(int ii = 1; i&lt;= 64 ; ii++) signal(ii,SIG_IGN); 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;//善后处理函数void EXIT(int sig)&#123; printf(&quot;接收到了信号%d\\n&quot;,sig); exit(0);&#125;int main()&#123; //全部忽略，避免被干扰 for(int ii = 1;ii &lt;= 64; ii++) signal(ii,SIG_IGN); //对感兴趣的信号进行善后处理 signal(SIGINT,EXIT); while(1)&#123; printf(&quot;执行了一次任务。\\n&quot;); sleep(1); &#125;&#125;","categories":[{"name":"C气象数据项目","slug":"C气象数据项目","permalink":"http://example.com/categories/C%E6%B0%94%E8%B1%A1%E6%95%B0%E6%8D%AE%E9%A1%B9%E7%9B%AE/"}],"tags":[]},{"title":"气象数据-第2章如何保证服务程序永不停机-1-生成测试数据","slug":"气象数据-第2章如何保证服务程序永不停机-1-生成测试数据","date":"2022-10-01T00:05:03.000Z","updated":"2022-11-17T07:56:15.000Z","comments":true,"path":"2022/10/01/气象数据-第2章如何保证服务程序永不停机-1-生成测试数据/","link":"","permalink":"http://example.com/2022/10/01/%E6%B0%94%E8%B1%A1%E6%95%B0%E6%8D%AE-%E7%AC%AC2%E7%AB%A0%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E6%B0%B8%E4%B8%8D%E5%81%9C%E6%9C%BA-1-%E7%94%9F%E6%88%90%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE/","excerpt":"","text":"","categories":[{"name":"C气象数据项目","slug":"C气象数据项目","permalink":"http://example.com/categories/C%E6%B0%94%E8%B1%A1%E6%95%B0%E6%8D%AE%E9%A1%B9%E7%9B%AE/"}],"tags":[]},{"title":"NDK系列(一)-Makefile详解","slug":"NDK-Makefile详解","date":"2022-09-27T01:19:25.000Z","updated":"2022-11-17T07:56:14.000Z","comments":true,"path":"2022/09/27/NDK-Makefile详解/","link":"","permalink":"http://example.com/2022/09/27/NDK-Makefile%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"makefile、cmake与shell之间的联系 makefile:帮助我们管理编译项目 cmake:CMake 是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装（编译过程）他能够输出各种各样Makefile或者project文件。CMake并不直接构建出最终的软件，而是产生标准的构建文档（如Makefile或projects） shell脚本：一系列命令和语法 makefile自动编译和链接gcc的四个步骤中生成.o比较耗时(汇编阶段) 1234gcc -c sub.cpp -o sub.ogcc -c add.cpp -o add.ogcc -c div.cpp -o div.ogcc -c hello.cpp -o hello.o 怎么把这些写在Makefile文件中？一个规则目标:依赖条件 (一个tab缩进)命令 12a.out:a.c gcc a.c -o a.out 把上面的生成的hello.o改成写Makefile形式 12345678910hello.out:hello.o sub.o add.o div.o gcc -c hello.o sub.o add.o div.o -o hello.outsub.o:sub.cpp gcc -c sub.cpp -o sub.odiv.o:div.cpp gcc -c div.cpp -o div.oadd.o:add.cpp gcc -c add.cpp -o add.ohello.o:hello.cpp gcc -c hello.cpp -o hello.o 注意：默认只会执行第一个，所以要把hello.out的命令放在第一个，然后会把所有的依赖都执行 两个函数12src = $(wildcard *.c) #找到当前目录下所有后缀为.c的文件，然后赋值给srcobj = $(patsubst %cpp,%o,$(src)) #就是把，src变量里所有的xxxcpp的字符串替换成xxxo 通过这两个函数，可以把多个.o进行替换，省略了 12345678910111213141516src = $(wildcard *.cpp)obj = $(patsubst %cpp,%o,$(src))hello.out:$(obj) gcc -c $(obj) -o hello.outsub.o:sub.cpp gcc -c sub.cpp -o sub.odiv.o:div.cpp gcc -c div.cpp -o div.oadd.o:add.cpp gcc -c add.cpp -o add.ohello.o:hello.cpp gcc -c hello.cpp -o hello.o clean: rm -rf $(obj) hello.out 通过自定义clean指令，可以执行make clean执行rm -rf 指令，在执行前可以先加-n 看执行的是不是需要的指令make clean -n 但还是很麻烦，如果我们动态的增加一个.cpp或者改动一个.cpp每次都要去改Makefile文件，所以看三个规则。 三个自动变量 $@:表示规则中的目标。 $^:表示规则中所有的依赖条件，组成一个列表，以空格隔开，如果这个列表有重复项则消除重复 $&lt;:表示模式套用规则中的第一个依赖条件，如果运行在模式套用中，相当于依次取出依赖条件套用该模式规则 12345678src = $(wildcard *.cpp)obj = $(patsubst %cpp,%o,$(src))hello.out:$(obj) gcc $^ -o $@#模式套用规则%o:%cpp gcc -c $&lt; -o %@","categories":[{"name":"NDK","slug":"NDK","permalink":"http://example.com/categories/NDK/"}],"tags":[]},{"title":"chromium 网络栈研究","slug":"chromium-网络栈研究","date":"2022-08-17T06:57:03.000Z","updated":"2022-11-17T07:56:15.000Z","comments":true,"path":"2022/08/17/chromium-网络栈研究/","link":"","permalink":"http://example.com/2022/08/17/chromium-%E7%BD%91%E7%BB%9C%E6%A0%88%E7%A0%94%E7%A9%B6/","excerpt":"","text":"网络栈位于net目录下 顶层网络栈对象是UrlRequestContext 位于net&#x2F;url_request&#x2F;url_request_context.cc context含有创建和发出URL请求需要的对象的非所有权指针。Context的生命期必须比所有使用它的request的生命期要长。创建Context是一个相当复杂的过程，通常由URLRequestContextBuilder管理。 net&#x2F;url_request&#x2F;url_request_context_builder.cc 1234567891011std::unique_ptr&lt;URLRequest&gt; URLRequestContext::CreateRequest( const GURL&amp; url, RequestPriority priority, URLRequest::Delegate* delegate, NetworkTrafficAnnotationTag traffic_annotation, bool is_for_websockets, const absl::optional&lt;net::NetLogSource&gt; net_log_source) const &#123; return base::WrapUnique(new URLRequest(url, priority, delegate, this, traffic_annotation, is_for_websockets, net_log_source));&#125; URLRequestContext 的主要用途是使用URLRequestContext::CreateRequest()来创建URLRequest对象 URLRequest是网络栈consumer使用的主要接口。它负责加载使用http、https、ws、wss的URLs。使用其他协议的URLs，例如file、filesystem、blob、chrome和data，都被&#x2F;&#x2F;net外的对象管理。","categories":[],"tags":[]},{"title":"ViewModel的原理","slug":"ViewModel的原理","date":"2022-08-16T02:18:59.000Z","updated":"2022-11-17T07:56:14.000Z","comments":true,"path":"2022/08/16/ViewModel的原理/","link":"","permalink":"http://example.com/2022/08/16/ViewModel%E7%9A%84%E5%8E%9F%E7%90%86/","excerpt":"","text":"ViewModel原理在页面中通过ViewModelProvider类来实现化ViewModel。 1val timerViewModel = ViewModelProvider(this).get(TimerViewModel::class.java) ViewModelProvider接收一个ViewModelStoreOwner对象作为参数。在以上示例代码中该参数是this,指代当前的Activity。这是因为我们的Activity继承自FragmentActivity，而在androidx依赖包中，FragmentActivity默认实现了ViewModelStoreOwner接口。 123456789public class ComponentActivity extends androidx.core.app.ComponentActivity implements ContextAware, LifecycleOwner, ViewModelStoreOwner, HasDefaultViewModelProviderFactory, SavedStateRegistryOwner, OnBackPressedDispatcherOwner, ActivityResultRegistryOwner, ActivityResultCaller ViewModelStoreOwner.java 接口 123456789public interface ViewModelStoreOwner &#123; /** * Returns owned &#123;@link ViewModelStore&#125; * * @return a &#123;@code ViewModelStore&#125; */ @NonNull ViewModelStore getViewModelStore();&#125; 接口返回类型是ViewModelStore 1234567891011121314151617181920212223242526272829public class ViewModelStore &#123; private final HashMap&lt;String, ViewModel&gt; mMap = new HashMap&lt;&gt;(); final void put(String key, ViewModel viewModel) &#123; ViewModel oldViewModel = mMap.put(key, viewModel); if (oldViewModel != null) &#123; oldViewModel.onCleared(); &#125; &#125; final ViewModel get(String key) &#123; return mMap.get(key); &#125; Set&lt;String&gt; keys() &#123; return new HashSet&lt;&gt;(mMap.keySet()); &#125; /** * Clears internal storage and notifies ViewModels that they are no longer used. */ public final void clear() &#123; for (ViewModel vm : mMap.values()) &#123; vm.clear(); &#125; mMap.clear(); &#125;&#125; 从源码可以看出，ViewModel实际上是以HashMap&lt;String,ViewModel&gt;的形式被缓存起来了。ViewModel与页面之间没有直接关联，它们通过ViewModelProvider索要，ViewModelProvider检查该ViewModel是否已经存在于缓存中，若存在，则直接返回，若不存在，则实例化一个。因此Activity由于配置变化导致的销毁重建并不会影响ViewModel，ViewModel是独立于页面而存在的。也正因为此，我们使用ViewModel时，需要特别注意，不要向ViewModel中传入任何类型Context或带有Context引用的对象，这可能会导致页面无法被销毁，从而引发内存泄漏。 需要注意的是，除了Activity，androidx依赖包中的Fragment也默认实现了ViewModelStoreOwner接口。因此我们也可以在Fragment中正常使用ViewModel。 ViewModel与AndroidViewModel前面提到过，使用ViewModel时，不能将任何类型的Context或含有Context引用的对象传入ViewModel，因为可能会导致内存泄漏。但如果你希望在ViewModel中使用Context，该怎么办？可以使用AndroidViewModel，它继承自ViewModel，并接收Application作为Context。这意味着，它的生命周期和Applicatioin是一样的，那么这就不算是一个内存泄漏了。 ViewModel与onSaveInstanceState()方法对于页面数据的保存与恢复，也许你会有这样的疑问，onSaveInstanceState()方法同样可以解决屏幕旋转带来的数据丢失问题，那么是不是没有必要使用ViewModel呢？好问题！请注意，onSaveInstanceState方法只能保存少量的、能支持序列化的数据，而ViewModel没有这个限制。ViewModel能支持页面中所有的数据。同样需要注意的是，ViewModel不支持数据的持久化，当界面被彻底销毁时，ViewModel及其持有的数据就不存在了，但是onSaveInstanceState方法没有这个限制，它可以持久化页面的数据。可见，onSaveInstance方法有其特殊用途，二者不可混淆。","categories":[],"tags":[]},{"title":"Android 平台Native代码崩溃捕获机制及实现","slug":"Android-平台Native代码崩溃捕获机制及实现","date":"2022-08-01T06:25:05.000Z","updated":"2022-11-17T07:56:14.000Z","comments":true,"path":"2022/08/01/Android-平台Native代码崩溃捕获机制及实现/","link":"","permalink":"http://example.com/2022/08/01/Android-%E5%B9%B3%E5%8F%B0Native%E4%BB%A3%E7%A0%81%E5%B4%A9%E6%BA%83%E6%8D%95%E8%8E%B7%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"信号机制程序崩溃 在Unix-like系统中，所有的崩溃都是编程错误或者硬件错误相关的，系统遇到不可恢复的错误时会触发崩溃机制让程序退出，如除零、段地址错误等。 异常发生时，CPU通过异常中断的方式，触发异常处理流程。不同的处理器，有不同的异常中断类型和中断处理方式。 linux把这些中断处理，统一为信号量，可以注册信号量向量进行处理。 信号机制是进程之间相互传递消息的一种方法，信号全称为软中断信号。 信号机制函数运行在用户态，当遇到系统调用、中断或是异常的情况时，程序会进入内核态。信号涉及到了这两种状态之间的转换。 (1) 信号的接收接收信号的任务是由内核代理的，当内核接收到信号后，会将其放到对应进程的信号队列中，同时向进程发送一个中断，使其陷入内核态。注意，此时信号还只是在队列中，对进程来说暂时是不知道有信号到来的。 (2) 信号的检测进程陷入内核态后，有两种场景会对信号进行检测： 进程从内核态返回到用户态前进行信号检测 进程在内核态中，从睡眠状态被唤醒的时候进行信号检测 当发现有新信号时，便会进入下一步，信号的处理。 (3) 信号的处理信号处理函数是运行在用户态的，调用处理函数前，内核会将当前内核栈的内容备份拷贝到用户栈上，并且修改指令寄存器（eip）将其指向信号处理函数。 接下来进程返回到用户态中，执行相应的信号处理函数。 信号处理函数执行完成后，还需要返回内核态，检查是否还有其它信号未处理。如果所有信号都处理完成，就会将内核栈恢复（从用户栈的备份拷贝回来），同时恢复指令寄存器（eip）将其指向中断前的运行位置，最后回到用户态继续执行进程。 至此，一个完整的信号处理流程便结束了，如果同时有多个信号到达，上面的处理流程会在第2步和第3步骤间重复进行。","categories":[],"tags":[]},{"title":"ELF文件学习-符号表","slug":"ELF文件学习-符号表","date":"2022-07-18T07:49:19.000Z","updated":"2022-11-17T07:56:14.000Z","comments":true,"path":"2022/07/18/ELF文件学习-符号表/","link":"","permalink":"http://example.com/2022/07/18/ELF%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0-%E7%AC%A6%E5%8F%B7%E8%A1%A8/","excerpt":"","text":"前言我们常常调试错误说需要符号表，那么符号表是什么？符号表仅仅用来调试？ 符号表本质就是一个映射表，举个例子：某行二进制汇编代码映射到源码第几行。 符号表的作用： 调试 重定位 调试重定位可以大致分为两种类别动态重定位与静态重定位 静态重定位看下面源代码 12345678910111213//mainA.cint globalvar=0x123;void test()&#123;&#125;//mainB.cextern test();extern int globalvar;void testFunB()&#123; test(); printf(&quot;I am %d\\r\\n&quot;,globalvar)&#125; 我们程序有两个源代码，我们知道我编译的时候我们首先先将程序编译成目标文件。 也就是mainB.o mainA.o，在目标文件中mainB.o不知道test函数和globalvar变量的地址，因此我们需要在链接时修正mainB.o函数调用地址。 在编译成目标文件时，编译器会把文件中所有的函数与变量地址放入一个符号表中。在链接时把所有目标文件的符号表合成一个，然后利用重定位表和符号表完成函数调用地址修正。 我们看链接前示意图： 链接后： 动态重定位假设A程序需要xxx.so中的yyyy函数那么就需要从xxx.so中的符号表进行读取。 动态重定位和静态符号表原理都差不多，不过重定位操作延迟到调用时 静态符号表12345678910111213141516#include &lt;stdio.h&gt;static int mystaticVar = 3 ;int myglobalvar=5;int myglobalvar2=6;extern void testfun();int main()&#123; int *inp= 0x00; *inp=2; testfun(); printf(&quot;hello world %d \\r\\n&quot;,mystaticVar); return 0;&#125;void hell()&#123;testfun();&#125; 编译成目标文件：gcc -c -o main.o main.c 首先我们查看对应头表 可以看到一个.symtab这个就是我们符号表数组起始地址 他的结构如下所示： 1234567891011121314151617typedef struct &#123; Elf32_Word st_name; Elf32_Addr st_value; Elf32_Word st_size; unsigned char st_info; unsigned char st_other; Elf32_Half st_shndx;&#125; Elf32_Sym;//32位typedef struct &#123; Elf64_Word st_name; unsigned char st_info; unsigned char st_other; Elf64_Half st_shndx; Elf64_Addr st_value; Elf64_Xword st_size;&#125; Elf64_Sym;//64位 相应的符号表的用命令查看 st_name数值表示该符号字符串位于字符串表(.)中的下标。","categories":[{"name":"NDK","slug":"NDK","permalink":"http://example.com/categories/NDK/"}],"tags":[]},{"title":"ELF文件学习-通过GDB学习PLT和GOT","slug":"ELF文件学习-通过GDB学习PLT和GOT","date":"2022-07-18T05:37:08.000Z","updated":"2022-11-17T07:56:14.000Z","comments":true,"path":"2022/07/18/ELF文件学习-通过GDB学习PLT和GOT/","link":"","permalink":"http://example.com/2022/07/18/ELF%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0-%E9%80%9A%E8%BF%87GDB%E5%AD%A6%E4%B9%A0PLT%E5%92%8CGOT/","excerpt":"","text":"前言我们知道printf代码的实现位于libc.so中，而我们知道我们的so是在运行通过加载器进行加载的。 如下代码所示： 123456//编译指令 gcc -o main2.out main2.c -zlazy //zlazy是启用延迟绑定。部分发行版本连接器直接程序加载的时候会进行绑定so函数#include &lt;stdio.h&gt;void main()&#123; printf(&quot;hello %d&quot;,23);&#125; 1ldd main2.out ldd 可以查看程序所需求的动态库 在so编译的时候printf是不知道函数地址的，因为你不知道so中被加载到内存哪个地址。 解决方案1我们直接在程序被加载时重写改写所有so的函数调用地址。 比如如下汇编在编译时的指令 123call xxx1call xxx2call xxx3 加载后修改所有地址 123call yyy1cal yyy2call yyy3 但是弊端异常明显，假设一个程序需要重定位100万个地址的话，那么程序启动会异常的慢，而且你程序不可能所有指令都会被调用(也许用户刚打开就关闭，你的代码基本没怎么执行却浪费大量的时间在加载时)。 解决方案2延迟绑定重定位的地址，也就是我们在调用某条指令的时候再去修改他的调用地址。为了实现延迟绑定ELF推出了两个节 .GOT，PLT. 首先我們要明白其中的一些格式 .got其实本质是一张表，每一项都是一个地址，也许是变量的地址或者函数的。某个需要重定位的函数被调用后.got表里的与之关联的地址会被改成真正函数地址（未被调用之前got的地址指向plt某个函数）。 .plt存储的是桩代码，负责解析与调用真正的重定位地址函数。 我们用一个例子举例说明： 我们原始调用某个函数的汇编指令： 1call xxxx #调用&lt;printf&gt;实际所在地址 启用延迟绑定后这个指令会改为调用plt某处代码 1call 1050 #改为调用plt的某处代码 跳转处plt代码如下所示 0x2fe2 指向.got.plt表中的第二个地址 0x2fe3 指禹.got.plt表中的第三个地址 0x2fe2 传入的是link_map结构，可以让我们查找函数 1234567891011struct link_map &#123; /* These first few members are part of the protocol with the debugger. This is the same format used in SVR4. */ ElfW(Addr) l_addr; /* Difference between the address in the ELF file and the addresses in memory. */ char *l_name; /* Absolute file name object was found in. */ ElfW(Dyn) *l_ld; /* Dynamic section of the shared object. */ struct link_map *l_next, *l_prev; /* Chain of loaded objects. */ &#125;; 而0x2fe3 其实是一个名叫_dl_runtime_resolve函数，他的作用有两个 根据传入的函数id和link_map修改got表地址为函数地址 跳转查找的函数地址 _dl_runtim_resolve 函数执行完了， 得到目标函数的地址然后写回.got表，然后才执行目标函数，这样就动态的找到了目标函数地址并执行，这时查看.got表中之前的地址，目录函数的地址已经被替换。 方便理解使有gdb调试进行演示： 123456//编译指令 gcc -o main2.out main2.c -zlazy //zlazy是启用延迟绑定。部分发行版本连接器直接程序加载的时候会进行绑定so函数#include &lt;stdio.h&gt;void main()&#123; printf(&quot;hello %d&quot;,23);&#125; 首先gbd main2.out进入gdb调试界面 layout asm打开汇编面板 b main 在main函数上打断点 r 运行程序 si 单独调试 运行到callq 0x1050 &lt;printf@plt&gt; si 步入 跳到0x555555555050地址 *0x2fbd(%rip) 是got表中的某一项地址，也就是printf地址，但是由于没有重定向，此时got中的地址会指向另一个plt函数地址 在图中的就是 0x555555558018 这个地址中存储的地址 接着调用 si 去步入 程序跳到 0x555555555030 pushq 0x0 是printf函数的id 这个由编译器&#x2F;连接器决定函数id是什么，这个地址的代码是ptl.sec中的代码，这段代码最后又跳到 0x555555555020 我们接着si 跳转 .got.plt 第二项是link_map .got.plt 中第三项是_dl_runtime_resolve函数地址 ni 跳过pushq si 步入到_dl_runtime_resolve函数 ni不停的一步步跳 最后执行到printf函数 bt看到当前执行栈 执行到printf函数了 这里我们查看.got表中的地址，已经替换 已经替换成了真实的地址","categories":[{"name":"NDK","slug":"NDK","permalink":"http://example.com/categories/NDK/"}],"tags":[]},{"title":"ELF格式学习-elf头部与节头","slug":"ELF文件学习","date":"2022-07-18T01:11:53.000Z","updated":"2022-11-17T07:56:14.000Z","comments":true,"path":"2022/07/18/ELF文件学习/","link":"","permalink":"http://example.com/2022/07/18/ELF%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"前言ELF是linux动态库,可执行文件的格式。可以类比到windows下exe的格式。首先推荐一个写的不错文档ELF格式 我们知道程序需要加载内存后才能运行。但是ELF文件加载到内存后布局会变化，和原始ELF文件相比，加载器会将相同的节属性（比如只读）合并一个段。所以ELF也就有了两种视图，一种未加载前静态视图，另一种是加载后的动态视图。 我们首先了解静态视图下ELF文件格式如下： 你可以把ELF内容大致分为四个部分: (1) ELF头部 (2) 节 (3) 节表头 (4) 程序头 ELF头部固定在ELF文件开始 需要留意程序头和节表头可以位于ELF任意位置，他们位置被ELF头部中的属性指定 节分有很多种格式需要根据节类别区分，比如重定义节 与代码节 本文根据以下代码作为示例 123456789101112131415161718#include &lt;stdio.h&gt;static int mystaticVar = 3 ;int myglobalvar=3;//函数来自test.soextern void testfun();int main()&#123; int *inp= 0x00; *inp=2; testfun(); static int myLocalVar1 = 3 ; static int myUnintLocallvar; printf(&quot;hello world %d \\r\\n&quot;,mystaticVar); return 0;&#125;void hell()&#123;testfun();&#125; 执行 1gcc -c -o main.o main.c 生成目录文件 main.o 再执行 1gcc -o main.out main.o 生成可执行文件main.out ELF头部在linux系统下执行 1file main.o ELF 64-bit 告诉我们这个文件是一个64位系统下的ELF文件 LSB是least significant bit缩写表示第一个字节是多字节中最低有效位，简而言之就是小端模式 x86-64 是指该文件运行在那个处理器的ABI下 version 1(SYSV)是该ELF标准是UNIX_System_V具体参阅SYSV not stripped表示该ELF存在符号表 relocatable 表示该文件是可重定位，因为main.o是目标文件而不是可执行文件，部分代码地址是不确定的 上面信息其实file程序读取该文件的elf头部得到，我们使用readelf -h文件头查看详细的信息 1readelf -h main.o 我们通过010Editor查看main.o 数据结构，我们通过查看elf.h头文件，可以看到 123456789101112131415161718192021222324252627282930313233#define EI_NIDENT 16typedef struct elf32_hdr&#123; unsigned char e_ident[EI_NIDENT]; Elf32_Half e_type; Elf32_Half e_machine; Elf32_Word e_version; Elf32_Addr e_entry; /* Entry point */ Elf32_Off e_phoff; Elf32_Off e_shoff; Elf32_Word e_flags; Elf32_Half e_ehsize; Elf32_Half e_phentsize; Elf32_Half e_phnum; Elf32_Half e_shentsize; Elf32_Half e_shnum; Elf32_Half e_shstrndx;&#125; Elf32_Ehdr;typedef struct elf64_hdr &#123; unsigned char e_ident[16]; /* ELF &quot;magic number&quot; */ Elf64_Half e_type; Elf64_Half e_machine; Elf64_Word e_version; Elf64_Addr e_entry; /* Entry point virtual address */ Elf64_Off e_phoff; /* Program header table file offset */ Elf64_Off e_shoff; /* Section header table file offset */ Elf64_Word e_flags; Elf64_Half e_ehsize; Elf64_Half e_phentsize; Elf64_Half e_phnum; Elf64_Half e_shentsize; Elf64_Half e_shnum; Elf64_Half e_shstrndx;&#125; Elf64_Ehdr; e_ident一个16字节数组大小 在elf.h有EI_XXX表示上面下标位置 123456789101112131415161718#define EI_MAG0 0 /* e_ident[] indexes */#define EI_MAG1 1#define EI_MAG2 2#define EI_MAG3 3#define EI_CLASS 4#define EI_DATA 5#define EI_VERSION 6#define EI_PAD 7#define ELFMAG0 0x7f /* EI_MAG */#define ELFMAG1 &#x27;E&#x27;#define ELFMAG2 &#x27;L&#x27;#define ELFMAG3 &#x27;F&#x27;#define ELFMAG &quot;177ELF&quot;#define SELFMAG 4#define ELFCLASSNONE 0 /* EI_CLASS */#define ELFCLASS32 1#define ELFCLASS64 2#define ELFCLASSNUM 3 e_type表示当前ELF文件类型，下面举例常见的类型 e_machine制定当前ELF运行的CPU架构下面举例常见的类型 e_version用于指定ELF版本一般都为1 e_entryelf 代码运行的入口 e_flags在e_machine指定的处理器下的一些特性 节头表相关字段e_shoff节头表在文件的偏移 e_shentsize节头表中每个条目的大小 e_shnum节头表中条目的数目 程序头相关字段e_phoff程序头在文件中的偏移 e_phentsize指定程序头中每个条目的大小 e_phnum指定程序头中每个条目的个数 e_shstrndx每个节头都一个名称，这些名称都存储一个特殊节中。而e_shstrndx 指定这个特殊的节所在节头表的下标 我们先看看这个程序中所有节如下： 1readelf -S --wide main.o 一共13个节，其中.shstrtab表示的存储字符串节 。.shstrtab是section head string table 我们查看这个节内容如下所示： 1readelf -x .shstrtab main.o 大致结构如下： 节头依旧使用main.o我们可以到节头表信息如下： 节头表的第一项固定为空节不存储实际内容 readelf指令为 1readelf -S --wide main.o 节头的数据结构 12345678910111213typedef struct&#123; Elf64_Word sh_name; /* Section name (string tbl index) */ Elf64_Word sh_type; /* Section type */ Elf64_Xword sh_flags; /* Section flags */ Elf64_Addr sh_addr; /* Section virtual addr at execution */ Elf64_Off sh_offset; /* Section file offset */ Elf64_Xword sh_size; /* Section size in bytes */ Elf64_Word sh_link; /* Link to another section */ Elf64_Word sh_info; /* Additional section information */ Elf64_Xword sh_addralign; /* Section alignment */ Elf64_Xword sh_entsize; /* Entry size if section holds table */&#125; Elf64_Shdr; elf节头规则详细文档 https://refspecs.linuxfoundation.org/elf/gabi4+/ch4.sheader.html sh_name节名在字符串节中下标,本例中字符串节名称为.shstrtab.我们举例其中一个节.text 我们看到.text节的sh_name为20h也就是十进制32.我们看下.shstrtab指向的字节数组的32位 sh_type这个字段根据节的内容(content)和语义(semantics)对节进行分类。分类类型有很多种，我们只举例其中比较常见的类型。 .text与.data一般就是SHT_PROGBITS （text存储代码 data存储数据）.shstrtab一般是SHT_STRTAB.bss一般是SHT_NOBITS (存储全局未初始化数据等) sh_flags字段标记是否可读可写可执行等，以及是否在内存中分配内存(SHF_ALLOC)下图为枚举值表： sh_addr这个节被加载后对应VA地址 sh_offset这个节在文件中的偏移 sh_size节大小（不是指节头大小哦） sh_link一般用于关联节所在节头表的数组下标，一般为0举例说明：我们节中有一个专门用于重定位的节如.rela.text 就是用来重定位代码段部分代码的。sh_link表示这个节所使用的的符号表节在节头表的下标sh_info表示哪个节需要重定向。这个值指向在节头表中的索引。 sh_info一般用于关联节所在节头表的数组下标，一般为0 sh_addralign对其数值。如果为0或者1表示不对齐。sh_addr必须为0或者对其sh_addralign取模 sh_entsizeent是entry缩写。 部分节内部存储是固定数据结构条目数组,针对这类别节sh_entsize指代的是每个条目的字节大小。 举例说明：符号表节名为.symtab,它存储若干固定结构的符号信息。如下图所示 123456789101112131415161718typedef struct &#123; Elf32_Word st_name; Elf32_Addr st_value; Elf32_Word st_size; unsigned char st_info; unsigned char st_other; Elf32_Half st_shndx;&#125; Elf32_Sym;//32位typedef struct &#123; Elf64_Word st_name; unsigned char st_info; unsigned char st_other; Elf64_Half st_shndx; Elf64_Addr st_value; Elf64_Xword st_size;&#125; Elf64_Sym;//64位 sh_entsize指的就是Elf64_Sym或者Elf32_Sym的大小","categories":[{"name":"NDK","slug":"NDK","permalink":"http://example.com/categories/NDK/"}],"tags":[]},{"title":"Android-VPN学习笔记","slug":"Android-VPN学习笔记","date":"2022-06-21T02:24:25.000Z","updated":"2022-11-17T07:56:14.000Z","comments":true,"path":"2022/06/21/Android-VPN学习笔记/","link":"","permalink":"http://example.com/2022/06/21/Android-VPN%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"基本原理android设备上，如果已经使用了VpnService框架，建立起了一条从设备到远端的VPN链接，那么数据包在设备上大致经历了如下四个过程的转换： 在介绍如何使用这些新增的API之前，先来说说其基本的原理。 android设备上，如果已经使用了VpnService框架，建立起了一条从设备到远端的VPN链接，那么数据包在设备上大致经历了如下四个过程的转换： 1）应用程序使用socket，将相应的数据包发送到真实的网络设备上。一般移动设备只有无线网卡，因此是发送到真实的WiFi设备上； 2）Android系统通过iptables，使用NAT，将所有的数据包转发到TUN虚拟网络设备上去，端口是tun0； 3）VPN程序通过打开&#x2F;dev&#x2F;tun设备，并读取该设备上的数据，可以获得所有转发到TUN虚拟网络设备上的IP包。因为设备上的所有IP包都会被NAT转成原地址是tun0端口发送的，所以也就是说你的VPN程序可以获得进出该设备的几乎所有的数据（也有例外，不是全部，比如回环数据就无法获得）； 4）VPN数据可以做一些处理，然后将处理过后的数据包，通过真实的网络设备发送出去。为了防止发送的数据包再被转到TUN虚拟网络设备上，VPN程序所使用的socket必须先被明确绑定到真实的网络设备上去。 代码实现要实现Android设备上的VPN程序，一般需要分别实现一个继承自Activity类的带UI的客户程序和一个继承自VpnService类的服务程序。 申明权限 要想让你的VPN程序正常运行，首先必须要在AndroidManifest.xml中显式申明使用“android.permission.BIND_VPN_SERVICE”权限。 客户程序实现 客户程序一般要首先调用VpnService.prepare函数： Vpnservice是安卓提供给开发者用于开发自己的VPN的服务。开发者继承这个Vpnservice，从而实现VPN。手机本身是有一块网卡，安卓虚拟出一个网卡，然后通过NAT，将真实网卡上的出站流量转发到虚拟网卡上，然后Vpnservice获取这个虚拟网卡上的“流量”，并转发给Vpn的服务端。其实还是挺好理解的。问题在于，上面说的流量，并不是传输层的tcp&#x2F;udp流量，而是ip数据报。 现在要处理ip数据报，而且java语言只提供了传输层（tcp&#x2F;udp）的socket传输api。这意味着，开发Vpn必定有一部分需要使用其他语言（C&#x2F;C++）。 看安卓example的ToyVpn中server的代码，发现他的代码就是直接open &#x2F;dev下的网卡文件，然后读写来收取ip数据。 解决方案一这也是ToyVpn所采用的实现方式，将IP数据包通过UDP发送给vps服务器，vps服务器解包后得到原始的IP数据包，通过C&#x2F;C++写进网卡文件，然后把IP数据包发送出去(为啥不用java,因为java只能操作tcp&#x2F;udp的socket api，无法直接把IP数据包写入网卡，并发送出去) 通过Udp传输的原因是，Udp（用户数据报）是ip数据报的简单包裹，不像tcp数据包那样，增加了很复杂的东西，也不进行失败重传等操作。要清楚，我们这里传输的是较底层的ip数据报，在ip数据报的上层，可能是UDP，也可能是TCP，不管传输层是什么协议，消息的正确性，失败重传等等，都有人在传输层做过了，我们只要传就好了，所以用UDP是最好的。 数据报文封包和UDP隧道相对来说还是比较容易理解的概念。试想一个进入隧道的TCP数据包： 这个数据报有正常的IP和TCP头，后面是用户要发送的数据。封包的过程如下： 这样，这个数据包就是一个UDP数据包，里面装的是TCP数据包。系统可以将他想普通的UDP数据包一样发送；在接收端，额外的UDP头部被去掉后，原始的包含tcp消息的ip数据报经修改后（修改源ip地址）继续进入网络堆栈进行处理。","categories":[],"tags":[]},{"title":"c++-类的定义、运算符重载","slug":"c-类的定义、运算符重载-1","date":"2022-06-19T05:15:31.000Z","updated":"2022-11-17T07:56:15.000Z","comments":true,"path":"2022/06/19/c-类的定义、运算符重载-1/","link":"","permalink":"http://example.com/2022/06/19/c-%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-1/","excerpt":"","text":"继承 class A:[private&#x2F;protected&#x2F;public] B 默认为private继承 A是基类，B称为子类或者派生类 方式 说明 public 基类的public、protected成员也是派生类相应的成员，基类的private成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。 protected 基类的公有和保护成员将成为派生类的保护成员 private 基类的公有和保护成员将成为派生类的私有成员 123456789101112131415class Parent &#123;public: void test() &#123; cout &lt;&lt; &quot;parent&quot; &lt;&lt; endl; &#125;&#125;;class Child : Parent &#123;public: void test() &#123; // 调用父类 方法 Parent::test(); cout &lt;&lt; &quot;child&quot; &lt;&lt; endl; &#125;&#125;; 多继承 一个子类可以有多个父类，它继承了多个父类的特性。 class &lt;派生类名&gt;:&lt;继承方式1&gt;&lt;基类名1&gt;,&lt;继承方式2&gt;&lt;基类名2&gt;,… 多态 多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。 静态多态（静态联编）是指在编译期间就可以确定函数的调用地址，通过函数重载和模版（泛型编程）实现 动态多态（动态联编）是指函数调用的地址不能在编译器期间确定，必须需要在运行时才确定 ,通过继承+虚函数 实现 虚函数123456789101112131415161718192021222324class Parent &#123;public: void test() &#123; cout &lt;&lt; &quot;parent&quot; &lt;&lt; endl; &#125;&#125;;class Child :public Parent &#123;public: void test() &#123; cout &lt;&lt; &quot;child&quot; &lt;&lt; endl; &#125;&#125;;Parent *c = new Child();// 编译期间 确定c 为 parent 调用parent的test方法c-&gt;test();//修改Parent为virtual 虚函数 动态链接,告诉编译器不要静态链接到该函数virtual void test() &#123; cout &lt;&lt; &quot;parent&quot; &lt;&lt; endl;&#125;//动态多态 调用Child的test方法c-&gt;test(); 构造函数任何时候都不可以声明为虚函数 析构函数一般都是虚函数,释放先执行子类再执行父类 纯虚函数 12345678910class Parent &#123;public: //纯虚函数 继承自这个类需要实现 抽象类型 virtual void test() = 0;&#125;;class Child :public Parent &#123;public: void test()&#123;&#125;&#125;; 模板 模板是泛型编程的基础 函数模板 函数模板能够用来创建一个通用的函数。以支持多种不同的形參。避免重载函数的函数体反复设计。 123456789template &lt;typename T&gt; T max(T a,T b)&#123; // 函数的主体 return a &gt; b ? a : b;&#125;//代替了int max(int a,int b)int max(float a,float b) 类模板(泛型类) 为类定义一种模式。使得类中的某些数据成员、默写成员函数的參数、某些成员函数的返回值，能够取随意类型 常见的 容器比如 向量 vector 或 vector 就是模板类 12345678910template&lt;class E,class T&gt;class Queue &#123;public: T add(E e,T t)&#123; return e+t; &#125;&#125;;Queue&lt;int,float&gt; q;q.add(1,1.1f) = 2.1f","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[]},{"title":"c++-类的定义、运算符重载","slug":"c-类的定义、运算符重载","date":"2022-06-19T04:24:30.000Z","updated":"2022-11-17T07:56:15.000Z","comments":true,"path":"2022/06/19/c-类的定义、运算符重载/","link":"","permalink":"http://example.com/2022/06/19/c-%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/","excerpt":"","text":"类 C++ 在 C 语言的基础上增加了面向对象编程，C++ 支持面向对象程序设计。类是 C++ 的核心特性，用户定义的类型。 12345678910111213141516171819class Student &#123; int i; //默认 privatepublic: Student(int i,int j,int k):i(i),j(j),k(k); //构造方法 ~Student(); //析构方法 private: int j;protected: int k;&#125;;Student student(1,2,3); //调用构造方法 栈//出方法释放student 调用析构方法//动态内存(堆)Student *student = new Student(1,2,3);//释放delete student;student = 0; 类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行(不需要手动调用)。 private：可以被该类中的函数、友元函数访问。 不能被任何其他访问，该类的对象也不能访问。 protected：可以被该类中的函数、子类的函数、友元函数访问。 但不能被该类的对象访问。 public：可以被该类中的函数、子类的函数、友元函数访问，也可以被该类的对象访问。 Student.cpp 123456789101112131415161718192021#include &quot;Student.h&quot;#include &lt;iostream&gt;using namespace std;//实现函数，要使用域作用符:://构造方法 i(i) 前面的是成员属性 后面是传参的i 只有构造函数可以这么写 这是一种给成员属性赋值的方法Student::Student(int i,int j):i(i),j(j) &#123; //由动态申请内存来的，没调用 free会泄漏 //xx = malloc(100); //可以跟java一样，这么给成员属性赋值 this-&gt;i = i; this-&gt;j = j; cout &lt;&lt; &quot;构造方法&quot; &lt;&lt; endl;&#125;//用于释放动态申请的内存Student::~Student() &#123; cout &lt;&lt; &quot;析构方法&quot; &lt;&lt; endl;&#125; 对应Student的实现，可以直接在h类中，也可以放在cpp中，放在cpp中要注意 使用Student::域作用符加函数名，如果是有返回值的void 的的要在域作用符之前 常量函数 函数后写上const，表示不会也不允许修改类中的成员。 12345678910111213141516class Student &#123; int i;public: Student() &#123;&#125; ~Student() &#123;&#125; // 常量函数 void setName(char* _name) const &#123; //错误 不能修改name 去掉const之后可以 name = _name; &#125;private: int j; char *name;protected: int k;&#125;; 友元 类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员 友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。 友元函数12345678910111213141516171819202122232425class Student &#123; int i;public: Student() &#123;&#125; ~Student() &#123;&#125; void setName(char* _name) &#123; name = _name; &#125; //友元函数 friend void printName(Student *student);private: int j; char *name;protected: int k;&#125;;void printName(Student *student) &#123; //能够使用student中私有的name属性 cout &lt;&lt; student-&gt;name &lt;&lt; endl;&#125;Student *student = new Student;student-&gt;setName(&quot;Lance&quot;);printName(student); 友元类12345678910111213141516171819202122232425class Student &#123; int i;public: Student() &#123;&#125; ~Student() &#123;&#125; void setName(char* _name) &#123; name = _name; &#125; friend void printName(Student *student); //友元类 friend class Teacher;private: int j; char *name;protected: int k;&#125;;class Teacher &#123;public: void call(Student *student) &#123; //能够使用student中私有的name属性 cout &lt;&lt; &quot;call:&quot; &lt;&lt; student-&gt;name &lt;&lt; endl; &#125;&#125;; 静态成员 和Java一样，可以使用static来声明类成员为静态的 当我们使用静态成员属性或者函数时候 需要使用 域运算符 :: 123456789101112131415161718192021//Instance.h#ifndef INSTANCE_H#define INSTANCE_Hclass Instance &#123;public: static Instance* getInstance();private: static Instance *instance;&#125;;#endif //Instance.cpp#include &quot;Instance.h&quot;Instance* Instance::instance = 0;Instance* Instance::getInstance() &#123; //C++11以后，编译器保证内部静态变量的线程安全性 if (!instance) &#123; instance = new Instance; &#125; return instance;&#125; 重载函数 C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分为函数重载和运算符重载。 函数重载1234567void print(int i) &#123; cout &lt;&lt; &quot;整数为: &quot; &lt;&lt; i &lt;&lt; endl;&#125; void print(double f) &#123; cout &lt;&lt; &quot;浮点数为: &quot; &lt;&lt; f &lt;&lt; endl;&#125; 操作符重载 C++允许重定义或重载大部分 C++ 内置的运算符 函数名是由关键字 operator 和其后要重载的运算符符号构成的 重载运算符可被定义为普通的非成员函数或者被定义为类成员函数 成员函数 123456789101112131415161718192021222324252627282930313233class Test1 &#123;public: Test1()&#123;&#125; //定义成员函数进行重载 //返回对象 调用拷贝构造函数 释放函数内 t 对象 //引用类型(Test1&amp;) 没有复制对象 返回的是 t 对象本身 t会被释放 所以会出现问题(数据释放不彻底就不一定) // 可以输出 t 与 t3 地址查看 Test1 operator+(const Test1&amp; t1) &#123; Test1 t; t.i = this-&gt;i + t1.i; return t; &#125; //拷贝构造函数 (有默认的) Test1(const Test1&amp; t)&#123; //浅拷贝 this-&gt;i = t.i; cout &lt;&lt; &quot;拷贝&quot; &lt;&lt; endl; //如果动态申请内存 需要深拷贝 &#125;; int i;&#125;;Test1 t1;Test1 t2;t1.i = 100;t2.i = 200;//发生两次拷贝// C++真正的临时对象是不可见的匿名对象//1、拷贝构造一个无名的临时对象，并返回这个临时对象//2、由临时对象拷贝构造对象 t3//语句结束析构临时对象Test1 t3 = t1 + t2;cout &lt;&lt; t3.i &lt;&lt; endl; Xcode上玩，使用的g++编译器会进行 返回值优化(RVO、NRVO) 从而看不到拷贝构造函数的调用。 可以加入 “-fno-elide-constructors” 取消GNU g++优化 对windows vs编译器cl.exe无效，VS Debug执行RVO，Release执行NRVO RVO（Return Value Optimization）:消除函数返回时创建的临时对象 NRVO(Named Return Value Optimization)：属于 RVO 的一种技术, 直接将要初始化的对象替代掉返回的局部对象进行操作。 非成员函数 1234567891011121314151617class Test2 &#123;public: int i;&#125;;//定义非成员函数进行 + 重载Test2 operator+(const Test2&amp; t21, const Test2&amp; t22) &#123; Test2 t; t.i = t21.i + t22.i; return t;&#125;Test2 t21;Test2 t22;t21.i = 100;t22.i = 200;Test2 t23 = t21 + t22;cout &lt;&lt; t23.i &lt;&lt; endl; 允许重载的运算符 类型 运算符 关系运算符 &#x3D;&#x3D;(等于)，!&#x3D; (不等于)，&lt; (小于)，&gt; (大于&gt;，&lt;&#x3D;(小于等于)，&gt;&#x3D;(大于等于) 逻辑运算符 ||(逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非) 单目运算符 + (正)，-(负)，*(指针)，&amp;(取地址) 自增自减运算符 ++(自增)，–(自减) 位运算符 | (按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移) 赋值运算符 &#x3D;, +&#x3D;, -&#x3D;, *&#x3D;, &#x2F;&#x3D; , % &#x3D; , &amp;&#x3D;, |&#x3D;, ^&#x3D;, &lt;&lt;&#x3D;, &gt;&gt;&#x3D; 空间申请与释放 new, delete, new[ ] , delete[] 其他运算符 ()(函数调用)，-&gt;(成员访问)，,(逗号)， 12345678910111213void *operator new (size_t size)&#123; cout &lt;&lt; &quot;新的new:&quot; &lt;&lt; size &lt;&lt; endl; return malloc(size);&#125;void operator delete(void *p)&#123; //释放由p指向的存储空间 cout &lt;&lt; &quot;新的delete&quot; &lt;&lt; endl; free(p);&#125;... ...","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[]},{"title":"c++-c++基础","slug":"c-c-基础","date":"2022-06-18T23:59:28.000Z","updated":"2022-11-17T07:56:15.000Z","comments":true,"path":"2022/06/19/c-c-基础/","link":"","permalink":"http://example.com/2022/06/19/c-c-%E5%9F%BA%E7%A1%80/","excerpt":"","text":"c与c++兼容c当中大部分代码都可以在c++中使用 在c++中调用c代码，要使用extern “C”{} 为什么？ 写两个一样内容的一个是c文件一个是cpp文件 a.c文件 1234567void test(int x,int y)&#123;&#125;int main()&#123; return 0;&#125; a.cpp文件 123456void test()&#123;&#125;int main()&#123; return 0;&#125; 使用 12gcc a.c -o ac.ogcc a.cpp -o acpp.o 分别进行编译 得到ac.o 和acpp.o两个文件 执行 1nm -A ac.o 我们看到 test编译后的符号表 还是test 然后执行 1nm -A acpp.o 看下按cpp的方式编译后的符号 发现cpp会把参数的类型合并到test上 如果有test(int x,int y) 就是 _Z4testii 那么在cpp中使用c就出现问题了，如图所示 这就是为什么c++中一旦使用c函数，要使用extern “C” 把头文件进行修饰的原因，统一采用C编码方式 引用类型1234567891011change(int&amp; j)&#123; j = 20;&#125;int i = 10;//int&amp; 引用类型 和java很像//10 这个内存地址 给了个别名jint&amp; j = i;//调用change后 j的内存地址上存的值会改变 和指针很像change(j); c中的字符串1234//c 使用NULL \\0结尾的一个字符数组char str1[] = &#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;\\0&#x27;&#125;;char *str2 = &quot;hello&quot;;//默认给我们添加了\\0 这两种都可以称为c风格的字符串 函数 描述 strcpy(s1, s2); 复制字符串 s2 到字符串 s1。 strcat(s1, s2); 连接字符串 s2 到字符串 s1 的末尾。 strlen(s1); 返回字符串 s1 的长度。 strcmp(s1, s2); 如果 s1 和 s2 相同，则返回 0；如果 s1 &lt; s2 则返回小于0；如果 s1&gt;s2 则返回大于0 strchr(s1, ch); 返回指向字符串 s1 中字符 ch 的第一次出现的位置的指针。 strstr(s1, s2); 返回指向字符串 s1 中字符串 s2 的第一次出现的位置的指针。 说明：strcmp:两个字符串自左向右逐个字符相比（按ASCII值大小相比较） c++ string12345678910111213141516171819202122232425262728293031323334#include&lt;string&gt;//都会创建一个c++类型的对象string str1 = &quot;hello&quot;;string str2(str1);string str3(&quot;天之道&quot;);//申请内存 调用 构造方法string *str4 = new String(&quot;88&quot;);//释放内存delete str4;str4 = NULL;//malloc = free//new = delete//new 数组 = delete[]//拼接字符串//+ 操作符重载：重新定义 + - * /的行为string str5 = str1 + str3;//跟java一样，string是一个对象str1.append(str3);//string是对象 不能直接打印 要先获得c风格的字符串cout &lt;&lt; str1.c_str() &lt;&lt; endl;str1.size();str1.empty();//指针就不能用.了 要用-&gt;//用指针有什么好处//1.出方法，清理栈//2.指针 占用字节小 指针是地址 用指针传输效率髚 str4-&gt;c_str(); 命名空间相当于java的包 using namespace std; 不加这个就要 std::cout 要用域作用名 1234567891011121314151617181920212223242526272829303132//定义一个自己的命名空间namespace A&#123; void test()&#123; &#125;&#125;namespace B&#123; namespace C&#123; void test()&#123; &#125; &#125;&#125;//::域作用符A::test();//就像包名一层层嵌套 using namespace A::BA::B::test();int ii;main()&#123; ii = 11; int ii = 10; cout &lt;&lt; ii &lt;&lt; endl;s //操作重名的全局变量的时候 可以使用域作用符 cout &lt;&lt; ::ii &lt;&lt; endl; ::ii = 100;&#125; 像java的包名一样，可以避免同名同参数的函数","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[]},{"title":"c语言-结构体、共用体","slug":"c语言-结构体、共用体","date":"2022-06-18T23:23:02.000Z","updated":"2022-11-17T07:56:15.000Z","comments":true,"path":"2022/06/19/c语言-结构体、共用体/","link":"","permalink":"http://example.com/2022/06/19/c%E8%AF%AD%E8%A8%80-%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%81%E5%85%B1%E7%94%A8%E4%BD%93/","excerpt":"","text":"结构体类似于javabean 结构体当中默认都是public 1234567891011121314151617181920212223//struct 结构体 java class struct Student &#123; int i; short j;&#125;s1,s2;typedef struct People&#123; int i; int j;&#125;People;int main() &#123; struct Student student; student.i = 10; student.j = 20; People people; people.i = 30; people.j = 40; return 0;&#125; c++中结构体是一种类型，可以直接 Student student;这么定义，但在c中，要用struct关键字 struct Student student;除非使用typedef 结构体字节对齐自然对齐：1.某一个变量 保存的内存地址的开始位置需要相对于结构体开始位置的偏移是这个变量字节数的整数倍开发 比如 int 4 保存4这个int 要以 0x00 0x04 0x08 开始 2.结构体所占的字节 是结构体中最长变量所占字节的整数倍 所以就算存出了10个字节的，如果里面有int 10不是4的整数倍，要补齐所以是12 预处理器设置对齐不同平台设置方式不同 只能传的是2的倍数 1234567#pragma pack(2) //windowsstruct MyStruct2&#123; short i; int j; short k;&#125; __attribut__((aligned(2),packed)) //这是linux mac上的设置方式 共用体内存复用，不再使用，节省内存 12345678910111213141516//在相同的内存位置存储不同的数据//共用体 最大成员的字节大小union MyUnion&#123; short i; int j;&#125;; union MyUnion mu; mu.i = 10;//给j赋值，会覆盖i的值 mu.j = 20; printf(&quot;main i的地址:%#x,j的地址:%#x\\n&quot;,&amp;mu.i,&amp;mu.j); 在内存中i和j的地址是一样的，所以 main i的地址:0xe8ee6640,j的地址:0xe8ee6640","categories":[{"name":"C语言","slug":"C语言","permalink":"http://example.com/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[]},{"title":"linux-进程创建与进程管理","slug":"linux-进程创建与进程管理","date":"2022-06-18T20:16:51.000Z","updated":"2022-11-17T07:56:15.000Z","comments":true,"path":"2022/06/19/linux-进程创建与进程管理/","link":"","permalink":"http://example.com/2022/06/19/linux-%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/","excerpt":"","text":"PCB进程操作块PCB本质就是一个结构体 123456789101112131415struct task_struct&#123; //... //进程id //文件描述符 //进程的状态：初始态、就绪态、运行态、挂起态(多个进程切换，同时执行)、终止态 //进程工作目录 //信号相关信息资源 //用户id组id&#125; 内存映射用户空间映射时会映射到不同的区域，但会隔离 pcb 内核空间映射到同一区域不同地方，但没有隔离","categories":[],"tags":[]},{"title":"系统调用及文件IO","slug":"系统调用","date":"2022-06-18T11:52:54.000Z","updated":"2022-11-17T07:56:15.000Z","comments":true,"path":"2022/06/18/系统调用/","link":"","permalink":"http://example.com/2022/06/18/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/","excerpt":"","text":"什么叫系统调用？3-4G是内核的空间，这部分是由操作系统来管理，那么如果我们要操作这部分数据，只能借助系统提供的一些函数(系统函数),用户调用这些函数就称之为系统调用。 系统函数查询通过man命令 1man 2 xxx(open) man 2 查询的是系统函数 如果man 2 查不到就去man 3查询 文件拷贝范例使用普通函数f_get_put.cpp 1234567891011121314151617181920212223242526272829303132333435#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(int argc,const char *argv[])&#123; FILE *rfp = NULL; FILE *wfp = NULL; //open the file rfp = fopen(argv[1],&quot;r&quot;); wfp = fopen(argv[2],&quot;w&quot;); //check the file is open successfully if(NULL == rfp)&#123; printf(&quot;Open the %s is error!\\n&quot;,argv[0]); exit(1); &#125; if(NULL == wfp)&#123; printf(&quot;Open the %s is error!\\n&quot;,argv[1]); exit(1); &#125; //read the file and save the char to the target file //define the char val,use to open and receive file content char ch = 0; while((ch = fgetc(rfp))!=EOF)&#123; fputc(ch,wfp); &#125; printf(&quot;the file copy complete!\\n&quot;); //close the file fclose(rfp); fclose(wfp); return 0;&#125; 使用 1234gcc f_get_put.cpp -o f_get_put#注意argv[1] argv[2] 分别对应两个参数 argv[0] 是f_get_put本身./f_get_put xxx.txt xxx.txt 使用系统函数f_read_write.cpp 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;int main(int argc,const char *argv[])&#123; int fd1,fd2,flag; char buffer[1]; fd1 = open(argv[1],O_RDONLY); if(-1 == fd1)&#123; //open the file fail,return the error printf(&quot;%s:%s\\n&quot;,strerror(errno),argv[1]); return -1; &#125; fd2 = open(argv[2],O_WRONLY|O_CREAT,S_IRUSR|S_IWUSR); if(-1 == fd2)&#123; return -1; &#125; while((flag = read(fd1,buffer,1))&gt;0)&#123; write(fd2,buffer,flag); &#125; close(fd1); close(fd2); return 0;&#125; 使用 1234gcc f_read_write.cpp -o f_read_write#注意argv[1] argv[2] 分别对应两个参数 argv[0] 是f_get_put本身./f_read_write xxx.txt xxx.txt 查看具体执行过程 1strace ./f_read_write 目录遍历123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;dirent.h&gt;#include&lt;error.h&gt;#include&lt;sys/stat.h&gt;bool isdir(const char* fileName)&#123; // struct stat buf; stat(fileName,&amp;buf); mode_t st_mode = buf.st_mode; return S_ISDIR(st_mode);&#125;int main(int argc,char *argv[])&#123; //open the dir DIR *dir = opendir(argv[1]); if(dir == NULL)&#123; perror(&quot;open dir fail&quot;); return -1; &#125; struct dirent* dirp; while((dirp = readdir(dir)) != NULL)&#123; printf(&quot;%s\\t is dir ? -&gt; %d\\n&quot;,dirp-&gt;d_name,isdir(dirp-&gt;d_name)); //这里可以进行递归的遍历操作，判断是不是文件目录 &#125; printf(&quot;\\n&quot;); return 0;&#125;","categories":[],"tags":[]},{"title":"动态库与静态库","slug":"动态库与静态库","date":"2022-06-18T11:47:25.000Z","updated":"2022-11-17T07:56:15.000Z","comments":true,"path":"2022/06/18/动态库与静态库/","link":"","permalink":"http://example.com/2022/06/18/%E5%8A%A8%E6%80%81%E5%BA%93%E4%B8%8E%E9%9D%99%E6%80%81%E5%BA%93/","excerpt":"","text":"概念 静态库：其实是内容的拷贝，运行阶段没有.a文件也是可以执行的。 动态库：不会拷贝内容，运行阶段起的作用(加载)，生成so的时候要生成与位置无关的的代码。 区别静态库的生成1.将c生成.o(省略4步)1gcc -c add.c -o add.o 2.使用ar工具制作静态库1ar rcs libmath.a add.o sub.o .... 3.编译静态库到可执行文件1gcc a.c libmath.a -o a 动态库生成1.将c生成.o(要生成与位置无关的代码)1gcc -c add.c -o add.o-fPIC 2.使用gcc -shared制作动态库1gcc -shared -o libmath.so add.o xxx.o .... 3.编译动态库到可执行文件，需要指定动态库的名称-l，指定库路径 -L1gcc a.c -o a -l 名称 -L 路径","categories":[{"name":"NDK","slug":"NDK","permalink":"http://example.com/categories/NDK/"}],"tags":[]},{"title":"gcc编译四个步骤","slug":"gcc编译四个步骤","date":"2022-06-18T11:43:15.000Z","updated":"2022-11-17T07:56:15.000Z","comments":true,"path":"2022/06/18/gcc编译四个步骤/","link":"","permalink":"http://example.com/2022/06/18/gcc%E7%BC%96%E8%AF%91%E5%9B%9B%E4%B8%AA%E6%AD%A5%E9%AA%A4/","excerpt":"","text":"gcc编译步骤1.预处理 宏展开 展开include文件 1gcc -E -o a.i a.c 2.预编译 gcc才会检测代码的规范性，语法是否有错误 gcc 会把代码翻译成汇编 1gcc -S -o a.s a.i 3.汇编阶段 得到汇编的文件 把.s文件翻译成二进制.o文件(机器的指令) ,文本打开的是乱码 1gcc -c -o a.o a.s 4.链接阶段 计算逻辑地址，合并数据段 有些函数是在另外一个so -o 链接 1gcc -o a a.o 一步编译为可以运行的可执行文件1gcc a.c/a.cpp -o a","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[]},{"title":"JNI 如何实现数据传递?","slug":"JNI-如何实现数据传递","date":"2022-06-05T08:45:53.000Z","updated":"2022-11-17T07:56:14.000Z","comments":true,"path":"2022/06/05/JNI-如何实现数据传递/","link":"","permalink":"http://example.com/2022/06/05/JNI-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92/","excerpt":"","text":"","categories":[{"name":"NDK","slug":"NDK","permalink":"http://example.com/categories/NDK/"}],"tags":[]},{"title":"Java Native 方法与 Native 函数是怎么绑定的","slug":"Java-Native-方法与-Native-函数是怎么绑定的","date":"2022-06-05T08:28:04.000Z","updated":"2022-11-17T07:56:14.000Z","comments":true,"path":"2022/06/05/Java-Native-方法与-Native-函数是怎么绑定的/","link":"","permalink":"http://example.com/2022/06/05/Java-Native-%E6%96%B9%E6%B3%95%E4%B8%8E-Native-%E5%87%BD%E6%95%B0%E6%98%AF%E6%80%8E%E4%B9%88%E7%BB%91%E5%AE%9A%E7%9A%84/","excerpt":"","text":"静态绑定：通过命名规则映射 动态绑定：通过JNI函数的注册 静态绑定 包名——类名——方法名 一一对应 extern “C” 告诉编译器，以c的方式去保留这一名称，这个是要在符号表中直接保留原名，而不是写了什么就是什么，必须在符号表中有对应关系 动态绑定 一般动态绑定在JNi_onLoad里触发 动态绑定可以在任何时刻触发 动态绑定之前根据静态规则查找Native函数 动态绑定可以在绑定后的任意时刻取消 动态绑定与静态绑定对比","categories":[{"name":"NDK","slug":"NDK","permalink":"http://example.com/categories/NDK/"}],"tags":[]},{"title":"CPU架构适配需要注意哪些问题","slug":"CPU架构适配需要注意哪些问题","date":"2022-06-05T08:04:16.000Z","updated":"2022-11-17T07:56:14.000Z","comments":true,"path":"2022/06/05/CPU架构适配需要注意哪些问题/","link":"","permalink":"http://example.com/2022/06/05/CPU%E6%9E%B6%E6%9E%84%E9%80%82%E9%85%8D%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98/","excerpt":"","text":"常见的CPU的架构都有哪些 mips64 mips x86_64 x86 arm64-v8a armeabi-v7a armeabi 其中mips64 mips不常见，已经被废弃，最常见的就是arm64-v8a、armeabi-v7a、armeabi 这三种 CPU的架构的兼容性 这个图的意思是armeabi 可以在armeabi-v7a 和 arm64-v8a上的机器上跑，它的兼容性最好，同时armeabi也可以在x86及x86_64的机器上跑， 而armeabi-v7a可以在arm64-v8a的机器上跑。 Native库加载一个arm64-v8a的机器上加载so库怎么加载，优先去自己的arm64-v8a上加载 如果没有libui.so 而只有libmath.so 会发生什么呢？ 它还是会去arm64-v8a下面找，没找到会报错，没错，是报错，而不是去它兼容的上一级去找，所以提供so的时候一定是一套，而不能缺少，要不就一个都不提供，那它才会去对应的次一级平台文件中建找 可以动态的根据平台去加载某个库是v8a 而把它们全放在v7a的目录下，这样有一些库性能不敏感可以只加载v7a的，如果性能敏感就加载v8a的，微信就是这么干的 动态加载Native库非启动的加载库可云端下发 优化so体积 构建时分包 sdk开发者注意什么 总结","categories":[{"name":"NDK","slug":"NDK","permalink":"http://example.com/categories/NDK/"}],"tags":[]},{"title":"基于RecyclerViewDiffUtilsDatabinding-Starter应用-学习DiffUtils和Databinding的使用","slug":"基于RecyclerViewDiffUtilsDatabinding-Starter应用-学习DiffUtils和Databinding的使用","date":"2022-05-25T05:24:47.000Z","updated":"2022-11-17T07:56:15.000Z","comments":true,"path":"2022/05/25/基于RecyclerViewDiffUtilsDatabinding-Starter应用-学习DiffUtils和Databinding的使用/","link":"","permalink":"http://example.com/2022/05/25/%E5%9F%BA%E4%BA%8ERecyclerViewDiffUtilsDatabinding-Starter%E5%BA%94%E7%94%A8-%E5%AD%A6%E4%B9%A0DiffUtils%E5%92%8CDatabinding%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"开始学习看下SleepNightAdapter.kt文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class SleepNightAdapter: RecyclerView.Adapter&lt;SleepNightAdapter.ViewHolder&gt;() &#123; var data = listOf&lt;SleepNight&gt;() set(value) &#123; field = value notifyDataSetChanged() &#125; override fun getItemCount() = data.size override fun onBindViewHolder(holder: ViewHolder, position: Int) &#123; val item = data[position] holder.bind(item) &#125; override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder &#123; return ViewHolder.from(parent) &#125; class ViewHolder private constructor(itemView: View) : RecyclerView.ViewHolder(itemView)&#123; val sleepLength: TextView = itemView.findViewById(R.id.sleep_length) val quality: TextView = itemView.findViewById(R.id.quality_string) val qualityImage: ImageView = itemView.findViewById(R.id.quality_image) fun bind(item: SleepNight) &#123; val res = itemView.context.resources sleepLength.text = convertDurationToFormatted(item.startTimeMilli, item.endTimeMilli, res) quality.text = convertNumericQualityToString(item.sleepQuality, res) qualityImage.setImageResource(when (item.sleepQuality) &#123; 0 -&gt; R.drawable.ic_sleep_0 1 -&gt; R.drawable.ic_sleep_1 2 -&gt; R.drawable.ic_sleep_2 3 -&gt; R.drawable.ic_sleep_3 4 -&gt; R.drawable.ic_sleep_4 5 -&gt; R.drawable.ic_sleep_5 else -&gt; R.drawable.ic_sleep_active &#125;) &#125; companion object &#123; fun from(parent: ViewGroup): ViewHolder &#123; val layoutInflater = LayoutInflater.from(parent.context) val view = layoutInflater .inflate(R.layout.list_item_sleep_night, parent, false) return ViewHolder(view) &#125; &#125; &#125;&#125; 应用根据用户输入创建 SleepNight 对象列表。每个 SleepNight 对象表示一个夜晚以及用户该晚睡眠的时长和质量。 SleepNightAdapter 会将 SleepNight 对象的列表调整为 RecyclerView 可以使用和显示的内容。 SleepNightAdapter 适配器会生成 ViewHolders，其中包含 RecyclerView 用于显示数据的视图、数据和元数据信息。 RecyclerView 使用 SleepNightAdapter 来确定要显示的项数 (getItemCount())。RecyclerView 使用 onCreateViewHolder() 和 onBindViewHolder() 获取与要显示的数据绑定的 ViewHolder。 notifyDataSetChanged() 方法效率低下为了告知 RecyclerView 列表中的某个项已更改且需要更新，当前代码会在 SleepNightAdapter 中调用 notifyDataSetChanged()，如下所示。 12345var data = listOf&lt;SleepNight&gt;() set(value) &#123; field = value notifyDataSetChanged() &#125; 但是，notifyDataSetChanged() 会告知 RecyclerView 整个列表可能无效。因此，RecyclerView 会重新绑定并重新绘制列表中的每个项，包括屏幕上看不到的项。这是一项既繁重又不必要的工作。对于较大或复杂的列表，这个过程可能需要较长时间，以至于在用户滚动浏览列表时，屏幕会闪烁或卡顿。 要解决此问题，您可以确切地告诉 RecyclerView 发生了什么更改。然后，RecyclerView 便可仅更新屏幕上已经发生更改的视图。 RecyclerView 拥有一个用于更新单个元素的功能丰富的 API。您可以使用 notifyItemChanged() 告知 RecyclerView 某个项发生了更改，并且您可以对添加、移除或移动的项使用类似的函数。您可以全部手动完成，但这样任务就会很繁重，并且可能需要使用大量代码。 幸运的是，我们有一个更好的办法。 DiffUtil 很高效并可为您完成繁重工作RecyclerView 有一个名为 DiffUtil 的类，用于计算两个列表之间的差异。DiffUtil 会接受一个旧列表和一个新列表，并确定二者有何不同。它会查找已添加、移除或更改的项。然后，它会使用一种算法（名为 Eugene W. Myers 差分算法），来确定要生成新列表，需要对旧列表做出的最小更改量。 在 DiffUtil 确定了更改内容后，RecyclerView 可以根据这些信息仅更新已更改、添加、移除或移动的项，这比重做整个列表要高效得多。 使用DiffUtil刷新列表内容第 1 步：实现 SleepNightDiffCallback为了使用 DiffUtil 类的功能，请扩展 DiffUtil.ItemCallback。 1.打开 SleepNightAdapter.kt。 2.在 SleepNightAdapter 的完整类定义下方，创建一个名为 SleepNightDiffCallback 的新顶级类，用于扩展 DiffUtil.ItemCallback。以通用参数的形式传递 SleepNight。 3.将光标放在 SleepNightDiffCallback 类名称上。 4.Alt+Enter（在 Mac 上，按 Option+Enter）并选择 Implement Members。 5.在打开的对话框中，按住 Shift 键并点击鼠标左键以选择 areItemsTheSame() 和 areContentsTheSame() 方法，然后点击 OK。 12class SleepNightDiffCallback : DiffUtil.ItemCallback&lt;SleepNight&gt;() &#123;&#125; 此操作会针对这两个方法在 SleepNightDiffCallback 中生成桩，如下所示。DiffUtil 使用这两种方法来确定列表和项的具体更改。 123456 TODO(&quot;not implemented&quot;) //To change body of created functions use File | Settings | File Templates.&#125;override fun areContentsTheSame(oldItem: SleepNight, newItem: SleepNight): Boolean &#123; TODO(&quot;not implemented&quot;) //To change body of created functions use File | Settings | File Templates.&#125; 6.在 areItemsTheSame() 中，将 TODO 替换为用于测试两个传入 SleepNight 项 oldItem 和 newItem 是否相同的代码。如果这两个项具有相同的 nightId，则表明它们是相同的，因此返回 true。否则返回 false。DiffUtil 使用此测试来帮助发现是否已添加、移除或移动某个项。 123override fun areItemsTheSame(oldItem: SleepNight, newItem: SleepNight): Boolean &#123; return oldItem.nightId == newItem.nightId&#125; 7.在 areContentsTheSame() 中，检查 oldItem 和 newItem 是否包含相同的数据；即判断它们是否相等。由于 SleepNight 是一个数据类，此相等性检查将检查所有字段。Data 类会自动为您定义 equals 和一些其他方法。如果 oldItem 和 newItem 之间存在差异，此代码会告知 DiffUtil 相应项已更新。 123override fun areContentsTheSame(oldItem: SleepNight, newItem: SleepNight): Boolean &#123; return oldItem == newItem&#125; 使用ListAdapter管理列表通常使用 RecyclerView 来显示会发生变化的列表。RecyclerView 提供适配器类 ListAdapter，可帮助您构建由列表支持的 RecyclerView 适配器。 ListAdapter 会为您跟踪列表，并在列表更新时通知适配器。 1.在 SleepNightAdapter.kt 文件中，更改 SleepNightAdapter 的类签名以扩展 ListAdapter。 2.如果出现提示，请导入 androidx.recyclerview.widget.ListAdapter。 3.将 SleepNight 作为第一个参数添加到 ListAdapter 中 SleepNightAdapter.ViewHolder 之前。 4.将 SleepNightDiffCallback() 作为参数添加到构造函数中。ListAdapter 将利用此参数确定列表中的更改内容。完成后的 SleepNightAdapter 类签名应如下所示。 1class SleepNightAdapter : ListAdapter&lt;SleepNight, SleepNightAdapter.ViewHolder&gt;(SleepNightDiffCallback()) &#123; 5.在 SleepNightAdapter 类中，删除 data 字段，包括 setter。您已不再需要它，因为 ListAdapter 会为您跟踪列表。 6.删除 getItemCount() 的替换方法，因为 ListAdapter 为您实现了此方法。 7.如需消除 onBindViewHolder() 中的错误，请更改 item 变量。调用 ListAdapter 提供的 getItem(position) 方法，而不要使用 data 来获取 item。 1val item = getItem(position) 第 2 步：使用 submitList() 及时更新列表在有已更改的列表时，您的代码需要告知 ListAdapter。ListAdapter 提供了一个名为 submitList() 的方法，用于告知 ListAdapter 列表有新版本。调用此方法时，ListAdapter 会将新列表与旧列表进行差异比较，并检测已添加、移除、移动或更改的项。然后，ListAdapter 会更新 RecyclerView 所显示的项。 1.打开 SleepTrackerFragment.kt。 2.在 sleepTrackerViewModel 内的观察器上，在 onCreateView() 中找到引用您已删除的 data 变量的错误。 3.将 adapter.data = it 替换为对 adapter.submitList(it) 的调用。更新后的代码如下所示。 12345sleepTrackerViewModel.nights.observe(viewLifecycleOwner, Observer &#123; it?.let &#123; adapter.submitList(it) &#125;&#125;) 4.运行您的应用。您可能需要导入 findNavController。您可能会注意到，您的应用运行速度变快了，然而如果列表太小，这个变化可能不明显。 将DataBinding与RecyclerView搭配使用在此任务中，您需要使用与之前 Codelab 相同的方法来设置数据绑定，并消除对 findViewById() 的调用。 第 1 步：向布局文件添加数据绑定1.在 Code 标签页中打开 list_item_sleep_night.xml 布局文件。 2.将光标放在 ConstraintLayout 标签上，然后按 Alt+Enter（在 Mac 上，按 Option+Enter）。系统随即会打开 intent 菜单（“quick fix”菜单）。 3.选择 Convert to data binding layout。这会将布局封装到 &lt;layout&gt; 中，并在其中添加 &lt;data&gt; 标签。 4.根据需要滚动回顶部，并在 &lt;data&gt; 标签内声明一个名为 sleep 的变量。 5.将其 type 设为 SleepNight 的完全限定名称 com.example.android.trackmysleepquality.database.SleepNight。完成后的 &lt;data&gt; 标签应如下所示。 12345&lt;data&gt; &lt;variable name=&quot;sleep&quot; type=&quot;com.example.android.trackmysleepquality.database.SleepNight&quot;/&gt; &lt;/data&gt; 6.如需强制创建 Binding 对象，请依次选择 Build &gt; Clean Project，然后依次选择 Build &gt; Rebuild Project。（如果仍然存在问题，请依次选择 File &gt; Invalidate Caches &#x2F; Restart。）ListItemSleepNightBinding 绑定对象以及相关代码会添加到项目生成的文件中。 第 2 步：使用数据绑定膨胀项布局1.打开 SleepNightAdapter.kt。 2.在 companion object 中，找到 from(parent: ViewGroup) 函数。 3.删除 view 变量的声明。 要删除的代码： 12val view = layoutInflater .inflate(R.layout.list_item_sleep_night, parent, false) 4.在 view 变量所在的位置，定义一个名为 binding 的新变量，以膨胀 ListItemSleepNightBinding 绑定对象，如下所示。根据需要导入绑定对象。 12val binding =ListItemSleepNightBinding.inflate(layoutInflater, parent, false) 5.在函数结尾，不要返回 view，而应返回 binding。 1return ViewHolder(binding) 6.要消除 binding 上的错误，请将光标放在 binding 一词上。按 Alt+Enter（在 Mac 上，按 Option+Enter）打开 intent 菜单。 7.选择 **Change parameter ‘itemView’ type of primary constructor of class ‘ViewHolder’ to ‘ListItemSleepNightBinding’**。这将更新 ViewHolder 类的参数类型。 8.向上滚动到 ViewHolder 的类定义，以查看签名中的更改。您会看到 itemView 的错误，因为您在 from() 方法中将 itemView 更改为了 binding。 在 ViewHolder 类定义中，右键点击 itemView 的一个发生实例，然后依次选择 Refactor &gt; Rename。将名称更改为 binding。 9.为构造函数参数 binding 添加 val 前缀，使其成为属性。 10.在对父类 RecyclerView.ViewHolder 的调用中，将参数从 binding 更改为 binding.root。您需要传递 View，并且将 binding.root 作为项布局中的根 ConstraintLayout。 11.完成后的类声明应如以下代码所示。 1class ViewHolder private constructor(val binding: ListItemSleepNightBinding) : RecyclerView.ViewHolder(binding.root)&#123; 您还会看到对 findViewById(). 的调用的错误。您将在下一部分中修复这些错误。 第 3 步：替换 findViewById()您现在可以更新 sleepLength、quality 和 qualityImage 属性，以使用 binding 对象代替 findViewById()。 1.将 sleepLength、qualityString 和 qualityImage 的初始化更改为使用 binding 对象的视图，如下所示。此后，您的代码应该不会再显示任何错误。 123val sleepLength: TextView = binding.sleepLengthval quality: TextView = binding.qualityStringval qualityImage: ImageView = binding.qualityImage 绑定对象就位后，您根本不需要定义 sleepLength、quality 和 qualityImage 属性。DataBinding 将缓存查询，因此无需声明这些属性。 2.右键点击 sleepLength、quality 和 qualityImage 属性名称。对于每个属性，依次选择 Refactor &gt; Inline，或按 Ctrl+Alt+N（在 Mac 上按 Option+Command+N）。 3.运行您的应用。（如果项目出现错误，您可能需要清理并重建项目。） 创建绑定适配器在此任务中，您需要升级应用，将数据绑定与绑定适配器结合使用，在视图中设置数据。 在上一个 Codelab 中，您使用了 Transformations 类来获取 LiveData 并生成要在文本视图中显示的格式化字符串。但是，如果您需要绑定不同类型或复杂类型的数据，您可以提供绑定适配器来帮助数据绑定功能使用这些类型。绑定适配器会获取您的数据，并将其调整为可供数据绑定功能用于绑定视图（例如文本或图片）的内容。 您需要实现三个绑定适配器，一个用于高质量图片，另外两个分别用于一个文本字段。总而言之，如需声明绑定适配器，您需要定义一种获取项和视图的方法，并用 @BindingAdapter 进行注解。在该方法的正文中，您可以实现转换。在 Kotlin 中，您可以在接收数据的视图类上将绑定适配器编写为扩展函数。 第 1 步：创建绑定适配器请注意，您必须在此步骤中导入很多类。 1.打开 SleepNightAdapter.kt。 2.在 ViewHolder 类中，找到 bind() 方法并注意该方法的用途。您需要获取用于计算 binding.sleepLength、binding.quality 和 binding.qualityImage 的值的代码，并在适配器中改用该代码。（目前不要更改代码，您需要在后续步骤中移动代码。） 3.在 sleeptracker 软件包中，创建一个名为 BindingUtils.kt 的新文件并打开此文件。 4.删除 BindingUtils 类中的所有内容，因为您接下来要创建静态函数。 1class BindingUtils &#123;&#125; 5.在 TextView 上声明一个名为 setSleepDurationFormatted 的扩展函数，并传入 SleepNight。此函数将作为适配器，用于计算和格式化睡眠时长。 1fun TextView.setSleepDurationFormatted(item: SleepNight) &#123;&#125; 6.在 setSleepDurationFormatted 的正文中，将数据绑定到视图，如在 ViewHolder.bind() 中一样。调用 convertDurationToFormatted()，然后将 TextView 的 text 设置为格式化文本。（由于这是 TextView 上的扩展函数，您可以直接访问 text 属性。） 1text = convertDurationToFormatted(item.startTimeMilli, item.endTimeMilli, context.resources) 7.如需向数据绑定功能告知此绑定适配器，请使用 @BindingAdapter 为该函数添加注解。 8.此函数是用于 sleepDurationFormatted 属性的适配器，因此请将 sleepDurationFormatted 作为参数传递给 @BindingAdapter。 1@BindingAdapter(&quot;sleepDurationFormatted&quot;) 9.第二个适配器根据 SleepNight 对象中的值设置睡眠质量。在 TextView 上再创建一个名为 setSleepQualityString() 的扩展函数，并传入 SleepNight。 10.在正文中，将数据绑定到视图，如在 ViewHolder.bind() 中一样。调用 convertNumericQualityToString 并设置 text。 11.使用 @BindingAdapter(&quot;sleepQualityString&quot;) 为该函数添加注解。 1234@BindingAdapter(&quot;sleepQualityString&quot;)fun TextView.setSleepQualityString(item: SleepNight) &#123; text = convertNumericQualityToString(item.sleepQuality, context.resources)&#125; 12.我们需要第三个绑定适配器，用于在图片视图上设置图片。在 ImageView 上创建第三个扩展函数，调用 setSleepImage，并使用 ViewHolder.bind() 中的代码，如下所示。 123456789101112@BindingAdapter(&quot;sleepImage&quot;)fun ImageView.setSleepImage(item: SleepNight) &#123; setImageResource(when (item.sleepQuality) &#123; 0 -&gt; R.drawable.ic_sleep_0 1 -&gt; R.drawable.ic_sleep_1 2 -&gt; R.drawable.ic_sleep_2 3 -&gt; R.drawable.ic_sleep_3 4 -&gt; R.drawable.ic_sleep_4 5 -&gt; R.drawable.ic_sleep_5 else -&gt; R.drawable.ic_sleep_active &#125;)&#125; 您可能需要导入 convertDurationToFormatted 和 convertNumericQualityToString。 第 2 步：更新 SleepNightAdapter1.打开 SleepNightAdapter.kt。 2.删除 bind() 方法中的所有内容，因为您现在可以使用数据绑定和新的适配器来为您执行这项操作。 12fun bind(item: SleepNight) &#123;&#125; 3.在 bind() 中，为 item 分配 sleep，因为您需要告知绑定对象您的新 SleepNight。 1binding.sleep = item 4.在该行的下方，添加 binding.executePendingBindings()。此调用是一种优化，用于要求数据绑定功能立即执行任何待处理的绑定。当您在 RecyclerView 中使用绑定适配器时，最好调用 executePendingBindings()，因为它可以略微加快调整视图大小的过程。 1binding.executePendingBindings() 第 3 步：向 XML 布局添加绑定1.打开 list_item_sleep_night.xml。 2.在 ImageView 中，添加与设置图片的绑定适配器同名的 app 属性。传入 sleep 变量，如下所示。 此属性通过适配器建立视图与绑定对象之间的连接。每当引用 sleepImage 时，适配器都会调整 SleepNight 中的数据。 1app:sleepImage=&quot;@&#123;sleep&#125;&quot; 3.现在，为 sleep_length 和 quality_string 文本视图添加类似的应用属性。每当引用 sleepDurationFormatted 或 sleepQualityString 时，适配器都会调整来自 SleepNight 中的数据。请务必将每个属性分别放入其各自的 TextView. 中 12app:sleepDurationFormatted=&quot;@&#123;sleep&#125;&quot;app:sleepQualityString=&quot;@&#123;sleep&#125;&quot; 4.运行您的应用，其运行情况与之前完全一样。绑定适配器负责处理随着数据变化而格式化和更新视图的所有工作，从而简化 ViewHolder 并为代码提供比之前更好的结构。","categories":[{"name":"kotlin","slug":"kotlin","permalink":"http://example.com/categories/kotlin/"}],"tags":[]},{"title":"Lifecycle 官方文档[转](更新中)","slug":"Lifecycle-官方文档-转-更新中","date":"2022-05-19T21:56:29.000Z","updated":"2022-11-17T07:56:14.000Z","comments":true,"path":"2022/05/20/Lifecycle-官方文档-转-更新中/","link":"","permalink":"http://example.com/2022/05/20/Lifecycle-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E8%BD%AC-%E6%9B%B4%E6%96%B0%E4%B8%AD/","excerpt":"","text":"使用生命周期感知型组件处理生命周期生命周期感知型组件可执行操作来响应另一个组件（如 Activity 和 Fragment）的生命周期状态的变化。这些组件有助于您编写出更有条理且往往更精简的代码，此类代码更易于维护。 一种常见的模式是在 Activity 和 Fragment 的生命周期方法中实现依赖组件的操作。但是，这种模式会导致代码条理性很差而且会扩散错误。通过使用生命周期感知型组件，您可以将依赖组件的代码从生命周期方法移入组件本身中。 androidx.lifecycle 软件包提供了可用于构建生命周期感知型组件的类和接口 - 这些组件可以根据 Activity 或 Fragment 的当前生命周期状态自动调整其行为。 注意：如需将 androidx.lifecycle导入 Android 项目，请参阅 Lifecycle 版本说明中关于声明依赖项的说明。 在 Android 框架中定义的大多数应用组件都存在生命周期。生命周期由操作系统或进程中运行的框架代码管理。它们是 Android 工作原理的核心，应用必须遵循它们。如果不这样做，可能会引发内存泄漏甚至应用崩溃。 假设我们有一个在屏幕上显示设备位置的 Activity。常见的实现可能如下所示： 12345678910111213141516171819202122232425262728293031323334353637internal class MyLocationListener( private val context: Context, private val callback: (Location) -&gt; Unit) &#123; fun start() &#123; // connect to system location service &#125; fun stop() &#123; // disconnect from system location service &#125;&#125;class MyActivity : AppCompatActivity() &#123; private lateinit var myLocationListener: MyLocationListener override fun onCreate(...) &#123; myLocationListener = MyLocationListener(this) &#123; location -&gt; // update UI &#125; &#125; public override fun onStart() &#123; super.onStart() myLocationListener.start() // manage other components that need to respond // to the activity lifecycle &#125; public override fun onStop() &#123; super.onStop() myLocationListener.stop() // manage other components that need to respond // to the activity lifecycle &#125;&#125; LifecycleLifecycle 是一个类，用于存储有关组件（如 Activity 或 Fragment）的生命周期状态的信息，并允许其他对象观察此状态。 Lifecycle 使用两种主要枚举跟踪其关联组件的生命周期状态： 事件 从框架和 Lifecycle 类分派的生命周期事件。这些事件映射到 Activity 和 Fragment 中的回调事件。 状态 由 Lifecycle 对象跟踪的组件的当前状态。 您可以将状态看作图中的节点，将事件看作这些节点之间的边。 类可以通过实现 DefaultLifecycleObserver 并替换相应的方法（如 onCreate 和 onStart 等）来监控组件的生命周期状态。然后，您可以通过调用 Lifecycle 类的 addObserver() 方法并传递观察器的实例来添加观察器，如下例所示： 1234567891011class MyObserver : DefaultLifecycleObserver &#123; override fun onResume(owner: LifecycleOwner) &#123; connect() &#125; override fun onPause(owner: LifecycleOwner) &#123; disconnect() &#125;&#125;myLifecycleOwner.getLifecycle().addObserver(MyObserver()) 在上面的示例中，myLifecycleOwner 对象实现了 LifecycleOwner 接口，我们将在接下来的部分中对该接口进行说明。","categories":[],"tags":[]},{"title":"Android8.0以上系统应用如何保活[转]","slug":"Android8-0以上系统应用如何保活-转","date":"2022-05-17T04:59:09.000Z","updated":"2022-11-17T07:56:14.000Z","comments":true,"path":"2022/05/17/Android8-0以上系统应用如何保活-转/","link":"","permalink":"http://example.com/2022/05/17/Android8-0%E4%BB%A5%E4%B8%8A%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%A6%82%E4%BD%95%E4%BF%9D%E6%B4%BB-%E8%BD%AC/","excerpt":"","text":"Android 8.0以上系统应用如何保活最近在做一个埋点的sdk，由于埋点是分批上传的，不是每次都上传，所以会有个进程保活的机制，这也是自研推送的实现技术之一：如何保证Android进程的存活。 对于Android来说，保活主要有以下一些方法： 开启前台Service（效果好，推荐） Service中循环播放一段无声音频（效果较好，但耗电量高，谨慎使用） 双进程守护（Android 5.0前有效） JobScheduler（Android 5.0后引入，8.0后失效） 1 像素activity保活方案（不推荐） 广播锁屏、自定义锁屏（不推荐） 第三方推送SDK唤醒（效果好，缺点是第三方接入） 下面是具体的实现方案：","categories":[],"tags":[]},{"title":"WorkManager相关(更新中)","slug":"WorkManager相关-更新中","date":"2022-05-17T04:08:53.000Z","updated":"2022-11-17T07:56:14.000Z","comments":true,"path":"2022/05/17/WorkManager相关-更新中/","link":"","permalink":"http://example.com/2022/05/17/WorkManager%E7%9B%B8%E5%85%B3-%E6%9B%B4%E6%96%B0%E4%B8%AD/","excerpt":"","text":"基本介绍 WorkManager WorkManager可以自动维护后台任务的执行时机，执行顺序，执行状态。 执行时机：我们创建一个任务可以指定它在什么时机执行，比如立刻执行，还是必须要等到设备空闲的时候执行，还是要等到设备的充电量必须要满足的时候执行，还是必须在wifi下才能执行，还是设备必须在存储空间足够的情况下执行。 执行顺序：指任务在执行过程中，是允许有依赖的关系，比如a执行完成才能执行任务b，任务b完成才能执行任务c,允许他们之间有相互的依赖关系。 执行状态：指任务执行的每个状态都会回调给我们，比如队列任务执行中，取消，成功，失败，结束等等。 相比于后台任务service,intentservice workmanager更加的轻量，更加的省电，理论上service能做的东西，workmaanager都能做。但是workmanager可以用于支持异步场景。 依赖添加 implementation ‘androidx.work:work-runtime:2.2.0’ 使用WorkManager来构建任务 1234WorkContinuation left,right;left = workManager.beginWith(A).then(B);right = workManager.beginWith(C).then(D);WorkContinuatioin.combine(Arrays.asList(left,right)).then(E).Enqueue(); 任务A执行完才能执行B 任务C执行完才能执行任务D BD都执行完才能执行E 之前使用service还要做线程间的同步，我们看workmanager怎么实现相同的效果？ beginWith(A).then(B) 指任务A执行完，才执行任务B，beginWith就可以使得两个任务串行依赖 WorkContinuation left right 分别创建出左侧的任务队列，右侧的任务队列 WorkContinuation 就是可以支持任务之间相互的串联，相互的依赖的对象 combine后，调用Enqueu()加入任务队列 WorkManager（状态通知） WorkManager（任务控制） UUID是我们创建work的时候返回的 我们创建任务的时候，可以给任务打上一组标签tag WorkManager(类关系) OneTimeWorkRequest 一次性 PeriodicWorkRequest 定时执行任务 ，定时任务最小的周期是15分钟，所以保活就不行了 WorkManager的使用1.创建任务 2.输入参数 3.创建workRequest 4.加入队列 5.监听结果 1234567891011121314151617181920212223242526//1.编写一个UploadFileWorker.class 继承自Worker//2.创建输入参数Data inputData = new Data.Builder() .putString(&quot;key&quot;,&quot;value&quot;) .putBoolean(&quot;key1&quot;,false) .putStringArray(&quot;key2&quot;,new String[]&#123;&#125;) .build();//3.创建workrequest 构建任务OneTimeWorkRequest request = new OneTimeWorkRequest.Builder(UploadFileWorker.class) //传入参 .setInputData(inputData) //...其他许许多多约束 .build();//4.加入队列WorkContinuation continuation = WorkManager.getInstance().beginWith(list).enqueue;//5.观察执行状态及结果continuation.getWorkInfosLiveData().observe(this,new Observer&lt;List&lt;WorkInfo&gt;&gt;()&#123; @Override public void onChanged(List&lt;WorkInfo&gt; workInfos)&#123; //监听任务执行的结果 //所以我们在创建work的时候需要work的UUID,用于观察这里是哪个work执行完成了 &#125;&#125;)","categories":[],"tags":[]},{"title":"MVVM及Databinding使用及原理解析","slug":"MVVM使用及原理解析","date":"2022-05-15T22:35:47.000Z","updated":"2022-11-17T07:56:14.000Z","comments":true,"path":"2022/05/16/MVVM使用及原理解析/","link":"","permalink":"http://example.com/2022/05/16/MVVM%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/","excerpt":"","text":"什么是MVVM 双向绑定。数据变更UI会自动刷新，UI变化了数据也会自动同步到最新的值 数据驱动UI：比如User中的字段，数据变化了，可以做到自动刷新UI。 UI同步数据：比如EditText、CheckBox、ToggleButton具有状态的View，当状态变化后，数据模型中与之关联的字段的值也会自动同步最新状态 123456//开启databindingandroid&#123; dataBinding&#123; enable = true &#125;&#125; 传统的MVVM 此时view层的定义比较广泛，可以指Activity/Fragment/xml实例化出来的view对象或者自定义view对象 VM就是这里的viewmodel,但是这并不是Jetpack组件里的viewmodel,18年，livedata和viewmodel没有出来前，这里的viewmodel只是一个普通的类，用于从model中获取数据，从Model中获取数据成功后会通过callback回传给viewmodel，而viewmodel中的数据更新后，并不是通过view接口(区别于MVP)回传给view更新的，而是通过Databinding，利用它观察者的特性，实现UI的更新 定义ViewModel用于处理数据相关的业务逻辑。并通过ObserverableField 观察者把结果回传出去 12345678910111213public class HomeViewModel &#123; public ObservableField&lt;User&gt; userField = new ObservableField&lt;&gt;(); public void queryUserInfo()&#123; User user = new User(); user.nickName = &quot;nickName&quot;; user.address = &quot;address&quot;; //自动通知与之关联的观察者 userField.set(user); &#125;&#125; 注意一定要给userField.set(user) 把对象set给userField 这步不调用，是无法从userField中取数据的，会报NPE 基于DataBinding在xml中进行数据绑定，可以实现数据&amp;UI双向绑定&#x3D;&gt;数据变更ui自动刷新，UI变动自动同步数据 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;data&gt; &lt;variable name=&quot;viewModel&quot; type=&quot;com.steve.mvvmdemo.test.HomeViewModel&quot; /&gt; &lt;/data&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;!--单向绑定@--&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/nick_name&quot; android:text=&quot;@&#123;viewModel.userField.nickName&#125;&quot;/&gt; &lt;!--双向绑定@=--&gt; &lt;EditText android:id=&quot;@+id/edit_address&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@=&#123;viewModel.userField.address&#125;&quot; /&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; 只要userField中的nickName发生变化，UI会刷新，这是单向的 编写完xml后rebuild一个项目 Activity控制数据的获取 1234567891011121314151617181920212223242526272829303132public class HomeActivity extends AppCompatActivity &#123; @Override protected void onCreate(@Nullable @org.jetbrains.annotations.Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ActivityHomeBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_home); HomeViewModel vm = new HomeViewModel(); binding.setViewModel(vm); model.queryUserInfo(); binding.editAddress.addTextChangedListener(new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; &#125; @Override public void afterTextChanged(Editable s) &#123; //当输入框文本变更后，userField的address数据会自动更新，变成输入框输入的内容 Log.e(&quot;zzl&quot;,&quot;after:&quot; + vm.userField.get().address); &#125; &#125;); &#125;&#125; 通过DataBindingUtil.setContentView完成Activity和xml布局文件的绑定工作，返回一个Databinding对象，这个databinding对象是根据xml的名称在编译阶段生成的，我们可以直接拿来使用。 把vm通过setViewModel设置给databinding 然后在Activity中调用 model.queryUserInfo()去获取数据，可能是网络上的数据，然后activity就不管数据获取后UI的更新了 这就是传统的MVVM，它着重利用了Databinding的能力，大部分的数据都是在xml中进行绑定，当然也会根据场景，具体问题具体分析。如果需要用户交互复杂的逻辑控制，可能还是需要在activity中进行控制更为方便。 但是这种写法已经过时了，后面出现了Jetpack，在Jetpack模式下，我们通常会利用VieModel + LiveData的组件结合。 这样做的目的是既能保证数据不会无缘无故丢失，还能自动关联宿主的生命周期，避免空指针的问题。Activity，Fragment UI逻辑和用户交互控制就可以了。数据的绑定可以交给Databindging Jetpack Viewmodel + livedata使用123456789101112public class HomeViewModel extends ViewModel &#123; public LiveData getUserInfo()&#123; MutableLiveData&lt;User&gt; liveData = new MutableLiveData&lt;&gt;(); User user = new User(); user.nickName = &quot;zzl&quot;; user.address = &quot;changchun&quot;; liveData.postValue(user); return liveData; &#125;&#125; 注意这里既不是使用观察者ObservableField包裹对象，也不是使用view的接口回调callback去回传数据，而是使用了livedata，通过liveData.postValue(user)并返回liveData，去通知观察者 下面看下xml文件的变化 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;data&gt; &lt;variable name=&quot;user&quot; type=&quot;com.steve.mvvmdemo.test.User&quot; /&gt; &lt;/data&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;!--单向绑定@--&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/nick_name&quot; android:text=&quot;@&#123;user.nickName&#125;&quot;/&gt; &lt;!--双向绑定@=--&gt; &lt;EditText android:id=&quot;@+id/edit_address&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@=&#123;user.address&#125;&quot; /&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; 这里注意绑定的对象不再是viewmodel而直接是user对象 直接使用user.nickName user.address访问对象的值 看下Activity里的逻辑 123456789101112131415public class HomeActivity3 extends AppCompatActivity &#123; @Override protected void onCreate(@Nullable @org.jetbrains.annotations.Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ActivityHome2Binding binding = DataBindingUtil.setContentView(this, R.layout.activity_home2); ViewModelProvider provider = new ViewModelProvider(this,new ViewModelProvider.NewInstanceFactory()); HomeViewModel vm = provider.get(HomeViewModel.class); vm.getUserInfo().observe(this, (Observer&lt;User&gt;) user -&gt; &#123; binding.setUser(user); &#125;); &#125;&#125; Jetpack里的api使用会有一点点不同 DataBindingUtil.setContentView把xml和activity进行绑定，生成databinding 通过ViewModelProvider获取具体的HomeViewModel对象 通过vm获取发送数据的liveData，注册观察者，在回调里进行binding.setUser(user);绑定 DataBinding的高频用法及注意事项什么是dataBinding? 可以理解为dataBinding只是一种工具，它解决了view和数据之间的双向绑定 dataBinding的优势？ 双向数据绑定 数据发生改变后，自动通知刷新UI页面，不再需要人工绑定最新数据到view上。UI改变后也能同步给数据。 减少模板代码 有了dataBinding，从此不用再写findViewById,setOnClickListener等枯燥生硬的代码，大大提高工作效率。从此Butterknife靠边站。 释放Activitty/Fragment压力 我们可以直接在xml布局文件中完成数据，事件绑定工作。Activity,Fragment让它更加只关注核心业务。 数据绑定空安全 在xml中绑定数据它是空安全的，因为dataBinding在数据绑定上会自动装箱和空判断，所以大大减少了数据绑定带来的NPE问题 dataBinding如何使用？ 在布局文件中，选中根布局的标签，按住 alt + 回车 ，点击convert to data binding layout 即可转换成dataBinding布局。 转换后的布局，最外层变成了layout标签，里面包裹了data标签和常规的布局元素。data元素用来声明在此布局使用到的变量和变量类型，以及类引用。最不是所有的属性都能用dataBinding来绑定呢？当然不是！如果一个属性xxx，在该类中有setXXX方法，我们才能使用dataBinding来绑定。比如android:layout_width，android_height就不能使用dataBinding来绑定值，而android:paddingLeft，android:textSize都是可以的。 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;data&gt; &lt;variable name=&quot;user&quot; type=&quot;com.steve.mvvmdemo.test.User&quot; /&gt; &lt;import type=&quot;com.steve.mvvmdemo.test.UserManager&quot;&gt;&lt;/import&gt; &lt;/data&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:id=&quot;@+id/tvName&quot; android:layout_width=&quot;200dp&quot; android:layout_height=&quot;wrap_content&quot; //不能使用dataBinding动态绑定 android:text=&quot;@&#123;user.name&#125;&quot; //单向绑定数据变更自动通知UI android:textSize=&quot;@&#123;@dimen/16sp&#125;&quot; //资源引用 android:text=&quot;@&#123;user.nickName + @string/suffix&#125;&quot; //字符串拼接需要引用资源 android:text=&quot;@&#123;UserManager.getUserName()&#125;&quot; //调用静态方法，类必须先导入 android:onClick=&quot;@&#123;()-&gt;UserManager.login()&#125;&quot; /&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; android:text=&quot;@&#123;user.name&#125;&quot;等价于tvName.text = user.name这样就将数据和view相关联了。那么如何实现view和数据的双向绑定呢？我们除了上面提到的让ObservableField持有外，还可以让实体类User继承BaseObservable。当user中字段发生变更，只需要调用user.notifyPropertyChanged就可以让UI刷新。 12345678910111213141516public class User extends BaseObservable &#123; String name; //当使用name字段发生变更后，若想UI自动刷新，我们需要给它写个get方法并且标记为Bindable注解 //最后调用 notifyPropertyChanged方法即可 @Bindable public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; notifyPropertyChanged(BR.user); &#125;&#125; dataBinding 也支持在布局文件中使用数组、List、Set和Map，且在布局文件中都可以通过list[index]的形式来获取元素，因为xml的特性，在声明List&lt;String&gt;之类的类型时，需要使用尖括号的转义字符，如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;data&gt; &lt;import type=&quot;java.util.List&quot;/&gt; &lt;import type=&quot;java.util.Set&quot;/&gt; &lt;import type=&quot;java.util.Map&quot;/&gt; &lt;import type=&quot;android.util.SparseArray&quot;/&gt; &lt;variable name=&quot;array&quot; type=&quot;String[]&quot; /&gt; &lt;!--List&lt;String&gt; 需要转义--&gt; &lt;variable name=&quot;list&quot; type=&quot;List&amp;lt;String&amp;gt;&quot; /&gt; &lt;!--Map&lt;String&gt;--&gt; &lt;variable name=&quot;map&quot; type=&quot;Map&amp;lt;String,String&amp;gt;&quot; /&gt; &lt;!--Set&lt;Strin&gt;--&gt; &lt;variable name=&quot;set&quot; type=&quot;Set&amp;lt;String&amp;gt;&quot; /&gt; &lt;!--SparseArray&lt;String&gt;--&gt; &lt;variable name=&quot;sparse&quot; type=&quot;SparseArray&amp;lt;String&amp;gt;&quot; /&gt; &lt;variable name=&quot;index&quot; type=&quot;int&quot; /&gt; &lt;variable name=&quot;key&quot; type=&quot;String&quot; /&gt; &lt;/data&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@&#123;array[1]&#125;&quot;/&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@&#123;sparse[index]&#125;&quot;/&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@&#123;list[index]&#125;&quot;/&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@&#123;map[key]&#125;&quot;/&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&#x27;@&#123;map[&quot;移动端架构师&quot;]&#125;&#x27;/&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&#x27;@&#123;set.contains(&quot;xxx&quot;)?&quot;移动端架构师&quot;:key&#125;&#x27;/&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; dataBinding在xml中数据绑定支持的语法表达式也是非常丰富的，支持在布局文件中使用以下运算符、表达式和关键字 dataBinding 拓展view属性 我们知道，以前想要给ImageView增加几个属性，必须要写个自定义的ImageView在构造函数中一顿解析。那看看使用dataBinding如何拓展view属性。 1234567public class HiImageView extends ImageView &#123; @BindingAdapter(value = &#123;&quot;image_url&quot;,&quot;isCircle&quot;,&quot;radius&quot;&#125;,requireAll = false) public static void setImageUrl(ImageView view,String imageUrl,boolean isCircle,int radius)&#123; &#125;&#125; 需要定义成public static 使用BindingAdapter注解并标记 value中的字段随意添加和方法参数一一对应即可。 requirAll &#x3D; false代表是否以下三个属性在xml中同时使用才会调用该方法，为flase的话，只要有一个属性被使用就能调用到该方法 12345&lt;com.steve.mvvmdemo.jetpackmvvm.HiImageView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; app:image_url=&quot;@&#123;user.avatar&#125;&quot; app:radius=&quot;@&#123;50&#125;&quot;/&gt; 在布局文件中如下使用，便能实现图片圆角和资源url绑定的功能 dataBinding使用建议 不建议在列表中乱用，因为dataBinding数据绑定是延迟一帧的，如果列表中的ItemView的宽高需要计算后才能正确展示，或者显隐控制，不建议使用databinding操作，否则会看到列表itemview有可能撑开的动画，体验不好。 12345678910111213141516171819202122232425protected void requestRebind() &#123; if (mContainingBinding != null) &#123; mContainingBinding.requestRebind(); &#125; else &#123; final LifecycleOwner owner = this.mLifecycleOwner; if (owner != null) &#123; Lifecycle.State state = owner.getLifecycle().getCurrentState(); if (!state.isAtLeast(Lifecycle.State.STARTED)) &#123; return; // wait until lifecycle owner is started &#125; &#125; synchronized (this) &#123; if (mPendingRebind) &#123; return; &#125; mPendingRebind = true; &#125; //这里下一次屏幕绘制才会进行绑定 if (USE_CHOREOGRAPHER) &#123; mChoreographer.postFrameCallback(mFrameCallback); &#125; else &#123; mUIThreadHandler.post(mRebindRunnable); &#125; &#125;&#125; SDK_INT&gt;&#x3D;16 都会执行这里，在下一次绘制时，才会重新绑定数据 如fragment_layout_my.xml布局，在编译时会生成FragmentLayoutMyImpl.class我们可以搜索这种类debug跟进解决问题。 build&#x2F;intermediates&#x2F;javac&#x2F;debug&#x2F;clasees&#x2F;org&#x2F;…&#x2F;databinding&#x2F;FragmentLayoutMyImpl.class dataBinding与ViewBinding的区别 viewbinding可以看做是一个databinding的一部分功能 最主要的表现就是可以通过绑定后不用findviewbyid了，但不能进行双向绑定 相对来说databinding的功能更强大一些，不只是可以直接获取控件对象，并且可以通过数据绑定的形式实时更新页面UI 从编译效率来讲viewBinding的效率更快一些，databinding的效率要慢一些 viewbinding优点也是明显的不需要对原有的xml文件进行侵入 DataBinding原理与编译时绑定布局对象 源码分析 1.通过源码我们要知道databinding如何实现M-V V-M的双向刷新机制 2.databinding内存开销过大的原因是什么？ 1.rebuild后，生成两个xml文件 这两个xml文件分别有各自的用处 xxx-layout 用于Databinding处理，正常的xml文件中也会有tag activity_home-layout.xml文件的路径是 1app/build/intermediates/data_binding_layout_info_type_merge/debug/out/activity_home-layout.xml activity_home.xml文件的路径是 1app/build/intermediates/incremental/mergeDebugResources/stripped.dir/layout/activity_home.xml 我们看下acitivty_home-layout.xml文件的内容 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;yes&quot;?&gt;&lt;Layout directory=&quot;layout&quot; filePath=&quot;app/src/main/res/layout/activity_home.xml&quot; isBindingData=&quot;true&quot; isMerge=&quot;false&quot; layout=&quot;activity_home&quot; modulePackage=&quot;com.steve.mvvmdemo&quot; rootNodeType=&quot;android.widget.LinearLayout&quot;&gt; &lt;Targets&gt; &lt;Target tag=&quot;layout/activity_home_0&quot; view=&quot;LinearLayout&quot;&gt; &lt;Expressions /&gt; &lt;location endLine=&quot;30&quot; endOffset=&quot;18&quot; startLine=&quot;10&quot; startOffset=&quot;4&quot; /&gt; &lt;/Target&gt; &lt;Target id=&quot;@+id/nick_name&quot; tag=&quot;binding_1&quot; view=&quot;TextView&quot;&gt; &lt;Expressions&gt; &lt;Expression attribute=&quot;android:text&quot; text=&quot;viewModel.userField.nickName&quot;&gt; &lt;Location endLine=&quot;20&quot; endOffset=&quot;57&quot; startLine=&quot;20&quot; startOffset=&quot;12&quot; /&gt; &lt;TwoWay&gt;false&lt;/TwoWay&gt; &lt;ValueLocation endLine=&quot;20&quot; endOffset=&quot;55&quot; startLine=&quot;20&quot; startOffset=&quot;28&quot; /&gt; &lt;/Expression&gt; &lt;/Expressions&gt; &lt;location endLine=&quot;20&quot; endOffset=&quot;59&quot; startLine=&quot;16&quot; startOffset=&quot;8&quot; /&gt; &lt;/Target&gt; &lt;Target id=&quot;@+id/edit_address&quot; tag=&quot;binding_2&quot; view=&quot;EditText&quot;&gt; &lt;Expressions&gt; &lt;Expression attribute=&quot;android:text&quot; text=&quot;viewModel.userField.address&quot;&gt; &lt;Location endLine=&quot;27&quot; endOffset=&quot;57&quot; startLine=&quot;27&quot; startOffset=&quot;12&quot; /&gt; &lt;TwoWay&gt;true&lt;/TwoWay&gt; &lt;ValueLocation endLine=&quot;27&quot; endOffset=&quot;55&quot; startLine=&quot;27&quot; startOffset=&quot;29&quot; /&gt; &lt;/Expression&gt; &lt;/Expressions&gt; &lt;location endLine=&quot;28&quot; endOffset=&quot;13&quot; startLine=&quot;23&quot; startOffset=&quot;8&quot; /&gt; &lt;/Target&gt; &lt;/Targets&gt; &lt;Variables name=&quot;viewModel&quot; declared=&quot;true&quot; type=&quot;com.steve.mvvmdemo.test.HomeViewModel&quot;&gt; &lt;location endLine=&quot;6&quot; endOffset=&quot;58&quot; startLine=&quot;4&quot; startOffset=&quot;8&quot; /&gt; &lt;/Variables&gt;&lt;/Layout&gt; 再看下activity_home.xml文件的内容 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:tag=&quot;layout/activity_home_0&quot; xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;!--单向绑定@--&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/nick_name&quot; android:tag=&quot;binding_1&quot; /&gt; &lt;!--双向绑定@=--&gt; &lt;EditText android:id=&quot;@+id/edit_address&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:tag=&quot;binding_2&quot; /&gt; &lt;/LinearLayout&gt; 它会把layout标签去掉，然后在每个标签下打上tag rebuild后发生了啥 2.从setContentView开始看源码 12//1.必须先ReBuilder 2.书写代码绑定val contentView = DataBindingUtil.setContentView&lt;ActivityLoginBinding&gt;(this, R.layout.activity_login) Databinding为什么还要去setContentView 因为需要activity去获取根布局root 这样binding才能去更改布局刷新 1234567public static &lt;T extends ViewDataBinding&gt; T setContentView(@NonNull Activity activity, int layoutId, @Nullable DataBindingComponent bindingComponent) &#123; activity.setContentView(layoutId); View decorView = activity.getWindow().getDecorView(); ViewGroup contentView = (ViewGroup) decorView.findViewById(android.R.id.content); return bindToAddedViews(bindingComponent, contentView, 0, layoutId);&#125; activity.getWindow().getDecorView() 获取根布局view 由decorView 获取contentView 然后发生bind绑定，执行bindToAddedViews 123456789101112131415private static &lt;T extends ViewDataBinding&gt; T bindToAddedViews(DataBindingComponent component, ViewGroup parent, int startChildren, int layoutId) &#123; final int endChildren = parent.getChildCount(); final int childrenAdded = endChildren - startChildren; if (childrenAdded == 1) &#123; final View childView = parent.getChildAt(endChildren - 1); return bind(component, childView, layoutId); &#125; else &#123; final View[] children = new View[childrenAdded]; for (int i = 0; i &lt; childrenAdded; i++) &#123; children[i] = parent.getChildAt(i + startChildren); &#125; return bind(component, children, layoutId); &#125;&#125; 所有的view子view都会执行bind函数 1234static &lt;T extends ViewDataBinding&gt; T bind(DataBindingComponent bindingComponent, View[] roots, int layoutId) &#123; return (T) sMapper.getDataBinder(bindingComponent, roots, layoutId);&#125; getDataBinder 是一个抽象方法 123456public abstract class DataBinderMapper &#123; public abstract ViewDataBinding getDataBinder(DataBindingComponent bindingComponent, View view, int layoutId); public abstract ViewDataBinding getDataBinder(DataBindingComponent bindingComponent, View[] view, int layoutId);&#125; 我们看它具体的实现类DataBinderMapperImpl 注意要找自己包名下的 12345678910111213141516171819202122232425262728public class DataBinderMapperImpl extends DataBinderMapper &#123; @Override public ViewDataBinding getDataBinder(DataBindingComponent component, View view, int layoutId) &#123; int localizedLayoutId = INTERNAL_LAYOUT_ID_LOOKUP.get(layoutId); if(localizedLayoutId &gt; 0) &#123; final Object tag = view.getTag(); if(tag == null) &#123; throw new RuntimeException(&quot;view must have a tag&quot;); &#125; switch(localizedLayoutId) &#123; case LAYOUT_ACTIVITYHOME: &#123; if (&quot;layout/activity_home_0&quot;.equals(tag)) &#123; return new ActivityHomeBindingImpl(component, view); &#125; throw new IllegalArgumentException(&quot;The tag for activity_home is invalid. Received: &quot; + tag); &#125; case LAYOUT_ACTIVITYLOGIN: &#123; if (&quot;layout/activity_login_0&quot;.equals(tag)) &#123; return new ActivityLoginBindingImpl(component, view); &#125; throw new IllegalArgumentException(&quot;The tag for activity_login is invalid. Received: &quot; + tag); &#125; &#125; &#125; return null; &#125;&#125; 之前说把所有的view都打上了tag 这里通过获取tag 开始匹配不同的bindingimpl，layout/activity_home_0 和之前的xml中的LineanerLayout标签的tag对应上了，走ActivityHomeBindingImpl的构造方法的逻辑 1234567891011121314151617public ActivityHomeBindingImpl(@Nullable androidx.databinding.DataBindingComponent bindingComponent, @NonNull View root)&#123; this(bindingComponent, root, mapBindings(bindingComponent, root, 3, sIncludes, sViewsWithIds));&#125;private ActivityHomeBindingImpl(androidx.databinding.DataBindingComponent bindingComponent, View root, Object[] bindings) &#123; super(bindingComponent, root, 1 , (android.widget.EditText) bindings[2] , (android.widget.TextView) bindings[1] ); this.editAddress.setTag(null); this.mboundView0 = (android.widget.LinearLayout) bindings[0]; this.mboundView0.setTag(null); this.nickName.setTag(null); setRootTag(root); // listeners invalidateAll();&#125; 第一个内存占用过高的原因来了，注意看 Object[] 这个对象数组缓存了控件，这块内存是额外的，通过执行mapBindings方法传入，我们看mapBindings怎么填充的这个对象数组 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687private static void mapBindings(DataBindingComponent bindingComponent, View view, Object[] bindings, IncludedLayouts includes, SparseIntArray viewsWithIds, boolean isRoot) &#123; final int indexInIncludes; final ViewDataBinding existingBinding = getBinding(view); if (existingBinding != null) &#123; return; &#125; Object objTag = view.getTag(); final String tag = (objTag instanceof String) ? (String) objTag : null; boolean isBound = false; if (isRoot &amp;&amp; tag != null &amp;&amp; tag.startsWith(&quot;layout&quot;)) &#123; final int underscoreIndex = tag.lastIndexOf(&#x27;_&#x27;); if (underscoreIndex &gt; 0 &amp;&amp; isNumeric(tag, underscoreIndex + 1)) &#123; final int index = parseTagInt(tag, underscoreIndex + 1); if (bindings[index] == null) &#123; bindings[index] = view; &#125; indexInIncludes = includes == null ? -1 : index; isBound = true; &#125; else &#123; indexInIncludes = -1; &#125; &#125; else if (tag != null &amp;&amp; tag.startsWith(BINDING_TAG_PREFIX)) &#123; int tagIndex = parseTagInt(tag, BINDING_NUMBER_START); if (bindings[tagIndex] == null) &#123; bindings[tagIndex] = view; &#125; isBound = true; indexInIncludes = includes == null ? -1 : tagIndex; &#125; else &#123; // Not a bound view indexInIncludes = -1; &#125; if (!isBound) &#123; final int id = view.getId(); if (id &gt; 0) &#123; int index; if (viewsWithIds != null &amp;&amp; (index = viewsWithIds.get(id, -1)) &gt;= 0 &amp;&amp; bindings[index] == null) &#123; bindings[index] = view; &#125; &#125; &#125; if (view instanceof ViewGroup) &#123; final ViewGroup viewGroup = (ViewGroup) view; final int count = viewGroup.getChildCount(); int minInclude = 0; for (int i = 0; i &lt; count; i++) &#123; final View child = viewGroup.getChildAt(i); boolean isInclude = false; if (indexInIncludes &gt;= 0 &amp;&amp; child.getTag() instanceof String) &#123; String childTag = (String) child.getTag(); if (childTag.endsWith(&quot;_0&quot;) &amp;&amp; childTag.startsWith(&quot;layout&quot;) &amp;&amp; childTag.indexOf(&#x27;/&#x27;) &gt; 0) &#123; // This *could* be an include. Test against the expected includes. int includeIndex = findIncludeIndex(childTag, minInclude, includes, indexInIncludes); if (includeIndex &gt;= 0) &#123; isInclude = true; minInclude = includeIndex + 1; final int index = includes.indexes[indexInIncludes][includeIndex]; final int layoutId = includes.layoutIds[indexInIncludes][includeIndex]; int lastMatchingIndex = findLastMatching(viewGroup, i); if (lastMatchingIndex == i) &#123; bindings[index] = DataBindingUtil.bind(bindingComponent, child, layoutId); &#125; else &#123; final int includeCount = lastMatchingIndex - i + 1; final View[] included = new View[includeCount]; for (int j = 0; j &lt; includeCount; j++) &#123; included[j] = viewGroup.getChildAt(i + j); &#125; bindings[index] = DataBindingUtil.bind(bindingComponent, included, layoutId); i += includeCount - 1; &#125; &#125; &#125; &#125; if (!isInclude) &#123; mapBindings(bindingComponent, child, bindings, includes, viewsWithIds, false); &#125; &#125; &#125;&#125; 对标签进行了解析，以layout开头的，以binding开头的 把view填充到object[]数组里 这样内存中就了textview edittext的副本，这是内存的额外开销 这是第一个为什么内存大的原因 我们来看看M-V V-M更新的机制 ActivityHomeBinding继承自ViewDataBinding ，看下ViewDataBinding的static静态代码块初始都做了啥 1234567891011121314151617181920static &#123; if (VERSION.SDK_INT &lt; VERSION_CODES.KITKAT) &#123; ROOT_REATTACHED_LISTENER = null; &#125; else &#123; ROOT_REATTACHED_LISTENER = new OnAttachStateChangeListener() &#123; @TargetApi(VERSION_CODES.KITKAT) @Override public void onViewAttachedToWindow(View v) &#123; // execute the pending bindings. final ViewDataBinding binding = getBinding(v); binding.mRebindRunnable.run(); v.removeOnAttachStateChangeListener(this); &#125; @Override public void onViewDetachedFromWindow(View v) &#123; &#125; &#125;; &#125;&#125; 一开始就注册了一个对view attachtowindow的监听 binding.mRebindRunnable是个的Runnable 这是第二个为什么占内存的原因，因为每一个使用了databinding的界面都会生成一个这个Runnable，同时数据的双向绑定也是在这里完成的 123456789101112131415161718192021private final Runnable mRebindRunnable = new Runnable() &#123; @Override public void run() &#123; synchronized (this) &#123; mPendingRebind = false; &#125; processReferenceQueue(); if (VERSION.SDK_INT &gt;= VERSION_CODES.KITKAT) &#123; // Nested so that we don&#x27;t get a lint warning in IntelliJ if (!mRoot.isAttachedToWindow()) &#123; // Don&#x27;t execute the pending bindings until the View // is attached again. mRoot.removeOnAttachStateChangeListener(ROOT_REATTACHED_LISTENER); mRoot.addOnAttachStateChangeListener(ROOT_REATTACHED_LISTENER); return; &#125; &#125; executePendingBindings(); &#125;&#125;; 看下executePendingBindings最后会执行到protected abstract void executeBindings() 这是一个抽象类，我们看它在ActivityHomeBindingImpl的实现 12345678910111213141516protected void executeBindings() &#123; ... // batch finished if ((dirtyFlags &amp; 0x7L) != 0) &#123; // api target 1 androidx.databinding.adapters.TextViewBindingAdapter.setText(this.editAddress, viewModelUserFieldAddress); androidx.databinding.adapters.TextViewBindingAdapter.setText(this.nickName, viewModelUserFieldNickName); &#125; if ((dirtyFlags &amp; 0x4L) != 0) &#123; // api target 1 androidx.databinding.adapters.TextViewBindingAdapter.setTextWatcher(this.editAddress, (androidx.databinding.adapters.TextViewBindingAdapter.BeforeTextChanged)null, (androidx.databinding.adapters.TextViewBindingAdapter.OnTextChanged)null, (androidx.databinding.adapters.TextViewBindingAdapter.AfterTextChanged)null, editAddressandroidTextAttrChanged); &#125;&#125; 看到这里应该就明白了，UI和data是怎么双向绑定的 那么还有一个内存过大的原因，我们看ActivityHomeBindingImpl的构造中 12345private ActivityHomeBindingImpl(androidx.databinding.DataBindingComponent bindingComponent, View root, Object[] bindings) &#123; ... // listeners invalidateAll();&#125; 这个invalidateAll会执行requestRebind函数 123456789101112131415161718192021222324protected void requestRebind() &#123; if (mContainingBinding != null) &#123; mContainingBinding.requestRebind(); &#125; else &#123; final LifecycleOwner owner = this.mLifecycleOwner; if (owner != null) &#123; Lifecycle.State state = owner.getLifecycle().getCurrentState(); if (!state.isAtLeast(Lifecycle.State.STARTED)) &#123; return; // wait until lifecycle owner is started &#125; &#125; synchronized (this) &#123; if (mPendingRebind) &#123; return; &#125; mPendingRebind = true; &#125; if (USE_CHOREOGRAPHER) &#123; mChoreographer.postFrameCallback(mFrameCallback); &#125; else &#123; mUIThreadHandler.post(mRebindRunnable); &#125; &#125;&#125; 然后这里给主线程发送消息,这也是内存开销之一","categories":[],"tags":[]},{"title":"竟然如此简单，DataBinding 和 ViewBinding[转]","slug":"竟然如此简单，DataBinding-和-ViewBinding-转","date":"2022-05-15T20:27:52.000Z","updated":"2022-11-17T07:56:15.000Z","comments":true,"path":"2022/05/16/竟然如此简单，DataBinding-和-ViewBinding-转/","link":"","permalink":"http://example.com/2022/05/16/%E7%AB%9F%E7%84%B6%E5%A6%82%E6%AD%A4%E7%AE%80%E5%8D%95%EF%BC%8CDataBinding-%E5%92%8C-ViewBinding-%E8%BD%AC/","excerpt":"","text":"原文链接：竟然如此简单，DataBinding 和 ViewBinding 在之前的文章 Kotlin 插件的落幕，ViewBinding 的崛起 中介绍了 Google 为什么不建议在项目中使用 Kotlin 合成方法（Synthetic 视图）， Google 建议使用 ViewBinding 替换 Kotlin 合成方法，那么 ViewBinding 和 DataBinding 都有什么区别。 ViewBinding： 仅仅支持绑定 View 不需要在布局文件中添加 layout 标签 需要在模块级 build.gradle 文件中添加 viewBinding = true 即可使用 效率高于 DataBinding，因为避免了与数据绑定相关的开销和性能问题 相比于 kotlin-android-extensions 插件避免了空异常 DataBinding： 包含了 ViewBinding 所有的功能 需要在模块级 build.gradle 文件内添加 dataBinding = true 并且需要在布局文件中添加 layout 标签才可以使用 支持 data 和 view 双向绑定 效率低于 ViewBinding，因为注释处理器会影响数据绑定的构建时间。 ViewBinding 可以实现的， DataBinding 都可以实现，但是 DataBinding 的性能低于 ViewBinding，DataBinding 和 ViewBinding 会为每个 XML 文件生成绑定类。 123R.layout.activity_main -&gt; ActivityMainBindingR.layout.fragment_main -&gt; FragmentMainBindingR.layout.dialog_app -&gt; DialogAppBinding 在 Kotlin 插件的落幕，ViewBinding 的崛起 文章中同时也分析了 Kotlin 合成方法所带来的问题。即使 Kotlin 合成方法有很多问题，但是还有小伙伴愿意使用。 ViewBinding 和 DataBinding 为我们解决了这么多问题，但是为什么很多小伙伴们不愿意使用 ViewBinding 和 DataBinding，今天我们从使用的角度来分析。 ViewBinding 和 DataBinding我大概汇总了 ViewBinding 和 DataBinding 在不同场景的所有用法，我们来看一下在项目中如何使用。 基本配置 从 Android Studio 3.6 版本开始，就内置在 Gradle 插件中了，不需要添加任何额外的库来使用它们，但是在 Android Studio 3.6 和 Android Studio 4.0 中使用方式不一样。 123456789101112131415161718// Android Studio 3.6android &#123; viewBinding &#123; enabled = true &#125; dataBinding&#123; enabled = true &#125;&#125;// Android Studio 4.0android &#123; buildFeatures &#123; dataBinding = true viewBinding = true &#125;&#125; ViewBinding 的使用因为涉及到的场景比较多，为了减少篇幅，我只列出来核心部分，如果之前从来没有用过，这里只需要知道 ViewBinding 的门槛比 Kotlin 合成方法要高即可。 不想为某个布局生成 binding 类，将下面属性添加到布局文件的根视图中 123&lt;LinearLayout tools:viewBindingIgnore=&quot;true&quot; &gt;&lt;/LinearLayout&gt; 在 Activity 中使用 123456override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) val binding: ActivityMainBinding = ActivityMainBinding.inflate(layoutInflater) setContentView(binding.root)&#125; 在 Fragment 中使用 1234override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View &#123; val binding = FragmentViewBindBinding.inflate(inflater,container,false) return binding.root&#125; 在 Adapter 中的使用 123override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder &#123; RecycleItemProductBinding.inflate(LayoutInflater.from(parent.context), parent, false)&#125; 在 Dialog 中使用 1234override fun onCreate(savedInstanceState: Bundle?) &#123; binding = DialogAppBinding.inflate(layoutInflater) setContentView(binding.root)&#125; include 标签的使用 include 标签不带 merge 标签，需要给 include 标签添加 id, 直接使用 id 即可，用法如下所示。 1234567&lt;include android:id=&quot;@+id/include&quot; layout=&quot;@layout/layout_include_item&quot; /&gt; val binding: ActivityMainBinding = ActivityMainBinding.inflate(layoutInflater)binding.include.includeTvTitle.setText(&quot;使用 include 布局中的控件, 不包含 merge&quot;) 作者：DHL链接：https://juejin.cn/post/6913723416671420430来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 作者：DHL链接：https://juejin.cn/post/6913723416671420430来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 作者：DHL链接：https://juejin.cn/post/6913723416671420430来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[],"tags":[]},{"title":"Jetpack系列—Lifecycle构架组件原理解析(更新中)","slug":"Jetpack系列—Lifecycle构架组件原理解析","date":"2022-05-14T03:14:51.000Z","updated":"2022-11-17T07:56:14.000Z","comments":true,"path":"2022/05/14/Jetpack系列—Lifecycle构架组件原理解析/","link":"","permalink":"http://example.com/2022/05/14/Jetpack%E7%B3%BB%E5%88%97%E2%80%94Lifecycle%E6%9E%84%E6%9E%B6%E7%BB%84%E4%BB%B6%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/","excerpt":"","text":"什么是Lifecycle 如何使用Lifecycle观察宿主状态 Fragment是如何实现Lifecycle的 Activity是如何实现Lifecycle的 Lifecycle是如何分发宿主状态的 什么是Lifecycle 具备宿主生命周期感知能力的组件。它能持有组件(如Activty或Fragment)生命周期状态的信息，并且允许其他观察者监听宿主的状态 Lifecycle怎么使用自定义LifecycleObserver观察者 这种写法是为了避免在Activity或者Fragment中去覆写大量的生命周期函数回调，如onCreate onStart等，可以在自己的生命周期回调里去写逻辑，避免宿主太乱 1234567891011121314151617181920212223242526//1.自定义的LifecycleObserver观察者，用注解声明每个方法观察的宿主的状态，想感知哪个，就在哪个上加注解public class LocationObserver implements LifecycleObserver &#123; @OnLifecycleEvent(Lifecycle.Event.ON_START) void onStart()&#123; //开启定位 &#125; @OnLifecycleEvent(Lifecycle.Event.ON_STOP) void onStop()&#123; //停止定位 &#125;&#125; //2.注册观察者，观察宿主生命周期状态变化public class MyFragment extends Fragment &#123; @Override public void onCreate(@Nullable @org.jetbrains.annotations.Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //2.注册观察者，观察宿主生命周期状态变化 getLifecycle().addObserver(new LocationObserver()); &#125;&#125; Fragment和Activity是如何进行消息派发的？Fragment 实现LifecycleOwner接口，返回LifecycleRegistry 通过LifecycleRegistry在各生命周期进行派发 123456789101112131415161718192021public class Fragment implements ComponentCallbacks, OnCreateContextMenuListener, LifecycleOwner, ViewModelStoreOwner, HasDefaultViewModelProviderFactory, SavedStateRegistryOwner, ActivityResultCaller &#123; LifecycleRegistry mLifecycleRegistry; @Override @NonNull public Lifecycle getLifecycle() &#123; return mLifecycleRegistry; &#125; void performStart() &#123; ... mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START); ... &#125; &#125; Activity 实现LifecycleOwner接口，实现getLifecycle方法，返回mLifecycleRegistry 并没有直接使用mLifecycleRegistry在各生命周期函数中进行派发，而是借助了一个透明的ReportFragment进行的 执行ReportFragment.injectIfNeededIn(this)，把自己挂载到Activity上 然后在对应的生命周期进行派出事件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class ComponentActivity extends androidx.core.app.ComponentActivity implements ContextAware, LifecycleOwner, ViewModelStoreOwner, HasDefaultViewModelProviderFactory, SavedStateRegistryOwner, OnBackPressedDispatcherOwner, ActivityResultRegistryOwner, ActivityResultCaller &#123; @Override public Lifecycle getLifecycle() &#123; return mLifecycleRegistry; &#125; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ReportFragment.injectIfNeededIn(this); if (mContentLayoutId != 0) &#123; setContentView(mContentLayoutId); &#125; &#125;&#125;public class ReportFragment extends android.app.Fragment &#123; //把自己添加到Activity上 public static void injectIfNeededIn(Activity activity) &#123; if (Build.VERSION.SDK_INT &gt;= 29) &#123; // On API 29+, we can register for the correct Lifecycle callbacks directly LifecycleCallbacks.registerIn(activity); &#125; // Prior to API 29 and to maintain compatibility with older versions of // ProcessLifecycleOwner (which may not be updated when lifecycle-runtime is updated and // need to support activities that don&#x27;t extend from FragmentActivity from support lib), // use a framework fragment to get the correct timing of Lifecycle events android.app.FragmentManager manager = activity.getFragmentManager(); if (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == null) &#123; manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit(); // Hopefully, we are the first to make a transaction. manager.executePendingTransactions(); &#125; &#125; @Override public void onStart() &#123; super.onStart(); dispatchStart(mProcessListener); dispatch(Lifecycle.Event.ON_START); &#125; private void dispatch(@NonNull Lifecycle.Event event) &#123; if (Build.VERSION.SDK_INT &lt; 29) &#123; // Only dispatch events from ReportFragment on API levels prior // to API 29. On API 29+, this is handled by the ActivityLifecycleCallbacks // added in ReportFragment.injectIfNeededIn dispatch(getActivity(), event); &#125; &#125; //真正派发的地方法 获取所在activity的LifecycleRegistry 这就是为什么ComponentActivity要实现LifecycleOnwer接口 static void dispatch(@NonNull Activity activity, @NonNull Lifecycle.Event event) &#123; if (activity instanceof LifecycleRegistryOwner) &#123; ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event); return; &#125; if (activity instanceof LifecycleOwner) &#123; Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle(); if (lifecycle instanceof LifecycleRegistry) &#123; ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event); &#125; &#125; &#125;&#125; 为什么要这么做？ 这是一种切面的方式，为了兼容不是继承AppcompactActivity的Activity,而是直接继承Activity这个类的，在LifecycleDispatcher这个类里，通过注册Ativity的生命周期回调，实现DispatchActivityCallback，然后在回调的onActivityCreated方法内执行ReportFragment.injectIfNeededIn(this); 这样每个继承自Activity的也同样可以进行生命周期事件的派发了 LifecycleOwner、Lifecycle、LifecycleRegistry的关系 LifecycleRestry事件分发的源码12345678910111213141516public class LifecycleRegistry extends Lifecycle &#123; @Override public void addObserver(@NonNull LifecycleObserver observer) &#123; enforceMainThreadIfNeeded(&quot;addObserver&quot;); //宿主的状态，和宿主的生命周期不是一个概念 //切换到后台后，会执行onPause()但是状态是started状态，因为State这个枚举中并没有Paused的状态，只到started状态后面是Resumed状态 State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED; ObserverWithState statefulObserver = new ObserverWithState(observer, initialState); ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver); ... &#125;&#125; 执行addObserver方法的可能在onCreate在onStart在onResume都可以，只要不是在onDestroy，都把宿主状态初始为INTIALIZED状态 把initialState包装成ObserverWithState即为带有状态的观察者 宿主的生命周期和宿主状态模型图 前进状态：执行onCreate方法变为CREATED状态，执行onStart方法后，变为STARTED状态，执行onResume方法后，变为RESUMED状态，这是前进状态 倒退状态：执行onPause方法后，由RESUMED状态倒退到STARTED状态，执行onSop方法后，由STARTED状态倒退到CREATED状态，这是倒退的状态 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071@Overridepublic void addObserver(@NonNull LifecycleObserver observer) &#123; enforceMainThreadIfNeeded(&quot;addObserver&quot;);... State targetState = calculateTargetState(observer); mAddingObserverCounter++; while ((statefulObserver.mState.compareTo(targetState) &lt; 0 &amp;&amp; mObserverMap.contains(observer))) &#123; pushParentState(statefulObserver.mState); final Event event = Event.upFrom(statefulObserver.mState); if (event == null) &#123; throw new IllegalStateException(&quot;no event up from &quot; + statefulObserver.mState); &#125; statefulObserver.dispatchEvent(lifecycleOwner, event); popParentState(); // mState / subling may have been changed recalculate targetState = calculateTargetState(observer); &#125; if (!isReentrance) &#123; // we do sync only on the top level. sync(); &#125; mAddingObserverCounter--;&#125;@Nullablepublic static Event upFrom(@NonNull State state) &#123; switch (state) &#123; case INITIALIZED: return ON_CREATE; case CREATED: return ON_START; case STARTED: return ON_RESUME; default: return null; &#125;&#125;void dispatchEvent(LifecycleOwner owner, Event event) &#123; State newState = event.getTargetState(); mState = min(mState, newState); mLifecycleObserver.onStateChanged(owner, event); mState = newState;&#125;@NonNullpublic State getTargetState() &#123; switch (this) &#123; case ON_CREATE: case ON_STOP: return State.CREATED; case ON_START: case ON_PAUSE: return State.STARTED; case ON_RESUME: return State.RESUMED; case ON_DESTROY: return State.DESTROYED; case ON_ANY: break; &#125; throw new IllegalArgumentException(this + &quot; has no target state&quot;);&#125;&#125; 这个while循环很重要，这个循环会把宿主由初始状态INITIALIZED 前进到当前宿主应有的生命周期状态可能是STARTED也可能是RESUMED的 先通过calculateTargetState(observer)拿到宿主的当前状态，比如宿主在onResume中注册的addObserver方法，那它当前应该的状态是RESUMED 通过比较当前状态和当前应该处于的状态statefulObserver.mState.compareTo(targetState)小于0代表状态还没有前进到，比如第一次状态肯定是INITIALIZED而宿主应该处于是RESUMED，所以执行while循环 final Event event &#x3D; Event.upFrom(statefulObserver.mState)由当前状态获取应该执行的生周期事件，得知要执行的事件是ON_CREATE 执行 statefulObserver.dispatchEvent(lifecycleOwner, event) 先由event.getTargetState() 事件获取newState，比如当前是ON_CREATE 得到CREATED mState &#x3D; newState赋值当前状态为新的状态，这样再去while中比较 这样就会把当前RESUMED之前的事件都派发给宿主，而不是在于它在哪里进行了注册，宿主会收到一个完整的生命周期事件，进行注册等操作","categories":[],"tags":[]},{"title":"聊聊WebSocket及OkHttp实现WebSocket","slug":"聊聊WebSocket及OkHttp实现WebSocket","date":"2022-05-13T10:43:51.000Z","updated":"2022-11-17T07:56:15.000Z","comments":true,"path":"2022/05/13/聊聊WebSocket及OkHttp实现WebSocket/","link":"","permalink":"http://example.com/2022/05/13/%E8%81%8A%E8%81%8AWebSocket%E5%8F%8AOkHttp%E5%AE%9E%E7%8E%B0WebSocket/","excerpt":"","text":"OkHttp应该算是Android中使用最广泛的网络库了，我们通常会利用它来实现HTTP请求，但是实际上它还可以支持WebSocket，并且使用起来还非常的便捷。那本文就来聊聊，利用OkHttp实现WebSocket的一些细节，包括对WebSocket的介绍，以及在传输如何做鉴权、长连接保活及其原理。 1.WebSocket1.1 为什么使用WebSocket?我们做客户端开发时，接触最多的应用层网络协议，就是HTTP协议，而今天介绍的WebSocket，下层和HTTP一样也是基于TCP协议，这是一种轻量级网络通信协议，也属于应用层协议。 WebSocket与HTTP2 一样，其实都是为了解决HTTP1.1的一些缺陷而诞生的，而WebSocket针对的就是「请求-应答」这种「半双工」的模式的通信缺陷。 「请求-应答」是半双工的通信模式，数据的传输必须经过一次请求应答，这个完整的通信过程，通信的同一时刻数据只能在一个方向上传递。它最大的问题在于，HTTP是一种被动的模式，服务端必须等待客户端请求才可以返回数据，无法主动向客户端发送数据。 这也导致在WebSocket出现之前，一些对实时性有要求的服务，通常是基于轮询这种简单的模式来实现。轮询就是由客户端定时发起请求，如果服输端有需要传递的数据，可以借助这个请求去响应数据。 轮询的缺点也非常明显，大量空闲的时间，其实是在反复发送无效的请求，这显然是一种资源的损耗。 虽然在之后的HTTP2 HTTP3中针对这种半双工的缺陷新增了Stream Server Push等特性，但是’请求-应答’依然是HTTP协议请要的通信方式。 WebSocket协议是由HTML5规范定义的，原本是为了浏览器而设计的，可以避免同源的限制，浏览器可以与任意服务端通信，现代浏览器基本上都已经支持WebSocket。 虽然WebSocket原本是被定义在HTML5中，但它也适用于移动端，尽管移动端也可以直接通过Socket与服务端通信，但借助WebSocket，可以利用80（HTTP）或443（HTTPS）端口通信，有效的避免一些防火墙的拦截。 WebSocket是真正意义上的全双工模式，也就我们俗称的‘长连接’。当完成握手连接后，客户端和服务端均可以主动的发起请求，回复响应，并且两边的传输都是相互独立的。 1.2 WebSocket的特点WebSocket的数据传输，是基于TCP协议，但是在传输之前，还有一个握手的过程，双方确认过眼神，才能够正式的传输数据。 WebSocket的握手过程，符合其‘Web’的特性，是利用HTTP本身的‘协议升级’来实现。 在建立连接前，客户端还需要知道服务端的地址，WebSocket并没有另辟路径，而是沿用了HTTP的URL格式，但协议标识变成了‘ws’或者‘wss’，分别表示明文加密的WebSocket协议，这一点和HTTP和HTTPS的关系类似。 以下是一些WebSocket的URL例子： 123ws://cxmydev.com/some/pathws://cxmydev.com:8080/some/pathwss://cxmydev.com:443?uid=xxx 而在连接建立后，WebSocket采用二进制帧的形式传输数据，其中常用的包括用于数据传输的数据帧MESSAGE以及3个控制帧： PING:主动保活的PING帧 PONG：收到PING帧后回复 CLOSE：主动关闭WebSocket连接 小结下WebSocket特性： WebSocket建立在TCP协议之上，对服务端友好。 默认端口采用80或443，握手阶段采用HTTP协议，不容易被防火墙屏蔽，能够通过各种HTTP代理服务器。 传输数据相比HTTP更轻量，少了HTTP HEADER，性能开销更小，通信更高效。 通过MESSAGE帧发送数据，可以发送文本或者二进制数据，如果数据过大，会被分为多个MESSAGE帧发送。 WebSocket沿用HTTP的URL，协议标识符’ws’或‘wss’ 1.3 WebSocket原理WebSocket在TCP连接建立后，还要通过Http进行一次握手，也就是通过Http发送一条GET请求消息给服务器，告诉服务器我要建立WebSocket连接了，你准备好哦，具体做法就是在头部信息中添加相关参数。然后服务器响应我知道了，并且将连接协议改成WebSocket，开始建立长连接。 这里贴上请求头和响应头信息，从网上找了一张图： 简单说明下参数： URL一般是以ws或者wss开头，ws对应Websocket协议，wss对应在TLS之上的WebSocket。类似于Http和Https的关系。 请求方法为GET方法。 Connection:Upgrade，表示客户端要连接升级，不用Http协议。 Upgrade:websocket， 表示客户端要升级建立Websocket连接。 Sec-Websocket-Key:key， 这个key是随机生成的，服务器会通过这个参数验证该请求是否有效。 Sec-WebSocket-Version:13， websocket使用的版本，一般就是13。 Sec-webSocket-Extension:permessage-deflate，客户端指定的一些扩展协议，比如这里permessage-deflate就是WebSocket的一种压缩协议。 响应码101,表示响应协议升级，后续的数据交互都按照Upgradet指定的WebSocket协议来。 2.结合OkHttp使用WebSocket进行通信2.1 添加OkHttp依赖1implementation(&quot;com.squareup.okhttp3:okhttp:4.7.2&quot;) 2.2 实现代码1234567891011//初始化WebSocketpublic void init() &#123; mWbSocketUrl = &quot;ws://echo.websocket.org&quot;; mClient = new OkHttpClient.Builder() .pingInterval(10, TimeUnit.SECONDS) .build(); Request request = new Request.Builder() .url(mWbSocketUrl) .build(); mWebSocket = mClient.newWebSocket(request, new WsListener());&#125; 这里主要是配置了OkHttp的一些参数，以及WebSocket的连接地址。其中newWebSocket方法就是进行WebSocket的初始化和连接。 这里要注意的点是pingInterval方法的配置，这个方法主要是用来设置WebSocket连接的保活。 相信做过长连接的同学都知道，一个长连接一般要隔几秒发送一条消息告诉服务器我在线，而服务器也会回复一个消息表示收到了，这样就确认了连接正常，客户端和服务器端都在线。 如果服务器没有按时收到这个消息那么服务器可能就会主动关闭这个连接，节约资源。 客户端没有正常收到这个返回的消息，也会做一些类似重连的操作，所以这个保活消息非常重要。 我们称这个消息叫作心跳包，一般用PING，PONG表示，像乒乓球一样，一来一回。 所以这里的pingInterval就是设置心跳包发送的间隔时间，设置了这个方法之后，OkHttp就会自动帮我们发送心跳包事件，也就是ping包。当间隔时间到了，没有收到pong包的话，监听事件中的onFailure方法就会被调用，此时我们就可以进行断线重连。 但是由于实际业务需求不一样，以及okhttp中心跳包事件给予我们权限较少，所以我们也可以自己完成心跳包事件，即在WebSocket连接成功之后，开始定时发送ping包，在下一次发送ping包之前检查上一个pong包是否收到，如果没收到，就视为异常，开始断线重连。感兴趣的同学可以看看文末的相关源码。 建立连接后，我们就可以正常发送和读取消息了，也就是在上文WsListener监听事件中表现： 在Android程序中，如果应用被系统kill了进程，这种我们是没办法告诉Sever端，结束连接的，所以心跳包是有必要的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//监听事件，用于收消息，监听连接的状态class WsListener extends WebSocketListener &#123; @Override public void onClosed(@NotNull WebSocket webSocket, int code, @NotNull String reason) &#123; super.onClosed(webSocket, code, reason); &#125; @Override public void onClosing(@NotNull WebSocket webSocket, int code, @NotNull String reason) &#123; super.onClosing(webSocket, code, reason); &#125; @Override public void onFailure(@NotNull WebSocket webSocket, @NotNull Throwable t, @Nullable Response response) &#123; super.onFailure(webSocket, t, response); &#125; @Override public void onMessage(@NotNull WebSocket webSocket, @NotNull String text) &#123; super.onMessage(webSocket, text); Log.e(TAG, &quot;客户端收到消息:&quot; + text); onWSDataChanged(DATE_NORMAL, text); //测试发消息 webSocket.send(&quot;我是客户端，你好啊&quot;); &#125; @Override public void onMessage(@NotNull WebSocket webSocket, @NotNull ByteString bytes) &#123; super.onMessage(webSocket, bytes); &#125; @Override public void onOpen(@NotNull WebSocket webSocket, @NotNull Response response) &#123; super.onOpen(webSocket, response); Log.e(TAG,&quot;连接成功！&quot;); &#125;&#125;//发送String消息public void send(final String message) &#123; if (mWebSocket != null) &#123; mWebSocket.send(message); &#125;&#125;//发送byte消息public void send(final ByteString message) &#123; if (mWebSocket != null) &#123; mWebSocket.send(message); &#125;&#125; //主动断开连接public void disconnect(int code, String reason) &#123; if (mWebSocket != null) mWebSocket.close(code, reason);&#125; 这里要注意，回调的方法都是在子线程回调的，如果需要更新UI，需要切换到主线程。 基本操作就这么多，还是很简单的吧，初始化Websocket——连接——连接成功——收发消息。 其中WebSocket类是一个操作接口，主要提供了以下几个方法 send(text: String)发送一个String类型的消息 send(bytes: ByteString) 发送一个二进制类型的消息 close(code: Int, reason: String?)关闭WebSocket连接 如果有同学想测试下WebSocket的功能但是又没有实际的服务器，怎么办呢？ 其实OkHttp官方有一个MockWebSocket服务，可以用来模拟服务端，下面我们一起试一下： 2.3 模拟服务器首先集成MockWebSocket服务库： 1implementation &#x27;com.squareup.okhttp3:mockwebserver:4.7.2&#x27; 然后就可以新建MockWebServer，并加入MockResponse作为接收消息的响应。 123456789101112131415161718192021222324252627MockWebServer mMockWebServer = new MockWebServer();MockResponse response = new MockResponse() .withWebSocketUpgrade(new WebSocketListener() &#123; @Override public void onOpen(@NotNull WebSocket webSocket, @NotNull Response response) &#123; super.onOpen(webSocket, response); //有客户端连接时回调 Log.e(TAG, &quot;服务器收到客户端连接成功回调：&quot;); mWebSocket = webSocket; mWebSocket.send(&quot;我是服务器，你好呀&quot;); &#125; @Override public void onMessage(@NotNull WebSocket webSocket, @NotNull String text) &#123; super.onMessage(webSocket, text); Log.e(TAG, &quot;服务器收到消息：&quot; + text); &#125; @Override public void onClosed(@NotNull WebSocket webSocket, int code, @NotNull String reason) &#123; super.onClosed(webSocket, code, reason); Log.e(TAG, &quot;onClosed：&quot;); &#125; &#125;);mMockWebServer.enqueue(response); 这里服务器端在收到客户端连接成功消息后，给客户端发送了一条消息。 要注意的是这段代码要在子线程执行，因为主线程不能进行网络操作。 然后就可以去初始化Websocket客户端了： 123//获取连接url，初始化websocket客户端String websocketUrl = &quot;ws://&quot; + mMockWebServer.getHostName() + &quot;:&quot; + mMockWebServer.getPort() + &quot;/&quot;;WSManager.getInstance().init(websocketUrl); ok，运行项目 123456//运行结果E/jimu: mWbSocketUrl=ws://localhost:38355/E/jimu: 服务器收到客户端连接成功回调：E/jimu: 连接成功！E/jimu: 客户端收到消息:我是服务器，你好呀E/jimu: 服务器收到消息：我是客户端，你好啊 2.4 WebSocket如何进行鉴权接下来我们聊聊 WebSocket 连接的鉴权问题。 所谓鉴权，其实就是为了安全考虑，避免服务端启动 WebSocket 的连接服务后，任谁都可以连接，这肯定会引发一些安全问题。其次，服务端还需要将 WebSocket 的连接实体与一个真是的用户对应起来，否者业务无法保证了。 那么问题就回到了，WebSocket 通信的完整过程中，如何以及何时将一些业务数据传递给服务端？当然在 WebSocket 连接建立之后，立即给服务端发送一些鉴权的数据，必然是可以做到业务实现的，但是这样明显是不够优雅的。 前文提到，WebSocket 在握手阶段，使用的是 HTTP 的 “协议升级”，它本质上还是 HTTP 的报文头发送一些特殊的头数据，来完成协议升级。 例如在 RealWebSocket 中，就有构造 Header 的过程，如 Upgrade、Connection 等等。 12345678910public void connect(OkHttpClient client) &#123; // ... final Request request = originalRequest.newBuilder() .header(&quot;Upgrade&quot;, &quot;websocket&quot;) .header(&quot;Connection&quot;, &quot;Upgrade&quot;) .header(&quot;Sec-WebSocket-Key&quot;, key) .header(&quot;Sec-WebSocket-Version&quot;, &quot;13&quot;) .build(); //....&#125; 那么实际我们在 WebSocket 阶段，也可以通过 Header 传输一些鉴权的数据，例如 uid、token 之类，具体方法就是在构造 Request 的时候，为其增加 Header，这里就不举例说明了。 另外 WebSocket 的 URL 也是可以携带参数的。 1wss://cxmydev.com:443?uid=xxx&amp;token=xxx 3.OkHttp 源码解读WebSocket连接过程及协议WebSocket整个流程无非三个功能：连接，接收消息，发送消息。下面我们就从这三个方面分析下具体是怎么实现的。 3.1 连接通过上面的代码我们得知，WebSocket连接是通过newWebSocket方法。直接点进去看这个方法： 12345678910111213override fun newWebSocket(request: Request, listener: WebSocketListener): WebSocket &#123; val webSocket = RealWebSocket( taskRunner = TaskRunner.INSTANCE, originalRequest = request, listener = listener, random = Random(), pingIntervalMillis = pingIntervalMillis.toLong(), extensions = null, // Always null for clients. minimumDeflateSize = minWebSocketMessageToCompress ) webSocket.connect(this) return webSocket&#125; 这里做了两件事： 初始化RealWebSocket，主要是设置了一些参数（比如pingIntervalMillis心跳包时间间隔，还有监听事件之类的） connect方法进行WebSocket连接 继续查看connect方法： 3.1.1 connect(WebSocket连接握手)12345678910111213141516171819202122232425262728293031323334353637fun connect(client: OkHttpClient) &#123; //*** val webSocketClient = client.newBuilder() .eventListener(EventListener.NONE) .protocols(ONLY_HTTP1) .build() val request = originalRequest.newBuilder() .header(&quot;Upgrade&quot;, &quot;websocket&quot;) .header(&quot;Connection&quot;, &quot;Upgrade&quot;) .header(&quot;Sec-WebSocket-Key&quot;, key) .header(&quot;Sec-WebSocket-Version&quot;, &quot;13&quot;) .header(&quot;Sec-WebSocket-Extensions&quot;, &quot;permessage-deflate&quot;) .build() call = RealCall(webSocketClient, request, forWebSocket = true) call!!.enqueue(object : Callback &#123; override fun onResponse(call: Call, response: Response) &#123; //得到数据流 val streams: Streams try &#123; checkUpgradeSuccess(response, exchange) streams = exchange!!.newWebSocketStreams() &#125; //*** // Process all web socket messages. try &#123; val name = &quot;$okHttpName WebSocket $&#123;request.url.redact()&#125;&quot; initReaderAndWriter(name, streams) listener.onOpen(this@RealWebSocket, response) loopReader() &#125; catch (e: Exception) &#123; failWebSocket(e, null) &#125; &#125; &#125;)&#125; Websocket连接需要一次Http协议的握手，然后才能把协议升级成WebSocket。所以这段代码就体现出这个功能了。 首先就new了一个用来进行Http连接的request，其中Header的参数就表示我要进行WebSocket连接了，参数解析如下： Connection:Upgrade，表示客户端要连接升级 Upgrade:websocket， 表示客户端要升级建立Websocket连接 Sec-Websocket-Key:key， 这个key是随机生成的，服务器会通过这个参数验证该请求是否有效 Sec-WebSocket-Version:13， websocket使用的版本，一般就是13 Sec-webSocket-Extension:permessage-deflate，客户端指定的一些扩展协议，比如这里permessage-deflate就是WebSocket的一种压缩协议。 Header设置好之后，就调用了call的enqueue方法，这个方法大家应该都很熟悉吧，OkHttp里面对于Http请求的异步请求就是这个方法。 至此，握手结束，服务器返回响应码101，表示协议升级。 然后我们继续看看获取服务器响应之后又做了什么？ 在发送Http请求成功之后，onResponse响应方法里面主要表现为四个处理逻辑： 将Http流转换成WebSocket流，得到Streams对象，这个流后面会转化成输入流和输出流，也就是进行发送和读取的操作流 listener.onOpen(this@RealWebSocket, response)，回调了接口WebSocketListener的onOpen方法，告诉用户WebSocket已经连接 initReaderAndWriter(name, streams) loopReader() 前两个逻辑还是比较好理解，主要是后两个方法，我们分别解析下。 首先看initReaderAndWriter方法。 3.1.2 initReaderAndWriter（初始化输入流输出流）123456789101112131415161718192021222324252627282930313233343536373839404142//RealWebSocket.kt@Throws(IOException::class)fun initReaderAndWriter(name: String, streams: Streams) &#123; val extensions = this.extensions!! synchronized(this) &#123; //*** //写数据，发送数据的工具类 this.writer = WebSocketWriter() //设置心跳包事件 if (pingIntervalMillis != 0L) &#123; val pingIntervalNanos = MILLISECONDS.toNanos(pingIntervalMillis) taskQueue.schedule(&quot;$name ping&quot;, pingIntervalNanos) &#123; writePingFrame() return@schedule pingIntervalNanos &#125; &#125; //*** &#125;//***//读取数据的工具类 reader = WebSocketReader( *** frameCallback = this, *** )&#125;internal fun writePingFrame() &#123; //*** try &#123; writer.writePing(ByteString.EMPTY) &#125; catch (e: IOException) &#123; failWebSocket(e, null) &#125;&#125; 这个方法主要干了两件事： 实例化输出流输入流工具类，也就是WebSocketWriter和WebSocketReader，用来处理数据的收发。 设置心跳包事件。如果pingIntervalMillis参数不为0，就通过计时器，每隔pingIntervalNanos发送一个ping消息。其中writePingFrame方法就是发送了ping帧数据。 3.2 接收消息处理消息3.2.1 loopReader接着看看这个loopReader方法是干什么的，看这个名字我们大胆猜测下，难道这个方法就是用来循环读取数据的？去代码里找找答案： 1234567fun loopReader() &#123; while (receivedCloseCode == -1) &#123; // This method call results in one or more onRead* methods being called on this thread. reader!!.processNextFrame() &#125;&#125; 代码很简单，一个while循环，循环条件是receivedCloseCode == -1的时候，做的事情是reader!!.processNextFrame()方法。继续： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//WebSocketWriter.ktfun processNextFrame() &#123; //读取头部信息 readHeader() if (isControlFrame) &#123; //如果是控制帧，读取控制帧内容 readControlFrame() &#125; else &#123; //读取普通消息内容 readMessageFrame() &#125;&#125;//读取头部信息@Throws(IOException::class, ProtocolException::class)private fun readHeader() &#123; if (closed) throw IOException(&quot;closed&quot;) try &#123; //读取数据，获取数据帧的前8位 b0 = source.readByte() and 0xff &#125; finally &#123; source.timeout().timeout(timeoutBefore, TimeUnit.NANOSECONDS) &#125; //*** //获取数据帧的opcode（数据格式） opcode = b0 and B0_MASK_OPCODE //是否为最终帧 isFinalFrame = b0 and B0_FLAG_FIN != 0 //是否为控制帧（指令） isControlFrame = b0 and OPCODE_FLAG_CONTROL != 0 //判断最终帧，获取帧长度等等&#125; //读取控制帧（指令） @Throws(IOException::class)private fun readControlFrame() &#123; if (frameLength &gt; 0L) &#123; source.readFully(controlFrameBuffer, frameLength) &#125; when (opcode) &#123; OPCODE_CONTROL_PING -&gt; &#123; //ping 帧 frameCallback.onReadPing(controlFrameBuffer.readByteString()) &#125; OPCODE_CONTROL_PONG -&gt; &#123; //pong 帧 frameCallback.onReadPong(controlFrameBuffer.readByteString()) &#125; OPCODE_CONTROL_CLOSE -&gt; &#123; //关闭 帧 var code = CLOSE_NO_STATUS_CODE var reason = &quot;&quot; val bufferSize = controlFrameBuffer.size if (bufferSize == 1L) &#123; throw ProtocolException(&quot;Malformed close payload length of 1.&quot;) &#125; else if (bufferSize != 0L) &#123; code = controlFrameBuffer.readShort().toInt() reason = controlFrameBuffer.readUtf8() val codeExceptionMessage = WebSocketProtocol.closeCodeExceptionMessage(code) if (codeExceptionMessage != null) throw ProtocolException(codeExceptionMessage) &#125; //回调onReadClose方法 frameCallback.onReadClose(code, reason) closed = true &#125; &#125;&#125;//读取普通消息@Throws(IOException::class)private fun readMessageFrame() &#123; readMessage() if (readingCompressedMessage) &#123; val messageInflater = this.messageInflater ?: MessageInflater(noContextTakeover).also &#123; this.messageInflater = it &#125; messageInflater.inflate(messageFrameBuffer) &#125; if (opcode == OPCODE_TEXT) &#123; frameCallback.onReadMessage(messageFrameBuffer.readUtf8()) &#125; else &#123; frameCallback.onReadMessage(messageFrameBuffer.readByteString()) &#125;&#125; 代码还是比较直观，这个processNextFrame其实就是读取数据用的，首先读取头部信息，获取数据帧的类型，判断是否为控制帧，再分别去读取控制帧数据或者普通消息帧数据。 3.2.2 数据帧格式问题来了，什么是数据头部信息，什么是控制帧？ 这里就要说下WebSocket的数据帧了，先附上一个数据帧格式： 1234567891011121314151617 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7+-+-+-+-+-------+ +-+-------------+ +-----------------------------+|F|R|R|R| OP | |M| LENGTH | Extended payload length|I|S|S|S| CODE | |A| | （if LENGTH=126）|N|V|V|V| | |S| || |1|2|3| | |K| |+-+-+-+-+-------+ +-+-------------+| Extended payload length（if LENGTH=127）+ +-------------------------------| Extended payload length | Masking-key，if Mask set to 1+----------------------------------+-------------------------------| Masking-key | Data+----------------------------------+-------------------------------| Data+----------------------------------+------------------------------- 我承认，我懵逼了。 冷静冷静，一步一步分析下吧。 首先每一行代表4个字节，一共也就是32位数，哦，那也就是几个字节而已嘛，每个字节有他自己的代表意义呗，这样想是不是就很简单了，下面来具体看看每个字节。 第1个字节： 第一位是FIN码，其实就是一个标示位，因为数据可能多帧操作嘛，所以多帧情况下，只有最后一帧的FIN设置成1，标示结束帧，前面所有帧设置为0。 第二位到第四位是RSV码，一般通信两端没有设置自定义协议，就默认为0。 后四位是opcode，我们叫它操作码。这个就是判断这个数据帧的类型了，一般有以下几个被定义好的类型： 1） 0x0 表示附加数据帧2） 0x1 表示文本数据帧3） 0x2 表示二进制数据帧4） 0x3-7 保留用于未来的非控制帧5） 0x8 表示连接关闭6） 0x9 表示ping7） 0xA 表示pong8） 0xB-F 保留用于未来的非控制帧 是不是发现了些什么，这不就对应了我们应用中的几种格式吗？2和3对应的是普通消息帧，包括了文本和二进制数据。567对应的就是控制帧格式，包括了close，ping，pong。 第2个字节： 第一位是Mask掩码，其实就是标识数据是否加密混淆，1代表数据经过掩码的，0是没有经过掩码的，如果是1的话，后续就会有4个字节代表掩码key，也就是数据帧中Masking-key所处的位置。 后7位是LENGTH，用来标示数据长度。因为只有7位，所以最大只能储存1111111对应的十进制数127长度的数据，如果需要更大的数据，这个储存长度肯定就不够了。 所以规定来了，1) 小于126长度则数据用这七位表示实际长度。2) 如果长度设置为126，也就是二进制1111110，就代表取额外2个字节表示数据长度，共是16位表示数据长度。3) 如果长度设置为127，也就是二进制1111111，就代表取额外8个字节，共是64位表示数据长度。 需要注意的是LENGHT的三种情况在一个数据帧里面只会出现一种情况，不共存，所以在图中是用if表示。同样的，Masking-key也是当Mask为1的时候才存在。 所以也就有了数据帧里面的Extended payload length（LENGTH=126）所处的2个字节，以及Extended payload length（LENGTH=127）所处的8个字节。 最后的字节部分自然就是掩码key（Mask为1的时候才存在）和具体的传输数据了。还是有点晕吧😷，来张图总结下： 好了，了解了数据帧格式后，我们再来读源码就清晰多了。 先看看怎么读的头部信息并解析的： 12345678//取数据帧前8位数据b0 = source.readByte() and 0xff//获取数据帧的opcode（数据格式）opcode = b0 and B0_MASK_OPCODE（15）//是否为最终帧isFinalFrame = b0 and B0_FLAG_FIN（128） != 0//是否为控制帧（指令）isControlFrame = b0 and OPCODE_FLAG_CONTROL（8） != 0 第一句获取头信息，and是按位与计算，and 0xff意思就是按位与11111111，所以头部信息其实就是取了数据帧的前8位数据，一个字节。 第二句获取opcode，and 15也就是按位与00001111，其实也就是取了后四位数据，刚好对应上opcode的位置，第一个字节的后四位。 第三句获取是否为最终帧，刚才数据帧格式中说过，第一位FIN标识了是否为最后一帧数据，1代表结束帧，所以这里and 128也就是按位与10000000，也就是取的第一位数。 第四句获取是否为控制帧，and 8也就是按位与00001000，取得是第五位，也就是opcode的第一位，这是什么意思呢？我们看看刚才的数据帧格式，发现从0x8开始就是所谓的控制帧了。0x8对应的二进制是1000，0x7对应的二进制是0111。发现了吧，如果为控制帧的时候，opcode第一位肯定是为1的，所以这里就判断的第五位。 后面还有读取第二个字节的代码，大家可以自己沿着这个思路自己看看，包括了读取MASK，读取数据长度的三种长度等。 所以这个processNextFrame方法主要做了三件事： readHeader方法中，判断了是否为控制帧，是否为结束帧，然后获取了Mask标识，帧长度等参数 readControlFrame方法中，主要处理了该帧数据为ping，pong，close三种情况，并且在收到close关闭帧的情况下，回调了onReadClose方法，这个待会要细看下。 readMessageFrame方法中，主要是读取了消息后，回调了onReadMessage方法。 至此可以发现，其实WebSocket传输数据并不是一个简单的事，只是OkHttp都帮我们封装好了，我们只需要直接传输数据即可，感谢这些三方库为我们开发作出的贡献，不知道什么时候我也能做出点贡献呢🤔。 对了，刚才说回调也很重要，接着看看。onReadClose和onReadMessage回调到哪了呢？还记得上文初始化WebSocketWriter的时候设置了回调接口吗。所以就是回调给RealWebSocket了： 12345678910111213141516171819202122232425262728293031323334353637//RealWebSocket.ktoverride fun onReadClose(code: Int, reason: String) &#123; require(code != -1) var toClose: Streams? = null var readerToClose: WebSocketReader? = null var writerToClose: WebSocketWriter? = null synchronized(this) &#123; check(receivedCloseCode == -1) &#123; &quot;already closed&quot; &#125; receivedCloseCode = code receivedCloseReason = reason //... &#125; try &#123; listener.onClosing(this, code, reason) if (toClose != null) &#123; listener.onClosed(this, code, reason) &#125; &#125; finally &#123; toClose?.closeQuietly() readerToClose?.closeQuietly() writerToClose?.closeQuietly() &#125;&#125;@Throws(IOException::class)override fun onReadMessage(text: String) &#123; listener.onMessage(this, text)&#125;@Throws(IOException::class)override fun onReadMessage(bytes: ByteString) &#123; listener.onMessage(this, bytes)&#125; onReadClose回调方法里面有个关键的参数，receivedCloseCode。还记得这个参数吗？上文中解析消息的循环条件就是receivedCloseCode == -1，所以当收到关闭帧的时候，receivedCloseCode就不再等于-1（规定大于1000），也就不再去读取解析消息了。这样整个流程就结束了。 其中还有一些WebSocketListener的回调，比如onClosing，onClosed，onMessage等，就直接回调给用户使用了。至此，接收消息处理消息说完了。 3.3 发消息好了。接着说发送，看看send方法： 123456789@Synchronized private fun send(data: ByteString, formatOpcode: Int): Boolean &#123; // *** // Enqueue the message frame. queueSize += data.size.toLong() messageAndCloseQueue.add(Message(formatOpcode, data)) runWriter() return true&#125; 首先，把要发送的data封装成Message对象，然后入队列messageAndCloseQueue。最后执行runWriter方法。这都不用猜了，runWriter肯定就要开始发送消息了，继续看： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//RealWebSocket.ktprivate fun runWriter() &#123; this.assertThreadHoldsLock() val writerTask = writerTask if (writerTask != null) &#123; taskQueue.schedule(writerTask) &#125;&#125;private inner class WriterTask : Task(&quot;$name writer&quot;) &#123; override fun runOnce(): Long &#123; try &#123; if (writeOneFrame()) return 0L &#125; catch (e: IOException) &#123; failWebSocket(e, null) &#125; return -1L &#125;&#125; //以下是schedule方法转到WriterTask的runOnce方法过程//TaskQueue.ktfun schedule(task: Task, delayNanos: Long = 0L) &#123; synchronized(taskRunner) &#123; if (scheduleAndDecide(task, delayNanos, recurrence = false)) &#123; taskRunner.kickCoordinator(this) &#125; &#125;&#125;internal fun scheduleAndDecide(task: Task, delayNanos: Long, recurrence: Boolean): Boolean &#123; //*** if (insertAt == -1) insertAt = futureTasks.size futureTasks.add(insertAt, task) // Impact the coordinator if we inserted at the front. return insertAt == 0&#125; //TaskRunner.ktinternal fun kickCoordinator(taskQueue: TaskQueue) &#123; this.assertThreadHoldsLock() if (taskQueue.activeTask == null) &#123; if (taskQueue.futureTasks.isNotEmpty()) &#123; readyQueues.addIfAbsent(taskQueue) &#125; else &#123; readyQueues.remove(taskQueue) &#125; &#125; if (coordinatorWaiting) &#123; backend.coordinatorNotify(this@TaskRunner) &#125; else &#123; backend.execute(runnable) &#125;&#125; private val runnable: Runnable = object : Runnable &#123; override fun run() &#123; while (true) &#123; val task = synchronized(this@TaskRunner) &#123; awaitTaskToRun() &#125; ?: return logElapsed(task, task.queue!!) &#123; var completedNormally = false try &#123; runTask(task) completedNormally = true &#125; finally &#123; // If the task is crashing start another thread to service the queues. if (!completedNormally) &#123; backend.execute(this) &#125; &#125; &#125; &#125; &#125;&#125;private fun runTask(task: Task) &#123; try &#123; delayNanos = task.runOnce() &#125; &#125; 代码有点长，这里是从runWriter开始跟的几个方法，拿到writerTask实例后，存到TaskQueue的futureTasks列表里，然后到runnable这里可以看到是一个while死循环，不断的从futureTasks中取出Task并执行runTask方法，直到Task为空，循环停止。 其中涉及到两个新的类： TaskQueue类主要就是管理消息任务列表，保证按顺序执行 TaskRunner类主要就是做一些任务的具体操作，比如线程池里执行任务，记录消息任务的状态（准备发送的任务队列readyQueues，正在执行的任务队列busyQueues等等） 而每一个Task最后都是执行到了WriterTask的runOnce方法，也就是writeOneFrame方法： 123456789101112131415161718192021222324252627282930313233343536373839404142internal fun writeOneFrame(): Boolean &#123; synchronized(this@RealWebSocket) &#123; if (failed) &#123; return false // Failed web socket. &#125; writer = this.writer pong = pongQueue.poll() if (pong == null) &#123; messageOrClose = messageAndCloseQueue.poll() if (messageOrClose is Close) &#123; &#125; else if (messageOrClose == null) &#123; return false // The queue is exhausted. &#125; &#125; &#125; //发送消息逻辑，包括`pong`消息，普通消息，关闭消息 try &#123; if (pong != null) &#123; writer!!.writePong(pong) &#125; else if (messageOrClose is Message) &#123; val message = messageOrClose as Message writer!!.writeMessageFrame(message.formatOpcode, message.data) synchronized(this) &#123; queueSize -= message.data.size.toLong() &#125; &#125; else if (messageOrClose is Close) &#123; val close = messageOrClose as Close writer!!.writeClose(close.code, close.reason) // We closed the writer: now both reader and writer are closed. if (streamsToClose != null) &#123; listener.onClosed(this, receivedCloseCode, receivedCloseReason!!) &#125; &#125; return true &#125; finally &#123; streamsToClose?.closeQuietly() readerToClose?.closeQuietly() writerToClose?.closeQuietly() &#125;&#125; 这里就会执行发送消息的逻辑了，主要有三种消息情况处理： pong消息，这个主要是为服务器端准备的，发送给客户端回应心跳包。 普通消息，就会把数据类型Opcode和具体数据发送过去 关闭消息，其实当用户执行close方法关闭WebSocket的时候，也是发送了一条Close控制帧消息给服务器告知这个关闭需求，并带上code状态码和reason关闭原因，然后服务器端就会关闭当前连接。 好了。最后一步了，就是把这些数据组装成WebSocket数据帧并写入流，分成控制帧数据和普通消息数据帧： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//写入（发送）控制帧private fun writeControlFrame(opcode: Int, payload: ByteString) &#123; if (writerClosed) throw IOException(&quot;closed&quot;) val length = payload.size require(length &lt;= PAYLOAD_BYTE_MAX) &#123; &quot;Payload size must be less than or equal to $PAYLOAD_BYTE_MAX&quot; &#125; val b0 = B0_FLAG_FIN or opcode sinkBuffer.writeByte(b0) var b1 = length if (isClient) &#123; b1 = b1 or B1_FLAG_MASK sinkBuffer.writeByte(b1) random.nextBytes(maskKey!!) sinkBuffer.write(maskKey) if (length &gt; 0) &#123; val payloadStart = sinkBuffer.size sinkBuffer.write(payload) sinkBuffer.readAndWriteUnsafe(maskCursor!!) maskCursor.seek(payloadStart) toggleMask(maskCursor, maskKey) maskCursor.close() &#125; &#125; else &#123; sinkBuffer.writeByte(b1) sinkBuffer.write(payload) &#125; sink.flush()&#125;//写入（发送）普通消息数据帧@Throws(IOException::class)fun writeMessageFrame(formatOpcode: Int, data: ByteString) &#123; if (writerClosed) throw IOException(&quot;closed&quot;) messageBuffer.write(data) var b0 = formatOpcode or B0_FLAG_FIN val dataSize = messageBuffer.size sinkBuffer.writeByte(b0) var b1 = 0 if (isClient) &#123; b1 = b1 or B1_FLAG_MASK &#125; when &#123; dataSize &lt;= PAYLOAD_BYTE_MAX -&gt; &#123; b1 = b1 or dataSize.toInt() sinkBuffer.writeByte(b1) &#125; dataSize &lt;= PAYLOAD_SHORT_MAX -&gt; &#123; b1 = b1 or PAYLOAD_SHORT sinkBuffer.writeByte(b1) sinkBuffer.writeShort(dataSize.toInt()) &#125; else -&gt; &#123; b1 = b1 or PAYLOAD_LONG sinkBuffer.writeByte(b1) sinkBuffer.writeLong(dataSize) &#125; &#125; if (isClient) &#123; random.nextBytes(maskKey!!) sinkBuffer.write(maskKey) if (dataSize &gt; 0L) &#123; messageBuffer.readAndWriteUnsafe(maskCursor!!) maskCursor.seek(0L) toggleMask(maskCursor, maskKey) maskCursor.close() &#125; &#125; sinkBuffer.write(messageBuffer, dataSize) sink.emit()&#125; 大家应该都能看懂了吧，其实就是组装数据帧，包括Opcode，mask，数据长度等等。两个方法的不同就在于普通数据需要判断数据长度的三种情况，再组装数据帧。最后都会通过sinkBuffer写入到输出数据流。 终于，基本的流程说的差不多了。其中还有很多细节，同学们可以自己花时间看看琢磨琢磨，比如Okio部分。还是那句话，希望大家有空自己也读一读相关源码，这样理解才能深刻，而且你肯定会发现很多我没说到的细节，欢迎大家讨论。我也会继续努力，最后大家给我加个油点个赞吧，感谢感谢。","categories":[],"tags":[]},{"title":"HTTPS 学习整理","slug":"HTTPS-学习整理","date":"2022-05-13T00:23:15.000Z","updated":"2022-11-17T07:56:14.000Z","comments":true,"path":"2022/05/13/HTTPS-学习整理/","link":"","permalink":"http://example.com/2022/05/13/HTTPS-%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86/","excerpt":"","text":"HTTPS 学习整理1.HTTPS 连接及握手过程第一步，客户端发送给服务器Client Hello，叫做Client Hello 其实是一个一字节的数据 发送Client Hello 还会附加一些信息 可选的TLS版本 可选的加密套件 可选的对称加密算法 可选的非对称加密算法 可选的hash算法 客户端随机数（这个随机数随后会用到，等于是第一个随机数客户端和服务器都会使用到） 第二步，服务端返回Server Hello 也是一个单字节数据，并把Client Hello 附加信息的确认值返回给客户端，同时生成服务端的随机数，返回给客户端 第三步，服务端下发证书，然后客户端这里会做证书的较验，这里的过程比较麻烦和复杂 如图所示，证书中包含 服务器公钥 服务器主机名 服务器公钥的签名 证书签发机构的公钥 证书签发机构的公角的签名 …. 较验的顺序也是如此，链式去使用签名去较验公钥是否准确，防止公钥被修改，一层层直到找到根证书，根证书一般都安装在pc或者手机里，然后逐层去较验公钥的正确性，最后证明服务器的公钥确实是真的，而不是假的 如图所示，访问hencoder.com 然后证书链中的三级证书，客户端验证服务器证书的真实性，还通过主机名确认对方的身份，确实是我要访问的服务器，而不是其他在ca公签的服务器 第四步，客户端拿到服务器公钥后，和服务器一起通过公钥生成加密的Pre-master secret ，双方就公同持有了三个东西 客户端随机数 服务器随机数 Pre-master secret 通过这三个东西会各自独立的生成master secret 所以注意啦，最终的对称密钥并不是客户端生成后发给服务器的，而是由前面交互的随机数，及加密后的公钥独立生成的 而且，生成的对称加密的密钥并不是简单的一个密码 那么有人可能会有疑问，为什么要很麻烦的生成客户端的加密密钥，服务端的加密密钥？用一个不行么？ 第五步，客户端告诉服务器，我将使用加密通信，还有把前面几步合一起加密发给服务器，生送Finished 同样服务器也返回客户端：将使用加密通信，同时Finished握手 服务端返回 2.在Android中合理使用HTTPSCA公签的就不讨论了，使用很方便，根据所使用的网络框架，可以自行百度，非常简单方便。这里说下如何较验主机名 12345678910111213141516171819// Create an HostnameVerifier that hardwires the expected hostname.// Note that is different than the URL&#x27;s hostname:// example.com versus example.orgHostnameVerifier hostnameVerifier = new HostnameVerifier() &#123; @Override public boolean verify(String hostname, SSLSession session) &#123; HostnameVerifier hv = HttpsURLConnection.getDefaultHostnameVerifier(); return hv.verify(&quot;example.com&quot;, session); &#125;&#125;;// Tell the URLConnection to use our HostnameVerifierURL url = new URL(&quot;https://example.org/&quot;);HttpsURLConnection urlConnection = (HttpsURLConnection)url.openConnection();urlConnection.setHostnameVerifier(hostnameVerifier);InputStream in = urlConnection.getInputStream();copyInputStreamToOutputStream(in, System.out); 还有一种情况，有一些公司使用自签名证书，或者非知名机构颁发的证书，如果不做处理，会报https的网络异常，那么这时候上网上查的话，很多都是告诉不做较验，放开所有的证书，当然这样可以走的通，但是同时也失去了使用HTTPS的作用，是不认真负责的。 我们看官网上对这一过程的描述，之所以之前我们记不住，也是因为我们对HTTPS的握手和证书较验过程不够理解，现在看这段话 在这种情况下，由于您的 CA 不受系统信任，将发生 SSLHandshakeException。原因可能是您有一个由 Android 尚不信任的新 CA 颁发的证书，或您的应用在没有 CA 的较旧版本上运行。CA 未知的原因通常是因为它不是公共 CA，而是由政府、公司或教育机构等组织颁发的仅供其自己使用的私有 CA。 幸运的是，您可以指示 HttpsURLConnection 信任特定的 CA 集。这个过程可能有点复杂，下面的示例展示了这个过程：从 InputStream 获取一个特定的 CA，用该 CA 创建 KeyStore，然后用后者创建和初始化 TrustManager。TrustManager 是系统用于验证来自服务器的证书的工具，可以通过包含一个或多个 CA 的 KeyStore 创建，而创建的 TrustManager 将仅信任这些 CA。 由于 TrustManager 是新建的，此示例将启动一个新的 SSLContext，它会提供一个 SSLSocketFactory，可用于替换来自 HttpsURLConnection 的默认 SSLSocketFactory。这样一来，连接将使用您的 CA 来验证证书。 这下你知道，为啥Android客户会有一个证书文件了吧 123456789101112131415161718192021222324252627282930313233343536 // Load CAs from an InputStream// (could be from a resource or ByteArrayInputStream or ...)CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;);// From https://www.washington.edu/itconnect/security/ca/load-der.crtInputStream caInput = new BufferedInputStream(new FileInputStream(&quot;load-der.crt&quot;));Certificate ca;try &#123; ca = cf.generateCertificate(caInput); System.out.println(&quot;ca=&quot; + ((X509Certificate) ca).getSubjectDN());&#125; finally &#123; caInput.close();&#125;// Create a KeyStore containing our trusted CAsString keyStoreType = KeyStore.getDefaultType();KeyStore keyStore = KeyStore.getInstance(keyStoreType);keyStore.load(null, null);keyStore.setCertificateEntry(&quot;ca&quot;, ca);// Create a TrustManager that trusts the CAs in our KeyStoreString tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);tmf.init(keyStore);// Create an SSLContext that uses our TrustManagerSSLContext context = SSLContext.getInstance(&quot;TLS&quot;);context.init(null, tmf.getTrustManagers(), null);// Tell the URLConnection to use a SocketFactory from our SSLContextURL url = new URL(&quot;https://certs.cac.washington.edu/CAtest/&quot;);HttpsURLConnection urlConnection = (HttpsURLConnection)url.openConnection();urlConnection.setSSLSocketFactory(context.getSocketFactory());InputStream in = urlConnection.getInputStream();copyInputStreamToOutputStream(in, System.out); 这个SSLContext很关键，由得到的SSLContextFactory是我们很多网络框架可以进行替换和设置，这样就可以通过自签名的ca集来检验较验证书的合法性了。 之所以说SSLContext很关键，因为不光HTTP可以使用SSL较验，很多上层加密都使用了SSL层的加密特性，比如我们可能会遇到的WSS Websocket的加密协议，怎么处理，一样的道理。","categories":[],"tags":[]},{"title":"Jetpack系列—底部导航路由BottomNavigationView原理","slug":"Jetpack系列—底部导航路由原理","date":"2022-05-07T22:35:47.000Z","updated":"2022-11-17T07:56:14.000Z","comments":true,"path":"2022/05/08/Jetpack系列—底部导航路由原理/","link":"","permalink":"http://example.com/2022/05/08/Jetpack%E7%B3%BB%E5%88%97%E2%80%94%E5%BA%95%E9%83%A8%E5%AF%BC%E8%88%AA%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86/","excerpt":"主要介绍BottomNavigationView及其实现原理","text":"主要介绍BottomNavigationView及其实现原理 bottom_nav_menu.xml 配置底部item的显示内容和个数 1234567891011&lt;fragment android:id=&quot;@+id/nav_host_fragment_activity_main&quot; android:name=&quot;androidx.navigation.fragment.NavHostFragment&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:defaultNavHost=&quot;true&quot; app:layout_constraintBottom_toTopOf=&quot;@id/nav_view&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:navGraph=&quot;@navigation/mobile_navigation&quot; /&gt; 1app:defaultNavHost=&quot;true&quot; 是否和系统的返回键相关联 如果相关联，如果回退栈中有fragment 那么就会拦截返回键 如果没有的话就执行返回键的默认行为 1app:navGraph=&quot;@navigation/mobile_navigation&quot; 底部路由结构 1234567891011121314151617181920212223242526&lt;navigation xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/mobile_navigation&quot; app:startDestination=&quot;@+id/navigation_home&quot;&gt; &lt;--节点所配置的fragment --&gt; &lt;fragment android:id=&quot;@+id/navigation_home&quot; android:name=&quot;com.steve.ppjoke_android.ui.home.HomeFragment&quot; android:label=&quot;@string/title_home&quot; tools:layout=&quot;@layout/fragment_home&quot; /&gt; &lt;fragment android:id=&quot;@+id/navigation_dashboard&quot; android:name=&quot;com.steve.ppjoke_android.ui.dashboard.DashboardFragment&quot; android:label=&quot;@string/title_dashboard&quot; tools:layout=&quot;@layout/fragment_dashboard&quot; /&gt; &lt;fragment android:id=&quot;@+id/navigation_notifications&quot; android:name=&quot;com.steve.ppjoke_android.ui.notifications.NotificationsFragment&quot; android:label=&quot;@string/title_notifications&quot; tools:layout=&quot;@layout/fragment_notifications&quot; /&gt;&lt;/navigation&gt; 1app:startDestination=&quot;@+id/navigation_home&quot; 默认要显示的页面是哪一个 通过可视化界面配置fragment 123456789101112131415161718&lt;fragment android:id=&quot;@+id/navigation_home&quot; android:name=&quot;com.steve.ppjoke_android.ui.home.HomeFragment&quot; android:label=&quot;@string/title_home&quot; tools:layout=&quot;@layout/fragment_home&quot;&gt; &lt;!-- 当前fragment跳转到下一页的动作，所以必须指定目标页--&gt; &lt;action android:id=&quot;@+id/id_action&quot; app:destination=&quot;@id/navigation_dashboard&quot; /&gt; &lt;!--指的是创建当前fragment时需要传递的参数 --&gt; &lt;argument android:name=&quot;arg1&quot; app:argType=&quot;integer&quot; /&gt; &lt;!--通过url拉起页面，隐式意图 就是页面路由 --&gt; &lt;deepLink android:id=&quot;@+id/deepLink&quot; app:uri=&quot;www.imooc.com&quot; /&gt;&lt;/fragment&gt; 先看承载的Fragment的实现逻辑 NavHostFragment.java 123456789101112131415161718192021222324252627282930313233343536373839404142public void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); final Context context = requireContext(); //切换fragment的能力委托给NavHostController mNavController = new NavHostController(context); ... //添加了两个导航器 onCreateNavController(mNavController); Bundle navState = null; if (savedInstanceState != null) &#123; navState = savedInstanceState.getBundle(KEY_NAV_CONTROLLER_STATE); if (savedInstanceState.getBoolean(KEY_DEFAULT_NAV_HOST, false)) &#123; mDefaultNavHost = true; getParentFragmentManager().beginTransaction() .setPrimaryNavigationFragment(this) .commit(); &#125; mGraphId = savedInstanceState.getInt(KEY_GRAPH_ID); &#125; if (navState != null) &#123; // Navigation controller state overrides arguments mNavController.restoreState(navState); &#125; if (mGraphId != 0) &#123; // Set from onInflate() mNavController.setGraph(mGraphId); &#125; else &#123; // See if it was set by NavHostFragment.create() final Bundle args = getArguments(); final int graphId = args != null ? args.getInt(KEY_GRAPH_ID) : 0; final Bundle startDestinationArgs = args != null ? args.getBundle(KEY_START_DESTINATION_ARGS) : null; if (graphId != 0) &#123; mNavController.setGraph(graphId, startDestinationArgs); &#125; &#125;&#125; onCreateNavController 1234567protected void onCreateNavController(@NonNull NavController navController) &#123; navController.getNavigatorProvider().addNavigator( //第一个，给dialogframgent提供跳转，切换的能力 new DialogFragmentNavigator(requireContext(), getChildFragmentManager())); //第二个，是给fragment提供跳转 navController.getNavigatorProvider().addNavigator(createFragmentNavigator());&#125; 除此之外，还在NavController的构造函数里添加了两个默认的navigator 1234567891011121314public NavController(@NonNull Context context) &#123; mContext = context; while (context instanceof ContextWrapper) &#123; if (context instanceof Activity) &#123; mActivity = (Activity) context; break; &#125; context = ((ContextWrapper) context).getBaseContext(); &#125; //这个导航器的作用是配置的默认启动的页面，启动后会跳转，唯一被用到的地方 mNavigatorProvider.addNavigator(new NavGraphNavigator(mNavigatorProvider)); //为activity跳转提供支持 mNavigatorProvider.addNavigator(new ActivityNavigator(mContext));&#125; 为什么把navigator添加到provider里呢？ privoder本质是一个hashmap，存储导航器的实例 这4个导航器有什么相同点有什么不同点？ 都继承自Navigator 12345678910111213141516171819202122232425262728//泛型必须继承NavDestination 而NavDestination就是dialog activity fragment 之所以这么设计泛型，是需要activity的navigator只能创建activity的navigator 而fragment只能创建fragment的导航器public abstract class Navigator&lt;D extends NavDestination&gt; &#123; //1.每一个navigator的子类都必须标注一个Name的注解，只有这样，才会把它添加到provider里，我们之前说provider是一个hashmap 它的key就是我们标注的name的名字，value是navigator的实例本身 //2.navigator在创建destination的时候,它会解析navigator上的name，以此来得到导航器的名称 public @interface Name &#123; String value(); &#125; ... //创建Destination 看下面Destination的构造 public abstract D createDestination(); //跳转逻辑 public abstract NavDestination navigate(@NonNull D destination, @Nullable Bundle args,@Nullable NavOptions navOptions, @Nullable Extras navigatorExtras); //是否拦截系统的返回键，实现回退栈的操作 public abstract boolean popBackStack(); //空接口，实现用来做额外的事情，比如过渡元素，转场动画 public interface Extras &#123; &#125;&#125; 123456789//传入一个navigatorpublic NavDestination(@NonNull Navigator&lt;? extends NavDestination&gt; navigator) &#123; this(NavigatorProvider.getNameForNavigator(navigator.getClass()));&#125;//传入一个navigatorName 这个name就是通过标注在navigator上面的name的注解得到的public NavDestination(@NonNull String navigatorName) &#123; mNavigatorName = navigatorName;&#125; 那么为什么要传入navigatorName呢？ NavDestination就是我们跳转的一个个页面，我们通过传入的navigatorName在provider这个hashmap中得到destination实例，就是这么得到我们的跳转的实例的 我们接着看Navigator中的navigate方法 12//跳转逻辑public abstract NavDestination navigate(@NonNull D destination, @Nullable Bundle args,@Nullable NavOptions navOptions, @Nullable Extras navigatorExtras); 由于activity fragment dialog的具体跳转方法都不一样，所以，不会交由父类来实现，所以这里是抽象的，使用了模板方法 Navigator父类了解后，我们来了了解其子类的实现 ActivityNavigator 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119//provider中的key的名字就是activity@Navigator.Name(&quot;activity&quot;)public class ActivityNavigator extends Navigator&lt;ActivityNavigator.Destination&gt; &#123; public final Destination setIntent(@Nullable Intent intent) &#123; mIntent = intent; return this &#125; ... public final Destination setTargetPackage(@Nullable String packageName) &#123; if (mIntent == null) &#123; mIntent = new Intent(); &#125; mIntent.setPackage(packageName); return this; &#125; public Destination setData()&#123; ... &#125; public Destination setComponentName()&#123; ... &#125; //上面这些类都是为了构造或传入Intent对象 ... //核心方法navigate public NavDestination navigate(@NonNull Destination destination, @Nullable Bundle args, @Nullable NavOptions navOptions, @Nullable Navigator.Extras navigatorExtras) &#123; //1.获取跳转Intent if (destination.getIntent() == null) &#123; throw new IllegalStateException(&quot;Destination &quot; + destination.getId() + &quot; does not have an Intent set.&quot;); &#125; Intent intent = new Intent(destination.getIntent()); if (args != null) &#123; intent.putExtras(args); String dataPattern = destination.getDataPattern(); if (!TextUtils.isEmpty(dataPattern)) &#123; // Fill in the data pattern with the args to build a valid URI StringBuffer data = new StringBuffer(); Pattern fillInPattern = Pattern.compile(&quot;\\\\&#123;(.+?)\\\\&#125;&quot;); Matcher matcher = fillInPattern.matcher(dataPattern); while (matcher.find()) &#123; String argName = matcher.group(1); if (args.containsKey(argName)) &#123; matcher.appendReplacement(data, &quot;&quot;); //noinspection ConstantConditions data.append(Uri.encode(args.get(argName).toString())); &#125; else &#123; throw new IllegalArgumentException(&quot;Could not find &quot; + argName + &quot; in &quot; + args + &quot; to fill data pattern &quot; + dataPattern); &#125; &#125; matcher.appendTail(data); intent.setData(Uri.parse(data.toString())); &#125; &#125; // extra 获取额外的flag if (navigatorExtras instanceof Extras) &#123; Extras extras = (Extras) navigatorExtras; intent.addFlags(extras.getFlags()); &#125; //设置intent的跳转的flag if (!(mContext instanceof Activity)) &#123; // If we&#x27;re not launching from an Activity context we have to launch in a new task. intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); &#125; if (navOptions != null &amp;&amp; navOptions.shouldLaunchSingleTop()) &#123; intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP); &#125; //设置跳转的当前页面的hostid 用来做页面溯源 if (mHostActivity != null) &#123; final Intent hostIntent = mHostActivity.getIntent(); if (hostIntent != null) &#123; final int hostCurrentId = hostIntent.getIntExtra(EXTRA_NAV_CURRENT, 0); if (hostCurrentId != 0) &#123; intent.putExtra(EXTRA_NAV_SOURCE, hostCurrentId); &#125; &#125; &#125; final int destId = destination.getId(); intent.putExtra(EXTRA_NAV_CURRENT, destId); //设置跳转的动画 if (navOptions != null) &#123; // For use in applyPopAnimationsToPendingTransition() intent.putExtra(EXTRA_POP_ENTER_ANIM, navOptions.getPopEnterAnim()); intent.putExtra(EXTRA_POP_EXIT_ANIM, navOptions.getPopExitAnim()); &#125; //使用context.startActivity来进行真正的跳转 if (navigatorExtras instanceof Extras) &#123; Extras extras = (Extras) navigatorExtras; ActivityOptionsCompat activityOptions = extras.getActivityOptions(); if (activityOptions != null) &#123; ActivityCompat.startActivity(mContext, intent, activityOptions.toBundle()); &#125; else &#123; mContext.startActivity(intent); &#125; &#125; else &#123; mContext.startActivity(intent); &#125; if (navOptions != null &amp;&amp; mHostActivity != null) &#123; int enterAnim = navOptions.getEnterAnim(); int exitAnim = navOptions.getExitAnim(); if (enterAnim != -1 || exitAnim != -1) &#123; enterAnim = enterAnim != -1 ? enterAnim : 0; exitAnim = exitAnim != -1 ? exitAnim : 0; mHostActivity.overridePendingTransition(enterAnim, exitAnim); &#125; &#125; return null; &#125; &#125; 接下来DialogFragment 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Navigator.Name(&quot;dialog&quot;)public final class DialogFragmentNavigator extends Navigator&lt;DialogFragmentNavigator.Destination&gt; &#123; //同样的创建，传入navigator通过navigator来取出它的名字 public Destination createDestination() &#123; return new Destination(this); &#125; //设置className public final Destination setClassName(@NonNull String className) &#123; mClassName = className; return this; &#125; //核心跳转navigate public NavDestination navigate(@NonNull final Destination destination, @Nullable Bundle args, @Nullable NavOptions navOptions, @Nullable Navigator.Extras navigatorExtras) &#123; if (mFragmentManager.isStateSaved()) &#123; Log.i(TAG, &quot;Ignoring navigate() call: FragmentManager has already&quot; + &quot; saved its state&quot;); return null; &#125; String className = destination.getClassName(); //1.获取classname 全类名 if (className.charAt(0) == &#x27;.&#x27;) &#123; className = mContext.getPackageName() + className; &#125; //2.通过classname 反射构造一个fragment的对象 instantiate这个方法 final Fragment frag = mFragmentManager.getFragmentFactory().instantiate( mContext.getClassLoader(), className); //3.如果不是dialogfragment的子类，就抛异常 if (!DialogFragment.class.isAssignableFrom(frag.getClass())) &#123; throw new IllegalArgumentException(&quot;Dialog destination &quot; + destination.getClassName() + &quot; is not an instance of DialogFragment&quot;); &#125; //4.强转成DialogFragment final DialogFragment dialogFragment = (DialogFragment) frag; dialogFragment.setArguments(args); dialogFragment.getLifecycle().addObserver(mObserver); //5.通过show方法就把dialogfragment展示出来 dialogFragment.show(mFragmentManager, DIALOG_TAG + mDialogCount++); return destination; &#125;&#125; 再来看FragmentNavigator 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697@Navigator.Name(&quot;fragment&quot;)public class FragmentNavigator extends Navigator&lt;FragmentNavigator.Destination&gt; &#123; public Destination createDestination() &#123; return new Destination(this); &#125; @NavDestination.ClassType(Fragment.class) public static class Destination extends NavDestination &#123; //同上，设置全类名 public final Destination setClassName(@NonNull String className) &#123; mClassName = className; return this; &#125; &#125; public NavDestination navigate(@NonNull Destination destination, @Nullable Bundle args, @Nullable NavOptions navOptions, @Nullable Navigator.Extras navigatorExtras) &#123; if (mFragmentManager.isStateSaved()) &#123; Log.i(TAG, &quot;Ignoring navigate() call: FragmentManager has already&quot; + &quot; saved its state&quot;); return null; &#125; //1.通过destination获取classname 全类名 String className = destination.getClassName(); if (className.charAt(0) == &#x27;.&#x27;) &#123; className = mContext.getPackageName() + className; &#125; //2.实例化一个fragment对象，并设置arguments final Fragment frag = instantiateFragment(mContext, mFragmentManager, className, args); frag.setArguments(args); //3.得到Transaction对象 final FragmentTransaction ft = mFragmentManager.beginTransaction(); //跳转动画 int enterAnim = navOptions != null ? navOptions.getEnterAnim() : -1; int exitAnim = navOptions != null ? navOptions.getExitAnim() : -1; int popEnterAnim = navOptions != null ? navOptions.getPopEnterAnim() : -1; int popExitAnim = navOptions != null ? navOptions.getPopExitAnim() : -1; if (enterAnim != -1 || exitAnim != -1 || popEnterAnim != -1 || popExitAnim != -1) &#123; enterAnim = enterAnim != -1 ? enterAnim : 0; exitAnim = exitAnim != -1 ? exitAnim : 0; popEnterAnim = popEnterAnim != -1 ? popEnterAnim : 0; popExitAnim = popExitAnim != -1 ? popExitAnim : 0; ft.setCustomAnimations(enterAnim, exitAnim, popEnterAnim, popExitAnim); &#125; //4.通过replace跳转，这种方式不好，会告诉页面生命周期重启，需要自己再构建一个使用hide和show的FragmentNavigator ft.replace(mContainerId, frag); ft.setPrimaryNavigationFragment(frag); final @IdRes int destId = destination.getId(); final boolean initialNavigation = mBackStack.isEmpty(); // TODO Build first class singleTop behavior for fragments final boolean isSingleTopReplacement = navOptions != null &amp;&amp; !initialNavigation &amp;&amp; navOptions.shouldLaunchSingleTop() &amp;&amp; mBackStack.peekLast() == destId; boolean isAdded; if (initialNavigation) &#123; isAdded = true; &#125; else if (isSingleTopReplacement) &#123; // Single Top means we only want one instance on the back stack if (mBackStack.size() &gt; 1) &#123; // If the Fragment to be replaced is on the FragmentManager&#x27;s // back stack, a simple replace() isn&#x27;t enough so we // remove it from the back stack and put our replacement // on the back stack in its place mFragmentManager.popBackStack( generateBackStackName(mBackStack.size(), mBackStack.peekLast()), FragmentManager.POP_BACK_STACK_INCLUSIVE); ft.addToBackStack(generateBackStackName(mBackStack.size(), destId)); &#125; isAdded = false; &#125; else &#123; ft.addToBackStack(generateBackStackName(mBackStack.size() + 1, destId)); isAdded = true; &#125; if (navigatorExtras instanceof Extras) &#123; Extras extras = (Extras) navigatorExtras; for (Map.Entry&lt;View, String&gt; sharedElement : extras.getSharedElements().entrySet()) &#123; ft.addSharedElement(sharedElement.getKey(), sharedElement.getValue()); &#125; &#125; ft.setReorderingAllowed(true); ft.commit(); // The commit succeeded, update our view of the world if (isAdded) &#123; mBackStack.add(destId); return destination; &#125; else &#123; return null; &#125; &#125;&#125; 最后来看NavGraphNavigator 1234567891011@Navigator.Name(&quot;navigation&quot;)public class NavGraphNavigator extends Navigator&lt;NavGraph&gt; &#123; //这里没有new Destination对象，而是new了一个NavGraph,传入Navigator public NavGraph createDestination() &#123; return new NavGraph(this); &#125; &#125; NavGraph.java 是NavDestination的子类，是特殊的子类 123456789public class NavGraph extends NavDestination implements Iterable&lt;NavDestination&gt; &#123; //node数组，这里就是存储了一个个跳转节点的的实例，也就是我们在 mobile_navigation.xml中声明的一个个fragment activity实例，都会被存储到mNodes中 final SparseArrayCompat&lt;NavDestination&gt; mNodes = new SparseArrayCompat&lt;&gt;(); //这个就是对应mobile_navigation.xml中指定的app:startDestination=&quot;@+id/navigation_dashboard&quot; 而一旦xml被解析，这里就获取到我们指定的页面id private int mStartDestId;&#125; 那么又是在哪里解析的，什么时候解析的呢？ 还记得我们上面的宿主fragment NavHostFragment 我们在oncreate中创建了NavHostController 我们看下Controller中的逻辑 123456789101112public class NavController &#123; public void setGraph(@NavigationRes int graphResId) &#123; setGraph(graphResId, null); &#125; public void setGraph(@NavigationRes int graphResId, @Nullable Bundle startDestinationArgs) &#123; //调用navinflater的inflate方法来解析xml文件 setGraph(getNavInflater().inflate(graphResId), startDestinationArgs); &#125;&#125; 这个inflate方法 12345678910111213141516171819202122232425262728293031323334public NavGraph inflate(@NavigationRes int graphResId) &#123; Resources res = mContext.getResources(); //1.获取xml parser来解析xml文件 XmlResourceParser parser = res.getXml(graphResId); //2.获取属性 final AttributeSet attrs = Xml.asAttributeSet(parser); try &#123; int type; while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; // Empty loop &#125; if (type != XmlPullParser.START_TAG) &#123; throw new XmlPullParserException(&quot;No start tag found&quot;); &#125; String rootElement = parser.getName(); //3.实际上是另一个inflate方法来解析构造出的具体的NavDestion对象 这里主要通过parser获取标签名，再通过name 在provider中拿到navigator 再通过navigator来创建各自的navigation NavDestination destination = inflate(res, parser, attrs, graphResId); if (!(destination instanceof NavGraph)) &#123; throw new IllegalArgumentException(&quot;Root element &lt;&quot; + rootElement + &quot;&gt;&quot; + &quot; did not inflate into a NavGraph&quot;); &#125; return (NavGraph) destination; &#125; catch (Exception e) &#123; //也就是说我们在编写mobile_navigation.xml中的根节点必须是navigation 否则解析后会抛出异常 throw new RuntimeException(&quot;Exception inflating &quot; + res.getResourceName(graphResId) + &quot; line &quot; + parser.getLineNumber(), e); &#125; finally &#123; parser.close(); &#125;&#125; 通过navigator来创建具体的跳转navigation实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051private NavDestination inflate(@NonNull Resources res, @NonNull XmlResourceParser parser, @NonNull AttributeSet attrs, int graphResId) throws XmlPullParserException, IOException &#123; //1.通过provider获取具体的navigator对象 parser.getName 得到的就是标签的名fragment dialog activity Navigator&lt;?&gt; navigator = mNavigatorProvider.getNavigator(parser.getName()); //2.得到navigator后，就通过调用 createDestination方法来得到创建NavDestination 最后也是返回的是这个dest final NavDestination dest = navigator.createDestination(); dest.onInflate(mContext, attrs); final int innerDepth = parser.getDepth() + 1; int type; int depth; while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; ((depth = parser.getDepth()) &gt;= innerDepth || type != XmlPullParser.END_TAG)) &#123; if (type != XmlPullParser.START_TAG) &#123; continue; &#125; if (depth &gt; innerDepth) &#123; continue; &#125; final String name = parser.getName(); //3.中间解析各个子标签 //如查是argument标签，就把argument数据inflate到destination中 if (TAG_ARGUMENT.equals(name)) &#123; inflateArgumentForDestination(res, dest, attrs, graphResId); &#125; else if (TAG_DEEP_LINK.equals(name)) &#123; //如果是deeplink 就把信息inflate到destination inflateDeepLink(res, dest, attrs); &#125; else if (TAG_ACTION.equals(name)) &#123; //如果是action就把信息infalte到destinatioin中的actioin中 inflateAction(res, dest, attrs, parser, graphResId); &#125; else if (TAG_INCLUDE.equals(name) &amp;&amp; dest instanceof NavGraph) &#123; final TypedArray a = res.obtainAttributes( attrs, androidx.navigation.R.styleable.NavInclude); final int id = a.getResourceId( androidx.navigation.R.styleable.NavInclude_graph, 0); ((NavGraph) dest).addDestination(inflate(id)); a.recycle(); //如查是NavGraph &#125; else if (dest instanceof NavGraph) &#123; //就递归去调用 inflate解析子标签，然后把子标签生成的destinatioin加入到NavGraph的mNodes中去 ((NavGraph) dest).addDestination(inflate(res, parser, attrs, graphResId)); &#125; &#125; return dest;&#125; 解析完Navgraph后，把graph和controller相关联 12345678910public void setGraph(@NonNull NavGraph graph, @Nullable Bundle startDestinationArgs) &#123; if (mGraph != null) &#123; // Pop everything from the old graph off the back stack popBackStackInternal(mGraph.getId(), true); &#125; //把graph 赋值给controller中的mGraph变量 mGraph = graph; //这里就会把默认显示的页面给打开 onGraphCreated(startDestinationArgs);&#125; 回头看看NavGraphNavigator.java 的navigate方法 1234567891011121314151617181920212223public NavDestination navigate(@NonNull NavGraph destination, @Nullable Bundle args, @Nullable NavOptions navOptions, @Nullable Extras navigatorExtras) &#123; //拿到默认展示页面的id int startId = destination.getStartDestination(); if (startId == 0) &#123; throw new IllegalStateException(&quot;no start destination defined via&quot; + &quot; app:startDestination for &quot; + destination.getDisplayName()); &#125; //有这个id后，就能拿到默认展示页面的destination对象 NavDestination startDestination = destination.findNode(startId, false); if (startDestination == null) &#123; final String dest = destination.getStartDestDisplayName(); throw new IllegalArgumentException(&quot;navigation destination &quot; + dest + &quot; is not a direct child of this NavGraph&quot;); &#125; //然后通过name在provider中拿到navigator 这个navigator可能是fragmentnavigator activitynavigator dialognavigator Navigator&lt;NavDestination&gt; navigator = mNavigatorProvider.getNavigator( startDestination.getNavigatorName()); //执行具体的navigator的naigate方法把默认页面启动起来 return navigator.navigate(startDestination, startDestination.addInDefaultArgs(args), navOptions, navigatorExtras);&#125; Navigation各类之间的关系","categories":[{"name":"Jetpack系列","slug":"Jetpack系列","permalink":"http://example.com/categories/Jetpack%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"},{"name":"Jetpack","slug":"Jetpack","permalink":"http://example.com/tags/Jetpack/"}]},{"title":"Gradle基础","slug":"Gradle基础","date":"2022-04-15T22:35:47.000Z","updated":"2022-11-17T07:56:14.000Z","comments":true,"path":"2022/04/16/Gradle基础/","link":"","permalink":"http://example.com/2022/04/16/Gradle%E5%9F%BA%E7%A1%80/","excerpt":"讲解Gradle基础知识，语法及生命周期","text":"讲解Gradle基础知识，语法及生命周期 Gradle 基础使用 .&#x2F;gradlew clean -q 来过滤只显示我们的自己的输出日志 一 语法1.1 基础语法123456789101112131415161718192021222324252627int a = 10def b = 10String str = &quot;Hello,&quot; + &quot;World&quot;String str2 = str.toUpperCase()//列表def array = [1,2,3,4]array.add(5)array.each&#123;//闭包特性，只有一个参数默认为it 可以省略 it -&gt; 不写 println(&quot;each item is $it&quot;)&#125;//映射表def map = [&quot;name&quot;:&quot;mooc&quot;,&quot;age&quot;:&quot;100&quot;]println(&quot;age is $&#123;map[&quot;age&quot;]&#125;&quot;)//循环for(int i = 0;i&lt;10;i++)&#123; println(&quot;i is $i&quot;)&#125;//函数def hello(String name)&#123; println(&quot;Hello, $name&quot;)&#125; 1.2 DSL Domain Specific Language 领域专用语言 只能用于构建，不能干别的，所以说是领域专用语言 这个是android build.gradle 的DSL 12345678910111213141516171819202122232425262728android &#123; compileSdkVersion 30 buildToolsVersion &quot;30.0.3&quot; defaultConfig &#123; applicationId &quot;com.steve.gradle_study&quot; minSdkVersion 21 targetSdkVersion 30 versionCode 1 versionName &quot;1.0&quot; testInstrumentationRunner &quot;androidx.test.runner.AndroidJUnitRunner&quot; &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile(&#x27;proguard-android-optimize.txt&#x27;), &#x27;proguard-rules.pro&#x27; &#125; &#125; compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 &#125; kotlinOptions &#123; jvmTarget = &#x27;1.8&#x27; &#125;&#125; 1.3 闭包DSL的实现是基于groovy中的闭包实现的 开放匿名的代码块，可以接受参数，具有返回值，也可以被分配给变量 定义规则:{ [params -&gt; ] statements } 123456789101112131415161718def c = &#123; println(&quot;hello closure&quot;)&#125;c()def c2 = &#123; it -&gt; println (&quot;it is $it&quot;)&#125;c2(&quot;yt&quot;)def c3 = &#123; println (&quot;it is $it&quot;)&#125;c3(&quot;yt&quot;)def c4 = &#123; name,age -&gt; println (&quot;name is $name&quot;) println (&quot;age is $age&quot;)&#125;c4(&quot;wwww&quot;,33) 1.4 实现自己的DSL123456&#123; compileSdkVersion 25 defaultConfig&#123; versionName &quot;1.0&quot; &#125;&#125; 用户配置成这样，我们怎么能取到对应的配置的值，使用对象关联起来 里面的defaultconfig 闭包对应的对象 123456class DefalutConfig&#123; private String versionName def versionName(String versionName)&#123; this.versionName = versionName &#125;&#125; 外面的android 闭包对应的对象 1234567891011121314151617181920class Android&#123; private int compileSdkVersion private DefalutConfig defalutConfig Android()&#123; this.defalutConfig = new DefalutConfig() &#125; def compileSdkVersion(int compileSdkVersion)&#123; this.compileSdkVersion =compileSdkVersion &#125; //传入一个闭包，接收到闭包后跟我们的DefaultConfig成员变量关联起来 def defaultConfig(Closure closure)&#123; //关联之后，对象就获到到闭包中对应同名的值了 closure.setDelegate(defalutConfig) closure.call() &#125;&#125; 使用 123456789101112def myAndroid = &#123; compileSdkVersion 25 defaultConfig&#123; versionName &quot;1.0&quot; &#125;&#125;Android a = new Android()//将闭包与具体对象关联起来，这样在闭包中设置的值就到了对象a中了，我们可以打印a 获取a中的值myAndroid.delegate = amyAndroid.call() 运行 1./graldew clean -q 二 Gradle构建脚本基础几个关键的文件 settings.gradle—定义全局参与构建的模块 build.gradle—有两类build.gradle文件，一个是全局的定义共用参数，各个单独的定义自己的配置 gradle.properties—定义开关型参数的文件 三 Gradle构建的生命周期 初始化阶段—收集所有要参与构建的子工程，创建一个项目层次结构，并且为每一个项目创建一个project实例，和这个阶段关系最大的就是我们的settings.gradle文件 配置阶段—执行各个子工程自己的build.gradle，对project进行配置，并且根据配置形成一个任务依赖链，以便在下一个阶段执行阶段，方便执行任务 执行阶段—执行上一阶段的tasks 我们在settings.gradle中添加生命周期的监听函数 1234567891011121314151617181920//添加构建的生命周期gradle.addBuildListener(new BuildAdapter()&#123; @Override void settingsEvaluated(Settings settings) &#123; super.settingsEvaluated(settings) println (&quot;[life-cycle] 初始化阶段完成&quot;) &#125; @Override void projectsEvaluated(Gradle gradle) &#123; super.projectsEvaluated(gradle) println (&quot;[life-cycle] 配置阶段完成&quot;) &#125; @Override void buildFinished(BuildResult result) &#123; super.buildFinished(result) println (&quot;[life-cycle] 构建结束&quot;) &#125;&#125;) 打印结果 几个主要角色 初始化阶段-root project 配置阶段-project 执行阶段-task","categories":[],"tags":[]},{"title":"Jetpack系列—LiveData原理解析","slug":"Jetpack系列—LiveData","date":"2022-03-20T10:43:51.000Z","updated":"2022-11-17T07:56:14.000Z","comments":true,"path":"2022/03/20/Jetpack系列—LiveData/","link":"","permalink":"http://example.com/2022/03/20/Jetpack%E7%B3%BB%E5%88%97%E2%80%94LiveData/","excerpt":"","text":"什么是LiveData LiveData几种衍生类 LiveData核心方法 LiveData实现原理 1.什么是LiveData LiveData组件是Jetpack新推出的基于观察者的消息订阅&#x2F;分发组件，具有宿主(Activity&#x2F;Fragment)生命周期感知能力，这种感知能力可确保LiveData仅分发消息给处于活跃状态的观察者，即只有处于活跃状态的观察者才能收到消息 LiveData的消息分发机制，是以往的Handler，EventBus，RxJavaBus无法比拟的，它们不会顾及当前页面是否可见，一股脑的有消息就转发。导致即便应用在后台，页面不可见，还在做一些无用的绘制，计算(细心的同学可以发现微信消息列表是在可见状态时才会更新列表最新信息的) 活跃状态：Observer所在宿主处于started,resumed状态 12345678910111213141516171819202122class MainActivity extends AppcompactActivity&#123; public void onCreate(Bundle bundle)&#123; @Ovderride public void handleMessage(@NonNull Message msg)&#123; //无论页面可见不可见，都会去执行页面刷新,IO。更有甚者弹出对话框 &#125; &#125; //1.无论当前页面是否可见，这条消息都会被分发。——消耗资源 //2.无论前宿主是否还存活，这条消息都会被分发。——内存泄漏 handler.sendMessage(msg); liveData.observer(this,new Observer&lt;User&gt;)&#123; void onChanged(User user)&#123; &#125; &#125; //1.减少资源占用 —— 页面不可见时不会派发消息 //2.确保页面始终保持最新状态——页面可见时，会立刻派发新新的一条消息给所有观察者——保证页面最新状态 //3.不再需要手动处理生命周期——避免NPE //4.livedata默认是不能跨页面使用的，但是我们有办法，可以打造一款不用反注册，不会内存泄漏的消息总线——取代eventbus liveData.postValue(data);&#125; 2.LiveData的几种用法2.1 MutableLiveData我们在使用LiveData在做消息分发的时候，需要使用这个子类。之所以这么设计，是考虑到单一开闭原则，只有拿到MutableLiveData对象才可以发送消息，LiveData对象只能接收消息，避免拿到LiveData对象时既能发消息也能收到消息的混乱使用。 1234567891011public class MutableLiveData&lt;T&gt; extends LiveData&lt;T&gt;&#123; @Override public void postValue(T value)&#123; super.postValue(value); &#125; @Override public void setValue(T value)&#123; super.setValue(value); &#125;&#125; 2.2 MediatorLiveData 可以统一观察多个LiveData的发射的数据进行统一的处理 同时也可以做为一个LiveData，被其他Observer观察。 1234567891011121314151617//创建两个长的差不多的LiveData对象LiveData&lt;Integer&gt; liveData1 = new MutableLiveData();LiveData&lt;Integer&gt; liveData2 = new MutableLiveData();//再创建一个聚合类MediatorLiveDataMediatorLiveData&lt;Integer&gt; liveDataMerger = new MediatorLiveData();//分别把上面创建的LiveData添加进来liveDataMerger.addSource(liveData1,observer);liveDataMerger.addSource(liveData2,observer);Observer observer = new Observer&lt;Integer&gt;&#123; @Override public void onChanged(@Nullable Integer s)&#123; titleTextView.setText(s); &#125;&#125;//一旦liveData1或者liveData2发送了新的数据，observer便能观察到，以便统一处理更新UI 2.3 Transformations.map 操作符可以对liveData进行变化，并且返回一个新的livedata对象 1234567891011MutableLiveData&lt;Integer&gt; data = new MutableLiveData&lt;&gt;();//数据转换LiveData&lt;String&gt; transformData = Transformations.map(data,input -&gt; String.valueOf(input));//使用转换后生成的transformData去观察数据transformData.observe(this,output -&gt; &#123; &#125;);//使用原始的livedata发送数据data.setValue(10); 3.LiveData核心方法 方法名 作用 observe(LifecycleOwner owner,Observer observer) 注册和宿主生命周期关联的观察者 observeForever(Observer observer) 注册观察者，不会反注册，需要自行维护 setValue(T data) 发送数据，没有活跃的观察者时不会分发。只能在主线程。 postValue(T data) 和setValue一样。不受线程环境限制。 onActive 当且仅当有一个活跃的观察者时会触发 inActive 不存在活跃的观察者时会触发 4.LiveData实现原理 LiveData使用的有很多好处 确保UI符合数据状态 不需要手动处理生命周期 始终保持最新的数据 事件总线LiveDataBus 确保UI符合数据状态 因为livedata实现了观察者模式 它里面的数据发生变化的时候，会向注册的Observer观察者发送通知，这时可以在观察者的onChanged里面更改UI 以保持数据的最新化 不需要手动处理生命周期 在注册observe的时候，会将当前宿主的生命周期进行绑定，当宿主被销毁时，就自动的进行销毁 始终保持最新的数据 可以这么理解，当宿主的生命周期变为非活跃状态的时候，那么它将在再次变为活跃状态的时候，接收到最新的数据，比如activity 从前台返回到后台，再从后台返回前台。再比如actvity和fragment由于配置的更改，而重新创建，也是能够接收到最新可用的数据，来保持最新的数据和UI 事件总线LiveDataBus 使用livedata来实现消息总线，替代使用eventbus 1234567891011//有参数构造 mVersion = 0 public LiveData(T value) &#123; mData = value; mVersion = START_VERSION + 1;&#125;//无参数构造，mVersion = -1 mData = NOT_SETpublic LiveData() &#123; mData = NOT_SET; mVersion = START_VERSION;&#125; 那么为什么livedata需要一个version呢？ 因为livedata通过version来控制数据分发，通过mVersion来进行数据的比对，本次是否需要进行数据的分发，因为不能livedata发送一次数据，而observable能接收到2，3次数据 123456789101112131415161718192021//把宿主和observer进行绑定public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? super T&gt; observer) &#123; assertMainThread(&quot;observe&quot;); if (owner.getLifecycle().getCurrentState() == DESTROYED) &#123; // ignore return; &#125; //把lifecycle 和 observer包装成了一个LifecycleBoundObserver，也就是一个有边界的的observer LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer); //包装完后，把wrapper放入一个hashmap里 ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper); if (existing != null &amp;&amp; !existing.isAttachedTo(owner)) &#123; throw new IllegalArgumentException(&quot;Cannot add the same observer&quot; + &quot; with different lifecycles&quot;); &#125; if (existing != null) &#123; return; &#125; //注意这里传入的是包装后的wrapper lifecycleboundobserver owner.getLifecycle().addObserver(wrapper);&#125; 通过observe可以向livedata注册一个观察者对象 owner.getLifecycle().addObserver(wrapper) 进入 会进行到实现 LifecycleRegistry.addObserver(observer)方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public void addObserver(@NonNull LifecycleObserver observer) &#123; enforceMainThreadIfNeeded(&quot;addObserver&quot;); //判断当前宿主的生命周期状态 State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED; //判断完后，会把当前宿主的生命周期和观察者进行包装 ObserverWithState statefulObserver = new ObserverWithState(observer, initialState); //包装完成后也会存储到hashmap里 ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver); //为什么要再进行这么包装呢？主要是为了分发当前宿主的生命周期状态给每个observer if (previous != null) &#123; return; &#125; LifecycleOwner lifecycleOwner = mLifecycleOwner.get(); if (lifecycleOwner == null) &#123; // it is null we should be destroyed. Fallback quickly return; &#125; boolean isReentrance = mAddingObserverCounter != 0 || mHandlingEvent; State targetState = calculateTargetState(observer); mAddingObserverCounter++; while ((statefulObserver.mState.compareTo(targetState) &lt; 0 &amp;&amp; mObserverMap.contains(observer))) &#123; pushParentState(statefulObserver.mState); final Event event = Event.upFrom(statefulObserver.mState); if (event == null) &#123; throw new IllegalStateException(&quot;no event up from &quot; + statefulObserver.mState); &#125; //分发宿主的生命周期状态 给observer statefulObserver.dispatchEvent(lifecycleOwner, event); popParentState(); // mState / subling may have been changed recalculate targetState = calculateTargetState(observer); &#125; if (!isReentrance) &#123; // we do sync only on the top level. sync(); &#125; mAddingObserverCounter--;&#125;void dispatchEvent(LifecycleOwner owner, Event event) &#123; State newState = event.getTargetState(); mState = min(mState, newState); //这个lifecycleobserver就是我们传递进来的lifecyclebounderobserver mLifecycleObserver.onStateChanged(owner, event); mState = newState;&#125; 这个接口是 LifecycleEventObserver的 1234public interface LifecycleEventObserver extends LifecycleObserver &#123; //这个回调的是宿主生命周期的变化 有两个参数，一个是宿主 一个是Event void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event);&#125; 12345678910111213141516171819202122232425262728293031public enum Event &#123; /** * Constant for onCreate event of the &#123;@link LifecycleOwner&#125;. */ ON_CREATE, /** * Constant for onStart event of the &#123;@link LifecycleOwner&#125;. */ ON_START, /** * Constant for onResume event of the &#123;@link LifecycleOwner&#125;. */ ON_RESUME, /** * Constant for onPause event of the &#123;@link LifecycleOwner&#125;. */ ON_PAUSE, /** * Constant for onStop event of the &#123;@link LifecycleOwner&#125;. */ ON_STOP, /** * Constant for onDestroy event of the &#123;@link LifecycleOwner&#125;. */ ON_DESTROY, /** * An &#123;@link Event Event&#125; constant that can be used to match all events. */ ON_ANY;&#125; 宿主的每个生命周期的改变都会回调到onStateChanged 我们看下它的实现 LifecycleBoundObserver 实现了LifecycleEventObserver LifecycleBoundObserver.onStateChanged 1234567891011121314151617public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) &#123; Lifecycle.State currentState = mOwner.getLifecycle().getCurrentState(); //如果当前状态是destroyed if (currentState == DESTROYED) &#123; //自行移除，自行反注册这个observer removeObserver(mObserver); return; &#125; Lifecycle.State prevState = null; while (prevState != currentState) &#123; prevState = currentState; //否则就执行活跃状态的变更 看shouldBeActive方法 activeStateChanged(shouldBeActive()); currentState = mOwner.getLifecycle().getCurrentState(); &#125;&#125; 1234//这里判断了只有宿主的生命周期大于start的时候 才代表宿主是活跃的boolean shouldBeActive() &#123; return mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);&#125; 继续看activeStateChanged 12345678910111213void activeStateChanged(boolean newActive) &#123; if (newActive == mActive) &#123; return; &#125; mActive = newActive; changeActiveCounter(mActive ? 1 : -1); if (mActive) &#123; dispatchingValue(this); &#125;&#125; 1234567891011121314151617181920212223void changeActiveCounter(int change) &#123; int previousActiveCount = mActiveCount; mActiveCount += change; if (mChangingActiveState) &#123; return; &#125; mChangingActiveState = true; try &#123; while (previousActiveCount != mActiveCount) &#123; boolean needToCallActive = previousActiveCount == 0 &amp;&amp; mActiveCount &gt; 0; boolean needToCallInactive = previousActiveCount &gt; 0 &amp;&amp; mActiveCount == 0; previousActiveCount = mActiveCount; if (needToCallActive) &#123;//首次注册会执行onActive onActive(); &#125; else if (needToCallInactive) &#123;//当最后一个观察者被移除时，会执行onInactive onInactive(); &#125; &#125; &#125; finally &#123; mChangingActiveState = false; &#125;&#125; 123protected void onInactive() &#123;//可以初始化&#125; 123protected void onActive() &#123;//可以反注册，释放资源，清理 paging就利用了这里&#125; 接着看 传入true 执行dispatchingValue 把当前的observer传入进去 123if (mActive) &#123; dispatchingValue(this);&#125; 123456789101112131415161718192021222324void dispatchingValue(@Nullable ObserverWrapper initiator) &#123; if (mDispatchingValue) &#123; mDispatchInvalidated = true; return; &#125; mDispatchingValue = true; do &#123; mDispatchInvalidated = false; //不为空，走到considerNotify 里，见considerNotify if (initiator != null) &#123; considerNotify(initiator); initiator = null; &#125; else &#123; for (Iterator&lt;Map.Entry&lt;Observer&lt;? super T&gt;, ObserverWrapper&gt;&gt; iterator = mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123; considerNotify(iterator.next().getValue()); if (mDispatchInvalidated) &#123; break; &#125; &#125; &#125; &#125; while (mDispatchInvalidated); mDispatchingValue = false;&#125; 1234567891011121314151617181920private void considerNotify(ObserverWrapper observer) &#123; //如果 observer是不活跃的，也是不进行分发的 if (!observer.mActive) &#123; return; &#125; //再判断宿主的生命周期是否大于start状态 if (!observer.shouldBeActive()) &#123; //如果不活跃，就把actvityStateChanged状态转为false observer.activeStateChanged(false); return; &#125; //mVersion是在livedata的构造里创建的 只有当observer.mLastVersion 小于mVersion的时候才会进行分发 if (observer.mLastVersion &gt;= mVersion) &#123; return; &#125; //这里是分发后，要把mLastVersion 和mVersion进行同步赋值 observer.mLastVersion = mVersion; //这里才是真正的分发回调onChaned 把livedata里的泛型数据传入进去 observer.mObserver.onChanged((T) mData);&#125; livedata中还有一个方法 12345678910111213public void observeForever(@NonNull Observer&lt;? super T&gt; observer) &#123; assertMainThread(&quot;observeForever&quot;); AlwaysActiveObserver wrapper = new AlwaysActiveObserver(observer); ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper); if (existing instanceof LiveData.LifecycleBoundObserver) &#123; throw new IllegalArgumentException(&quot;Cannot add the same observer&quot; + &quot; with different lifecycles&quot;); &#125; if (existing != null) &#123; return; &#125; wrapper.activeStateChanged(true);&#125; 如果注册了这个方法，在宿主被销毁时，livedata是不会帮我们反注册的，需要我们自行去调用removeObserver 接着来看postValue 1234567891011protected void postValue(T value) &#123; boolean postTask; synchronized (mDataLock) &#123; postTask = mPendingData == NOT_SET; mPendingData = value; &#125; if (!postTask) &#123; return; &#125; ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);&#125; 如果当前在子线程中，则必须调用postvalue 不能调用 setvalue 1234567protected void setValue(T value) &#123; assertMainThread(&quot;setValue&quot;); //新的数据需要进行分发，这里mLastVersion就小于mVersion了，可以进行分发，如果调用了onChanged的，消费了这个事件和数据，mLastVersion就同步了 mVersion++; mData = value; dispatchingValue(null);&#125; dispatchingValue 传了null值 这个要区别于上面activeStateChanged中的dispatchingValue 1234567891011121314151617181920212223242526void dispatchingValue(@Nullable ObserverWrapper initiator) &#123; if (mDispatchingValue) &#123; mDispatchInvalidated = true; return; &#125; mDispatchingValue = true; do &#123; mDispatchInvalidated = false; if (initiator != null) &#123; considerNotify(initiator); initiator = null; &#125; else &#123; //这里传了null 所以，走下面的这个逻辑 遍历这个observers //这个observers就是我们之前addObserver添加进去的 for (Iterator&lt;Map.Entry&lt;Observer&lt;? super T&gt;, ObserverWrapper&gt;&gt; iterator = mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123; //遍历之后，就会调用considerNoity进行数据的分发，调用onChanged considerNotify(iterator.next().getValue()); if (mDispatchInvalidated) &#123; break; &#125; &#125; &#125; &#125; while (mDispatchInvalidated); mDispatchingValue = false;&#125; livedata 这个方法，判断是否有活跃的观察者 123public boolean hasActiveObservers() &#123; return mActiveCount &gt; 0;&#125; 看下livedata的子类，实现 123456789101112131415161718192021public class MutableLiveData&lt;T&gt; extends LiveData&lt;T&gt; &#123; public MutableLiveData(T value) &#123; super(value); &#125; public MutableLiveData() &#123; super(); &#125; @Override public void postValue(T value) &#123; super.postValue(value); &#125; @Override public void setValue(T value) &#123; super.setValue(value); &#125;&#125; 这个类好像什么都没做，只是复写了postvalue和setvalue并把方法改成了public而已，那么原因是什么？ 因为livedata作为数据发送组件，必定是一方发送一方接收，不能既发送又接收，所以MutableLiveData 是为了规避这个问题才存在的，只有拿到的对象是MutableLiveData它才能进行一个数据的发送","categories":[{"name":"Jetpack系列","slug":"Jetpack系列","permalink":"http://example.com/categories/Jetpack%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"},{"name":"Jetpack","slug":"Jetpack","permalink":"http://example.com/tags/Jetpack/"}]},{"title":"提升海量用户极致体验的Hybrid架构设计[转]","slug":"[转]提升海量用户极致体验的 Hybrid 架构设计","date":"2022-03-17T20:23:47.000Z","updated":"2022-10-09T00:04:29.000Z","comments":true,"path":"2022/03/18/[转]提升海量用户极致体验的 Hybrid 架构设计/","link":"","permalink":"http://example.com/2022/03/18/[%E8%BD%AC]%E6%8F%90%E5%8D%87%E6%B5%B7%E9%87%8F%E7%94%A8%E6%88%B7%E6%9E%81%E8%87%B4%E4%BD%93%E9%AA%8C%E7%9A%84%20Hybrid%20%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"原文链接 引言上一篇原理篇，我们已经详细地阐述了 Hybrid App 的基础原理，了解了 Native 端 和 H5 端 是如何通信的，还有 bridge 的设计和接入。而本篇文章将开始把这些原因进一步实践，用代码真正地去实现一套完整且稳定的 Hybrid 方案。如果对原理还有疑问的小伙伴，请移步提升海量用户极致体验的 Hybrid 架构设计（原理篇），只有在理解了理论的基础上，进一步与实践相结合，才能真正地去深入一项技术。 摩天大楼说了那么一大堆理论知识，可能有小伙伴会说：“ 你是不是吹流弊啊。”那就先来简单介绍下我们已经使用这套方案落地的项目之一。 这是一个完全内置在 App 里的 Hybrid 模块，由 Native 与 H5 深度协作完成，总共有 4 个页面，其中首页和制作页由 H5 制作，而相机页和保存页是复用 Native 页面。 项目上线一年累积使用次数已经超过 10 亿次。这套方案经受住了考验，并在过程中仍然在不断的优化和拓展。 使用这套实现方案是基于以下几点考虑： 整个模块的风格多变，整体 UI 是与妆容所搭配的，而整个模块一直都在持续不断的迭代之中； 项目逻辑流程的可变性大，需要 H5 强大的热更新能力，及时应对数据的变化，快速的试错和纠正； 拍摄页与保存页是客户端已经有的模块，可以略微定制后直接复用； 需要由客户端协助接入多套 SDK，例如使用算法 SDK 进行复杂的图像处理。 简单看完项目，我们接下来开始 bridge.js 的构建。由于本系列文章主要面向前端童鞋，因此我们主要展开 H5 的部分，即会注入到每个页面头部的 bridge.js 的实现，客户端中的 SDK 部分就不详细解构了，只会提到一些细节。 搭建地基 — bridge.js 架构基于上篇文章阐述的结构，我们进一步去完善细节部分，先整理成下面这样的流程结构图，大家先看下图，有个大致的概念： 接下来我们会细看里面各个部分的代码实现。 (一) 业务方使用姿势首先，我们先看下在这套方案中，业务方是如何使用的，下面以获取网络状态为例： (二) H5 –&gt; Native接下来直接来看 nativeCall 的内部实现： 里面可以解构成下面 4 个步骤: 1.生成唯一 handler 标识，从 0 开始累加； 2.将参数按 handler 值的规则存入参数池(_paramsStore)中； 3.以 handler 注册自定义事件，绑定 callback，并将 callback 也存入 _callbackStore 中，addEvent()，储存的目的主要是为了事件解绑时使用； 4.以 iframe 的形式发送协议，并携带唯一标识 handler，send()； Native: 客户端接收到请求后，会使用 handler 调用 getParam 从参数池中获取对应的参数。 执行协议对应的功能； 这样即走通了 H5 –&gt; Native 的这个流程，在客户端完成了对应的功能后，既开始回传执行结果。 (三) Native –&gt; H5Native： Native 完成功能后，直接调用 Bridge.postMessage(handler, data)，将 执行结果 和 之前 nativeCall 传过来的 标识 回传给 H5； H5： H5 在接收到唯一标识后初始化对应的自定义事件，挂载数据后触发，这里涉及的就是 fireEvent 这个函数: 这样，我们就已经完成了双端之间的双向交互机制了，梳理出了整个 bridge.js 的核心代码了，包含了： 最重要的开放 API: nativeCall 与 postMessage ； 客户端获取参数函数: getParam ； 事件回调系统中的 addEvent 和 fireEvent ； 用于发送协议的 send。 安卓兼容性如果看过上一篇提升海量用户极致体验的 Hybrid 架构设计（原理篇）的童鞋，这时可能会有个疑问：在 Android 4.4 以下时，使用的 loadUrl 进行 js 函数的调用，而此时是无法获取函数的返回值的，也就是说 4.4- 时，安卓并无法通过 getParam 这个函数来获取到协议的参数，这里需要做兼容性的处理，而我们这里可以使用一个曲线救国的骚操作，使用到的原理就是上一篇文章中有提到的另一种 H5 -&gt; Native 的方案：WebView 中的 prompt 拦截 方案如下: 当安卓接受到协议，并拿到 handler 值； 使用无兼容性问题的 loadUrl 执行 js：Bridge.getParam(handler) ，直接将返回值直接通过 js 中的 prompt 发出： 通过重写 onJsPrompt 这个方法，拦截上一步发出的 prompt 的内容，并解析出相应的参数； 通过这样的方式，安卓全平台都可以完成参数的获取，并且方式统一，不需要分平台兼容，这就非常的 skrskr 啦。 现在看下来，是不是觉得炒鸡简单？。分分钟能写 100 个。没错！其实核心的原理就是这么的简单，但这只是一个最基础的地基而已，而基于地基之上，我们就可以开始一层一层建造我们的大楼了！ 建造大楼 — 协议的定制在完成最基础的架构后，我们就可以开始来进一步完成一些上层建筑了，制定一系列真正开放给业务方使用的协议 API，完善整套方案。 首先我们可以将这些协议分成 功能协议 和 业务协议。 功能协议这类协议是指用于完善整套方案的基础功能的一些通用协议，以 command:&#x2F;&#x2F;作为通用头，封装在 SDK 之中，可以在全线 App、全线 WebView 中使用： 1.初始化机制上篇文章有提到由于 bridge.js 注入的异步性，我们需要由客户端在注入完成后通知 H5。 这里我们可以约定一个通用的初始化事件，这里我们约定为 init，因此前端就可以进行入口的监听, 类似于我们常用的 DOMContentLoaded: 大家可以看到，这里用了个标记位用于避免事件被重复触发，这是由于客户端中是通过监听 WebView 的生命周期钩子来触发的，而 iframe 之类的操作会导致这些钩子的多次触发，因此需要双方各做一层防御性措施。 接下来，我们可以通过该事件，直接初始化传给 H5 一些环境参数和系统信息等，下面是我们使用到的： 同样的，我们可以约定更多的页面生命周期事件，例如因为 App 很经常性的隐藏到后台，因此在被激活时，我们可以设置个生命周期: resume，可以用于告知 H5 页面被激活。 Tips: 这里就能体现出我们通过事件机制来作为回调系统的优势了，我们可以以最习惯的方式进行事件的监听，而客户端可以直接使用 bridge.fireEvent(‘init’, data)触发事件，这样便可以优雅地实现 Native -&gt; H5 的单方向交互。 2.打包机制Hybrid 模块 的其中一种方式是将前端代码打包后内置于 App 本地，以便拥有最快的启动性能和离线访问能力。而这种方式最大的麻烦点，就是代码的更新，我们不可能每次有修改时就手动重新打包给客户端童鞋替换，而且这样也失去了我们的热更新机制。 因此这里就需要一套新的热更新机制，这套机制需要由客户端&#x2F;前端&#x2F;服务端 三端的童鞋提供对应的资源，共同协作完成整套流程。 资源： H5: 每个代码包都有一个唯一且递增的版本号； Native: 提供包下载且解压到对应目录的服务，前端可以由下面这个协议来调用该功能。 服务端: 提供一个接口，可以获取线上最新代码包的版本号和下载地址。 流程： 前端更新代码打包后按版本号上传至指定的服务器上； 每次打开页面时，H5 请求接口获取线上最新代码包版本号，并与本地包进行版本号比对，当线上的版本号 大于 本地包版本号时，发起包下载协议： 客户端接受到协议后，直接去线上地址下载最新的代码包，并解压替换到当前目录文件。 拥有这样的机制后，H5 在开发后，就可以直接打包将包上传到对应的服务器上，这样在 App 中打开页面后，即可以实时的热更新。 3.环境系统 和 多语言系统通常，我们会将项目分成多个不同的环境，相互隔离。而由于 Hybrid 模块是置于 App 中的，因此环境需要与 App 进行匹配，这里就可以直接使用上面第一点提到的，通过 init 中携带的数据 data.env 来匹配： env: 0 - 正式环境； 1 - 测试环境； 2 - 开发环境； 同理， 多语言也可以直接使用 e.data.language 直接进行匹配； Tips： 环境机制我们通常主要用于匹配后端的环境，正式环境和测试环境对应不同的接口。而这里还有一点特别的，就是需要注意代码包的更新，上述的包更新条件要包含三个方面: 版本号、环境和 App 版本，在不同环境不同 App 版本下，也应该更新到相应的最新代码包。 4. 事件中转站由于页面是 H5 开发，而 Native 可能需要控制 H5 页面，例如最常用的场景: 当页面中有弹窗或者 SPA 切换页面时，安卓的返回实体键应该能完成对应的回退，而不是因为 WebView 没有 history 就直接关闭。 类似于这类需求，这里就可以定制一个事件中心(eventListeners )，用于监听客户端的实体返回键： 5. 数据传递机制在业务中，很多场景需要做到 Native 与 H5 保持数据的同步，此时就可以使用类似上面的原理，制定一套数据传递协议: Tips： Hybrid 模块通常需要从对应的入口进入，因此这里有一种可以优化的方式： 由 App 在启动时先去获取线上数据，在进入 WebView 后直接通过 init 或者触发 getData 直接发送给 H5，这样能减少请求数量，优化用户体验。 6. 代理请求H5 中最常用的就是请求，通常我们可以直接使用 ajax，但是这里有几个问题比较棘手: 最常见的请求跨域； 数据算法加密； 用户登录校验； 而客户端的请求便不会出现这些问题，因此我们可以由客户端代理我们发出的请求，可以定制 4 个协议: getProxy，postProxy， getProxyLogined，postProxyLogined，其中带有 Logined 的协议代表着在请求时会自动携带已登录用户的 token 和 uid 等参数，使用在一些需要登录信息的接口上。这样做的好处是： H5 方就无需处理繁多的各项复杂信息，不需要进行跨端传输； 能够对 H5 与 Native 的请求出口进行统一，方便加工处理。 7.更多除了这些重要的功能外，我们还可以非常自由地定制很多协议，让 H5 拥有更多更强大的功能，下面是我们所定制的一些功能： getNetwork：获取网络状态； openApp：唤起其它 App； setShareInfo 与 callShare：分享内容到第三方平台； link：使用新的 WebView 打开页面； closeWebview：关闭 WebView； setStorage 与 getStorage：设置与获取缓存数据； loading：调用客户端通用 Loading； setWebviewTitle：设置 WebView 标题； saveImage：保存图片到本地； … 这里可以定义更多的通用性协议，这里有个原则可以遵守，即这部分协议应该是基础性功能，应该是纯净的，适用于所有的业务方。根据上篇文章提到的理念，这部分是当成通用 SDK 进行维护与升级的，因此不应该耦合业务层的任何逻辑。 而有时我们会遇到需要定制一些业务上的逻辑，例如上面提到的项目中，我们要将用户图片通过算法处理成卡通画。这样的需求就是非常的业务化，不适用于其它项目，因此我们应该定制成业务协议。 业务协议这类协议区别于功能协议，它们会杂合一定程度的业务逻辑，而这些逻辑只是针对于特定的项目。其实对于 H5 的使用上，差别并不大，只是使用对应特殊的协议头用于区分，例如: 这类协议通常不包含在 SDK 中，因此需要由客户端的童鞋针对项目的 WebView 进行定制，使用 bridge.js 提供的基础功能实现对应的复杂功能。而在其它的项目入口中，就无法使用这些协议。 总结看到总结两个字，有没有长舒了一口气。通过这两篇文章，我们终于将 Hybrid 方案的前端部分完全的解构清楚了，是不是有种神清气爽的感觉，完全可以马上开启你们的 Hybrid 之旅了。鼓掌鼓掌！ 但这也远非终点，或者说这永无终点。~大楼建成后，离真正的摩天大楼还是差着一步 — 内部装修，其实接下来我们还需要做很多的优化措施，来解决一些仍然存在的问题，这部分其实我们也一直还在努力的阶段。 受篇幅所限，有时间会将这部分再写一篇优化篇，主要来与大家探讨下我们所能想到的一些优化方案，非常期待大佬们也能给我们提供更多的建议和解决办法。感恩~~😇","categories":[{"name":"hybrid","slug":"hybrid","permalink":"http://example.com/categories/hybrid/"}],"tags":[]},{"title":"提升海量用户极致体验的Hybrid架构设计（原理篇）[转]","slug":"[转]提升海量用户极致体验的 Hybrid 架构设计（原理篇）","date":"2022-03-16T20:23:47.000Z","updated":"2022-10-09T00:04:40.000Z","comments":true,"path":"2022/03/17/[转]提升海量用户极致体验的 Hybrid 架构设计（原理篇）/","link":"","permalink":"http://example.com/2022/03/17/[%E8%BD%AC]%E6%8F%90%E5%8D%87%E6%B5%B7%E9%87%8F%E7%94%A8%E6%88%B7%E6%9E%81%E8%87%B4%E4%BD%93%E9%AA%8C%E7%9A%84%20Hybrid%20%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E5%8E%9F%E7%90%86%E7%AF%87%EF%BC%89/","excerpt":"","text":"原文链接 一、引言随着 Web 技术和移动设备的快速发展，Hybrid 技术已经成为一种最主流最常见的方案。一套好的 Hybrid 架构方案能让 App 既能拥有极致的体验和性能，同时也能拥有 Web 技术灵活的开发模式、跨平台能力以及热更新机制，想想是不是都鸡冻不已…本系列文章是美图公司在这方面实践的一个总结，包含了原理解析、方案选型与实现、实践优化等方面。 大家可以到 github (https://github.com/xd-tayde/blog/blob/master/hybrid-1.md)上和作者进行讨论哈！ 二、现有混合方案Hybrid App，俗称混合应用，即混合了 Native 技术 与 Web 技术进行开发的移动应用。现在比较流行的混合方案主要有三种，主要是在 UI 渲染机制上的不同： 1.基于 WebView UI 的基础方案，市面上大部分主流 App 都有采用，例如微信 JS-SDK ，通过 JSBridge 完成 H5 与 Native 的双向通讯，从而赋予 H5 一定程度的原生能力。 2.基于 Native UI 的方案，例如 React-Native、Weex。在赋予 H5 原生 API 能力的基础上，进一步通过 JSBridge 将 js 解析成的虚拟节点树( Virtual DOM )传递到 Native 并使用原生渲染。 3.另外还有近期比较流行的小程序方案，也是通过更加定制化的 JSBridge，并使用双 WebView 双线程的模式隔离了 JS 逻辑与 UI 渲染，形成了特殊的开发模式，加强了 H5 与 Native 混合程度，提高了页面性能及开发体验。 以上的三种方案，其实同样都是基于 JSBridge 完成的通讯层，第二三种方案，其实可以看做是在方案一的基础上，继续通过不同的新技术进一步提高了应用的混合程度。因此，JSBridge 也是整个混合应用最关键的部分，例如我们在设置微信分享时用到的 JS-SDK，wx 对象便是我们最常见的 JSBridge: 三、方案选型任何技术方案的选型，其实都应该基于使用场景和现有条件。基于公司现有情况的几点考虑，在方案一上进一步优化，更加适合我们的需求。 需求 Web 技术 快速迭代、灵活开发的特点和线上热更新的机制。 产品的核心能力是强大的拍照与底层图片处理能力，因此单纯的 H5 技术能做的事非常有限，不能满足需求，通过 Hybrid 技术来强化 H5 ，便是一种必需。 公司业务上，并没有非常复杂的 UI 渲染需求，而且 App 中的一系列原生 UI 组件 已经非常成熟，因此我们并不强需类似 RN 这样的方案。 因此，如何既能利用 H5 强大的开发和迭代能力，又能赋予 H5 强大的底层能力和用户体验，同时能复用现有的成熟 Native 组件，便成为了我们最大的需求点 – 一套完整又强大的 Hybrid 技术架构方案。 四、Hybrid 技术原理Hybrid App 的本质，其实是在原生的 App 中，使用 WebView 作为容器直接承载 Web 页面。因此，最核心的点就是 Native 端与 H5 端之间的双向通讯层，其实这里也可以理解为我们需要一套跨语言通讯方案，来完成 Native(Java&#x2F;Objective-c&#x2F;…) 与 JavaScript 的通讯。这个方案就是我们所说的 JSBridge，而实现的关键便是作为容器的 WebView，一切的原理都是基于 WebView 的机制。 4.1 JavaScript 通知 Native基于 WebView 的机制和开放的 API , 实现这个功能有三种常见的方案： API 注入，原理其实就是 Native 获取 JavaScript 环境上下文，并直接在上面挂载对象或者方法，使 js 可以直接调用，Android 与 IOS 分别拥有对应的挂载方式。 WebView 中的 prompt&#x2F;console&#x2F;alert 拦截，通常使用 prompt ，因为这个方法在前端中使用频率低，比较不会出现冲突； WebView URL Scheme 跳转拦截； 第二三种机制的原理是类似的，都是通过对 WebView 信息冒泡传递的拦截，从而达到通讯的，接下来我们主要从 原理-定制协议-拦截协议-参数传递-回调机制 5 个方面详细阐述下第三种方案 – URL 拦截方案。 4.1.1 实现原理在 WebView 中发出的网络请求，客户端都能进行监听和捕获 4.1.2 协议的定制我们需要制定一套 URL Scheme 规则，通常我们的请求会带有对应的协议开头，例如常见的 https://xxx.com 或者 file:&#x2F;&#x2F;1.jpg ，代表着不同的含义。我们这里可以将协议类型的请求定制为: xxcommand:&#x2F;&#x2F;xxxx?param1&#x3D;1&amp;param2&#x3D;2 这里有几个需要注意点的是: (1) xxcommand:&#x2F;&#x2F; 只是一种规则，可以根据业务进行制定，使其具有含义，例如我们定义 xxcommand:&#x2F;&#x2F; 为公司所有 App 系通用，为通用工具协议： xxcommand:&#x2F;&#x2F;getProxy?h&#x3D;1 而定义 xxapp:&#x2F;&#x2F; 为每个 App 单独的业务协议。 xxapp:&#x2F;&#x2F;openCamera?h&#x3D;2 不同的协议头代表着不同的含义，这样便能清楚知道每个协议的适用范围。 (2) 这里不要使用 location.href 发送，因为其自身机制有个问题是同时并发多次请求会被合并成为一次，导致协议被忽略，而并发协议其实是非常常见的功能。我们会使用创建 iframe 发送请求的方式。 (3) 通常考虑到安全性，需要在客户端中设置域名白名单或者限制，避免公司内部业务协议被第三方直接调用。 4.1.3 协议的拦截客户端可以通过 API 对 WebView 发出的请求进行拦截： IOS 上: shouldStartLoadWithRequest Android: shouldOverrideUrlLoading 当解析到请求 URL 头为制定的协议时，便不发起对应的资源请求，而是解析参数，并进行相关功能或者方法的调用，完成协议功能的映射。 4.1.4 协议回调由于协议的本质其实是发送请求，这属于一个异步的过程，因此我们便需要处理对应的回调机制。这里我们采用的方式是 JS 的事件系统，这里我们会用到 window.addEventListener 和 window.dispatchEvent 这两个基础 API； 1.发送协议时，通过协议的唯一标识注册自定义事件，并将回调绑定到对应的事件上。 2.客户端完成对应的功能后，调用 Bridge 的 dispatch API ，直接携带 data 触发该协议的自定义事件。 通过事件的机制，会让开发更符合我们前端的习惯，例如当你需要监听客户端的通知时，同样只需要在通过 addEventListener 进行监听即可。 Tips: 这里有一点需要注意的是，应该避免事件的多次重复绑定，因此当唯一标识重置时，需要 removeEventListener 对应的事件。 4.1.5 参数传递方式由于 WebView 对 URL 会有长度的限制，因此常规的通过 search 参数 进行传递的方式便具有一个问题，既 当需要传递的参数过长时，可能会导致被截断，例如传递 base64 或者传递大量数据时。 因此我们需要制定新的参数传递规则，我们使用的是函数调用的方式。这里的原理主要是基于:Native 可以直接调用 JS 方法并直接获取函数的返回值。 我们只需要对每条协议标记一个唯一标识，并把参数存入参数池中，到时客户端再通过该唯一标识从参数池中获取对应的参数即可。 4.2 Native 通知 Javascript由于 Native 可以算作 H5 的宿主，因此拥有更大的权限，上面也提到了 Native 可以通过 WebView API 直接执行 Js 代码。这样的权限也就让这个方向的通讯变得十分的便捷。 IOS: stringByEvaluatingJavaScriptFromString Android: loadUrl (4.4-) Tips: 当系统低于 4.4 时，evaluateJavascript 是无法使用的，因此单纯的使用 loadUrl 无法获取 JS 返回值，这时我们需要使用前面提到的 prompt 的方法进行兼容，让 H5 端 通过 prompt 进行数据的发送，客户端进行拦截并获取数据。 Android: evaluateJavascript (4.4+) 基于上面的原理，我们已经明白 JSBridge 最基础的原理，并且能实现 Native &lt;&#x3D;&gt; H5 的双向通讯机制了。 4.3 JSBridge 的接入接下来，我们来理下代码上需要的资源。实现这套方案，从上图可以看出，其实可以分为两个部分: JS 部分(bridge): 在 JS 环境中注入 bridge 的实现代码，包含了协议的拼装&#x2F;发送&#x2F;参数池&#x2F;回调池等一些基础功能。 Native 部分(SDK): 在客户端中 bridge 的功能映射代码，实现了 URL 拦截与解析&#x2F;环境信息的注入&#x2F;通用功能映射等功能。 我们这里的做法是，将这两部分一起封装成一个 Native SDK，由客户端统一引入。客户端在初始化一个 WebView 打开页面时，如果页面地址在白名单中，会直接在 HTML 的头部注入对应的 bridge.js。这样的做法有以下的好处： 双方的代码统一维护，避免出现版本分裂的情况。有更新时，只要由客户端更新 SDK 即可，不会出现版本兼容的问题； App 的接入十分方便，只需要按文档接入最新版本的 SDK ，即可直接运行整套 Hybrid 方案，便于在多个 App 中快速的落地； H5 端无需关注，这样有利于将 bridge 开放给第三方页面使用。 这里有一点需要注意的是，协议的调用，一定是需要确保执行在 bridge.js 成功注入后。由于客户端的注入行为属于一个附加的异步行为，从 H5 方很难去捕捉准确的完成时机，因此这里需要通过客户端监听页面完成后，基于上面的事件回调机制通知 H5 端，页面中即可通过 window.addEventListener(‘bridgeReady’, e &#x3D;&gt; {})进行初始化。 4.4 App 中 H5 的接入方式将 H5 接入 App 中通常有两种方式：在线 H5 和内置包 H5。 (1) 在线 H5，这是最常见的一种方式。我们只需要将 H5 代码部署到服务器上，只要把对应的 URL 地址 给到客户端，用 WebView 打开该 URL，即可嵌入。该方式的好处在于: 独立性强，有非常独立的开发&#x2F;调试&#x2F;更新&#x2F;上线能力； 资源放在服务器上，完全不会影响客户端的包体积； 接入成本很低，完全的热更新机制。 但相对的，这种方式也有对应的缺点: 完全的网络依赖，在离线的情况下无法打开页面； 首屏加载速度依赖于网络，网络较慢时，首屏加载也较慢； 通常，这种方式更适用在一些比较轻量级的页面上，例如一些帮助页、提示页、使用攻略等页面。这些页面的特点是功能性不强，不太需要复杂的功能协议，且不需要离线使用。在一些第三方页面接入上，也会使用这种方式，例如我们的页面调用微信 JS-SDK 。 (2) 内置包 H5，这是一种本地化的嵌入方式，我们需要将代码进行打包后下发到客户端，并由客户端直接解压到本地储存中。通常我们运用在一些比较大和比较重要的模块上。其优点是: 由于其本地化，首屏加载速度快，用户体验更为接近原生； 可以不依赖网络，离线运行； 但同时，它的劣势也十分明显: 开发流程&#x2F;更新机制复杂化，需要客户端，甚至服务端的共同协作； 会相应的增加 App 包体积； 这两种接入方式均有自己的优缺点，应该根据不同场景进行选择。 五、总结本文主要解析了现在 Hybrid App 的发展现状和其基础原理，包含了 JavaScript 通知 Native Native 通知 Javascript JSBridge 的接入 H5 的接入 只有在了解了其最本质的实现原理后，才能对这套方案进行实现以及进一步的优化。接下来，我们将基于上面的理论，继续探讨如何把这套方案的真正代码实现以及方案优化方案，欢迎大家一起讨论！","categories":[{"name":"hybrid","slug":"hybrid","permalink":"http://example.com/categories/hybrid/"}],"tags":[]},{"title":"Android 实现水印背景效果[转]","slug":"Android 实现水印背景效果","date":"2022-03-14T20:23:47.000Z","updated":"2022-05-13T00:19:38.000Z","comments":true,"path":"2022/03/15/Android 实现水印背景效果/","link":"","permalink":"http://example.com/2022/03/15/Android%20%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%8D%B0%E8%83%8C%E6%99%AF%E6%95%88%E6%9E%9C/","excerpt":"","text":"[转]Android 实现水印背景效果项目中有需要加水印的需求，实现完效果图是这样的 什么看不清… 为了让大家看清效果，字体改了一下，正常应该是文章最上面那个的效果。话不多说，直接上代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332import android.annotation.SuppressLint;import android.content.Context;import android.content.res.TypedArray;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.graphics.Rect;import android.graphics.Typeface;import android.text.TextPaint;import android.util.AttributeSet;import android.view.MotionEvent;import android.view.View; import com.hkdc.commonlib.R; public class WaterMarkView extends View &#123; private static final String DEFAULT_SEPARATOR = &quot;///&quot;; private TextPaint mTextPaint = new TextPaint(); private String[] mText; private int mDegrees; private int mTextColor; private int mTextSize=35; private boolean mTextBold; private int mDx; private int mDy; private Paint.Align mAlign; private boolean mSync; private int textWidth, textHeight; public WaterMarkView(Context context) &#123; this(context, null); &#125; public WaterMarkView(Context context, AttributeSet attrs) &#123; super(context, attrs); TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.WaterMarkView); mDegrees = typedArray.getInt(R.styleable.WaterMarkView_water_mark_degree, WaterMarkManager.INFO != null ? WaterMarkManager.INFO.getDegrees() : -30); String text = typedArray.getString(R.styleable.WaterMarkView_water_mark_text); if (text != null) &#123; mText = text.split(DEFAULT_SEPARATOR); &#125; mTextColor = typedArray.getColor(R.styleable.WaterMarkView_water_mark_textColor, WaterMarkManager.INFO != null ? WaterMarkManager.INFO.getTextColor() : Color.parseColor(&quot;#33000000&quot;)); mTextSize = typedArray.getDimensionPixelSize(R.styleable.WaterMarkView_water_mark_textSize, WaterMarkManager.INFO != null ? WaterMarkManager.INFO.getTextSize() : 42); mTextBold = typedArray.getBoolean(R.styleable.WaterMarkView_water_mark_textBold, WaterMarkManager.INFO != null &amp;&amp; WaterMarkManager.INFO.isTextBold()); mDx = typedArray.getDimensionPixelSize(R.styleable.WaterMarkView_water_mark_dx, WaterMarkManager.INFO != null ? WaterMarkManager.INFO.getDx() : 100); mDy = typedArray.getDimensionPixelSize(R.styleable.WaterMarkView_water_mark_dy, WaterMarkManager.INFO != null ? WaterMarkManager.INFO.getDy() : 240); int align = typedArray.getInt(R.styleable.WaterMarkView_water_mark_align, WaterMarkManager.INFO != null ? WaterMarkManager.INFO.getAlignInt() : 1); mAlign = align == 0 ? Paint.Align.LEFT : align == 2 ? Paint.Align.RIGHT : Paint.Align.CENTER; mSync = typedArray.getBoolean(R.styleable.WaterMarkView_water_mark_sync, true); typedArray.recycle(); setBackgroundColor(Color.TRANSPARENT); mTextPaint.setAntiAlias(true); mTextPaint.setFlags(Paint.ANTI_ALIAS_FLAG); mTextPaint.setColor(mTextColor); mTextPaint.setTextSize(mTextSize); mTextPaint.setTypeface(mTextBold ? Typeface.DEFAULT_BOLD : Typeface.DEFAULT); mTextPaint.setTextAlign(mAlign); mText = mText == null &amp;&amp; mSync ? WaterMarkManager.CONTENT : mText; textWidth = 0; textHeight = 0; if (mText != null &amp;&amp; mText.length &gt; 0) &#123; for (String s : mText) &#123; Rect tvRect = new Rect(); mTextPaint.getTextBounds(s, 0, s.length(), tvRect); textWidth = textWidth &gt; tvRect.width() ? textWidth : tvRect.width(); textHeight += (tvRect.height() + 10); &#125; &#125; if (mSync) &#123; WaterMarkManager.LIST.add(this); &#125; &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if (mText != null &amp;&amp; mText.length &gt; 0) &#123; int measuredWidth = getMeasuredWidth(); int measuredHeight = getMeasuredHeight(); if (measuredWidth == 0 || measuredHeight == 0) &#123; return; &#125; int canvasLength = measuredWidth &gt; measuredHeight ? measuredWidth : measuredHeight; canvas.save(); canvas.rotate(mDegrees, measuredWidth / 2, measuredHeight / 2); canvas.save(); int y = 0; boolean odd = true; while (y &lt; canvasLength + textHeight) &#123; int x = odd ? 0 : -(textWidth + mDx) / 2; while (x &lt; canvasLength + textWidth) &#123; drawTexts(mText, mTextPaint, canvas, x, y); x = x + textWidth + mDx; &#125; y = y + textHeight + mDy; odd = !odd; &#125; canvas.restore(); &#125; &#125; private void drawTexts(String[] ss, Paint paint, Canvas canvas, int x, int y) &#123; Paint.FontMetrics fontMetrics = paint.getFontMetrics(); float top = fontMetrics.top; float bottom = fontMetrics.bottom; int length = ss.length; float total = (length - 1) * (bottom - top) + (fontMetrics.descent - fontMetrics.ascent); float offset = total / 2 - bottom; for (int i = 0; i &lt; length; i++) &#123; float yAxis = -(length - i - 1) * (bottom - top) + offset; canvas.drawText(ss[i], x, y + yAxis + 10, paint); &#125; &#125; /** * 设置水印文字内容 * * @param text 文字内容 */ public void setText(String... text) &#123; mText = text; textWidth = 0; textHeight = 0; if (mText != null &amp;&amp; mText.length &gt; 0) &#123; for (String s : mText) &#123; Rect tvRect = new Rect(); mTextPaint.getTextBounds(s, 0, s.length(), tvRect); textWidth = textWidth &gt; tvRect.width() ? textWidth : tvRect.width(); textHeight += (tvRect.height() + 10); &#125; &#125; postInvalidate(); &#125; /** * 同步设置水印文字内容 * * @param text 文字内容 */ void setSyncText(String... text) &#123; if (mSync) &#123; setText(text); &#125; &#125; /** * 设置水印倾斜角度 * * @param degrees 倾斜角度(默认:-30) */ public void setDegrees(int degrees) &#123; mDegrees = degrees; postInvalidate(); &#125; /** * 同步设置水印倾斜角度 * * @param degrees 倾斜角度(默认:-30) */ void setSyncDegrees(int degrees) &#123; if (mSync) &#123; setDegrees(degrees); &#125; &#125; /** * 设置水印字体颜色 * * @param textColor 字体颜色(默认:#33000000) */ public void setTextColor(int textColor) &#123; mTextColor = textColor; mTextPaint.setColor(mTextColor); postInvalidate(); &#125; /** * 同步设置水印字体颜色 * * @param textColor 字体颜色(默认:#33000000) */ void setSyncTextColor(int textColor) &#123; if (mSync) &#123; setTextColor(textColor); &#125; &#125; /** * 设置水印字体大小（单位：px） * * @param textSize 字体大小(默认:42px) */ public void setTextSize(int textSize) &#123; mTextSize = textSize; mTextPaint.setTextSize(30); postInvalidate(); &#125; /** * 同步设置水印字体大小（单位：px） * * @param textSize 字体大小(默认:42px) */ void setSyncTextSize(int textSize) &#123; if (mSync) &#123; setTextSize(30); &#125; &#125; /** * 设置水印字体是否粗体 * * @param textBold 是否粗体(默认:false) */ public void setTextBold(boolean textBold) &#123; mTextBold = textBold; mTextPaint.setTypeface(mTextBold ? Typeface.DEFAULT_BOLD : Typeface.DEFAULT); postInvalidate(); &#125; /** * 同步设置水印字体是否粗体 * * @param textBold 是否粗体(默认:false) */ void setSyncTextBold(boolean textBold) &#123; if (mSync) &#123; setTextBold(textBold); &#125; &#125; /** * 设置水印X轴偏移量（单位：px） * * @param dx X轴偏移量(默认:100px) */ public void setDx(int dx) &#123; this.mDx = dx; postInvalidate(); &#125; /** * 同步设置水印X轴偏移量（单位：px） * * @param dx X轴偏移量(默认:100px) */ void setSyncDx(int dx) &#123; if (mSync) &#123; setDx(dx); &#125; &#125; /** * 设置水印Y轴偏移量（单位：px） * * @param dy Y轴偏移量(默认:240px) */ public void setDy(int dy) &#123; this.mDy = dy; postInvalidate(); &#125; /** * 同步设置水印Y轴偏移量（单位：px） * * @param dy Y轴偏移量(默认:240px) */ void setSignDy(int dy) &#123; if (mSync) &#123; setDy(dy); &#125; &#125; /** * 设置水印对齐方式 * * @param align 对齐方式(默认:Center) */ public void setAlign(Paint.Align align) &#123; this.mAlign = align; postInvalidate(); &#125; /** * 同步设置水印对齐方式 * * @param align 对齐方式(默认:Center) */ void setSignAlign(Paint.Align align) &#123; if (mSync) &#123; setAlign(align); &#125; &#125; /** * 销毁相关页面时调用（切记） */ public void onDestroy() &#123; if (mSync) &#123; WaterMarkManager.LIST.remove(this); &#125; &#125; @Override public boolean dispatchTouchEvent(MotionEvent event) &#123; return false; &#125; @SuppressLint(&quot;ClickableViewAccessibility&quot;) @Override public boolean onTouchEvent(MotionEvent event) &#123; return false; &#125;&#125; 123456789101112131415&lt;declare-styleable name=&quot;WaterMarkView&quot;&gt; &lt;attr name=&quot;water_mark_degree&quot; format=&quot;integer|reference&quot; /&gt; &lt;attr name=&quot;water_mark_text&quot; format=&quot;string|reference&quot; /&gt; &lt;attr name=&quot;water_mark_textColor&quot; format=&quot;color|reference&quot; /&gt; &lt;attr name=&quot;water_mark_textSize&quot; format=&quot;dimension|reference&quot; /&gt; &lt;attr name=&quot;water_mark_textBold&quot; format=&quot;boolean&quot; /&gt; &lt;attr name=&quot;water_mark_dx&quot; format=&quot;dimension|reference&quot; /&gt; &lt;attr name=&quot;water_mark_dy&quot; format=&quot;dimension|reference&quot; /&gt; &lt;attr name=&quot;water_mark_align&quot; format=&quot;dimension&quot;&gt; &lt;enum name=&quot;LEFT&quot; value=&quot;0&quot; /&gt; &lt;enum name=&quot;CENTER&quot; value=&quot;1&quot; /&gt; &lt;enum name=&quot;RIGHT&quot; value=&quot;2&quot; /&gt; &lt;/attr&gt; &lt;attr name=&quot;water_mark_sync&quot; format=&quot;boolean&quot; /&gt; &lt;/declare-styleable&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187package com.hkdc.commonlib.warkmark; import android.annotation.SuppressLint;import android.app.Activity;import android.graphics.Paint;import android.view.LayoutInflater; import com.hkdc.commonlib.R; import java.util.ArrayList;import java.util.List; /** * @author Leon (wshk729@163.com) * @date 2018/8/24 * &lt;p&gt; */public class WaterMarkManager &#123; static WaterMarkInfo INFO = null; static String[] CONTENT = null; static List&lt;WaterMarkView&gt; LIST = new ArrayList&lt;&gt;(); /** * 设置水印全局配置信息 * * @param info 配置信息 */ public static void setInfo(WaterMarkInfo info) &#123; INFO = info; &#125; /** * 获取一个满屏水印View * * @param activity activity */ @SuppressLint(&quot;InflateParams&quot;) public static WaterMarkView getView(Activity activity) &#123; return (WaterMarkView) LayoutInflater.from(activity).inflate(R.layout.view_water_mark, null); &#125; /** * WaterMarkInfo初始化判断 */ private static void assertInitialized() &#123; if (INFO == null) &#123; INFO = WaterMarkInfo.create().generate(); &#125; &#125; /** * 同步设置全部水印文字信息 * * @param content 文字信息 */ public static void setText(String... content) &#123; assertInitialized(); CONTENT = content; if (LIST.size() &gt; 0) &#123; for (WaterMarkView view : LIST) &#123; if (view != null) &#123; view.setSyncText(content); &#125; &#125; &#125; &#125; /** * 同步设置全部水印倾斜角度 * * @param degrees 倾斜角度(默认:-30) */ public static void setDegrees(int degrees) &#123; assertInitialized(); INFO.setDegrees(degrees); if (LIST.size() &gt; 0) &#123; for (WaterMarkView view : LIST) &#123; if (view != null) &#123; view.setSyncDegrees(degrees); &#125; &#125; &#125; &#125; /** * 同步设置全部水印字体颜色 * * @param textColor 字体颜色(默认:#33000000) */ public static void setTextColor(int textColor) &#123; assertInitialized(); INFO.setTextColor(textColor); if (LIST.size() &gt; 0) &#123; for (WaterMarkView view : LIST) &#123; if (view != null) &#123; view.setSyncTextColor(textColor); &#125; &#125; &#125; &#125; /** * 同步设置全部水印字体大小（单位：px） * * @param textSize 字体大小(默认:42px) */ public static void setTextSize(int textSize) &#123; assertInitialized(); INFO.setTextSize(textSize); if (LIST.size() &gt; 0) &#123; for (WaterMarkView view : LIST) &#123; if (view != null) &#123; view.setSyncTextSize(textSize); &#125; &#125; &#125; &#125; /** * 同步设置全部水印字体是否粗体 * * @param textBold 是否粗体(默认:false) */ public static void setTextBold(boolean textBold) &#123; assertInitialized(); INFO.setTextBold(textBold); if (LIST.size() &gt; 0) &#123; for (WaterMarkView view : LIST) &#123; if (view != null) &#123; view.setSyncTextBold(textBold); &#125; &#125; &#125; &#125; /** * 同步设置全部水印X轴偏移量（单位：px） * * @param dx X轴偏移量(默认:100px) */ public static void setDx(int dx) &#123; assertInitialized(); INFO.setDx(dx); if (LIST.size() &gt; 0) &#123; for (WaterMarkView view : LIST) &#123; if (view != null) &#123; view.setSyncDx(dx); &#125; &#125; &#125; &#125; /** * 同步设置全部水印Y轴偏移量（单位：px） * * @param dy Y轴偏移量(默认:240px) */ public static void setDy(int dy) &#123; assertInitialized(); INFO.setDy(dy); if (LIST.size() &gt; 0) &#123; for (WaterMarkView view : LIST) &#123; if (view != null) &#123; view.setSignDy(dy); &#125; &#125; &#125; &#125; /** * 同步设置全部水印对齐方式 * * @param align 对齐方式(默认:Center) */ public static void setAlign(Paint.Align align) &#123; assertInitialized(); INFO.setAlign(align); if (LIST.size() &gt; 0) &#123; for (WaterMarkView view : LIST) &#123; if (view != null) &#123; view.setSignAlign(align); &#125; &#125; &#125; &#125;&#125; view_water_mark.xml 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;com.commonlib.WaterMarkView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206import android.graphics.Color;import android.graphics.Paint; /** * @author Leon (wshk729@163.com) * @date 2018/8/24 * &lt;p&gt; */public class WaterMarkInfo &#123; private int mDegrees; private int mTextColor; private int mTextSize; private boolean mTextBold; private int mDx; private int mDy; private Paint.Align mAlign; private WaterMarkInfo(int degrees, int textColor, int textSize, boolean textBold, int dx, int dy, Paint.Align align) &#123; mDegrees = degrees; mTextColor = textColor; mTextSize = textSize; mTextBold = textBold; mDx = dx; mDy = dy; mAlign = align; &#125; public int getDegrees() &#123; return mDegrees; &#125; public int getTextColor() &#123; return mTextColor; &#125; public int getTextSize() &#123; return mTextSize; &#125; public int getDx() &#123; return mDx; &#125; public int getDy() &#123; return mDy; &#125; public Paint.Align getAlign() &#123; return mAlign; &#125; public int getAlignInt() &#123; switch (mAlign) &#123; case LEFT: return 0; case RIGHT: return 2; default: return 1; &#125; &#125; public boolean isTextBold() &#123; return mTextBold; &#125; void setDegrees(int degrees) &#123; mDegrees = degrees; &#125; void setTextColor(int textColor) &#123; mTextColor = textColor; &#125; void setTextSize(int textSize) &#123; mTextSize = textSize; &#125; void setTextBold(boolean textBold) &#123; mTextBold = textBold; &#125; void setDx(int dx) &#123; mDx = dx; &#125; void setDy(int dy) &#123; mDy = dy; &#125; void setAlign(Paint.Align align) &#123; this.mAlign = align; &#125; public static Builder create() &#123; return new Builder(); &#125; public static class Builder &#123; private int mDegrees; private int mTextColor; private int mTextSize; private boolean mTextBold; private int mDx; private int mDy; private Paint.Align mAlign; private Builder() &#123; mDegrees = -30; mTextColor = Color.parseColor(&quot;#33000000&quot;); mTextSize = 35; mTextBold = false; mDx = 100; mDy = 240; mAlign = Paint.Align.CENTER; &#125; /** * 设置水印文字倾斜度 * * @param degrees 文字倾斜度(默认:-30) * @return Builder */ public Builder setDegrees(int degrees) &#123; mDegrees = degrees; return this; &#125; /** * 设置水印文字颜色 * * @param textColor 文字颜色(默认:#33000000) * @return Builder */ public Builder setTextColor(int textColor) &#123; mTextColor = textColor; return this; &#125; /** * 设置水印文字大小（单位：px） * * @param textSize 文字大小(默认:42px) * @return Builder */ public Builder setTextSize(int textSize) &#123; mTextSize = textSize; return this; &#125; /** * 设置水印文字是否加粗 * * @param textBold 文字加粗(默认:false) * @return Builder */ public Builder setTextBold(boolean textBold) &#123; mTextBold = textBold; return this; &#125; /** * 设置水印文字X轴间距（单位：px） * * @param dx 文字X轴间距(默认:100px) * @return Builder */ public Builder setDx(int dx) &#123; mDx = dx; return this; &#125; /** * 设置水印文字Y轴间距（单位：px） * * @param dy 文字Y轴间距(默认:240px) * @return Builder */ public Builder setDy(int dy) &#123; mDy = dy; return this; &#125; /** * 设置水印文字对齐方式 * * @param align 对齐方式(默认:Center) * @return Builder */ public Builder setAlign(Paint.Align align) &#123; mAlign = align; return this; &#125; /** * 生成水印全局配置信息 * * @return 配置信息 */ public WaterMarkInfo generate() &#123; return new WaterMarkInfo(mDegrees, mTextColor, mTextSize, mTextBold, mDx, mDy, mAlign); &#125; &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import android.content.Context;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.ColorFilter;import android.graphics.Paint;import android.graphics.PixelFormat;import android.graphics.drawable.Drawable;import android.support.annotation.IntRange;import android.support.annotation.NonNull;import android.support.annotation.Nullable; import java.util.List; public class WaterMarkBg extends Drawable &#123; private Paint paint = new Paint(); private List&lt;String&gt; labels; private Context context; private int degress;//角度 private int fontSize;//字体大小 单位sp /** * 初始化构造 * @param context 上下文 * @param labels 水印文字列表 多行显示支持 * @param degress 水印角度 * @param fontSize 水印文字大小 */ public WaterMarkBg(Context context, List&lt;String&gt; labels, int degress, int fontSize) &#123; this.labels = labels; this.context = context; this.degress = degress; this.fontSize = fontSize; &#125; @Override public void draw(@NonNull Canvas canvas) &#123; int width = getBounds().right; int height = getBounds().bottom; canvas.drawColor(Color.parseColor(&quot;#40F3F5F9&quot;)); paint.setColor(Color.parseColor(&quot;#50AEAEAE&quot;)); paint.setAntiAlias(true); paint.setTextSize(sp2px(context,fontSize)); canvas.save(); canvas.rotate(degress); float textWidth = paint.measureText(labels.get(0)); int index = 0; for (int positionY = height / 10; positionY &lt;= height; positionY += height / 10+80) &#123; float fromX = -width + (index++ % 2) * textWidth; for (float positionX = fromX; positionX &lt; width; positionX += textWidth * 2) &#123; int spacing = 0;//间距 for(String label:labels)&#123; canvas.drawText(label, positionX, positionY+spacing, paint); spacing = spacing+50; &#125; &#125; &#125; canvas.restore(); &#125; @Override public void setAlpha(@IntRange(from = 0, to = 255) int alpha) &#123; &#125; @Override public void setColorFilter(@Nullable ColorFilter colorFilter) &#123; &#125; @Override public int getOpacity() &#123; return PixelFormat.UNKNOWN; &#125; public static int sp2px(Context context, float spValue) &#123; final float fontScale = context.getResources().getDisplayMetrics().scaledDensity; return (int) (spValue * fontScale + 0.5f); &#125;&#125; xml中 引用 1234567891011121314&lt;com.commonlib.WaterMarkView android:singleLine=&quot;false&quot; android:id=&quot;@+id/wm&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:water_mark_align=&quot;CENTER&quot; app:water_mark_degree=&quot;-30&quot; app:water_mark_dx=&quot;100px&quot; app:water_mark_dy=&quot;240px&quot; app:water_mark_sync=&quot;true&quot; app:water_mark_text=&quot;再见孙悟空&quot; app:water_mark_textBold=&quot;false&quot; app:water_mark_textColor=&quot;@color/black&quot; app:water_mark_textSize=&quot;30px&quot; /&gt; activity中 12345678910private WaterMarkView wm; wm = (WaterMarkView) findViewById(R.id.wm); private void water() &#123; SharedPreferences jobcede = getSharedPreferences(&quot;jobcede&quot;, MODE_PRIVATE); String userName = jobcede.getString(&quot;username&quot;, &quot;&quot;); String name = jobcede.getString(&quot;name&quot;, &quot;&quot;); wm.setText(name,userName);&#125; ————————————————版权声明：本文为CSDN博主「再见孙悟空_」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/shaoyezhangliwei/article/details/109849305","categories":[{"name":"UI","slug":"UI","permalink":"http://example.com/categories/UI/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}]},{"title":"Jetpack系列—paging框架使用和原理(基于paging-runtime-2.1.0版本)","slug":"Jetpack系列—paging框架原理","date":"2022-02-24T20:23:47.000Z","updated":"2022-11-17T07:56:14.000Z","comments":true,"path":"2022/02/25/Jetpack系列—paging框架原理/","link":"","permalink":"http://example.com/2022/02/25/Jetpack%E7%B3%BB%E5%88%97%E2%80%94paging%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/","excerpt":"","text":"Jetpack系列—paging框架使用和原理(基于paging-runtime-2.1.0版本) 基于paging-runtime-2.1.0版本 先看下pageing的基本使用 1.构造一个pageData对象 1234567LiveData&lt;PagedList&lt;T&gt;&gt; pageData = new LivePagedListBuilder(factory, config) //加载初始化数据时需要传递的参数，首页就给传个0就行了，如果是多个参数，需要把多个参数组装成一个 javabean对象 .setInitialLoadKey(0) //.setFetchExecutor() //这个callback可以知道pagelist加载数据的状态，可以判定界面上有没有数据等异常的状态,看名字就知道，是边界情况回调，但 不是每一次分页 都会回调这里 .setBoundaryCallback(callback) .build(); 2.先看更新数据接收和更新的地方 12345//触发页面初始化数据加载的逻辑mViewModel.getPageData().observe(this, pagedList -&gt; submitList(pagedList));//监听分页时有无更多数据,以决定是否关闭上拉加载的动画mViewModel.getBoundaryPageData().observe(this, hasData -&gt; finishRefresh(hasData)); 本质通过这个pageData去observe进行数据的分发事件通知，进而刷新页面数据，本质上是使用了livedata的能力。 3.看具体构造pageData对象时还需要一个factory config callback这些都是什么 config 1234567891011PagedList.Config config = new PagedList.Config.Builder() //一页加载多少条数据 .setPageSize(10) //设置默认加载多少条数据 .setInitialLoadSizeHint(12) //知道列表一共多少条数据 //.setMaxSize(100) //还有多少条的时候的预加载，默认是pageSize 如果不想有这个功能，就让setInitialLoadSizeHint 大于pageSize //要不一开始它加载了10条，它马上就执行loadMore了 //.setPrefetchDistance(4) .build(); factory 12345678910DataSource.Factory factory = new DataSource.Factory() &#123; @NonNull @Override public DataSource create() &#123; if (dataSource == null || dataSource.isInvalid()) &#123; dataSource = createDataSource(); &#125; return dataSource; &#125;&#125;; callback 边界 123456789101112131415161718PagedList.BoundaryCallback&lt;T&gt; callback = new PagedList.BoundaryCallback&lt;T&gt;() &#123; @Override public void onZeroItemsLoaded() &#123; //新提交的PagedList中没有数据 boundaryPageData.postValue(false); &#125; @Override public void onItemAtFrontLoaded(@NonNull T itemAtFront) &#123; //新提交的PagedList中第一条数据被加载到列表上 boundaryPageData.postValue(true); &#125; @Override public void onItemAtEndLoaded(@NonNull T itemAtEnd) &#123; //新提交的PagedList中最后一条数据被加载到列表上 &#125;&#125;; 看到了吧，在第一次时没有数据，在onZeroItemsLoaded会发送一条boundaryPageData.postValue(false) 这也是livedata.postValue 所以触发第一次加载时页面更新，后续加载更多 那么具体的实现逻辑，看下原代码 基于paging-runtime-2.1.0版本 1234public LiveData&lt;PagedList&lt;Value&gt;&gt; build() &#123; return create(mInitialLoadKey, mConfig, mBoundaryCallback, mDataSourceFactory, ArchTaskExecutor.getMainThreadExecutor(), mFetchExecutor);&#125; mInitialLoadKey——第一次加载数据时的入参 mConfig——配置了maxsize pagesize PrefetchDistance 等等参数 mBoundaryCallback——数据加载边界的回调 mDataSourceFactory——提供数据源 ArchTaskExecutor.getMainThreadExecutor()——主线程 mFetchExecutor——异步线程 静态方法create 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private static &lt;Key, Value&gt; LiveData&lt;PagedList&lt;Value&gt;&gt; create( @Nullable final Key initialLoadKey, @NonNull final PagedList.Config config, @Nullable final PagedList.BoundaryCallback boundaryCallback, @NonNull final DataSource.Factory&lt;Key, Value&gt; dataSourceFactory, @NonNull final Executor notifyExecutor, @NonNull final Executor fetchExecutor) &#123; //实际上return的是ComputableLiveData.getLiveData return new ComputableLiveData&lt;PagedList&lt;Value&gt;&gt;(fetchExecutor) &#123; @Nullable private PagedList&lt;Value&gt; mList; @Nullable private DataSource&lt;Key, Value&gt; mDataSource; private final DataSource.InvalidatedCallback mCallback = new DataSource.InvalidatedCallback() &#123; @Override public void onInvalidated() &#123; invalidate(); &#125; &#125;; @SuppressWarnings(&quot;unchecked&quot;) // for casting getLastKey to Key @Override protected PagedList&lt;Value&gt; compute() &#123; @Nullable Key initializeKey = initialLoadKey; if (mList != null) &#123; initializeKey = (Key) mList.getLastKey(); &#125; do &#123; if (mDataSource != null) &#123; mDataSource.removeInvalidatedCallback(mCallback); &#125; mDataSource = dataSourceFactory.create(); mDataSource.addInvalidatedCallback(mCallback); mList = new PagedList.Builder&lt;&gt;(mDataSource, config) .setNotifyExecutor(notifyExecutor) .setFetchExecutor(fetchExecutor) .setBoundaryCallback(boundaryCallback) .setInitialKey(initializeKey) .build(); &#125; while (mList.isDetached()); return mList; &#125; &#125;.getLiveData();&#125; 看看ComputableLiveData里都做了啥 构造方法 1234567891011public ComputableLiveData(@NonNull Executor executor) &#123; mExecutor = executor; //new了livedata 并且复写了onActive方法 mLiveData = new LiveData&lt;T&gt;() &#123; @Override protected void onActive() &#123; //onActive方法执行时机？当且仅当第一个活跃的observer被注册到livedata里的时候就会触发activie mExecutor.execute(mRefreshRunnable); &#125; &#125;;&#125; 也就是说，只要用调用了pageData.observe(Observer) 就会立马触发 ComputableLiveData里的livedata的onActive的回调 看下mRefreshRunnable 里做了什么，刷新了数据 123456789101112131415161718192021222324252627final Runnable mRefreshRunnable = new Runnable() &#123; @WorkerThread @Override public void run() &#123; boolean computed; do &#123; computed = false; if (mComputing.compareAndSet(false, true)) &#123; // as long as it is invalid, keep computing. try &#123; T value = null; while (mInvalid.compareAndSet(true, false)) &#123; computed = true; value = compute(); &#125; if (computed) &#123; mLiveData.postValue(value); &#125; &#125; finally &#123; // release compute lock mComputing.set(false); &#125; &#125; &#125; while (computed &amp;&amp; mInvalid.get()); &#125;&#125;; 1protected abstract T compute(); 是一个抽象，具体实现在ComputeLiveData的匿名实现里 12345678910111213141516171819protected PagedList&lt;Value&gt; compute() &#123; Key initializeKey = initialLoadKey; if (this.mList != null) &#123; initializeKey = this.mList.getLastKey(); &#125; do &#123; if (this.mDataSource != null) &#123; this.mDataSource.removeInvalidatedCallback(this.mCallback); &#125; //通过create方法，生成了一个datasource对象 是一个抽象方法，由用户在上层实现 this.mDataSource = dataSourceFactory.create(); this.mDataSource.addInvalidatedCallback(this.mCallback); this.mList = (new androidx.paging.PagedList.Builder(this.mDataSource, config)).setNotifyExecutor(notifyExecutor).setFetchExecutor(fetchExecutor).setBoundaryCallback(boundaryCallback).setInitialKey(initializeKey).build(); &#125; while(this.mList.isDetached()); return this.mList;&#125; 由用户在上层实现 1public abstract DataSource&lt;Key, Value&gt; create(); 我们在viewmodel中的实现 12345678910DataSource.Factory factory = new DataSource.Factory() &#123; @NonNull @Override public DataSource create() &#123; if (dataSource == null || dataSource.isInvalid()) &#123; dataSource = createDataSource(); &#125; return dataSource; &#125;&#125;; 进而由每个具体的viewmodel中的new的datasource对象 12345678910111213141516171819202122232425262728class FeedDataSource extends ItemKeyedDataSource&lt;Integer, Feed&gt; &#123; @Override public void loadInitial(@NonNull LoadInitialParams&lt;Integer&gt; params, @NonNull LoadInitialCallback&lt;Feed&gt; callback) &#123; //加载初始化数据的 Log.e(&quot;homeviewmodel&quot;, &quot;loadInitial: &quot;); loadData(0, params.requestedLoadSize, callback); witchCache = false; &#125; @Override public void loadAfter(@NonNull LoadParams&lt;Integer&gt; params, @NonNull LoadCallback&lt;Feed&gt; callback) &#123; //向后加载分页数据的 Log.e(&quot;homeviewmodel&quot;, &quot;loadAfter: &quot;); loadData(params.key, params.requestedLoadSize, callback); &#125; @Override public void loadBefore(@NonNull LoadParams&lt;Integer&gt; params, @NonNull LoadCallback&lt;Feed&gt; callback) &#123; callback.onResult(Collections.emptyList()); //能够向前加载数据的 &#125; @NonNull @Override public Integer getKey(@NonNull Feed item) &#123; return item.id; &#125;&#125; 接着往下看 1this.mDataSource.addInvalidatedCallback(this.mCallback); 为什么要给datasource注册一个callback呢？先往下看，这个callback干了什么 12345678public void invalidate() &#123; //通过原子的方式，把mInvalide标志位设为true if (mInvalid.compareAndSet(false, true)) &#123; for (InvalidatedCallback callback : mOnInvalidatedCallbacks) &#123; callback.onInvalidated(); &#125; &#125;&#125; 这就会走到 12345private final InvalidatedCallback mCallback = new InvalidatedCallback() &#123; public void onInvalidated() &#123; invalidate(); &#125;&#125;; 走到 ComputableLivedata.invalidate() 123public void invalidate() &#123; ArchTaskExecutor.getInstance().executeOnMainThread(mInvalidationRunnable);&#125; 123456789101112final Runnable mInvalidationRunnable = new Runnable() &#123; @MainThread @Override public void run() &#123; boolean isActive = mLiveData.hasActiveObservers(); if (mInvalid.compareAndSet(false, true)) &#123; if (isActive) &#123; mExecutor.execute(mRefreshRunnable); &#125; &#125; &#125;&#125;; 这个mRefreshRunnable同样在onActive方法中被执行过 如何通过下拉刷新去触发 执行mRefreshRunnable呢？ 上层执行 1mViewModel.getDataSource().invalidate(); 就会再次触发我们创建的ComputableLiveData中的mCallback中的onInvalidated方法进而实现invalidate的调用，并执行里面的mRefreshRunnable去刷新数据，所以 我们第一次创建时会刷新一次，后面就可以通这个注册的callback 上层调用 去主动刷新数据 再看mRefreshRunnable的后面 1234567891011121314151617181920212223242526272829final Runnable mRefreshRunnable = new Runnable() &#123; @WorkerThread @Override public void run() &#123; boolean computed; do &#123; computed = false; // compute can happen only in 1 thread but no reason to lock others. if (mComputing.compareAndSet(false, true)) &#123; // as long as it is invalid, keep computing. try &#123; T value = null; while (mInvalid.compareAndSet(true, false)) &#123; computed = true; //拿到value pagedlist value = compute(); &#125; if (computed) &#123; //通过livedata发送pagelist分发数据，这样注册的地方就可以接收到数据了 mLiveData.postValue(value); &#125; &#125; finally &#123; // release compute lock mComputing.set(false); &#125; &#125; &#125; while (computed &amp;&amp; mInvalid.get()); &#125;&#125;;","categories":[{"name":"Jetpack系列","slug":"Jetpack系列","permalink":"http://example.com/categories/Jetpack%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"},{"name":"Jetpack","slug":"Jetpack","permalink":"http://example.com/tags/Jetpack/"}]},{"title":"Android - 在Fragment中观察LiveData时，为什么要使用viewLifecycleOwner[转]","slug":"Android - 在Fragment中观察LiveData时，为什么要使用viewLifecycleOwner","date":"2022-02-16T02:37:54.000Z","updated":"2022-05-12T07:32:47.000Z","comments":true,"path":"2022/02/16/Android - 在Fragment中观察LiveData时，为什么要使用viewLifecycleOwner/","link":"","permalink":"http://example.com/2022/02/16/Android%20-%20%E5%9C%A8Fragment%E4%B8%AD%E8%A7%82%E5%AF%9FLiveData%E6%97%B6%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8viewLifecycleOwner/","excerpt":"使用LiveData 在调用observe时传入this会报提醒，要求使用viewLifecycleOwner原因是什么？","text":"使用LiveData 在调用observe时传入this会报提醒，要求使用viewLifecycleOwner原因是什么？ 原文链接 Android - 在Fragment中观察LiveData时，为什么要使用viewLifecycleOwner官网建议使用viewLifecycleOwner 在Fragment中对LiveData对象调用Observe方法的时候，如果传递的LifecycleOwner参数为this，也就是Fragment的时候，会受到AndroidStudio的提醒，要求使用viewLifecycleOwner： fragment.png 从类型上来说，Fragment与viewLifecycleOwner的类型FragmentViewLifecycle两者都继承了LifecycleOwner，像之前那样直接this，大部分情况下运行也是正常的，那么这里的Lint提醒是什么呢？ 通过在官网寻找androidx.fragment:fragment的文档，可以看到1.2.0版本更新的内容有一条： 26005601-ff3b75c18a8b2c79.png 可以知道，这肯定是有他的道理。我们来一起分析一下原因： 123456789101112131415161718192021222324252627282930313233viewLifecycleOwner相关生命周期找到viewLifecycleOwner相关代码( 只看关键点 )：//Fragment.java中void performCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123;mChildFragmentManager.noteStateNotSaved(); mPerformedCreateView =true; mViewLifecycleOwner =new FragmentViewLifecycleOwner(); //此处创建了FragmentViewLifecycleOwner mView = onCreateView(inflater, container, savedInstanceState); //创建完成之后，调用了onCreateView()方法 ... //省略无关代码&#125;//FragmentManager.javaprivate void destroyFragmentView(@NonNull Fragment fragment) &#123; fragment.performDestroyView(); //此方法中执行了onDestroyView()方法 fragment.mViewLifecycleOwner =null; //在执行完onDestroyView()方法之后，将viewLifecycleOwner置空&#125;//Fragment.javavoid performDestroyView() &#123; ... onDestroyView(); // fragment.performDestroyView()方法调用中，执行了onDestroyView()方法 ...&#125;可以发现mViewLifecycleOwner的赋值在onCreateView()之前，置空在onDestroyView()之后，mViewLifecycleOwner的注释也说明了这点： // 这在performCreateView中初始化，在外部不可用 // This is initialized in performCreateView and unavailable outside of the // onCreateView/onDestroyView生命周期 // onCreateView/onDestroyView lifecycle @Nullable FragmentViewLifecycleOwner mViewLifecycleOwner; 正如类名所示，这个FragmentViewLifecycle代表的是Fragment中View的LifecycleOwner，Fragment中View的生命周期与Fragment本身并不相同。 看到这里，想必有些同学对Fragment的生命周期也半知半解，顺便温习一下： Fragment.png Fragment入back stack的过程会执行onDestroyView但不执行之后的onDestroy与onDetach，而出back stack是从onCreateView开始执行，而没有之前的onAttach与onCreate。 LiveData的observe过程温习了相关生命周期后，下面来看一下LiveData的observe过程。 我们知道在LiveData的observe方法内，会将参数owner与observer包装起来，使得observer的回调受owner的生命周期的影响，只有在owner处于活跃状态才回调observer，而活跃状态指的是当前owner的生命周期至少为STARTED，即如下（1）处，owner与observer的包装类中否活跃的判断方法。 12345678910111213141516171819202122class LifecycleBoundObserver extends ObserverWrapper implements LifecycleEventObserver &#123; @NonNull final LifecycleOwner mOwner; LifecycleBoundObserver(@NonNull LifecycleOwner owner, Observer&lt;? super T&gt; observer) &#123; super(observer); mOwner = owner; &#125; @Override boolean shouldBeActive() &#123; return mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED); &#125;//(1) @Override public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) &#123; if (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123; removeObserver(mObserver);//(2) return; &#125; activeStateChanged(shouldBeActive()); &#125; ...&#125; 可是，Fragment与Fragment中的View在活跃的生命周期状态是一致的，这里的owner使用fragment还是viewLifecycleOwner并无不同，二者只有在onCreateView到onDestroyView之外有区别。 包装类中的onStateChanged方法会执行observer的适时移除工作，而（2）处的移除observer正是在owner处于DESTROYED时发生的。对于Fragment，状态会在onDestroyView执行前夕，变为DESTROYED，如下所示： 12345678910//Fragment.java 也对应了上边的内容 void performDestroyView() &#123; mChildFragmentManager.dispatchDestroyView(); if (mView != null) &#123; mViewLifecycleOwner.handleLifecycleEvent(Lifecycle.Event.ON_DESTROY); &#125; mState = CREATED; onDestroyView(); ... &#125; 原因此时，一切都解释得通了，在Fragment中对LiveData对象调用observe方法时，使用viewLifecycleOwner代替this的原因是：Fragment与Fragment中的View的生命周期并不一致，需要让observer感知Fragment中的View的生命周期而非Fragment，因此Android专门构造了Fragment中的View的LifecycleOwner，即viewLifecycleOwner。","categories":[],"tags":[]}],"categories":[{"name":"NDK","slug":"NDK","permalink":"http://example.com/categories/NDK/"},{"name":"加固","slug":"加固","permalink":"http://example.com/categories/%E5%8A%A0%E5%9B%BA/"},{"name":"Android基础","slug":"Android基础","permalink":"http://example.com/categories/Android%E5%9F%BA%E7%A1%80/"},{"name":"C气象数据项目","slug":"C气象数据项目","permalink":"http://example.com/categories/C%E6%B0%94%E8%B1%A1%E6%95%B0%E6%8D%AE%E9%A1%B9%E7%9B%AE/"},{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"C语言","slug":"C语言","permalink":"http://example.com/categories/C%E8%AF%AD%E8%A8%80/"},{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"},{"name":"kotlin","slug":"kotlin","permalink":"http://example.com/categories/kotlin/"},{"name":"Jetpack系列","slug":"Jetpack系列","permalink":"http://example.com/categories/Jetpack%E7%B3%BB%E5%88%97/"},{"name":"hybrid","slug":"hybrid","permalink":"http://example.com/categories/hybrid/"},{"name":"UI","slug":"UI","permalink":"http://example.com/categories/UI/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"},{"name":"Jetpack","slug":"Jetpack","permalink":"http://example.com/tags/Jetpack/"}]}